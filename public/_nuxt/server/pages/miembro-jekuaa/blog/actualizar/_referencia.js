exports.ids = [27,4,7,8,13];
exports.modules = Array(67).concat([
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VTabs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(238);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "c", function() { return _VTabs__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony import */ var _VTab__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VTab__WEBPACK_IMPORTED_MODULE_1__["a"]; });

/* harmony import */ var _VTabsItems__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "d", function() { return _VTabsItems__WEBPACK_IMPORTED_MODULE_2__["a"]; });

/* harmony import */ var _VTabItem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(399);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "b", function() { return _VTabItem__WEBPACK_IMPORTED_MODULE_3__["a"]; });

/* harmony import */ var _VTabsSlider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(100);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "e", function() { return _VTabsSlider__WEBPACK_IMPORTED_MODULE_4__["a"]; });







/* unused harmony default export */ var _unused_webpack_default_export = ({
  $_vuetify_subcomponents: {
    VTabs: _VTabs__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"],
    VTab: _VTab__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"],
    VTabsItems: _VTabsItems__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"],
    VTabItem: _VTabItem__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"],
    VTabsSlider: _VTabsSlider__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]
  }
});

/***/ }),
/* 68 */,
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ VAppBar["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ VAppBarNavIcon["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ VAppBarTitle; });

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VAppBar/VAppBar.js
var VAppBar = __webpack_require__(228);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VAppBar/VAppBarNavIcon.js
var VAppBarNavIcon = __webpack_require__(229);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/registrable/index.js
var registrable = __webpack_require__(33);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/util/helpers.js
var helpers = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/services/goto/easing-patterns.js
var easing_patterns = __webpack_require__(104);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VAppBar/VAppBarTitle.js
// Mixins
 // Utilities



const base = Object(registrable["a" /* inject */])('VAppBar', 'v-app-bar-title', 'v-app-bar');
/* harmony default export */ var VAppBarTitle = (base.extend().extend({
  name: 'v-app-bar-title',
  data: () => ({
    contentWidth: 0,
    left: 0,
    width: 0
  }),
  watch: {
    '$vuetify.breakpoint.width': 'updateDimensions'
  },
  computed: {
    styles() {
      if (!this.contentWidth) return {};
      const min = this.width;
      const max = this.contentWidth;
      const ratio = Object(easing_patterns["easeInOutCubic"])(Math.min(1, this.VAppBar.scrollRatio * 1.5));
      return {
        width: Object(helpers["i" /* convertToUnit */])(min + (max - min) * ratio),
        visibility: this.VAppBar.scrollRatio ? 'visible' : 'hidden'
      };
    }

  },

  mounted() {
    this.updateDimensions();
  },

  methods: {
    updateDimensions() {
      const dimensions = this.$refs.placeholder.getBoundingClientRect();
      this.width = dimensions.width;
      this.left = dimensions.left;
      this.contentWidth = this.$refs.content.scrollWidth;
    }

  },

  render(h) {
    return h('div', {
      class: 'v-toolbar__title v-app-bar-title'
    }, [h('div', {
      class: 'v-app-bar-title__content',
      style: this.styles,
      ref: 'content'
    }, [this.$slots.default]), h('div', {
      class: 'v-app-bar-title__placeholder',
      style: {
        visibility: this.VAppBar.scrollRatio ? 'hidden' : 'visible'
      },
      ref: 'placeholder'
    }, [this.$slots.default])]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VAppBar/index.js




/* harmony default export */ var components_VAppBar = ({
  $_vuetify_subcomponents: {
    VAppBar: VAppBar["a" /* default */],
    VAppBarNavIcon: VAppBarNavIcon["a" /* default */],
    VAppBarTitle: VAppBarTitle
  }
});

/***/ }),
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ VContainer["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ VCol["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ VRow["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ VSpacer["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ VLayout; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ VFlex; });

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VGrid/VContainer.js
var VContainer = __webpack_require__(377);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VGrid/VCol.js
var VCol = __webpack_require__(277);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VGrid/VRow.js
var VRow = __webpack_require__(278);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VGrid/VSpacer.js
var VSpacer = __webpack_require__(231);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VGrid/_grid.sass
var _grid = __webpack_require__(123);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VGrid/grid.js
var grid = __webpack_require__(299);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VGrid/VLayout.js


/* harmony default export */ var VLayout = (Object(grid["a" /* default */])('layout'));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VGrid/VFlex.js


/* harmony default export */ var VFlex = (Object(grid["a" /* default */])('flex'));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VGrid/index.js







/* harmony default export */ var VGrid = ({
  $_vuetify_subcomponents: {
    VContainer: VContainer["a" /* default */],
    VCol: VCol["a" /* default */],
    VRow: VRow["a" /* default */],
    VSpacer: VSpacer["a" /* default */],
    VLayout: VLayout,
    VFlex: VFlex
  }
});

/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VDivider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(210);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VDivider__WEBPACK_IMPORTED_MODULE_0__["a"]; });



/* harmony default export */ __webpack_exports__["b"] = (_VDivider__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VImg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VImg__WEBPACK_IMPORTED_MODULE_0__["a"]; });



/* unused harmony default export */ var _unused_webpack_default_export = (_VImg__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ }),
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VApp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(235);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VApp__WEBPACK_IMPORTED_MODULE_0__["a"]; });



/* unused harmony default export */ var _unused_webpack_default_export = (_VApp__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VMain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(206);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VMain__WEBPACK_IMPORTED_MODULE_0__["a"]; });



/* unused harmony default export */ var _unused_webpack_default_export = (_VMain__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VNavigationDrawer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(230);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VNavigationDrawer__WEBPACK_IMPORTED_MODULE_0__["a"]; });



/* unused harmony default export */ var _unused_webpack_default_export = (_VNavigationDrawer__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ }),
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VTextField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(201);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VTextField__WEBPACK_IMPORTED_MODULE_0__["a"]; });



/* harmony default export */ __webpack_exports__["b"] = (_VTextField__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ }),
/* 201 */,
/* 202 */,
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VThemeProvider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(128);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VThemeProvider__WEBPACK_IMPORTED_MODULE_0__["a"]; });



/* unused harmony default export */ var _unused_webpack_default_export = (_VThemeProvider__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ }),
/* 204 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VMenu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(211);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VMenu__WEBPACK_IMPORTED_MODULE_0__["a"]; });



/* harmony default export */ __webpack_exports__["b"] = (_VMenu__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ }),
/* 205 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VSnackbar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VSnackbar__WEBPACK_IMPORTED_MODULE_0__["a"]; });



/* unused harmony default export */ var _unused_webpack_default_export = (_VSnackbar__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ }),
/* 206 */,
/* 207 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VFooter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(233);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VFooter__WEBPACK_IMPORTED_MODULE_0__["a"]; });



/* unused harmony default export */ var _unused_webpack_default_export = (_VFooter__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ }),
/* 208 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ click_outside["a" /* ClickOutside */]; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ intersect["a" /* Intersect */]; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ Mutate; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ resize["a" /* Resize */]; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ ripple["a" /* Ripple */]; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ directives_scroll["a" /* Scroll */]; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* reexport */ touch["a" /* Touch */]; });

// EXTERNAL MODULE: ./node_modules/vuetify/lib/directives/click-outside/index.js
var click_outside = __webpack_require__(55);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/directives/intersect/index.js
var intersect = __webpack_require__(24);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/directives/mutate/index.js
function inserted(el, binding, vnode) {
  const modifiers = binding.modifiers || {};
  const value = binding.value;
  const callback = typeof value === 'object' ? value.handler : value;
  const {
    once,
    ...modifierKeys
  } = modifiers;
  const hasModifiers = Object.keys(modifierKeys).length > 0; // Options take top priority

  const options = typeof value === 'object' && value.options ? value.options : hasModifiers // If we have modifiers, use only those provided
  ? {
    attributes: modifierKeys.attr,
    childList: modifierKeys.child,
    subtree: modifierKeys.sub,
    characterData: modifierKeys.char
  } // Defaults to everything on
  : {
    attributes: true,
    childList: true,
    subtree: true,
    characterData: true
  };
  const observer = new MutationObserver((mutationsList, observer) => {
    /* istanbul ignore if */
    if (!el._mutate) return; // Just in case, should never fire

    callback(mutationsList, observer); // If has the once modifier, unbind

    once && unbind(el, binding, vnode);
  });
  observer.observe(el, options);
  el._mutate = Object(el._mutate);
  el._mutate[vnode.context._uid] = {
    observer
  };
}

function unbind(el, binding, vnode) {
  var _el$_mutate;

  if (!((_el$_mutate = el._mutate) != null && _el$_mutate[vnode.context._uid])) return;

  el._mutate[vnode.context._uid].observer.disconnect();

  delete el._mutate[vnode.context._uid];
}

const Mutate = {
  inserted,
  unbind
};
/* harmony default export */ var mutate = (Mutate);
// EXTERNAL MODULE: ./node_modules/vuetify/lib/directives/resize/index.js
var resize = __webpack_require__(20);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/directives/ripple/index.js
var ripple = __webpack_require__(25);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/directives/scroll/index.js
var directives_scroll = __webpack_require__(70);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/directives/touch/index.js
var touch = __webpack_require__(35);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/directives/index.js








/***/ }),
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 263 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export PARSE_REGEX */
/* unused harmony export PARSE_TIME */
/* unused harmony export DAYS_IN_MONTH */
/* unused harmony export DAYS_IN_MONTH_LEAP */
/* unused harmony export DAYS_IN_MONTH_MIN */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DAYS_IN_MONTH_MAX; });
/* unused harmony export MONTH_MAX */
/* unused harmony export MONTH_MIN */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return DAY_MIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return DAYS_IN_WEEK; });
/* unused harmony export MINUTES_IN_HOUR */
/* unused harmony export MINUTE_MAX */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return MINUTES_IN_DAY; });
/* unused harmony export HOURS_IN_DAY */
/* unused harmony export HOUR_MAX */
/* unused harmony export FIRST_HOUR */
/* unused harmony export OFFSET_YEAR */
/* unused harmony export OFFSET_MONTH */
/* unused harmony export OFFSET_HOUR */
/* unused harmony export OFFSET_TIME */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return getStartOfWeek; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return getEndOfWeek; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return getStartOfMonth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return getEndOfMonth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return validateTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return parseTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return validateTimestamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return parseTimestamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return parseDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return getDayIdentifier; });
/* unused harmony export getTimeIdentifier */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return getTimestampIdentifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return updateRelative; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return isTimedless; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return updateHasTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return updateMinutes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return updateWeekday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return updateFormatted; });
/* unused harmony export getWeekday */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return daysInMonth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return copyTimestamp; });
/* unused harmony export padNumber */
/* unused harmony export getDate */
/* unused harmony export getTime */
/* unused harmony export nextMinutes */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return nextDay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return prevDay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return relativeDays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return diffMinutes; });
/* unused harmony export findWeekday */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return getWeekdaySkips; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return timestampToDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return createDayList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return createIntervalList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return createNativeLocaleFormatter; });
/* harmony import */ var _util_dateTimeUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(303);

const PARSE_REGEX = /^(\d{4})-(\d{1,2})(-(\d{1,2}))?([^\d]+(\d{1,2}))?(:(\d{1,2}))?(:(\d{1,2}))?$/;
const PARSE_TIME = /(\d\d?)(:(\d\d?)|)(:(\d\d?)|)/;
const DAYS_IN_MONTH = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const DAYS_IN_MONTH_LEAP = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const DAYS_IN_MONTH_MIN = 28;
const DAYS_IN_MONTH_MAX = 31;
const MONTH_MAX = 12;
const MONTH_MIN = 1;
const DAY_MIN = 1;
const DAYS_IN_WEEK = 7;
const MINUTES_IN_HOUR = 60;
const MINUTE_MAX = 59;
const MINUTES_IN_DAY = 24 * 60;
const HOURS_IN_DAY = 24;
const HOUR_MAX = 23;
const FIRST_HOUR = 0;
const OFFSET_YEAR = 10000;
const OFFSET_MONTH = 100;
const OFFSET_HOUR = 100;
const OFFSET_TIME = 10000;
function getStartOfWeek(timestamp, weekdays, today) {
  const start = copyTimestamp(timestamp);
  findWeekday(start, weekdays[0], prevDay);
  updateFormatted(start);

  if (today) {
    updateRelative(start, today, start.hasTime);
  }

  return start;
}
function getEndOfWeek(timestamp, weekdays, today) {
  const end = copyTimestamp(timestamp);
  findWeekday(end, weekdays[weekdays.length - 1]);
  updateFormatted(end);

  if (today) {
    updateRelative(end, today, end.hasTime);
  }

  return end;
}
function getStartOfMonth(timestamp) {
  const start = copyTimestamp(timestamp);
  start.day = DAY_MIN;
  updateWeekday(start);
  updateFormatted(start);
  return start;
}
function getEndOfMonth(timestamp) {
  const end = copyTimestamp(timestamp);
  end.day = daysInMonth(end.year, end.month);
  updateWeekday(end);
  updateFormatted(end);
  return end;
}
function validateTime(input) {
  return typeof input === 'number' && isFinite(input) || !!PARSE_TIME.exec(input) || typeof input === 'object' && isFinite(input.hour) && isFinite(input.minute);
}
function parseTime(input) {
  if (typeof input === 'number') {
    // when a number is given, it's minutes since 12:00am
    return input;
  } else if (typeof input === 'string') {
    // when a string is given, it's a hh:mm:ss format where seconds are optional
    const parts = PARSE_TIME.exec(input);

    if (!parts) {
      return false;
    }

    return parseInt(parts[1]) * 60 + parseInt(parts[3] || 0);
  } else if (typeof input === 'object') {
    // when an object is given, it must have hour and minute
    if (typeof input.hour !== 'number' || typeof input.minute !== 'number') {
      return false;
    }

    return input.hour * 60 + input.minute;
  } else {
    // unsupported type
    return false;
  }
}
function validateTimestamp(input) {
  return typeof input === 'number' && isFinite(input) || typeof input === 'string' && !!PARSE_REGEX.exec(input) || input instanceof Date;
}
function parseTimestamp(input, required = false, now) {
  if (typeof input === 'number' && isFinite(input)) {
    input = new Date(input);
  }

  if (input instanceof Date) {
    const date = parseDate(input);

    if (now) {
      updateRelative(date, now, date.hasTime);
    }

    return date;
  }

  if (typeof input !== 'string') {
    if (required) {
      throw new Error(`${input} is not a valid timestamp. It must be a Date, number of milliseconds since Epoch, or a string in the format of YYYY-MM-DD or YYYY-MM-DD hh:mm. Zero-padding is optional and seconds are ignored.`);
    }

    return null;
  } // YYYY-MM-DD hh:mm:ss


  const parts = PARSE_REGEX.exec(input);

  if (!parts) {
    if (required) {
      throw new Error(`${input} is not a valid timestamp. It must be a Date, number of milliseconds since Epoch, or a string in the format of YYYY-MM-DD or YYYY-MM-DD hh:mm. Zero-padding is optional and seconds are ignored.`);
    }

    return null;
  }

  const timestamp = {
    date: input,
    time: '',
    year: parseInt(parts[1]),
    month: parseInt(parts[2]),
    day: parseInt(parts[4]) || 1,
    hour: parseInt(parts[6]) || 0,
    minute: parseInt(parts[8]) || 0,
    weekday: 0,
    hasDay: !!parts[4],
    hasTime: !!(parts[6] && parts[8]),
    past: false,
    present: false,
    future: false
  };
  updateWeekday(timestamp);
  updateFormatted(timestamp);

  if (now) {
    updateRelative(timestamp, now, timestamp.hasTime);
  }

  return timestamp;
}
function parseDate(date) {
  return updateFormatted({
    date: '',
    time: '',
    year: date.getFullYear(),
    month: date.getMonth() + 1,
    day: date.getDate(),
    weekday: date.getDay(),
    hour: date.getHours(),
    minute: date.getMinutes(),
    hasDay: true,
    hasTime: true,
    past: false,
    present: true,
    future: false
  });
}
function getDayIdentifier(timestamp) {
  return timestamp.year * OFFSET_YEAR + timestamp.month * OFFSET_MONTH + timestamp.day;
}
function getTimeIdentifier(timestamp) {
  return timestamp.hour * OFFSET_HOUR + timestamp.minute;
}
function getTimestampIdentifier(timestamp) {
  return getDayIdentifier(timestamp) * OFFSET_TIME + getTimeIdentifier(timestamp);
}
function updateRelative(timestamp, now, time = false) {
  let a = getDayIdentifier(now);
  let b = getDayIdentifier(timestamp);
  let present = a === b;

  if (timestamp.hasTime && time && present) {
    a = getTimeIdentifier(now);
    b = getTimeIdentifier(timestamp);
    present = a === b;
  }

  timestamp.past = b < a;
  timestamp.present = present;
  timestamp.future = b > a;
  return timestamp;
}
function isTimedless(input) {
  return input instanceof Date || typeof input === 'number' && isFinite(input);
}
function updateHasTime(timestamp, hasTime, now) {
  if (timestamp.hasTime !== hasTime) {
    timestamp.hasTime = hasTime;

    if (!hasTime) {
      timestamp.hour = HOUR_MAX;
      timestamp.minute = MINUTE_MAX;
      timestamp.time = getTime(timestamp);
    }

    if (now) {
      updateRelative(timestamp, now, timestamp.hasTime);
    }
  }

  return timestamp;
}
function updateMinutes(timestamp, minutes, now) {
  timestamp.hasTime = true;
  timestamp.hour = Math.floor(minutes / MINUTES_IN_HOUR);
  timestamp.minute = minutes % MINUTES_IN_HOUR;
  timestamp.time = getTime(timestamp);

  if (now) {
    updateRelative(timestamp, now, true);
  }

  return timestamp;
}
function updateWeekday(timestamp) {
  timestamp.weekday = getWeekday(timestamp);
  return timestamp;
}
function updateFormatted(timestamp) {
  timestamp.time = getTime(timestamp);
  timestamp.date = getDate(timestamp);
  return timestamp;
}
function getWeekday(timestamp) {
  if (timestamp.hasDay) {
    const _ = Math.floor;
    const k = timestamp.day;
    const m = (timestamp.month + 9) % MONTH_MAX + 1;

    const C = _(timestamp.year / 100);

    const Y = timestamp.year % 100 - (timestamp.month <= 2 ? 1 : 0);
    return ((k + _(2.6 * m - 0.2) - 2 * C + Y + _(Y / 4) + _(C / 4)) % 7 + 7) % 7;
  }

  return timestamp.weekday;
}
function daysInMonth(year, month) {
  return Object(_util_dateTimeUtils__WEBPACK_IMPORTED_MODULE_0__[/* isLeapYear */ "a"])(year) ? DAYS_IN_MONTH_LEAP[month] : DAYS_IN_MONTH[month];
}
function copyTimestamp(timestamp) {
  const {
    date,
    time,
    year,
    month,
    day,
    weekday,
    hour,
    minute,
    hasDay,
    hasTime,
    past,
    present,
    future
  } = timestamp;
  return {
    date,
    time,
    year,
    month,
    day,
    weekday,
    hour,
    minute,
    hasDay,
    hasTime,
    past,
    present,
    future
  };
}
function padNumber(x, length) {
  let padded = String(x);

  while (padded.length < length) {
    padded = '0' + padded;
  }

  return padded;
}
function getDate(timestamp) {
  let str = `${padNumber(timestamp.year, 4)}-${padNumber(timestamp.month, 2)}`;
  if (timestamp.hasDay) str += `-${padNumber(timestamp.day, 2)}`;
  return str;
}
function getTime(timestamp) {
  if (!timestamp.hasTime) {
    return '';
  }

  return `${padNumber(timestamp.hour, 2)}:${padNumber(timestamp.minute, 2)}`;
}
function nextMinutes(timestamp, minutes) {
  timestamp.minute += minutes;

  while (timestamp.minute > MINUTES_IN_HOUR) {
    timestamp.minute -= MINUTES_IN_HOUR;
    timestamp.hour++;

    if (timestamp.hour >= HOURS_IN_DAY) {
      nextDay(timestamp);
      timestamp.hour = FIRST_HOUR;
    }
  }

  return timestamp;
}
function nextDay(timestamp) {
  timestamp.day++;
  timestamp.weekday = (timestamp.weekday + 1) % DAYS_IN_WEEK;

  if (timestamp.day > DAYS_IN_MONTH_MIN && timestamp.day > daysInMonth(timestamp.year, timestamp.month)) {
    timestamp.day = DAY_MIN;
    timestamp.month++;

    if (timestamp.month > MONTH_MAX) {
      timestamp.month = MONTH_MIN;
      timestamp.year++;
    }
  }

  return timestamp;
}
function prevDay(timestamp) {
  timestamp.day--;
  timestamp.weekday = (timestamp.weekday + 6) % DAYS_IN_WEEK;

  if (timestamp.day < DAY_MIN) {
    timestamp.month--;

    if (timestamp.month < MONTH_MIN) {
      timestamp.year--;
      timestamp.month = MONTH_MAX;
    }

    timestamp.day = daysInMonth(timestamp.year, timestamp.month);
  }

  return timestamp;
}
function relativeDays(timestamp, mover = nextDay, days = 1) {
  while (--days >= 0) mover(timestamp);

  return timestamp;
}
function diffMinutes(min, max) {
  const Y = (max.year - min.year) * 525600;
  const M = (max.month - min.month) * 43800;
  const D = (max.day - min.day) * 1440;
  const h = (max.hour - min.hour) * 60;
  const m = max.minute - min.minute;
  return Y + M + D + h + m;
}
function findWeekday(timestamp, weekday, mover = nextDay, maxDays = 6) {
  while (timestamp.weekday !== weekday && --maxDays >= 0) mover(timestamp);

  return timestamp;
}
function getWeekdaySkips(weekdays) {
  const skips = [1, 1, 1, 1, 1, 1, 1];
  const filled = [0, 0, 0, 0, 0, 0, 0];

  for (let i = 0; i < weekdays.length; i++) {
    filled[weekdays[i]] = 1;
  }

  for (let k = 0; k < DAYS_IN_WEEK; k++) {
    let skip = 1;

    for (let j = 1; j < DAYS_IN_WEEK; j++) {
      const next = (k + j) % DAYS_IN_WEEK;

      if (filled[next]) {
        break;
      }

      skip++;
    }

    skips[k] = filled[k] * skip;
  }

  return skips;
}
function timestampToDate(timestamp) {
  const time = `${padNumber(timestamp.hour, 2)}:${padNumber(timestamp.minute, 2)}`;
  const date = timestamp.date;
  return new Date(`${date}T${time}:00+00:00`);
}
function createDayList(start, end, now, weekdaySkips, max = 42, min = 0) {
  const stop = getDayIdentifier(end);
  const days = [];
  let current = copyTimestamp(start);
  let currentIdentifier = 0;
  let stopped = currentIdentifier === stop;

  if (stop < getDayIdentifier(start)) {
    throw new Error('End date is earlier than start date.');
  }

  while ((!stopped || days.length < min) && days.length < max) {
    currentIdentifier = getDayIdentifier(current);
    stopped = stopped || currentIdentifier === stop;

    if (weekdaySkips[current.weekday] === 0) {
      current = nextDay(current);
      continue;
    }

    const day = copyTimestamp(current);
    updateFormatted(day);
    updateRelative(day, now);
    days.push(day);
    current = relativeDays(current, nextDay, weekdaySkips[current.weekday]);
  }

  if (!days.length) throw new Error('No dates found using specified start date, end date, and weekdays.');
  return days;
}
function createIntervalList(timestamp, first, minutes, count, now) {
  const intervals = [];

  for (let i = 0; i < count; i++) {
    const mins = first + i * minutes;
    const int = copyTimestamp(timestamp);
    intervals.push(updateMinutes(int, mins, now));
  }

  return intervals;
}
function createNativeLocaleFormatter(locale, getOptions) {
  const emptyFormatter = (_t, _s) => '';

  if (typeof Intl === 'undefined' || typeof Intl.DateTimeFormat === 'undefined') {
    return emptyFormatter;
  }

  return (timestamp, short) => {
    try {
      const intlFormatter = new Intl.DateTimeFormat(locale || undefined, getOptions(timestamp, short));
      return intlFormatter.format(timestampToDate(timestamp));
    } catch (e) {
      return '';
    }
  };
}

/***/ }),
/* 264 */,
/* 265 */,
/* 266 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ defaultMenuProps; });

// EXTERNAL MODULE: external "core-js/modules/esnext.array.last-item.js"
var esnext_array_last_item_js_ = __webpack_require__(247);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.delete-all.js"
var esnext_map_delete_all_js_ = __webpack_require__(187);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.every.js"
var esnext_map_every_js_ = __webpack_require__(188);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.filter.js"
var esnext_map_filter_js_ = __webpack_require__(189);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.find.js"
var esnext_map_find_js_ = __webpack_require__(190);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.find-key.js"
var esnext_map_find_key_js_ = __webpack_require__(191);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.includes.js"
var esnext_map_includes_js_ = __webpack_require__(192);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.key-of.js"
var esnext_map_key_of_js_ = __webpack_require__(193);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.map-keys.js"
var esnext_map_map_keys_js_ = __webpack_require__(194);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.map-values.js"
var esnext_map_map_values_js_ = __webpack_require__(195);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.merge.js"
var esnext_map_merge_js_ = __webpack_require__(196);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.reduce.js"
var esnext_map_reduce_js_ = __webpack_require__(197);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.some.js"
var esnext_map_some_js_ = __webpack_require__(198);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.update.js"
var esnext_map_update_js_ = __webpack_require__(199);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VTextField/VTextField.sass
var VTextField = __webpack_require__(127);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VSelect/VSelect.sass
var VSelect = __webpack_require__(418);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VChip/index.js
var VChip = __webpack_require__(267);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VMenu/index.js
var VMenu = __webpack_require__(204);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VCheckbox/VSimpleCheckbox.js
var VSimpleCheckbox = __webpack_require__(280);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VDivider/index.js
var VDivider = __webpack_require__(89);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VSubheader/index.js + 1 modules
var VSubheader = __webpack_require__(314);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VList/VListItem.js
var VListItem = __webpack_require__(52);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VList/VListItemAction.js
var VListItemAction = __webpack_require__(80);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VList/index.js + 2 modules
var VList = __webpack_require__(11);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VList/VList.js
var VList_VList = __webpack_require__(79);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/directives/ripple/index.js
var ripple = __webpack_require__(25);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/colorable/index.js
var colorable = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/themeable/index.js
var themeable = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/util/helpers.js
var helpers = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/util/mixins.js
var mixins = __webpack_require__(2);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSelect/VSelectList.js
// Components



 // Directives

 // Mixins


 // Helpers

 // Types


/* @vue/component */

/* harmony default export */ var VSelectList = (Object(mixins["a" /* default */])(colorable["a" /* default */], themeable["a" /* default */]).extend({
  name: 'v-select-list',
  // https://github.com/vuejs/vue/issues/6872
  directives: {
    ripple: ripple["b" /* default */]
  },
  props: {
    action: Boolean,
    dense: Boolean,
    hideSelected: Boolean,
    items: {
      type: Array,
      default: () => []
    },
    itemDisabled: {
      type: [String, Array, Function],
      default: 'disabled'
    },
    itemText: {
      type: [String, Array, Function],
      default: 'text'
    },
    itemValue: {
      type: [String, Array, Function],
      default: 'value'
    },
    noDataText: String,
    noFilter: Boolean,
    searchInput: null,
    selectedItems: {
      type: Array,
      default: () => []
    }
  },
  computed: {
    parsedItems() {
      return this.selectedItems.map(item => this.getValue(item));
    },

    tileActiveClass() {
      return Object.keys(this.setTextColor(this.color).class || {}).join(' ');
    },

    staticNoDataTile() {
      const tile = {
        attrs: {
          role: undefined
        },
        on: {
          mousedown: e => e.preventDefault()
        }
      };
      return this.$createElement(VListItem["a" /* default */], tile, [this.genTileContent(this.noDataText)]);
    }

  },
  methods: {
    genAction(item, inputValue) {
      return this.$createElement(VListItemAction["a" /* default */], [this.$createElement(VSimpleCheckbox["a" /* default */], {
        props: {
          color: this.color,
          value: inputValue,
          ripple: false
        },
        on: {
          input: () => this.$emit('select', item)
        }
      })]);
    },

    genDivider(props) {
      return this.$createElement(VDivider["b" /* default */], {
        props
      });
    },

    genFilteredText(text) {
      text = text || '';
      if (!this.searchInput || this.noFilter) return Object(helpers["o" /* escapeHTML */])(text);
      const {
        start,
        middle,
        end
      } = this.getMaskedCharacters(text);
      return `${Object(helpers["o" /* escapeHTML */])(start)}${this.genHighlight(middle)}${Object(helpers["o" /* escapeHTML */])(end)}`;
    },

    genHeader(props) {
      return this.$createElement(VSubheader["b" /* default */], {
        props
      }, props.header);
    },

    genHighlight(text) {
      return `<span class="v-list-item__mask">${Object(helpers["o" /* escapeHTML */])(text)}</span>`;
    },

    getMaskedCharacters(text) {
      const searchInput = (this.searchInput || '').toString().toLocaleLowerCase();
      const index = text.toLocaleLowerCase().indexOf(searchInput);
      if (index < 0) return {
        start: text,
        middle: '',
        end: ''
      };
      const start = text.slice(0, index);
      const middle = text.slice(index, index + searchInput.length);
      const end = text.slice(index + searchInput.length);
      return {
        start,
        middle,
        end
      };
    },

    genTile({
      item,
      index,
      disabled = null,
      value = false
    }) {
      if (!value) value = this.hasItem(item);

      if (item === Object(item)) {
        disabled = disabled !== null ? disabled : this.getDisabled(item);
      }

      const tile = {
        attrs: {
          // Default behavior in list does not
          // contain aria-selected by default
          'aria-selected': String(value),
          id: `list-item-${this._uid}-${index}`,
          role: 'option'
        },
        on: {
          mousedown: e => {
            // Prevent onBlur from being called
            e.preventDefault();
          },
          click: () => disabled || this.$emit('select', item)
        },
        props: {
          activeClass: this.tileActiveClass,
          disabled,
          ripple: true,
          inputValue: value
        }
      };

      if (!this.$scopedSlots.item) {
        return this.$createElement(VListItem["a" /* default */], tile, [this.action && !this.hideSelected && this.items.length > 0 ? this.genAction(item, value) : null, this.genTileContent(item, index)]);
      }

      const parent = this;
      const scopedSlot = this.$scopedSlots.item({
        parent,
        item,
        attrs: { ...tile.attrs,
          ...tile.props
        },
        on: tile.on
      });
      return this.needsTile(scopedSlot) ? this.$createElement(VListItem["a" /* default */], tile, scopedSlot) : scopedSlot;
    },

    genTileContent(item, index = 0) {
      const innerHTML = this.genFilteredText(this.getText(item));
      return this.$createElement(VList["g" /* VListItemContent */], [this.$createElement(VList["k" /* VListItemTitle */], {
        domProps: {
          innerHTML
        }
      })]);
    },

    hasItem(item) {
      return this.parsedItems.indexOf(this.getValue(item)) > -1;
    },

    needsTile(slot) {
      return slot.length !== 1 || slot[0].componentOptions == null || slot[0].componentOptions.Ctor.options.name !== 'v-list-item';
    },

    getDisabled(item) {
      return Boolean(Object(helpers["u" /* getPropertyFromItem */])(item, this.itemDisabled, false));
    },

    getText(item) {
      return String(Object(helpers["u" /* getPropertyFromItem */])(item, this.itemText, item));
    },

    getValue(item) {
      return Object(helpers["u" /* getPropertyFromItem */])(item, this.itemValue, this.getText(item));
    }

  },

  render() {
    const children = [];
    const itemsLength = this.items.length;

    for (let index = 0; index < itemsLength; index++) {
      const item = this.items[index];
      if (this.hideSelected && this.hasItem(item)) continue;
      if (item == null) children.push(this.genTile({
        item,
        index
      }));else if (item.header) children.push(this.genHeader(item));else if (item.divider) children.push(this.genDivider(item));else children.push(this.genTile({
        item,
        index
      }));
    }

    children.length || children.push(this.$slots['no-data'] || this.staticNoDataTile);
    this.$slots['prepend-item'] && children.unshift(this.$slots['prepend-item']);
    this.$slots['append-item'] && children.push(this.$slots['append-item']);
    return this.$createElement(VList_VList["a" /* default */], {
      staticClass: 'v-select-list',
      class: this.themeClasses,
      attrs: {
        role: 'listbox',
        tabindex: -1
      },
      props: {
        dense: this.dense
      }
    }, children);
  }

}));
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VInput/index.js + 1 modules
var VInput = __webpack_require__(23);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VTextField/VTextField.js
var VTextField_VTextField = __webpack_require__(201);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/comparable/index.js
var comparable = __webpack_require__(98);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/dependent/index.js
var dependent = __webpack_require__(56);

// EXTERNAL MODULE: external "vue"
var external_vue_ = __webpack_require__(1);
var external_vue_default = /*#__PURE__*/__webpack_require__.n(external_vue_);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/mixins/filterable/index.js

/* @vue/component */

/* harmony default export */ var filterable = (external_vue_default.a.extend({
  name: 'filterable',
  props: {
    noDataText: {
      type: String,
      default: '$vuetify.noDataText'
    }
  }
}));
// EXTERNAL MODULE: ./node_modules/vuetify/lib/directives/click-outside/index.js
var click_outside = __webpack_require__(55);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/util/mergeData.js
var mergeData = __webpack_require__(28);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/util/console.js
var console = __webpack_require__(3);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSelect/VSelect.js














// Styles

 // Components



 // Extensions


 // Mixins



 // Directives

 // Utilities



 // Types


const defaultMenuProps = {
  closeOnClick: false,
  closeOnContentClick: false,
  disableKeys: true,
  openOnClick: false,
  maxHeight: 304
}; // Types

const baseMixins = Object(mixins["a" /* default */])(VTextField_VTextField["a" /* default */], comparable["a" /* default */], dependent["a" /* default */], filterable);
/* @vue/component */

/* harmony default export */ var VSelect_VSelect = __webpack_exports__["a"] = (baseMixins.extend().extend({
  name: 'v-select',
  directives: {
    ClickOutside: click_outside["b" /* default */]
  },
  props: {
    appendIcon: {
      type: String,
      default: '$dropdown'
    },
    attach: {
      type: null,
      default: false
    },
    cacheItems: Boolean,
    chips: Boolean,
    clearable: Boolean,
    deletableChips: Boolean,
    disableLookup: Boolean,
    eager: Boolean,
    hideSelected: Boolean,
    items: {
      type: Array,
      default: () => []
    },
    itemColor: {
      type: String,
      default: 'primary'
    },
    itemDisabled: {
      type: [String, Array, Function],
      default: 'disabled'
    },
    itemText: {
      type: [String, Array, Function],
      default: 'text'
    },
    itemValue: {
      type: [String, Array, Function],
      default: 'value'
    },
    menuProps: {
      type: [String, Array, Object],
      default: () => defaultMenuProps
    },
    multiple: Boolean,
    openOnClear: Boolean,
    returnObject: Boolean,
    smallChips: Boolean
  },

  data() {
    return {
      cachedItems: this.cacheItems ? this.items : [],
      menuIsBooted: false,
      isMenuActive: false,
      lastItem: 20,
      // As long as a value is defined, show it
      // Otherwise, check if multiple
      // to determine which default to provide
      lazyValue: this.value !== undefined ? this.value : this.multiple ? [] : undefined,
      selectedIndex: -1,
      selectedItems: [],
      keyboardLookupPrefix: '',
      keyboardLookupLastTime: 0
    };
  },

  computed: {
    /* All items that the select has */
    allItems() {
      return this.filterDuplicates(this.cachedItems.concat(this.items));
    },

    classes() {
      return { ...VTextField_VTextField["a" /* default */].options.computed.classes.call(this),
        'v-select': true,
        'v-select--chips': this.hasChips,
        'v-select--chips--small': this.smallChips,
        'v-select--is-menu-active': this.isMenuActive,
        'v-select--is-multi': this.multiple
      };
    },

    /* Used by other components to overwrite */
    computedItems() {
      return this.allItems;
    },

    computedOwns() {
      return `list-${this._uid}`;
    },

    computedCounterValue() {
      const value = this.multiple ? this.selectedItems : (this.getText(this.selectedItems[0]) || '').toString();

      if (typeof this.counterValue === 'function') {
        return this.counterValue(value);
      }

      return value.length;
    },

    directives() {
      return this.isFocused ? [{
        name: 'click-outside',
        value: {
          handler: this.blur,
          closeConditional: this.closeConditional,
          include: () => this.getOpenDependentElements()
        }
      }] : undefined;
    },

    dynamicHeight() {
      return 'auto';
    },

    hasChips() {
      return this.chips || this.smallChips;
    },

    hasSlot() {
      return Boolean(this.hasChips || this.$scopedSlots.selection);
    },

    isDirty() {
      return this.selectedItems.length > 0;
    },

    listData() {
      const scopeId = this.$vnode && this.$vnode.context.$options._scopeId;
      const attrs = scopeId ? {
        [scopeId]: true
      } : {};
      return {
        attrs: { ...attrs,
          id: this.computedOwns
        },
        props: {
          action: this.multiple,
          color: this.itemColor,
          dense: this.dense,
          hideSelected: this.hideSelected,
          items: this.virtualizedItems,
          itemDisabled: this.itemDisabled,
          itemText: this.itemText,
          itemValue: this.itemValue,
          noDataText: this.$vuetify.lang.t(this.noDataText),
          selectedItems: this.selectedItems
        },
        on: {
          select: this.selectItem
        },
        scopedSlots: {
          item: this.$scopedSlots.item
        }
      };
    },

    staticList() {
      if (this.$slots['no-data'] || this.$slots['prepend-item'] || this.$slots['append-item']) {
        Object(console["b" /* consoleError */])('assert: staticList should not be called if slots are used');
      }

      return this.$createElement(VSelectList, this.listData);
    },

    virtualizedItems() {
      return this.$_menuProps.auto ? this.computedItems : this.computedItems.slice(0, this.lastItem);
    },

    menuCanShow: () => true,

    $_menuProps() {
      let normalisedProps = typeof this.menuProps === 'string' ? this.menuProps.split(',') : this.menuProps;

      if (Array.isArray(normalisedProps)) {
        normalisedProps = normalisedProps.reduce((acc, p) => {
          acc[p.trim()] = true;
          return acc;
        }, {});
      }

      return { ...defaultMenuProps,
        eager: this.eager,
        value: this.menuCanShow && this.isMenuActive,
        nudgeBottom: normalisedProps.offsetY ? 1 : 0,
        ...normalisedProps
      };
    }

  },
  watch: {
    internalValue(val) {
      this.initialValue = val;
      this.setSelectedItems();
    },

    isMenuActive(val) {
      window.setTimeout(() => this.onMenuActiveChange(val));
    },

    items: {
      immediate: true,

      handler(val) {
        if (this.cacheItems) {
          // Breaks vue-test-utils if
          // this isn't calculated
          // on the next tick
          this.$nextTick(() => {
            this.cachedItems = this.filterDuplicates(this.cachedItems.concat(val));
          });
        }

        this.setSelectedItems();
      }

    }
  },
  methods: {
    /** @public */
    blur(e) {
      VTextField_VTextField["a" /* default */].options.methods.blur.call(this, e);
      this.isMenuActive = false;
      this.isFocused = false;
      this.selectedIndex = -1;
      this.setMenuIndex(-1);
    },

    /** @public */
    activateMenu() {
      if (!this.isInteractive || this.isMenuActive) return;
      this.isMenuActive = true;
    },

    clearableCallback() {
      this.setValue(this.multiple ? [] : null);
      this.setMenuIndex(-1);
      this.$nextTick(() => this.$refs.input && this.$refs.input.focus());
      if (this.openOnClear) this.isMenuActive = true;
    },

    closeConditional(e) {
      if (!this.isMenuActive) return true;
      return !this._isDestroyed && ( // Click originates from outside the menu content
      // Multiple selects don't close when an item is clicked
      !this.getContent() || !this.getContent().contains(e.target)) && // Click originates from outside the element
      this.$el && !this.$el.contains(e.target) && e.target !== this.$el;
    },

    filterDuplicates(arr) {
      const uniqueValues = new Map();

      for (let index = 0; index < arr.length; ++index) {
        const item = arr[index]; // Do not deduplicate headers or dividers (#12517)

        if (item.header || item.divider) {
          uniqueValues.set(item, item);
          continue;
        }

        const val = this.getValue(item); // TODO: comparator

        !uniqueValues.has(val) && uniqueValues.set(val, item);
      }

      return Array.from(uniqueValues.values());
    },

    findExistingIndex(item) {
      const itemValue = this.getValue(item);
      return (this.internalValue || []).findIndex(i => this.valueComparator(this.getValue(i), itemValue));
    },

    getContent() {
      return this.$refs.menu && this.$refs.menu.$refs.content;
    },

    genChipSelection(item, index) {
      const isDisabled = this.isDisabled || this.getDisabled(item);
      const isInteractive = !isDisabled && this.isInteractive;
      return this.$createElement(VChip["b" /* default */], {
        staticClass: 'v-chip--select',
        attrs: {
          tabindex: -1
        },
        props: {
          close: this.deletableChips && isInteractive,
          disabled: isDisabled,
          inputValue: index === this.selectedIndex,
          small: this.smallChips
        },
        on: {
          click: e => {
            if (!isInteractive) return;
            e.stopPropagation();
            this.selectedIndex = index;
          },
          'click:close': () => this.onChipInput(item)
        },
        key: JSON.stringify(this.getValue(item))
      }, this.getText(item));
    },

    genCommaSelection(item, index, last) {
      const color = index === this.selectedIndex && this.computedColor;
      const isDisabled = this.isDisabled || this.getDisabled(item);
      return this.$createElement('div', this.setTextColor(color, {
        staticClass: 'v-select__selection v-select__selection--comma',
        class: {
          'v-select__selection--disabled': isDisabled
        },
        key: JSON.stringify(this.getValue(item))
      }), `${this.getText(item)}${last ? '' : ', '}`);
    },

    genDefaultSlot() {
      const selections = this.genSelections();
      const input = this.genInput(); // If the return is an empty array
      // push the input

      if (Array.isArray(selections)) {
        selections.push(input); // Otherwise push it into children
      } else {
        selections.children = selections.children || [];
        selections.children.push(input);
      }

      return [this.genFieldset(), this.$createElement('div', {
        staticClass: 'v-select__slot',
        directives: this.directives
      }, [this.genLabel(), this.prefix ? this.genAffix('prefix') : null, selections, this.suffix ? this.genAffix('suffix') : null, this.genClearIcon(), this.genIconSlot(), this.genHiddenInput()]), this.genMenu(), this.genProgress()];
    },

    genIcon(type, cb, extraData) {
      const icon = VInput["b" /* default */].options.methods.genIcon.call(this, type, cb, extraData);

      if (type === 'append') {
        // Don't allow the dropdown icon to be focused
        icon.children[0].data = Object(mergeData["a" /* default */])(icon.children[0].data, {
          attrs: {
            tabindex: icon.children[0].componentOptions.listeners && '-1',
            'aria-hidden': 'true',
            'aria-label': undefined
          }
        });
      }

      return icon;
    },

    genInput() {
      const input = VTextField_VTextField["a" /* default */].options.methods.genInput.call(this);
      delete input.data.attrs.name;
      input.data = Object(mergeData["a" /* default */])(input.data, {
        domProps: {
          value: null
        },
        attrs: {
          readonly: true,
          type: 'text',
          'aria-readonly': String(this.isReadonly),
          'aria-activedescendant': Object(helpers["s" /* getObjectValueByPath */])(this.$refs.menu, 'activeTile.id'),
          autocomplete: Object(helpers["s" /* getObjectValueByPath */])(input.data, 'attrs.autocomplete', 'off'),
          placeholder: !this.isDirty && (this.persistentPlaceholder || this.isFocused || !this.hasLabel) ? this.placeholder : undefined
        },
        on: {
          keypress: this.onKeyPress
        }
      });
      return input;
    },

    genHiddenInput() {
      return this.$createElement('input', {
        domProps: {
          value: this.lazyValue
        },
        attrs: {
          type: 'hidden',
          name: this.attrs$.name
        }
      });
    },

    genInputSlot() {
      const render = VTextField_VTextField["a" /* default */].options.methods.genInputSlot.call(this);
      render.data.attrs = { ...render.data.attrs,
        role: 'button',
        'aria-haspopup': 'listbox',
        'aria-expanded': String(this.isMenuActive),
        'aria-owns': this.computedOwns
      };
      return render;
    },

    genList() {
      // If there's no slots, we can use a cached VNode to improve performance
      if (this.$slots['no-data'] || this.$slots['prepend-item'] || this.$slots['append-item']) {
        return this.genListWithSlot();
      } else {
        return this.staticList;
      }
    },

    genListWithSlot() {
      const slots = ['prepend-item', 'no-data', 'append-item'].filter(slotName => this.$slots[slotName]).map(slotName => this.$createElement('template', {
        slot: slotName
      }, this.$slots[slotName])); // Requires destructuring due to Vue
      // modifying the `on` property when passed
      // as a referenced object

      return this.$createElement(VSelectList, { ...this.listData
      }, slots);
    },

    genMenu() {
      const props = this.$_menuProps;
      props.activator = this.$refs['input-slot']; // Attach to root el so that
      // menu covers prepend/append icons

      if ( // TODO: make this a computed property or helper or something
      this.attach === '' || // If used as a boolean prop (<v-menu attach>)
      this.attach === true || // If bound to a boolean (<v-menu :attach="true">)
      this.attach === 'attach' // If bound as boolean prop in pug (v-menu(attach))
      ) {
        props.attach = this.$el;
      } else {
        props.attach = this.attach;
      }

      return this.$createElement(VMenu["b" /* default */], {
        attrs: {
          role: undefined
        },
        props,
        on: {
          input: val => {
            this.isMenuActive = val;
            this.isFocused = val;
          },
          scroll: this.onScroll
        },
        ref: 'menu'
      }, [this.genList()]);
    },

    genSelections() {
      let length = this.selectedItems.length;
      const children = new Array(length);
      let genSelection;

      if (this.$scopedSlots.selection) {
        genSelection = this.genSlotSelection;
      } else if (this.hasChips) {
        genSelection = this.genChipSelection;
      } else {
        genSelection = this.genCommaSelection;
      }

      while (length--) {
        children[length] = genSelection(this.selectedItems[length], length, length === children.length - 1);
      }

      return this.$createElement('div', {
        staticClass: 'v-select__selections'
      }, children);
    },

    genSlotSelection(item, index) {
      return this.$scopedSlots.selection({
        attrs: {
          class: 'v-chip--select'
        },
        parent: this,
        item,
        index,
        select: e => {
          e.stopPropagation();
          this.selectedIndex = index;
        },
        selected: index === this.selectedIndex,
        disabled: !this.isInteractive
      });
    },

    getMenuIndex() {
      return this.$refs.menu ? this.$refs.menu.listIndex : -1;
    },

    getDisabled(item) {
      return Object(helpers["u" /* getPropertyFromItem */])(item, this.itemDisabled, false);
    },

    getText(item) {
      return Object(helpers["u" /* getPropertyFromItem */])(item, this.itemText, item);
    },

    getValue(item) {
      return Object(helpers["u" /* getPropertyFromItem */])(item, this.itemValue, this.getText(item));
    },

    onBlur(e) {
      e && this.$emit('blur', e);
    },

    onChipInput(item) {
      if (this.multiple) this.selectItem(item);else this.setValue(null); // If all items have been deleted,
      // open `v-menu`

      if (this.selectedItems.length === 0) {
        this.isMenuActive = true;
      } else {
        this.isMenuActive = false;
      }

      this.selectedIndex = -1;
    },

    onClick(e) {
      if (!this.isInteractive) return;

      if (!this.isAppendInner(e.target)) {
        this.isMenuActive = true;
      }

      if (!this.isFocused) {
        this.isFocused = true;
        this.$emit('focus');
      }

      this.$emit('click', e);
    },

    onEscDown(e) {
      e.preventDefault();

      if (this.isMenuActive) {
        e.stopPropagation();
        this.isMenuActive = false;
      }
    },

    onKeyPress(e) {
      if (this.multiple || !this.isInteractive || this.disableLookup) return;
      const KEYBOARD_LOOKUP_THRESHOLD = 1000; // milliseconds

      const now = performance.now();

      if (now - this.keyboardLookupLastTime > KEYBOARD_LOOKUP_THRESHOLD) {
        this.keyboardLookupPrefix = '';
      }

      this.keyboardLookupPrefix += e.key.toLowerCase();
      this.keyboardLookupLastTime = now;
      const index = this.allItems.findIndex(item => {
        const text = (this.getText(item) || '').toString();
        return text.toLowerCase().startsWith(this.keyboardLookupPrefix);
      });
      const item = this.allItems[index];

      if (index !== -1) {
        this.lastItem = Math.max(this.lastItem, index + 5);
        this.setValue(this.returnObject ? item : this.getValue(item));
        this.$nextTick(() => this.$refs.menu.getTiles());
        setTimeout(() => this.setMenuIndex(index));
      }
    },

    onKeyDown(e) {
      if (this.isReadonly && e.keyCode !== helpers["B" /* keyCodes */].tab) return;
      const keyCode = e.keyCode;
      const menu = this.$refs.menu;
      this.$emit('keydown', e);
      if (!menu) return; // If menu is active, allow default
      // listIndex change from menu

      if (this.isMenuActive && [helpers["B" /* keyCodes */].up, helpers["B" /* keyCodes */].down, helpers["B" /* keyCodes */].home, helpers["B" /* keyCodes */].end, helpers["B" /* keyCodes */].enter].includes(keyCode)) {
        this.$nextTick(() => {
          menu.changeListIndex(e);
          this.$emit('update:list-index', menu.listIndex);
        });
      } // If enter, space, open menu


      if ([helpers["B" /* keyCodes */].enter, helpers["B" /* keyCodes */].space].includes(keyCode)) this.activateMenu(); // If menu is not active, up/down/home/end can do
      // one of 2 things. If multiple, opens the
      // menu, if not, will cycle through all
      // available options

      if (!this.isMenuActive && [helpers["B" /* keyCodes */].up, helpers["B" /* keyCodes */].down, helpers["B" /* keyCodes */].home, helpers["B" /* keyCodes */].end].includes(keyCode)) return this.onUpDown(e); // If escape deactivate the menu

      if (keyCode === helpers["B" /* keyCodes */].esc) return this.onEscDown(e); // If tab - select item or close menu

      if (keyCode === helpers["B" /* keyCodes */].tab) return this.onTabDown(e); // If space preventDefault

      if (keyCode === helpers["B" /* keyCodes */].space) return this.onSpaceDown(e);
    },

    onMenuActiveChange(val) {
      // If menu is closing and mulitple
      // or menuIndex is already set
      // skip menu index recalculation
      if (this.multiple && !val || this.getMenuIndex() > -1) return;
      const menu = this.$refs.menu;
      if (!menu || !this.isDirty) return; // When menu opens, set index of first active item

      this.$refs.menu.getTiles();

      for (let i = 0; i < menu.tiles.length; i++) {
        if (menu.tiles[i].getAttribute('aria-selected') === 'true') {
          this.setMenuIndex(i);
          break;
        }
      }
    },

    onMouseUp(e) {
      // eslint-disable-next-line sonarjs/no-collapsible-if
      if (this.hasMouseDown && e.which !== 3 && this.isInteractive) {
        // If append inner is present
        // and the target is itself
        // or inside, toggle menu
        if (this.isAppendInner(e.target)) {
          this.$nextTick(() => this.isMenuActive = !this.isMenuActive);
        }
      }

      VTextField_VTextField["a" /* default */].options.methods.onMouseUp.call(this, e);
    },

    onScroll() {
      if (!this.isMenuActive) {
        requestAnimationFrame(() => this.getContent().scrollTop = 0);
      } else {
        if (this.lastItem > this.computedItems.length) return;
        const showMoreItems = this.getContent().scrollHeight - (this.getContent().scrollTop + this.getContent().clientHeight) < 200;

        if (showMoreItems) {
          this.lastItem += 20;
        }
      }
    },

    onSpaceDown(e) {
      e.preventDefault();
    },

    onTabDown(e) {
      const menu = this.$refs.menu;
      if (!menu) return;
      const activeTile = menu.activeTile; // An item that is selected by
      // menu-index should toggled

      if (!this.multiple && activeTile && this.isMenuActive) {
        e.preventDefault();
        e.stopPropagation();
        activeTile.click();
      } else {
        // If we make it here,
        // the user has no selected indexes
        // and is probably tabbing out
        this.blur(e);
      }
    },

    onUpDown(e) {
      const menu = this.$refs.menu;
      if (!menu) return;
      e.preventDefault(); // Multiple selects do not cycle their value
      // when pressing up or down, instead activate
      // the menu

      if (this.multiple) return this.activateMenu();
      const keyCode = e.keyCode; // Cycle through available values to achieve
      // select native behavior

      menu.isBooted = true;
      window.requestAnimationFrame(() => {
        menu.getTiles();
        if (!menu.hasClickableTiles) return this.activateMenu();

        switch (keyCode) {
          case helpers["B" /* keyCodes */].up:
            menu.prevTile();
            break;

          case helpers["B" /* keyCodes */].down:
            menu.nextTile();
            break;

          case helpers["B" /* keyCodes */].home:
            menu.firstTile();
            break;

          case helpers["B" /* keyCodes */].end:
            menu.lastTile();
            break;
        }

        this.selectItem(this.allItems[this.getMenuIndex()]);
      });
    },

    selectItem(item) {
      if (!this.multiple) {
        this.setValue(this.returnObject ? item : this.getValue(item));
        this.isMenuActive = false;
      } else {
        const internalValue = (this.internalValue || []).slice();
        const i = this.findExistingIndex(item);
        i !== -1 ? internalValue.splice(i, 1) : internalValue.push(item);
        this.setValue(internalValue.map(i => {
          return this.returnObject ? i : this.getValue(i);
        })); // When selecting multiple
        // adjust menu after each
        // selection

        this.$nextTick(() => {
          this.$refs.menu && this.$refs.menu.updateDimensions();
        }); // There is no item to re-highlight
        // when selections are hidden

        if (this.hideSelected) {
          this.setMenuIndex(-1);
        } else {
          const index = this.allItems.indexOf(item);

          if (~index) {
            this.$nextTick(() => this.$refs.menu.getTiles());
            setTimeout(() => this.setMenuIndex(index));
          }
        }
      }
    },

    setMenuIndex(index) {
      this.$refs.menu && (this.$refs.menu.listIndex = index);
    },

    setSelectedItems() {
      const selectedItems = [];
      const values = !this.multiple || !Array.isArray(this.internalValue) ? [this.internalValue] : this.internalValue;

      for (const value of values) {
        const index = this.allItems.findIndex(v => this.valueComparator(this.getValue(v), this.getValue(value)));

        if (index > -1) {
          selectedItems.push(this.allItems[index]);
        }
      }

      this.selectedItems = selectedItems;
    },

    setValue(value) {
      if (!this.valueComparator(value, this.internalValue)) {
        this.internalValue = value;
        this.$emit('change', value);
      }
    },

    isAppendInner(target) {
      // return true if append inner is present
      // and the target is itself or inside
      const appendInner = this.$refs['append-inner'];
      return appendInner && (appendInner === target || appendInner.contains(target));
    }

  }
}));

/***/ }),
/* 267 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VChip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(300);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VChip__WEBPACK_IMPORTED_MODULE_0__["a"]; });



/* harmony default export */ __webpack_exports__["b"] = (_VChip__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ }),
/* 268 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mixins_bootable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/* harmony import */ var _mixins_groupable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34);
/* harmony import */ var _directives_touch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35);
/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2);
// Mixins

 // Directives

 // Utilities



const baseMixins = Object(_util_mixins__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(_mixins_bootable__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"], Object(_mixins_groupable__WEBPACK_IMPORTED_MODULE_1__[/* factory */ "a"])('windowGroup', 'v-window-item', 'v-window'));
/* harmony default export */ __webpack_exports__["a"] = (baseMixins.extend().extend().extend({
  name: 'v-window-item',
  directives: {
    Touch: _directives_touch__WEBPACK_IMPORTED_MODULE_2__[/* default */ "b"]
  },
  props: {
    disabled: Boolean,
    reverseTransition: {
      type: [Boolean, String],
      default: undefined
    },
    transition: {
      type: [Boolean, String],
      default: undefined
    },
    value: {
      required: false
    }
  },

  data() {
    return {
      isActive: false,
      inTransition: false
    };
  },

  computed: {
    classes() {
      return this.groupClasses;
    },

    computedTransition() {
      if (!this.windowGroup.internalReverse) {
        return typeof this.transition !== 'undefined' ? this.transition || '' : this.windowGroup.computedTransition;
      }

      return typeof this.reverseTransition !== 'undefined' ? this.reverseTransition || '' : this.windowGroup.computedTransition;
    }

  },
  methods: {
    genDefaultSlot() {
      return this.$slots.default;
    },

    genWindowItem() {
      return this.$createElement('div', {
        staticClass: 'v-window-item',
        class: this.classes,
        directives: [{
          name: 'show',
          value: this.isActive
        }],
        on: this.$listeners
      }, this.genDefaultSlot());
    },

    onAfterTransition() {
      if (!this.inTransition) {
        return;
      } // Finalize transition state.


      this.inTransition = false;

      if (this.windowGroup.transitionCount > 0) {
        this.windowGroup.transitionCount--; // Remove container height if we are out of transition.

        if (this.windowGroup.transitionCount === 0) {
          this.windowGroup.transitionHeight = undefined;
        }
      }
    },

    onBeforeTransition() {
      if (this.inTransition) {
        return;
      } // Initialize transition state here.


      this.inTransition = true;

      if (this.windowGroup.transitionCount === 0) {
        // Set initial height for height transition.
        this.windowGroup.transitionHeight = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_3__[/* convertToUnit */ "i"])(this.windowGroup.$el.clientHeight);
      }

      this.windowGroup.transitionCount++;
    },

    onTransitionCancelled() {
      this.onAfterTransition(); // This should have the same path as normal transition end.
    },

    onEnter(el) {
      if (!this.inTransition) {
        return;
      }

      this.$nextTick(() => {
        // Do not set height if no transition or cancelled.
        if (!this.computedTransition || !this.inTransition) {
          return;
        } // Set transition target height.


        this.windowGroup.transitionHeight = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_3__[/* convertToUnit */ "i"])(el.clientHeight);
      });
    }

  },

  render(h) {
    return h('transition', {
      props: {
        name: this.computedTransition
      },
      on: {
        // Handlers for enter windows.
        beforeEnter: this.onBeforeTransition,
        afterEnter: this.onAfterTransition,
        enterCancelled: this.onTransitionCancelled,
        // Handlers for leave windows.
        beforeLeave: this.onBeforeTransition,
        afterLeave: this.onAfterTransition,
        leaveCancelled: this.onTransitionCancelled,
        // Enter handler for height transition.
        enter: this.onEnter
      }
    }, this.showLazyContent(() => [this.genWindowItem()]));
  }

}));

/***/ }),
/* 269 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VDialog__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(281);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VDialog__WEBPACK_IMPORTED_MODULE_0__["a"]; });



/* unused harmony default export */ var _unused_webpack_default_export = (_VDialog__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ }),
/* 270 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _components_VItemGroup_VItemGroup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
// Extensions

/* @vue/component */

/* harmony default export */ __webpack_exports__["a"] = (_components_VItemGroup_VItemGroup__WEBPACK_IMPORTED_MODULE_0__[/* BaseItemGroup */ "a"].extend({
  name: 'button-group',

  provide() {
    return {
      btnToggle: this
    };
  },

  computed: {
    classes() {
      return _components_VItemGroup_VItemGroup__WEBPACK_IMPORTED_MODULE_0__[/* BaseItemGroup */ "a"].options.computed.classes.call(this);
    }

  },
  methods: {
    // Isn't being passed down through types
    genData: _components_VItemGroup_VItemGroup__WEBPACK_IMPORTED_MODULE_0__[/* BaseItemGroup */ "a"].options.methods.genData
  }
}));

/***/ }),
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);

/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({
  name: 'localable',
  props: {
    locale: String
  },
  computed: {
    currentLocale() {
      return this.locale || this.$vuetify.lang.current;
    }

  }
}));

/***/ }),
/* 276 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
let secciones = {}; // Secciones

agregarSecciones([{
  uid: 'informatica',
  nombre: 'Informática'
}, {
  uid: 'matematica',
  nombre: 'Matemática'
}]); // Categorias

agregarCategorias([{
  uid: 'algoritmos',
  nombre: 'Algoritmos'
}, {
  uid: 'desarrollo-web',
  nombre: 'Desarrollo Web'
}, {
  uid: 'redes',
  nombre: 'Redes'
}], 'informatica');
agregarCategorias([{
  uid: 'calculo',
  nombre: 'Cálculo'
}], 'matematica'); // Subcategorias

agregarSubCategorias([{
  uid: 'busqueda',
  nombre: 'Busqueda'
}, {
  uid: 'eficiencia',
  nombre: 'Eficiencia'
}, {
  uid: 'ordenacion',
  nombre: 'Ordenación'
}], 'informatica', 'algoritmos');
agregarSubCategorias([{
  uid: 'disenho-web',
  nombre: 'Diseño web'
}, {
  uid: 'vuejs',
  nombre: 'Vue.js'
}], 'informatica', 'desarrollo-web');
agregarSubCategorias([{
  uid: 'tcp',
  nombre: 'TCP'
}], 'informatica', 'redes');
agregarSubCategorias([{
  uid: 'derivada',
  nombre: 'Derivada'
}], 'matematica', 'calculo');
/* harmony default export */ __webpack_exports__["a"] = (secciones); // Funciones para agregar varios elementos

function agregarSecciones(secciones) {
  for (let i = 0; i < secciones.length; i++) {
    const seccion = secciones[i];
    agregarSeccion(seccion);
  }
}

function agregarCategorias(categorias, idSeccion) {
  for (let i = 0; i < categorias.length; i++) {
    const categoria = categorias[i];
    agregarCategoria(categoria, idSeccion);
  }
}

function agregarSubCategorias(subCategorias, idSeccion, idCategoria) {
  for (let i = 0; i < subCategorias.length; i++) {
    const subCategoria = subCategorias[i];
    agregarSubCategoria(subCategoria, idSeccion, idCategoria);
  }
} // Funciones para agregar un elemento


function agregarSeccion(seccion) {
  secciones[seccion.uid] = { ...seccion,
    categorias: {}
  };
}

function agregarCategoria(categoria, idSeccion) {
  secciones[idSeccion].categorias[categoria.uid] = { ...categoria,
    subCategorias: {}
  };
}

function agregarSubCategoria(subCategoria, idSeccion, idCategoria) {
  secciones[idSeccion].categorias[idCategoria].subCategorias[subCategoria.uid] = subCategoria;
}

/***/ }),
/* 277 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var core_js_modules_esnext_map_delete_all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(187);
/* harmony import */ var core_js_modules_esnext_map_delete_all_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_delete_all_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_esnext_map_every_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/* harmony import */ var core_js_modules_esnext_map_every_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_every_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_esnext_map_filter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(189);
/* harmony import */ var core_js_modules_esnext_map_filter_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_filter_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_esnext_map_find_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(190);
/* harmony import */ var core_js_modules_esnext_map_find_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_find_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_esnext_map_find_key_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(191);
/* harmony import */ var core_js_modules_esnext_map_find_key_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_find_key_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_esnext_map_includes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(192);
/* harmony import */ var core_js_modules_esnext_map_includes_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_includes_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_esnext_map_key_of_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(193);
/* harmony import */ var core_js_modules_esnext_map_key_of_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_key_of_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_esnext_map_map_keys_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(194);
/* harmony import */ var core_js_modules_esnext_map_map_keys_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_map_keys_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_esnext_map_map_values_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(195);
/* harmony import */ var core_js_modules_esnext_map_map_values_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_map_values_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_esnext_map_merge_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(196);
/* harmony import */ var core_js_modules_esnext_map_merge_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_merge_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_esnext_map_reduce_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(197);
/* harmony import */ var core_js_modules_esnext_map_reduce_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_reduce_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var core_js_modules_esnext_map_some_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(198);
/* harmony import */ var core_js_modules_esnext_map_some_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_some_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var core_js_modules_esnext_map_update_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(199);
/* harmony import */ var core_js_modules_esnext_map_update_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_update_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _src_components_VGrid_VGrid_sass__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(262);
/* harmony import */ var _src_components_VGrid_VGrid_sass__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_src_components_VGrid_VGrid_sass__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(1);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _util_mergeData__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(28);
/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(0);
















 // no xs

const breakpoints = ['sm', 'md', 'lg', 'xl'];

const breakpointProps = (() => {
  return breakpoints.reduce((props, val) => {
    props[val] = {
      type: [Boolean, String, Number],
      default: false
    };
    return props;
  }, {});
})();

const offsetProps = (() => {
  return breakpoints.reduce((props, val) => {
    props['offset' + Object(_util_helpers__WEBPACK_IMPORTED_MODULE_16__[/* upperFirst */ "K"])(val)] = {
      type: [String, Number],
      default: null
    };
    return props;
  }, {});
})();

const orderProps = (() => {
  return breakpoints.reduce((props, val) => {
    props['order' + Object(_util_helpers__WEBPACK_IMPORTED_MODULE_16__[/* upperFirst */ "K"])(val)] = {
      type: [String, Number],
      default: null
    };
    return props;
  }, {});
})();

const propMap = {
  col: Object.keys(breakpointProps),
  offset: Object.keys(offsetProps),
  order: Object.keys(orderProps)
};

function breakpointClass(type, prop, val) {
  let className = type;

  if (val == null || val === false) {
    return undefined;
  }

  if (prop) {
    const breakpoint = prop.replace(type, '');
    className += `-${breakpoint}`;
  } // Handling the boolean style prop when accepting [Boolean, String, Number]
  // means Vue will not convert <v-col sm></v-col> to sm: true for us.
  // Since the default is false, an empty string indicates the prop's presence.


  if (type === 'col' && (val === '' || val === true)) {
    // .col-md
    return className.toLowerCase();
  } // .order-md-6


  className += `-${val}`;
  return className.toLowerCase();
}

const cache = new Map();
/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_14___default.a.extend({
  name: 'v-col',
  functional: true,
  props: {
    cols: {
      type: [Boolean, String, Number],
      default: false
    },
    ...breakpointProps,
    offset: {
      type: [String, Number],
      default: null
    },
    ...offsetProps,
    order: {
      type: [String, Number],
      default: null
    },
    ...orderProps,
    alignSelf: {
      type: String,
      default: null,
      validator: str => ['auto', 'start', 'end', 'center', 'baseline', 'stretch'].includes(str)
    },
    tag: {
      type: String,
      default: 'div'
    }
  },

  render(h, {
    props,
    data,
    children,
    parent
  }) {
    // Super-fast memoization based on props, 5x faster than JSON.stringify
    let cacheKey = '';

    for (const prop in props) {
      cacheKey += String(props[prop]);
    }

    let classList = cache.get(cacheKey);

    if (!classList) {
      classList = []; // Loop through `col`, `offset`, `order` breakpoint props

      let type;

      for (type in propMap) {
        propMap[type].forEach(prop => {
          const value = props[prop];
          const className = breakpointClass(type, prop, value);
          if (className) classList.push(className);
        });
      }

      const hasColClasses = classList.some(className => className.startsWith('col-'));
      classList.push({
        // Default to .col if no other col-{bp}-* classes generated nor `cols` specified.
        col: !hasColClasses || !props.cols,
        [`col-${props.cols}`]: props.cols,
        [`offset-${props.offset}`]: props.offset,
        [`order-${props.order}`]: props.order,
        [`align-self-${props.alignSelf}`]: props.alignSelf
      });
      cache.set(cacheKey, classList);
    }

    return h(props.tag, Object(_util_mergeData__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"])(data, {
      class: classList
    }), children);
  }

}));

/***/ }),
/* 278 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var core_js_modules_esnext_map_delete_all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(187);
/* harmony import */ var core_js_modules_esnext_map_delete_all_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_delete_all_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_esnext_map_every_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/* harmony import */ var core_js_modules_esnext_map_every_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_every_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_esnext_map_filter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(189);
/* harmony import */ var core_js_modules_esnext_map_filter_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_filter_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_esnext_map_find_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(190);
/* harmony import */ var core_js_modules_esnext_map_find_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_find_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_esnext_map_find_key_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(191);
/* harmony import */ var core_js_modules_esnext_map_find_key_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_find_key_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_esnext_map_includes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(192);
/* harmony import */ var core_js_modules_esnext_map_includes_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_includes_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_esnext_map_key_of_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(193);
/* harmony import */ var core_js_modules_esnext_map_key_of_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_key_of_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_esnext_map_map_keys_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(194);
/* harmony import */ var core_js_modules_esnext_map_map_keys_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_map_keys_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_esnext_map_map_values_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(195);
/* harmony import */ var core_js_modules_esnext_map_map_values_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_map_values_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_esnext_map_merge_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(196);
/* harmony import */ var core_js_modules_esnext_map_merge_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_merge_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_esnext_map_reduce_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(197);
/* harmony import */ var core_js_modules_esnext_map_reduce_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_reduce_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var core_js_modules_esnext_map_some_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(198);
/* harmony import */ var core_js_modules_esnext_map_some_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_some_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var core_js_modules_esnext_map_update_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(199);
/* harmony import */ var core_js_modules_esnext_map_update_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_update_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _src_components_VGrid_VGrid_sass__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(262);
/* harmony import */ var _src_components_VGrid_VGrid_sass__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_src_components_VGrid_VGrid_sass__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(1);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _util_mergeData__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(28);
/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(0);
















 // no xs

const breakpoints = ['sm', 'md', 'lg', 'xl'];
const ALIGNMENT = ['start', 'end', 'center'];

function makeProps(prefix, def) {
  return breakpoints.reduce((props, val) => {
    props[prefix + Object(_util_helpers__WEBPACK_IMPORTED_MODULE_16__[/* upperFirst */ "K"])(val)] = def();
    return props;
  }, {});
}

const alignValidator = str => [...ALIGNMENT, 'baseline', 'stretch'].includes(str);

const alignProps = makeProps('align', () => ({
  type: String,
  default: null,
  validator: alignValidator
}));

const justifyValidator = str => [...ALIGNMENT, 'space-between', 'space-around'].includes(str);

const justifyProps = makeProps('justify', () => ({
  type: String,
  default: null,
  validator: justifyValidator
}));

const alignContentValidator = str => [...ALIGNMENT, 'space-between', 'space-around', 'stretch'].includes(str);

const alignContentProps = makeProps('alignContent', () => ({
  type: String,
  default: null,
  validator: alignContentValidator
}));
const propMap = {
  align: Object.keys(alignProps),
  justify: Object.keys(justifyProps),
  alignContent: Object.keys(alignContentProps)
};
const classMap = {
  align: 'align',
  justify: 'justify',
  alignContent: 'align-content'
};

function breakpointClass(type, prop, val) {
  let className = classMap[type];

  if (val == null) {
    return undefined;
  }

  if (prop) {
    // alignSm -> Sm
    const breakpoint = prop.replace(type, '');
    className += `-${breakpoint}`;
  } // .align-items-sm-center


  className += `-${val}`;
  return className.toLowerCase();
}

const cache = new Map();
/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_14___default.a.extend({
  name: 'v-row',
  functional: true,
  props: {
    tag: {
      type: String,
      default: 'div'
    },
    dense: Boolean,
    noGutters: Boolean,
    align: {
      type: String,
      default: null,
      validator: alignValidator
    },
    ...alignProps,
    justify: {
      type: String,
      default: null,
      validator: justifyValidator
    },
    ...justifyProps,
    alignContent: {
      type: String,
      default: null,
      validator: alignContentValidator
    },
    ...alignContentProps
  },

  render(h, {
    props,
    data,
    children
  }) {
    // Super-fast memoization based on props, 5x faster than JSON.stringify
    let cacheKey = '';

    for (const prop in props) {
      cacheKey += String(props[prop]);
    }

    let classList = cache.get(cacheKey);

    if (!classList) {
      classList = []; // Loop through `align`, `justify`, `alignContent` breakpoint props

      let type;

      for (type in propMap) {
        propMap[type].forEach(prop => {
          const value = props[prop];
          const className = breakpointClass(type, prop, value);
          if (className) classList.push(className);
        });
      }

      classList.push({
        'no-gutters': props.noGutters,
        'row--dense': props.dense,
        [`align-${props.align}`]: props.align,
        [`justify-${props.justify}`]: props.justify,
        [`align-content-${props.alignContent}`]: props.alignContent
      });
      cache.set(cacheKey, classList);
    }

    return h(props.tag, Object(_util_mergeData__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"])(data, {
      staticClass: 'row',
      class: classList
    }), children);
  }

}));

/***/ }),
/* 279 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 280 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _src_components_VCheckbox_VSimpleCheckbox_sass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(419);
/* harmony import */ var _src_components_VCheckbox_VSimpleCheckbox_sass__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_components_VCheckbox_VSimpleCheckbox_sass__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _directives_ripple__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(72);
/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4);
/* harmony import */ var _util_mergeData__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(28);
/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);



 // Mixins


 // Utilities



/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_2___default.a.extend({
  name: 'v-simple-checkbox',
  functional: true,
  directives: {
    ripple: _directives_ripple__WEBPACK_IMPORTED_MODULE_1__[/* default */ "b"]
  },
  props: { ..._mixins_colorable__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].options.props,
    ..._mixins_themeable__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].options.props,
    disabled: Boolean,
    ripple: {
      type: Boolean,
      default: true
    },
    value: Boolean,
    indeterminate: Boolean,
    indeterminateIcon: {
      type: String,
      default: '$checkboxIndeterminate'
    },
    onIcon: {
      type: String,
      default: '$checkboxOn'
    },
    offIcon: {
      type: String,
      default: '$checkboxOff'
    }
  },

  render(h, {
    props,
    data,
    listeners
  }) {
    const children = [];
    let icon = props.offIcon;
    if (props.indeterminate) icon = props.indeterminateIcon;else if (props.value) icon = props.onIcon;
    children.push(h(_VIcon__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], _mixins_colorable__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].options.methods.setTextColor(props.value && props.color, {
      props: {
        disabled: props.disabled,
        dark: props.dark,
        light: props.light
      }
    }), icon));

    if (props.ripple && !props.disabled) {
      const ripple = h('div', _mixins_colorable__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].options.methods.setTextColor(props.color, {
        staticClass: 'v-input--selection-controls__ripple',
        directives: [{
          name: 'ripple',
          value: {
            center: true
          }
        }]
      }));
      children.push(ripple);
    }

    return h('div', Object(_util_mergeData__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(data, {
      class: {
        'v-simple-checkbox': true,
        'v-simple-checkbox--disabled': props.disabled
      },
      on: {
        click: e => {
          e.stopPropagation();

          if (data.on && data.on.input && !props.disabled) {
            Object(_util_helpers__WEBPACK_IMPORTED_MODULE_7__[/* wrapInArray */ "L"])(data.on.input).forEach(f => f(!props.value));
          }
        }
      }
    }), [h('div', {
      staticClass: 'v-input--selection-controls__input'
    }, children)]);
  }

}));

/***/ }),
/* 281 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _src_components_VDialog_VDialog_sass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(279);
/* harmony import */ var _src_components_VDialog_VDialog_sass__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_components_VDialog_VDialog_sass__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _VThemeProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(128);
/* harmony import */ var _mixins_activatable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(46);
/* harmony import */ var _mixins_dependent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56);
/* harmony import */ var _mixins_detachable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(97);
/* harmony import */ var _mixins_overlayable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(95);
/* harmony import */ var _mixins_returnable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(92);
/* harmony import */ var _mixins_stackable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(96);
/* harmony import */ var _mixins_toggleable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(9);
/* harmony import */ var _directives_click_outside__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(55);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(2);
/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(3);
/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(0);
// Styles
 // Components

 // Mixins







 // Directives

 // Helpers




const baseMixins = Object(_util_mixins__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"])(_mixins_activatable__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], _mixins_dependent__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], _mixins_detachable__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], _mixins_overlayable__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"], _mixins_returnable__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"], _mixins_stackable__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"], _mixins_toggleable__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"]);
/* @vue/component */

/* harmony default export */ __webpack_exports__["a"] = (baseMixins.extend({
  name: 'v-dialog',
  directives: {
    ClickOutside: _directives_click_outside__WEBPACK_IMPORTED_MODULE_9__[/* default */ "b"]
  },
  props: {
    dark: Boolean,
    disabled: Boolean,
    fullscreen: Boolean,
    light: Boolean,
    maxWidth: [String, Number],
    noClickAnimation: Boolean,
    origin: {
      type: String,
      default: 'center center'
    },
    persistent: Boolean,
    retainFocus: {
      type: Boolean,
      default: true
    },
    scrollable: Boolean,
    transition: {
      type: [String, Boolean],
      default: 'dialog-transition'
    },
    width: [String, Number]
  },

  data() {
    return {
      activatedBy: null,
      animate: false,
      animateTimeout: -1,
      isActive: !!this.value,
      stackMinZIndex: 200,
      previousActiveElement: null
    };
  },

  computed: {
    classes() {
      return {
        [`v-dialog ${this.contentClass}`.trim()]: true,
        'v-dialog--active': this.isActive,
        'v-dialog--persistent': this.persistent,
        'v-dialog--fullscreen': this.fullscreen,
        'v-dialog--scrollable': this.scrollable,
        'v-dialog--animated': this.animate
      };
    },

    contentClasses() {
      return {
        'v-dialog__content': true,
        'v-dialog__content--active': this.isActive
      };
    },

    hasActivator() {
      return Boolean(!!this.$slots.activator || !!this.$scopedSlots.activator);
    }

  },
  watch: {
    isActive(val) {
      if (val) {
        this.show();
        this.hideScroll();
      } else {
        var _this$previousActiveE;

        this.removeOverlay();
        this.unbind();
        (_this$previousActiveE = this.previousActiveElement) == null ? void 0 : _this$previousActiveE.focus();
      }
    },

    fullscreen(val) {
      if (!this.isActive) return;

      if (val) {
        this.hideScroll();
        this.removeOverlay(false);
      } else {
        this.showScroll();
        this.genOverlay();
      }
    }

  },

  created() {
    /* istanbul ignore next */
    if (this.$attrs.hasOwnProperty('full-width')) {
      Object(_util_console__WEBPACK_IMPORTED_MODULE_11__[/* removed */ "e"])('full-width', this);
    }
  },

  beforeMount() {
    this.$nextTick(() => {
      this.isBooted = this.isActive;
      this.isActive && this.show();
    });
  },

  beforeDestroy() {
    if (typeof window !== 'undefined') this.unbind();
  },

  methods: {
    animateClick() {
      this.animate = false; // Needed for when clicking very fast
      // outside of the dialog

      this.$nextTick(() => {
        this.animate = true;
        window.clearTimeout(this.animateTimeout);
        this.animateTimeout = window.setTimeout(() => this.animate = false, 150);
      });
    },

    closeConditional(e) {
      const target = e.target; // Ignore the click if the dialog is closed or destroyed,
      // if it was on an element inside the content,
      // if it was dragged onto the overlay (#6969),
      // or if this isn't the topmost dialog (#9907)

      return !(this._isDestroyed || !this.isActive || this.$refs.content.contains(target) || this.overlay && target && !this.overlay.$el.contains(target)) && this.activeZIndex >= this.getMaxZIndex();
    },

    hideScroll() {
      if (this.fullscreen) {
        document.documentElement.classList.add('overflow-y-hidden');
      } else {
        _mixins_overlayable__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].options.methods.hideScroll.call(this);
      }
    },

    show() {
      !this.fullscreen && !this.hideOverlay && this.genOverlay(); // Double nextTick to wait for lazy content to be generated

      this.$nextTick(() => {
        this.$nextTick(() => {
          if (!this.$refs.content.contains(document.activeElement)) {
            this.previousActiveElement = document.activeElement;
            this.$refs.content.focus();
          }

          this.bind();
        });
      });
    },

    bind() {
      window.addEventListener('focusin', this.onFocusin);
    },

    unbind() {
      window.removeEventListener('focusin', this.onFocusin);
    },

    onClickOutside(e) {
      this.$emit('click:outside', e);

      if (this.persistent) {
        this.noClickAnimation || this.animateClick();
      } else {
        this.isActive = false;
      }
    },

    onKeydown(e) {
      if (e.keyCode === _util_helpers__WEBPACK_IMPORTED_MODULE_12__[/* keyCodes */ "B"].esc && !this.getOpenDependents().length) {
        if (!this.persistent) {
          this.isActive = false;
          const activator = this.getActivator();
          this.$nextTick(() => activator && activator.focus());
        } else if (!this.noClickAnimation) {
          this.animateClick();
        }
      }

      this.$emit('keydown', e);
    },

    // On focus change, wrap focus to stay inside the dialog
    // https://github.com/vuetifyjs/vuetify/issues/6892
    onFocusin(e) {
      if (!e || !this.retainFocus) return;
      const target = e.target;

      if (!!target && // It isn't the document or the dialog body
      ![document, this.$refs.content].includes(target) && // It isn't inside the dialog body
      !this.$refs.content.contains(target) && // We're the topmost dialog
      this.activeZIndex >= this.getMaxZIndex() && // It isn't inside a dependent element (like a menu)
      !this.getOpenDependentElements().some(el => el.contains(target)) // So we must have focused something outside the dialog and its children
      ) {
        // Find and focus the first available element inside the dialog
        const focusable = this.$refs.content.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
        const el = [...focusable].find(el => !el.hasAttribute('disabled'));
        el && el.focus();
      }
    },

    genContent() {
      return this.showLazyContent(() => [this.$createElement(_VThemeProvider__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"], {
        props: {
          root: true,
          light: this.light,
          dark: this.dark
        }
      }, [this.$createElement('div', {
        class: this.contentClasses,
        attrs: {
          role: 'document',
          tabindex: this.isActive ? 0 : undefined,
          ...this.getScopeIdAttrs()
        },
        on: {
          keydown: this.onKeydown
        },
        style: {
          zIndex: this.activeZIndex
        },
        ref: 'content'
      }, [this.genTransition()])])]);
    },

    genTransition() {
      const content = this.genInnerContent();
      if (!this.transition) return content;
      return this.$createElement('transition', {
        props: {
          name: this.transition,
          origin: this.origin,
          appear: true
        }
      }, [content]);
    },

    genInnerContent() {
      const data = {
        class: this.classes,
        ref: 'dialog',
        directives: [{
          name: 'click-outside',
          value: {
            handler: this.onClickOutside,
            closeConditional: this.closeConditional,
            include: this.getOpenDependentElements
          }
        }, {
          name: 'show',
          value: this.isActive
        }],
        style: {
          transformOrigin: this.origin
        }
      };

      if (!this.fullscreen) {
        data.style = { ...data.style,
          maxWidth: Object(_util_helpers__WEBPACK_IMPORTED_MODULE_12__[/* convertToUnit */ "i"])(this.maxWidth),
          width: Object(_util_helpers__WEBPACK_IMPORTED_MODULE_12__[/* convertToUnit */ "i"])(this.width)
        };
      }

      return this.$createElement('div', data, this.getContentSlot());
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'v-dialog__container',
      class: {
        'v-dialog__container--attached': this.attach === '' || this.attach === true || this.attach === 'attach'
      },
      attrs: {
        role: 'dialog'
      }
    }, [this.genActivator(), this.genContent()]);
  }

}));

/***/ }),
/* 282 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const padStart = (string, targetLength, padString) => {
  targetLength = targetLength >> 0;
  string = String(string);
  padString = String(padString);

  if (string.length > targetLength) {
    return String(string);
  }

  targetLength = targetLength - string.length;

  if (targetLength > padString.length) {
    padString += padString.repeat(targetLength / padString.length);
  }

  return padString.slice(0, targetLength) + String(string);
};

/* harmony default export */ __webpack_exports__["a"] = ((n, length = 2) => padStart(n, length, '0'));

/***/ }),
/* 283 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VCarousel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(304);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VCarousel__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony import */ var _VCarouselItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(305);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "b", function() { return _VCarouselItem__WEBPACK_IMPORTED_MODULE_1__["a"]; });




/* unused harmony default export */ var _unused_webpack_default_export = ({
  $_vuetify_subcomponents: {
    VCarousel: _VCarousel__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"],
    VCarouselItem: _VCarouselItem__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]
  }
});

/***/ }),
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 299 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return VGrid; });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);
// Types

function VGrid(name) {
  /* @vue/component */
  return vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({
    name: `v-${name}`,
    functional: true,
    props: {
      id: String,
      tag: {
        type: String,
        default: 'div'
      }
    },

    render(h, {
      props,
      data,
      children
    }) {
      data.staticClass = `${name} ${data.staticClass || ''}`.trim();
      const {
        attrs
      } = data;

      if (attrs) {
        // reset attrs to extract utility clases like pa-3
        data.attrs = {};
        const classes = Object.keys(attrs).filter(key => {
          // TODO: Remove once resolved
          // https://github.com/vuejs/vue/issues/7841
          if (key === 'slot') return false;
          const value = attrs[key]; // add back data attributes like data-test="foo" but do not
          // add them as classes

          if (key.startsWith('data-')) {
            data.attrs[key] = value;
            return false;
          }

          return value || typeof value === 'string';
        });
        if (classes.length) data.staticClass += ` ${classes.join(' ')}`;
      }

      if (props.id) {
        data.domProps = data.domProps || {};
        data.domProps.id = props.id;
      }

      return h(props.tag, data, children);
    }

  });
}

/***/ }),
/* 300 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _src_components_VChip_VChip_sass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(298);
/* harmony import */ var _src_components_VChip_VChip_sass__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_components_VChip_VChip_sass__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _transitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29);
/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12);
/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
/* harmony import */ var _mixins_groupable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(34);
/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4);
/* harmony import */ var _mixins_toggleable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(9);
/* harmony import */ var _mixins_routable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(15);
/* harmony import */ var _mixins_sizeable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(58);
/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(3);
// Styles

 // Components


 // Mixins






 // Utilities


/* @vue/component */

/* harmony default export */ __webpack_exports__["a"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], _mixins_sizeable__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"], _mixins_routable__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"], Object(_mixins_groupable__WEBPACK_IMPORTED_MODULE_5__[/* factory */ "a"])('chipGroup'), Object(_mixins_toggleable__WEBPACK_IMPORTED_MODULE_7__[/* factory */ "b"])('inputValue')).extend({
  name: 'v-chip',
  props: {
    active: {
      type: Boolean,
      default: true
    },
    activeClass: {
      type: String,

      default() {
        if (!this.chipGroup) return '';
        return this.chipGroup.activeClass;
      }

    },
    close: Boolean,
    closeIcon: {
      type: String,
      default: '$delete'
    },
    closeLabel: {
      type: String,
      default: '$vuetify.close'
    },
    disabled: Boolean,
    draggable: Boolean,
    filter: Boolean,
    filterIcon: {
      type: String,
      default: '$complete'
    },
    label: Boolean,
    link: Boolean,
    outlined: Boolean,
    pill: Boolean,
    tag: {
      type: String,
      default: 'span'
    },
    textColor: String,
    value: null
  },
  data: () => ({
    proxyClass: 'v-chip--active'
  }),
  computed: {
    classes() {
      return {
        'v-chip': true,
        ..._mixins_routable__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].options.computed.classes.call(this),
        'v-chip--clickable': this.isClickable,
        'v-chip--disabled': this.disabled,
        'v-chip--draggable': this.draggable,
        'v-chip--label': this.label,
        'v-chip--link': this.isLink,
        'v-chip--no-color': !this.color,
        'v-chip--outlined': this.outlined,
        'v-chip--pill': this.pill,
        'v-chip--removable': this.hasClose,
        ...this.themeClasses,
        ...this.sizeableClasses,
        ...this.groupClasses
      };
    },

    hasClose() {
      return Boolean(this.close);
    },

    isClickable() {
      return Boolean(_mixins_routable__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].options.computed.isClickable.call(this) || this.chipGroup);
    }

  },

  created() {
    const breakingProps = [['outline', 'outlined'], ['selected', 'input-value'], ['value', 'active'], ['@input', '@active.sync']];
    /* istanbul ignore next */

    breakingProps.forEach(([original, replacement]) => {
      if (this.$attrs.hasOwnProperty(original)) Object(_util_console__WEBPACK_IMPORTED_MODULE_10__[/* breaking */ "a"])(original, replacement, this);
    });
  },

  methods: {
    click(e) {
      this.$emit('click', e);
      this.chipGroup && this.toggle();
    },

    genFilter() {
      const children = [];

      if (this.isActive) {
        children.push(this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_3__[/* default */ "b"], {
          staticClass: 'v-chip__filter',
          props: {
            left: true
          }
        }, this.filterIcon));
      }

      return this.$createElement(_transitions__WEBPACK_IMPORTED_MODULE_2__[/* VExpandXTransition */ "g"], children);
    },

    genClose() {
      return this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_3__[/* default */ "b"], {
        staticClass: 'v-chip__close',
        props: {
          right: true,
          size: 18
        },
        attrs: {
          'aria-label': this.$vuetify.lang.t(this.closeLabel)
        },
        on: {
          click: e => {
            e.stopPropagation();
            e.preventDefault();
            this.$emit('click:close');
            this.$emit('update:active', false);
          }
        }
      }, this.closeIcon);
    },

    genContent() {
      return this.$createElement('span', {
        staticClass: 'v-chip__content'
      }, [this.filter && this.genFilter(), this.$slots.default, this.hasClose && this.genClose()]);
    }

  },

  render(h) {
    const children = [this.genContent()];
    let {
      tag,
      data
    } = this.generateRouteLink();
    data.attrs = { ...data.attrs,
      draggable: this.draggable ? 'true' : undefined,
      tabindex: this.chipGroup && !this.disabled ? 0 : data.attrs.tabindex
    };
    data.directives.push({
      name: 'show',
      value: this.active
    });
    data = this.setBackgroundColor(this.color, data);
    const color = this.textColor || this.outlined && this.color;
    return h(tag, this.setTextColor(color, data), children);
  }

}));

/***/ }),
/* 301 */,
/* 302 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 303 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return weekNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isLeapYear; });
function createUTCDate(year, month = 0, day = 1) {
  let date;

  if (year < 100 && year >= 0) {
    date = new Date(Date.UTC(year, month, day));

    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(year);
    }
  } else {
    date = new Date(Date.UTC(year, month, day));
  }

  return date;
}

function firstWeekOffset(year, firstDayOfWeek, firstDayOfYear) {
  const firstWeekDayInFirstWeek = 7 + firstDayOfWeek - firstDayOfYear;
  const firstWeekDayOfYear = (7 + createUTCDate(year, 0, firstWeekDayInFirstWeek).getUTCDay() - firstDayOfWeek) % 7;
  return -firstWeekDayOfYear + firstWeekDayInFirstWeek - 1;
}

function dayOfYear(year, month, day, firstDayOfWeek) {
  let dayOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334][month];

  if (month > 1 && isLeapYear(year)) {
    dayOfYear++;
  }

  return dayOfYear + day;
}

function weeksInYear(year, firstDayOfWeek, firstDayOfYear) {
  const weekOffset = firstWeekOffset(year, firstDayOfWeek, firstDayOfYear);
  const weekOffsetNext = firstWeekOffset(year + 1, firstDayOfWeek, firstDayOfYear);
  const daysInYear = isLeapYear(year) ? 366 : 365;
  return (daysInYear - weekOffset + weekOffsetNext) / 7;
}

function weekNumber(year, month, day, firstDayOfWeek, localeFirstDayOfYear) {
  const weekOffset = firstWeekOffset(year, firstDayOfWeek, localeFirstDayOfYear);
  const week = Math.ceil((dayOfYear(year, month, day, firstDayOfWeek) - weekOffset) / 7);

  if (week < 1) {
    return week + weeksInYear(year - 1, firstDayOfWeek, localeFirstDayOfYear);
  } else if (week > weeksInYear(year, firstDayOfWeek, localeFirstDayOfYear)) {
    return week - weeksInYear(year, firstDayOfWeek, localeFirstDayOfYear);
  } else {
    return week;
  }
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}

/***/ }),
/* 304 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _src_components_VCarousel_VCarousel_sass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(302);
/* harmony import */ var _src_components_VCarousel_VCarousel_sass__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_components_VCarousel_VCarousel_sass__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _VWindow_VWindow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68);
/* harmony import */ var _VBtn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12);
/* harmony import */ var _VProgressLinear__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(91);
/* harmony import */ var _mixins_button_group__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(270);
/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0);
/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3);
// Styles
 // Extensions

 // Components



 // Mixins
// TODO: Move this into core components v2.0

 // Utilities



/* harmony default export */ __webpack_exports__["a"] = (_VWindow_VWindow__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].extend({
  name: 'v-carousel',
  props: {
    continuous: {
      type: Boolean,
      default: true
    },
    cycle: Boolean,
    delimiterIcon: {
      type: String,
      default: '$delimiter'
    },
    height: {
      type: [Number, String],
      default: 500
    },
    hideDelimiters: Boolean,
    hideDelimiterBackground: Boolean,
    interval: {
      type: [Number, String],
      default: 6000,
      validator: value => value > 0
    },
    mandatory: {
      type: Boolean,
      default: true
    },
    progress: Boolean,
    progressColor: String,
    showArrows: {
      type: Boolean,
      default: true
    },
    verticalDelimiters: {
      type: String,
      default: undefined
    }
  },

  // pass down the parent's theme
  provide() {
    return {
      parentTheme: this.theme
    };
  },

  data() {
    return {
      internalHeight: this.height,
      slideTimeout: undefined
    };
  },

  computed: {
    classes() {
      return { ..._VWindow_VWindow__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].options.computed.classes.call(this),
        'v-carousel': true,
        'v-carousel--hide-delimiter-background': this.hideDelimiterBackground,
        'v-carousel--vertical-delimiters': this.isVertical
      };
    },

    isDark() {
      return this.dark || !this.light;
    },

    isVertical() {
      return this.verticalDelimiters != null;
    }

  },
  watch: {
    internalValue: 'restartTimeout',
    interval: 'restartTimeout',

    height(val, oldVal) {
      if (val === oldVal || !val) return;
      this.internalHeight = val;
    },

    cycle(val) {
      if (val) {
        this.restartTimeout();
      } else {
        clearTimeout(this.slideTimeout);
        this.slideTimeout = undefined;
      }
    }

  },

  created() {
    /* istanbul ignore next */
    if (this.$attrs.hasOwnProperty('hide-controls')) {
      Object(_util_console__WEBPACK_IMPORTED_MODULE_7__[/* breaking */ "a"])('hide-controls', ':show-arrows="false"', this);
    }
  },

  mounted() {
    this.startTimeout();
  },

  methods: {
    genControlIcons() {
      if (this.isVertical) return null;
      return _VWindow_VWindow__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].options.methods.genControlIcons.call(this);
    },

    genDelimiters() {
      return this.$createElement('div', {
        staticClass: 'v-carousel__controls',
        style: {
          left: this.verticalDelimiters === 'left' && this.isVertical ? 0 : 'auto',
          right: this.verticalDelimiters === 'right' ? 0 : 'auto'
        }
      }, [this.genItems()]);
    },

    genItems() {
      const length = this.items.length;
      const children = [];

      for (let i = 0; i < length; i++) {
        const child = this.$createElement(_VBtn__WEBPACK_IMPORTED_MODULE_2__[/* default */ "b"], {
          staticClass: 'v-carousel__controls__item',
          attrs: {
            'aria-label': this.$vuetify.lang.t('$vuetify.carousel.ariaLabel.delimiter', i + 1, length)
          },
          props: {
            icon: true,
            small: true,
            value: this.getValue(this.items[i], i)
          }
        }, [this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_3__[/* default */ "b"], {
          props: {
            size: 18
          }
        }, this.delimiterIcon)]);
        children.push(child);
      }

      return this.$createElement(_mixins_button_group__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"], {
        props: {
          value: this.internalValue,
          mandatory: this.mandatory
        },
        on: {
          change: val => {
            this.internalValue = val;
          }
        }
      }, children);
    },

    genProgress() {
      return this.$createElement(_VProgressLinear__WEBPACK_IMPORTED_MODULE_4__[/* default */ "b"], {
        staticClass: 'v-carousel__progress',
        props: {
          color: this.progressColor,
          value: (this.internalIndex + 1) / this.items.length * 100
        }
      });
    },

    restartTimeout() {
      this.slideTimeout && clearTimeout(this.slideTimeout);
      this.slideTimeout = undefined;
      window.requestAnimationFrame(this.startTimeout);
    },

    startTimeout() {
      if (!this.cycle) return;
      this.slideTimeout = window.setTimeout(this.next, +this.interval > 0 ? +this.interval : 6000);
    }

  },

  render(h) {
    const render = _VWindow_VWindow__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].options.render.call(this, h);
    render.data.style = `height: ${Object(_util_helpers__WEBPACK_IMPORTED_MODULE_6__[/* convertToUnit */ "i"])(this.height)};`;
    /* istanbul ignore else */

    if (!this.hideDelimiters) {
      render.children.push(this.genDelimiters());
    }
    /* istanbul ignore else */


    if (this.progress || this.progressColor) {
      render.children.push(this.genProgress());
    }

    return render;
  }

}));

/***/ }),
/* 305 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VWindow_VWindowItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(268);
/* harmony import */ var _VImg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);
/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var _mixins_routable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(15);
// Extensions
 // Components

 // Utilities



 // Types

const baseMixins = Object(_util_mixins__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(_VWindow_VWindowItem__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"], _mixins_routable__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]);
/* @vue/component */

/* harmony default export */ __webpack_exports__["a"] = (baseMixins.extend().extend({
  name: 'v-carousel-item',
  inject: {
    parentTheme: {
      default: {
        isDark: false
      }
    }
  },

  // pass down the parent's theme
  provide() {
    return {
      theme: this.parentTheme
    };
  },

  inheritAttrs: false,
  methods: {
    genDefaultSlot() {
      return [this.$createElement(_VImg__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"], {
        staticClass: 'v-carousel__item',
        props: { ...this.$attrs,
          height: this.windowGroup.internalHeight
        },
        on: this.$listeners,
        scopedSlots: {
          placeholder: this.$scopedSlots.placeholder
        }
      }, Object(_util_helpers__WEBPACK_IMPORTED_MODULE_3__[/* getSlot */ "v"])(this))];
    },

    genWindowItem() {
      const {
        tag,
        data
      } = this.generateRouteLink();
      data.staticClass = 'v-window-item';
      data.directives.push({
        name: 'show',
        value: this.isActive
      });
      return this.$createElement(tag, data, this.genDefaultSlot());
    }

  }
}));

/***/ }),
/* 306 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _src_components_VDatePicker_VDatePickerTitle_sass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(414);
/* harmony import */ var _src_components_VDatePicker_VDatePickerTitle_sass__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_components_VDatePicker_VDatePickerTitle_sass__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var _mixins_picker_button__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(307);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);
 // Components

 // Mixins

 // Utils


/* harmony default export */ __webpack_exports__["a"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(_mixins_picker_button__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]
/* @vue/component */
).extend({
  name: 'v-date-picker-title',
  props: {
    date: {
      type: String,
      default: ''
    },
    disabled: Boolean,
    readonly: Boolean,
    selectingYear: Boolean,
    value: {
      type: String
    },
    year: {
      type: [Number, String],
      default: ''
    },
    yearIcon: {
      type: String
    }
  },
  data: () => ({
    isReversing: false
  }),
  computed: {
    computedTransition() {
      return this.isReversing ? 'picker-reverse-transition' : 'picker-transition';
    }

  },
  watch: {
    value(val, prev) {
      this.isReversing = val < prev;
    }

  },
  methods: {
    genYearIcon() {
      return this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_1__[/* default */ "b"], {
        props: {
          dark: true
        }
      }, this.yearIcon);
    },

    getYearBtn() {
      return this.genPickerButton('selectingYear', true, [String(this.year), this.yearIcon ? this.genYearIcon() : null], false, 'v-date-picker-title__year');
    },

    genTitleText() {
      return this.$createElement('transition', {
        props: {
          name: this.computedTransition
        }
      }, [this.$createElement('div', {
        domProps: {
          innerHTML: this.date || '&nbsp;'
        },
        key: this.value
      })]);
    },

    genTitleDate() {
      return this.genPickerButton('selectingYear', false, [this.genTitleText()], false, 'v-date-picker-title__date');
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'v-date-picker-title',
      class: {
        'v-date-picker-title--disabled': this.disabled
      }
    }, [this.getYearBtn(), this.genTitleDate()]);
  }

}));

/***/ }),
/* 307 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _colorable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
// Mixins
 // Utilities



/* @vue/component */

/* harmony default export */ __webpack_exports__["a"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_colorable__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]).extend({
  methods: {
    genPickerButton(prop, value, content, readonly = false, staticClass = '') {
      const active = this[prop] === value;

      const click = event => {
        event.stopPropagation();
        this.$emit(`update:${Object(_util_helpers__WEBPACK_IMPORTED_MODULE_2__[/* kebabCase */ "A"])(prop)}`, value);
      };

      return this.$createElement('div', {
        staticClass: `v-picker__title__btn ${staticClass}`.trim(),
        class: {
          'v-picker__title__btn--active': active,
          'v-picker__title__btn--readonly': readonly
        },
        on: active || readonly ? undefined : {
          click
        }
      }, Array.isArray(content) ? content : [content]);
    }

  }
}));

/***/ }),
/* 308 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _src_components_VDatePicker_VDatePickerHeader_sass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(415);
/* harmony import */ var _src_components_VDatePicker_VDatePickerHeader_sass__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_components_VDatePicker_VDatePickerHeader_sass__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _VBtn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32);
/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);
/* harmony import */ var _mixins_localable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(275);
/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(488);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(489);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(2);
 // Components


 // Mixins



 // Utils



/* harmony default export */ __webpack_exports__["a"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], _mixins_localable__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]
/* @vue/component */
).extend({
  name: 'v-date-picker-header',
  props: {
    disabled: Boolean,
    format: Function,
    min: String,
    max: String,
    nextAriaLabel: String,
    nextIcon: {
      type: String,
      default: '$next'
    },
    prevAriaLabel: String,
    prevIcon: {
      type: String,
      default: '$prev'
    },
    readonly: Boolean,
    value: {
      type: [Number, String],
      required: true
    }
  },

  data() {
    return {
      isReversing: false
    };
  },

  computed: {
    formatter() {
      if (this.format) {
        return this.format;
      } else if (String(this.value).split('-')[1]) {
        return Object(_util__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(this.currentLocale, {
          month: 'long',
          year: 'numeric',
          timeZone: 'UTC'
        }, {
          length: 7
        });
      } else {
        return Object(_util__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(this.currentLocale, {
          year: 'numeric',
          timeZone: 'UTC'
        }, {
          length: 4
        });
      }
    }

  },
  watch: {
    value(newVal, oldVal) {
      this.isReversing = newVal < oldVal;
    }

  },
  methods: {
    genBtn(change) {
      const ariaLabelId = change > 0 ? this.nextAriaLabel : this.prevAriaLabel;
      const ariaLabel = ariaLabelId ? this.$vuetify.lang.t(ariaLabelId) : undefined;
      const disabled = this.disabled || change < 0 && this.min && this.calculateChange(change) < this.min || change > 0 && this.max && this.calculateChange(change) > this.max;
      return this.$createElement(_VBtn__WEBPACK_IMPORTED_MODULE_1__[/* default */ "b"], {
        attrs: {
          'aria-label': ariaLabel
        },
        props: {
          dark: this.dark,
          disabled,
          icon: true,
          light: this.light
        },
        on: {
          click: e => {
            e.stopPropagation();
            this.$emit('input', this.calculateChange(change));
          }
        }
      }, [this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_2__[/* default */ "b"], change < 0 === !this.$vuetify.rtl ? this.prevIcon : this.nextIcon)]);
    },

    calculateChange(sign) {
      const [year, month] = String(this.value).split('-').map(Number);

      if (month == null) {
        return `${year + sign}`;
      } else {
        return Object(_util__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(String(this.value), sign);
      }
    },

    genHeader() {
      const color = !this.disabled && (this.color || 'accent');
      const header = this.$createElement('div', this.setTextColor(color, {
        key: String(this.value)
      }), [this.$createElement('button', {
        attrs: {
          type: 'button'
        },
        on: {
          click: () => this.$emit('toggle')
        }
      }, [this.$slots.default || this.formatter(String(this.value))])]);
      const transition = this.$createElement('transition', {
        props: {
          name: this.isReversing === !this.$vuetify.rtl ? 'tab-reverse-transition' : 'tab-transition'
        }
      }, [header]);
      return this.$createElement('div', {
        staticClass: 'v-date-picker-header__value',
        class: {
          'v-date-picker-header__value--disabled': this.disabled
        }
      }, [transition]);
    }

  },

  render() {
    return this.$createElement('div', {
      staticClass: 'v-date-picker-header',
      class: {
        'v-date-picker-header--disabled': this.disabled,
        ...this.themeClasses
      }
    }, [this.genBtn(-1), this.genHeader(), this.genBtn(+1)]);
  }

}));

/***/ }),
/* 309 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mixins_date_picker_table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(376);
/* harmony import */ var _util_dateTimeUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(303);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(488);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(489);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(282);
/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(0);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2);
// Mixins
 // Utils





/* harmony default export */ __webpack_exports__["a"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(_mixins_date_picker_table__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]
/* @vue/component */
).extend({
  name: 'v-date-picker-date-table',
  props: {
    firstDayOfWeek: {
      type: [String, Number],
      default: 0
    },
    localeFirstDayOfYear: {
      type: [String, Number],
      default: 0
    },
    showAdjacentMonths: Boolean,
    showWeek: Boolean,
    weekdayFormat: Function
  },
  computed: {
    formatter() {
      return this.format || Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(this.currentLocale, {
        day: 'numeric',
        timeZone: 'UTC'
      }, {
        start: 8,
        length: 2
      });
    },

    weekdayFormatter() {
      return this.weekdayFormat || Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(this.currentLocale, {
        weekday: 'narrow',
        timeZone: 'UTC'
      });
    },

    weekDays() {
      const first = parseInt(this.firstDayOfWeek, 10);
      return this.weekdayFormatter ? Object(_util_helpers__WEBPACK_IMPORTED_MODULE_5__[/* createRange */ "j"])(7).map(i => this.weekdayFormatter(`2017-01-${first + i + 15}`)) // 2017-01-15 is Sunday
      : Object(_util_helpers__WEBPACK_IMPORTED_MODULE_5__[/* createRange */ "j"])(7).map(i => ['S', 'M', 'T', 'W', 'T', 'F', 'S'][(i + first) % 7]);
    }

  },
  methods: {
    calculateTableDate(delta) {
      return Object(_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(this.tableDate, Math.sign(delta || 1));
    },

    genTHead() {
      const days = this.weekDays.map(day => this.$createElement('th', day));

      if (this.showWeek) {
        days.unshift(this.$createElement('th'));
      }

      return this.$createElement('thead', this.genTR(days));
    },

    // Returns number of the days from the firstDayOfWeek to the first day of the current month
    weekDaysBeforeFirstDayOfTheMonth() {
      const firstDayOfTheMonth = new Date(`${this.displayedYear}-${Object(_util__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(this.displayedMonth + 1)}-01T00:00:00+00:00`);
      const weekDay = firstDayOfTheMonth.getUTCDay();
      return (weekDay - parseInt(this.firstDayOfWeek) + 7) % 7;
    },

    getWeekNumber(dayInMonth) {
      return Object(_util_dateTimeUtils__WEBPACK_IMPORTED_MODULE_1__[/* weekNumber */ "b"])(this.displayedYear, this.displayedMonth, dayInMonth, parseInt(this.firstDayOfWeek), parseInt(this.localeFirstDayOfYear));
    },

    genWeekNumber(weekNumber) {
      return this.$createElement('td', [this.$createElement('small', {
        staticClass: 'v-date-picker-table--date__week'
      }, String(weekNumber).padStart(2, '0'))]);
    },

    // eslint-disable-next-line max-statements
    genTBody() {
      const children = [];
      const daysInMonth = new Date(this.displayedYear, this.displayedMonth + 1, 0).getDate();
      let rows = [];
      let day = this.weekDaysBeforeFirstDayOfTheMonth();

      if (this.showWeek) {
        rows.push(this.genWeekNumber(this.getWeekNumber(1)));
      }

      const prevMonthYear = this.displayedMonth ? this.displayedYear : this.displayedYear - 1;
      const prevMonth = (this.displayedMonth + 11) % 12;
      const firstDayFromPreviousMonth = new Date(this.displayedYear, this.displayedMonth, 0).getDate();
      const cellsInRow = this.showWeek ? 8 : 7;

      while (day--) {
        const date = `${prevMonthYear}-${Object(_util__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(prevMonth + 1)}-${Object(_util__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(firstDayFromPreviousMonth - day)}`;
        rows.push(this.$createElement('td', this.showAdjacentMonths ? [this.genButton(date, true, 'date', this.formatter, true)] : []));
      }

      for (day = 1; day <= daysInMonth; day++) {
        const date = `${this.displayedYear}-${Object(_util__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(this.displayedMonth + 1)}-${Object(_util__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(day)}`;
        rows.push(this.$createElement('td', [this.genButton(date, true, 'date', this.formatter)]));

        if (rows.length % cellsInRow === 0) {
          children.push(this.genTR(rows));
          rows = [];

          if (this.showWeek && (day < daysInMonth || this.showAdjacentMonths)) {
            rows.push(this.genWeekNumber(this.getWeekNumber(day + 7)));
          }
        }
      }

      const nextMonthYear = this.displayedMonth === 11 ? this.displayedYear + 1 : this.displayedYear;
      const nextMonth = (this.displayedMonth + 1) % 12;
      let nextMonthDay = 1;

      while (rows.length < cellsInRow) {
        const date = `${nextMonthYear}-${Object(_util__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(nextMonth + 1)}-${Object(_util__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(nextMonthDay++)}`;
        rows.push(this.$createElement('td', this.showAdjacentMonths ? [this.genButton(date, true, 'date', this.formatter, true)] : []));
      }

      if (rows.length) {
        children.push(this.genTR(rows));
      }

      return this.$createElement('tbody', children);
    },

    genTR(children) {
      return [this.$createElement('tr', children)];
    }

  },

  render() {
    return this.genTable('v-date-picker-table v-date-picker-table--date', [this.genTHead(), this.genTBody()], this.calculateTableDate);
  }

}));

/***/ }),
/* 310 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mixins_date_picker_table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(376);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(488);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(282);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);
// Mixins
 // Utils



/* harmony default export */ __webpack_exports__["a"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(_mixins_date_picker_table__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]
/* @vue/component */
).extend({
  name: 'v-date-picker-month-table',
  computed: {
    formatter() {
      return this.format || Object(_util__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this.currentLocale, {
        month: 'short',
        timeZone: 'UTC'
      }, {
        start: 5,
        length: 2
      });
    }

  },
  methods: {
    calculateTableDate(delta) {
      return `${parseInt(this.tableDate, 10) + Math.sign(delta || 1)}`;
    },

    genTBody() {
      const children = [];
      const cols = Array(3).fill(null);
      const rows = 12 / cols.length;

      for (let row = 0; row < rows; row++) {
        const tds = cols.map((_, col) => {
          const month = row * cols.length + col;
          const date = `${this.displayedYear}-${Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(month + 1)}`;
          return this.$createElement('td', {
            key: month
          }, [this.genButton(date, false, 'month', this.formatter)]);
        });
        children.push(this.$createElement('tr', {
          key: row
        }, tds));
      }

      return this.$createElement('tbody', children);
    }

  },

  render() {
    return this.genTable('v-date-picker-table v-date-picker-table--month', [this.genTBody()], this.calculateTableDate);
  }

}));

/***/ }),
/* 311 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _src_components_VDatePicker_VDatePickerYears_sass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(417);
/* harmony import */ var _src_components_VDatePicker_VDatePickerYears_sass__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_components_VDatePicker_VDatePickerYears_sass__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _mixins_localable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(275);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(488);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(490);
/* harmony import */ var _util_mergeData__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(28);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2);
 // Mixins


 // Utils




/* harmony default export */ __webpack_exports__["a"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"], _mixins_localable__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]
/* @vue/component */
).extend({
  name: 'v-date-picker-years',
  props: {
    format: Function,
    min: [Number, String],
    max: [Number, String],
    readonly: Boolean,
    value: [Number, String]
  },

  data() {
    return {
      defaultColor: 'primary'
    };
  },

  computed: {
    formatter() {
      return this.format || Object(_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(this.currentLocale, {
        year: 'numeric',
        timeZone: 'UTC'
      }, {
        length: 4
      });
    }

  },

  mounted() {
    setTimeout(() => {
      const activeItem = this.$el.getElementsByClassName('active')[0];

      if (activeItem) {
        this.$el.scrollTop = activeItem.offsetTop - this.$el.offsetHeight / 2 + activeItem.offsetHeight / 2;
      } else if (this.min && !this.max) {
        this.$el.scrollTop = this.$el.scrollHeight;
      } else if (!this.min && this.max) {
        this.$el.scrollTop = 0;
      } else {
        this.$el.scrollTop = this.$el.scrollHeight / 2 - this.$el.offsetHeight / 2;
      }
    });
  },

  methods: {
    genYearItem(year) {
      const formatted = this.formatter(`${year}`);
      const active = parseInt(this.value, 10) === year;
      const color = active && (this.color || 'primary');
      return this.$createElement('li', this.setTextColor(color, {
        key: year,
        class: {
          active
        },
        on: Object(_util_mergeData__WEBPACK_IMPORTED_MODULE_5__[/* mergeListeners */ "c"])({
          click: () => this.$emit('input', year)
        }, Object(_util__WEBPACK_IMPORTED_MODULE_4__[/* createItemTypeNativeListeners */ "b"])(this, ':year', year))
      }), formatted);
    },

    genYearItems() {
      const children = [];
      const selectedYear = this.value ? parseInt(this.value, 10) : new Date().getFullYear();
      const maxYear = this.max ? parseInt(this.max, 10) : selectedYear + 100;
      const minYear = Math.min(maxYear, this.min ? parseInt(this.min, 10) : selectedYear - 100);

      for (let year = maxYear; year >= minYear; year--) {
        children.push(this.genYearItem(year));
      }

      return children;
    }

  },

  render() {
    return this.$createElement('ul', {
      staticClass: 'v-date-picker-years',
      ref: 'years'
    }, this.genYearItems());
  }

}));

/***/ }),
/* 312 */,
/* 313 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ VPicker_VPicker; });

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VPicker/VPicker.sass
var VPicker = __webpack_require__(413);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VCard/VCard.sass
var VCard = __webpack_require__(129);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/colorable/index.js
var colorable = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/elevatable/index.js
var elevatable = __webpack_require__(57);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/themeable/index.js
var themeable = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/util/helpers.js
var helpers = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/util/mixins.js
var mixins = __webpack_require__(2);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VPicker/VPicker.js

 // Mixins



 // Helpers



/* @vue/component */

/* harmony default export */ var VPicker_VPicker = (Object(mixins["a" /* default */])(colorable["a" /* default */], elevatable["a" /* default */], themeable["a" /* default */]).extend({
  name: 'v-picker',
  props: {
    flat: Boolean,
    fullWidth: Boolean,
    landscape: Boolean,
    noTitle: Boolean,
    transition: {
      type: String,
      default: 'fade-transition'
    },
    width: {
      type: [Number, String],
      default: 290
    }
  },
  computed: {
    computedTitleColor() {
      const defaultTitleColor = this.isDark ? false : this.color || 'primary';
      return this.color || defaultTitleColor;
    }

  },
  methods: {
    genTitle() {
      return this.$createElement('div', this.setBackgroundColor(this.computedTitleColor, {
        staticClass: 'v-picker__title',
        class: {
          'v-picker__title--landscape': this.landscape
        }
      }), this.$slots.title);
    },

    genBodyTransition() {
      return this.$createElement('transition', {
        props: {
          name: this.transition
        }
      }, this.$slots.default);
    },

    genBody() {
      return this.$createElement('div', {
        staticClass: 'v-picker__body',
        class: {
          'v-picker__body--no-title': this.noTitle,
          ...this.themeClasses
        },
        style: this.fullWidth ? undefined : {
          width: Object(helpers["i" /* convertToUnit */])(this.width)
        }
      }, [this.genBodyTransition()]);
    },

    genActions() {
      return this.$createElement('div', {
        staticClass: 'v-picker__actions v-card__actions',
        class: {
          'v-picker__actions--no-title': this.noTitle
        }
      }, this.$slots.actions);
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'v-picker v-card',
      class: {
        'v-picker--flat': this.flat,
        'v-picker--landscape': this.landscape,
        'v-picker--full-width': this.fullWidth,
        ...this.themeClasses,
        ...this.elevationClasses
      }
    }, [this.$slots.title ? this.genTitle() : null, this.genBody(), this.$slots.actions ? this.genActions() : null]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VPicker/index.js


/* harmony default export */ var components_VPicker = __webpack_exports__["b"] = (VPicker_VPicker);

/***/ }),
/* 314 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ VSubheader_VSubheader; });

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VSubheader/VSubheader.sass
var VSubheader = __webpack_require__(420);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/themeable/index.js
var themeable = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/util/mixins.js
var mixins = __webpack_require__(2);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSubheader/VSubheader.js
// Styles
 // Mixins



/* harmony default export */ var VSubheader_VSubheader = (Object(mixins["a" /* default */])(themeable["a" /* default */]
/* @vue/component */
).extend({
  name: 'v-subheader',
  props: {
    inset: Boolean
  },

  render(h) {
    return h('div', {
      staticClass: 'v-subheader',
      class: {
        'v-subheader--inset': this.inset,
        ...this.themeClasses
      },
      attrs: this.$attrs,
      on: this.$listeners
    }, this.$slots.default);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSubheader/index.js


/* harmony default export */ var components_VSubheader = __webpack_exports__["b"] = (VSubheader_VSubheader);

/***/ }),
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 363 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return prevent; });
/* harmony import */ var _components_VInput__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var _rippleable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(364);
/* harmony import */ var _comparable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);
// Components
 // Mixins


 // Utilities


function prevent(e) {
  e.preventDefault();
}
/* @vue/component */

/* harmony default export */ __webpack_exports__["a"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(_components_VInput__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"], _rippleable__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"], _comparable__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]).extend({
  name: 'selectable',
  model: {
    prop: 'inputValue',
    event: 'change'
  },
  props: {
    id: String,
    inputValue: null,
    falseValue: null,
    trueValue: null,
    multiple: {
      type: Boolean,
      default: null
    },
    label: String
  },

  data() {
    return {
      hasColor: this.inputValue,
      lazyValue: this.inputValue
    };
  },

  computed: {
    computedColor() {
      if (!this.isActive) return undefined;
      if (this.color) return this.color;
      if (this.isDark && !this.appIsDark) return 'white';
      return 'primary';
    },

    isMultiple() {
      return this.multiple === true || this.multiple === null && Array.isArray(this.internalValue);
    },

    isActive() {
      const value = this.value;
      const input = this.internalValue;

      if (this.isMultiple) {
        if (!Array.isArray(input)) return false;
        return input.some(item => this.valueComparator(item, value));
      }

      if (this.trueValue === undefined || this.falseValue === undefined) {
        return value ? this.valueComparator(value, input) : Boolean(input);
      }

      return this.valueComparator(input, this.trueValue);
    },

    isDirty() {
      return this.isActive;
    },

    rippleState() {
      return !this.isDisabled && !this.validationState ? undefined : this.validationState;
    }

  },
  watch: {
    inputValue(val) {
      this.lazyValue = val;
      this.hasColor = val;
    }

  },
  methods: {
    genLabel() {
      const label = _components_VInput__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"].options.methods.genLabel.call(this);
      if (!label) return label;
      label.data.on = {
        // Label shouldn't cause the input to focus
        click: prevent
      };
      return label;
    },

    genInput(type, attrs) {
      return this.$createElement('input', {
        attrs: Object.assign({
          'aria-checked': this.isActive.toString(),
          disabled: this.isDisabled,
          id: this.computedId,
          role: type,
          type
        }, attrs),
        domProps: {
          value: this.value,
          checked: this.isActive
        },
        on: {
          blur: this.onBlur,
          change: this.onChange,
          focus: this.onFocus,
          keydown: this.onKeydown,
          click: prevent
        },
        ref: 'input'
      });
    },

    onBlur() {
      this.isFocused = false;
    },

    onClick(e) {
      this.onChange();
      this.$emit('click', e);
    },

    onChange() {
      if (!this.isInteractive) return;
      const value = this.value;
      let input = this.internalValue;

      if (this.isMultiple) {
        if (!Array.isArray(input)) {
          input = [];
        }

        const length = input.length;
        input = input.filter(item => !this.valueComparator(item, value));

        if (input.length === length) {
          input.push(value);
        }
      } else if (this.trueValue !== undefined && this.falseValue !== undefined) {
        input = this.valueComparator(input, this.trueValue) ? this.falseValue : this.trueValue;
      } else if (value) {
        input = this.valueComparator(input, value) ? null : value;
      } else {
        input = !input;
      }

      this.validate(true, input);
      this.internalValue = input;
      this.hasColor = input;
    },

    onFocus() {
      this.isFocused = true;
    },

    /** @abstract */
    onKeydown(e) {}

  }
}));

/***/ }),
/* 364 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _directives_ripple__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_1__);
// Directives
 // Types


/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_1___default.a.extend({
  name: 'rippleable',
  directives: {
    ripple: _directives_ripple__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"]
  },
  props: {
    ripple: {
      type: [Boolean, Object],
      default: true
    }
  },
  methods: {
    genRipple(data = {}) {
      if (!this.ripple) return null;
      data.staticClass = 'v-input--selection-controls__ripple';
      data.directives = data.directives || [];
      data.directives.push({
        name: 'ripple',
        value: {
          center: true
        }
      });
      return this.$createElement('div', data);
    }

  }
}));

/***/ }),
/* 365 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VDatePicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(386);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VDatePicker__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony import */ var _VDatePickerTitle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(306);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "e", function() { return _VDatePickerTitle__WEBPACK_IMPORTED_MODULE_1__["a"]; });

/* harmony import */ var _VDatePickerHeader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(308);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "c", function() { return _VDatePickerHeader__WEBPACK_IMPORTED_MODULE_2__["a"]; });

/* harmony import */ var _VDatePickerDateTable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(309);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "b", function() { return _VDatePickerDateTable__WEBPACK_IMPORTED_MODULE_3__["a"]; });

/* harmony import */ var _VDatePickerMonthTable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(310);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "d", function() { return _VDatePickerMonthTable__WEBPACK_IMPORTED_MODULE_4__["a"]; });

/* harmony import */ var _VDatePickerYears__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(311);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "f", function() { return _VDatePickerYears__WEBPACK_IMPORTED_MODULE_5__["a"]; });








/* unused harmony default export */ var _unused_webpack_default_export = ({
  $_vuetify_subcomponents: {
    VDatePicker: _VDatePicker__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"],
    VDatePickerTitle: _VDatePickerTitle__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"],
    VDatePickerHeader: _VDatePickerHeader__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"],
    VDatePickerDateTable: _VDatePickerDateTable__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"],
    VDatePickerMonthTable: _VDatePickerMonthTable__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"],
    VDatePickerYears: _VDatePickerYears__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]
  }
});

/***/ }),
/* 366 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VSelect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(266);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VSelect__WEBPACK_IMPORTED_MODULE_0__["a"]; });



/* unused harmony default export */ var _unused_webpack_default_export = (_VSelect__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ }),
/* 367 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VTextarea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(387);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VTextarea__WEBPACK_IMPORTED_MODULE_0__["a"]; });



/* unused harmony default export */ var _unused_webpack_default_export = (_VTextarea__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ }),
/* 368 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VCheckbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(398);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VCheckbox__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony import */ var _VSimpleCheckbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(280);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "b", function() { return _VSimpleCheckbox__WEBPACK_IMPORTED_MODULE_1__["a"]; });




/* unused harmony default export */ var _unused_webpack_default_export = ({
  $_vuetify_subcomponents: {
    VCheckbox: _VCheckbox__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"],
    VSimpleCheckbox: _VSimpleCheckbox__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]
  }
});

/***/ }),
/* 369 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VExpansionPanels__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(389);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "d", function() { return _VExpansionPanels__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony import */ var _VExpansionPanel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(390);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VExpansionPanel__WEBPACK_IMPORTED_MODULE_1__["a"]; });

/* harmony import */ var _VExpansionPanelContent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(392);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "b", function() { return _VExpansionPanelContent__WEBPACK_IMPORTED_MODULE_2__["a"]; });

/* harmony import */ var _VExpansionPanelHeader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(391);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "c", function() { return _VExpansionPanelHeader__WEBPACK_IMPORTED_MODULE_3__["a"]; });






/* unused harmony default export */ var _unused_webpack_default_export = ({
  $_vuetify_subcomponents: {
    VExpansionPanels: _VExpansionPanels__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"],
    VExpansionPanel: _VExpansionPanel__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"],
    VExpansionPanelHeader: _VExpansionPanelHeader__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"],
    VExpansionPanelContent: _VExpansionPanelContent__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]
  }
});

/***/ }),
/* 370 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VParallax__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(371);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VParallax__WEBPACK_IMPORTED_MODULE_0__["a"]; });



/* unused harmony default export */ var _unused_webpack_default_export = (_VParallax__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ }),
/* 371 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VParallax/VParallax.sass
var VParallax = __webpack_require__(374);

// EXTERNAL MODULE: external "vue"
var external_vue_ = __webpack_require__(1);
var external_vue_default = /*#__PURE__*/__webpack_require__.n(external_vue_);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/mixins/translatable/index.js

/* harmony default export */ var translatable = (external_vue_default.a.extend({
  name: 'translatable',
  props: {
    height: Number
  },
  data: () => ({
    elOffsetTop: 0,
    parallax: 0,
    parallaxDist: 0,
    percentScrolled: 0,
    scrollTop: 0,
    windowHeight: 0,
    windowBottom: 0
  }),
  computed: {
    imgHeight() {
      return this.objHeight();
    }

  },

  beforeDestroy() {
    window.removeEventListener('scroll', this.translate, false);
    window.removeEventListener('resize', this.translate, false);
  },

  methods: {
    calcDimensions() {
      const offset = this.$el.getBoundingClientRect();
      this.scrollTop = window.pageYOffset;
      this.parallaxDist = this.imgHeight - this.height;
      this.elOffsetTop = offset.top + this.scrollTop;
      this.windowHeight = window.innerHeight;
      this.windowBottom = this.scrollTop + this.windowHeight;
    },

    listeners() {
      window.addEventListener('scroll', this.translate, false);
      window.addEventListener('resize', this.translate, false);
    },

    /** @abstract **/
    objHeight() {
      throw new Error('Not implemented !');
    },

    translate() {
      this.calcDimensions();
      this.percentScrolled = (this.windowBottom - this.elOffsetTop) / (parseInt(this.height) + this.windowHeight);
      this.parallax = Math.round(this.parallaxDist * this.percentScrolled);
    }

  }
}));
// EXTERNAL MODULE: ./node_modules/vuetify/lib/util/mixins.js
var mixins = __webpack_require__(2);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VParallax/VParallax.js
// Style
 // Mixins



const baseMixins = Object(mixins["a" /* default */])(translatable);
/* @vue/component */

/* harmony default export */ var VParallax_VParallax = __webpack_exports__["a"] = (baseMixins.extend().extend({
  name: 'v-parallax',
  props: {
    alt: {
      type: String,
      default: ''
    },
    height: {
      type: [String, Number],
      default: 500
    },
    src: String,
    srcset: String
  },
  data: () => ({
    isBooted: false
  }),
  computed: {
    styles() {
      return {
        display: 'block',
        opacity: this.isBooted ? 1 : 0,
        transform: `translate(-50%, ${this.parallax}px)`
      };
    }

  },

  mounted() {
    this.init();
  },

  methods: {
    init() {
      const img = this.$refs.img;
      if (!img) return;

      if (img.complete) {
        this.translate();
        this.listeners();
      } else {
        img.addEventListener('load', () => {
          this.translate();
          this.listeners();
        }, false);
      }

      this.isBooted = true;
    },

    objHeight() {
      return this.$refs.img.naturalHeight;
    }

  },

  render(h) {
    const imgData = {
      staticClass: 'v-parallax__image',
      style: this.styles,
      attrs: {
        src: this.src,
        srcset: this.srcset,
        alt: this.alt
      },
      ref: 'img'
    };
    const container = h('div', {
      staticClass: 'v-parallax__image-container'
    }, [h('img', imgData)]);
    const content = h('div', {
      staticClass: 'v-parallax__content'
    }, this.$slots.default);
    return h('div', {
      staticClass: 'v-parallax',
      style: {
        height: `${this.height}px`
      },
      on: this.$listeners
    }, [container, content]);
  }

}));

/***/ }),
/* 372 */,
/* 373 */,
/* 374 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 375 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isDateAllowed; });
function isDateAllowed(date, min, max, allowedFn) {
  return (!allowedFn || allowedFn(date)) && (!min || date >= min.substr(0, 10)) && (!max || date <= max);
}

/***/ }),
/* 376 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _src_components_VDatePicker_VDatePickerTable_sass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(416);
/* harmony import */ var _src_components_VDatePicker_VDatePickerTable_sass__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_components_VDatePicker_VDatePickerTable_sass__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _directives_touch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35);
/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var _mixins_localable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(275);
/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(490);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(487);
/* harmony import */ var _util_isDateAllowed__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(375);
/* harmony import */ var _util_mergeData__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(28);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(2);
/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(0);
 // Directives

 // Mixins



 // Utils






/* harmony default export */ __webpack_exports__["a"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], _mixins_localable__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]
/* @vue/component */
).extend({
  directives: {
    Touch: _directives_touch__WEBPACK_IMPORTED_MODULE_1__[/* default */ "b"]
  },
  props: {
    allowedDates: Function,
    current: String,
    disabled: Boolean,
    format: Function,
    events: {
      type: [Array, Function, Object],
      default: () => null
    },
    eventColor: {
      type: [Array, Function, Object, String],
      default: () => 'warning'
    },
    min: String,
    max: String,
    range: Boolean,
    readonly: Boolean,
    scrollable: Boolean,
    tableDate: {
      type: String,
      required: true
    },
    value: [String, Array]
  },
  data: () => ({
    isReversing: false,
    wheelThrottle: null
  }),
  computed: {
    computedTransition() {
      return this.isReversing === !this.$vuetify.rtl ? 'tab-reverse-transition' : 'tab-transition';
    },

    displayedMonth() {
      return Number(this.tableDate.split('-')[1]) - 1;
    },

    displayedYear() {
      return Number(this.tableDate.split('-')[0]);
    }

  },
  watch: {
    tableDate(newVal, oldVal) {
      this.isReversing = newVal < oldVal;
    }

  },

  mounted() {
    this.wheelThrottle = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_10__[/* throttle */ "J"])(this.wheel, 250);
  },

  methods: {
    genButtonClasses(isAllowed, isFloating, isSelected, isCurrent, isFirst, isLast) {
      return {
        'v-size--default': !isFloating,
        'v-date-picker-table__current': isCurrent,
        'v-btn--active': isSelected,
        'v-btn--flat': !isAllowed || this.disabled,
        'v-btn--text': isSelected === isCurrent,
        'v-btn--rounded': isFloating,
        'v-btn--disabled': !isAllowed || this.disabled,
        'v-btn--outlined': isCurrent && !isSelected,
        'v-date-picker--first-in-range': isFirst,
        'v-date-picker--last-in-range': isLast,
        ...this.themeClasses
      };
    },

    genButtonEvents(value, isAllowed, mouseEventType) {
      if (this.disabled) return undefined;
      return Object(_util_mergeData__WEBPACK_IMPORTED_MODULE_8__[/* mergeListeners */ "c"])({
        click: () => {
          if (isAllowed && !this.readonly) this.$emit('input', value);
        }
      }, Object(_util__WEBPACK_IMPORTED_MODULE_5__[/* createItemTypeNativeListeners */ "b"])(this, `:${mouseEventType}`, value));
    },

    genButton(value, isFloating, mouseEventType, formatter, isOtherMonth = false) {
      const isAllowed = Object(_util_isDateAllowed__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(value, this.min, this.max, this.allowedDates);
      const isSelected = this.isSelected(value) && isAllowed;
      const isCurrent = value === this.current;
      const setColor = isSelected ? this.setBackgroundColor : this.setTextColor;
      const color = (isSelected || isCurrent) && (this.color || 'accent');
      let isFirst = false;
      let isLast = false;

      if (this.range && !!this.value && Array.isArray(this.value)) {
        isFirst = value === this.value[0];
        isLast = value === this.value[this.value.length - 1];
      }

      return this.$createElement('button', setColor(color, {
        staticClass: 'v-btn',
        class: this.genButtonClasses(isAllowed && !isOtherMonth, isFloating, isSelected, isCurrent, isFirst, isLast),
        attrs: {
          type: 'button'
        },
        domProps: {
          disabled: this.disabled || !isAllowed || isOtherMonth
        },
        on: this.genButtonEvents(value, isAllowed, mouseEventType)
      }), [this.$createElement('div', {
        staticClass: 'v-btn__content'
      }, [formatter(value)]), this.genEvents(value)]);
    },

    getEventColors(date) {
      const arrayize = v => Array.isArray(v) ? v : [v];

      let eventData;
      let eventColors = [];

      if (Array.isArray(this.events)) {
        eventData = this.events.includes(date);
      } else if (this.events instanceof Function) {
        eventData = this.events(date) || false;
      } else if (this.events) {
        eventData = this.events[date] || false;
      } else {
        eventData = false;
      }

      if (!eventData) {
        return [];
      } else if (eventData !== true) {
        eventColors = arrayize(eventData);
      } else if (typeof this.eventColor === 'string') {
        eventColors = [this.eventColor];
      } else if (typeof this.eventColor === 'function') {
        eventColors = arrayize(this.eventColor(date));
      } else if (Array.isArray(this.eventColor)) {
        eventColors = this.eventColor;
      } else {
        eventColors = arrayize(this.eventColor[date]);
      }

      return eventColors.filter(v => v);
    },

    genEvents(date) {
      const eventColors = this.getEventColors(date);
      return eventColors.length ? this.$createElement('div', {
        staticClass: 'v-date-picker-table__events'
      }, eventColors.map(color => this.$createElement('div', this.setBackgroundColor(color)))) : null;
    },

    isValidScroll(value, calculateTableDate) {
      const tableDate = calculateTableDate(value); // tableDate is 'YYYY-MM' for DateTable and 'YYYY' for MonthTable

      const sanitizeType = tableDate.split('-').length === 1 ? 'year' : 'month';
      return value < 0 && (this.min ? tableDate >= Object(_util__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(this.min, sanitizeType) : true) || value > 0 && (this.max ? tableDate <= Object(_util__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(this.max, sanitizeType) : true);
    },

    wheel(e, calculateTableDate) {
      this.$emit('update:table-date', calculateTableDate(e.deltaY));
    },

    touch(value, calculateTableDate) {
      this.$emit('update:table-date', calculateTableDate(value));
    },

    genTable(staticClass, children, calculateTableDate) {
      const transition = this.$createElement('transition', {
        props: {
          name: this.computedTransition
        }
      }, [this.$createElement('table', {
        key: this.tableDate
      }, children)]);
      const touchDirective = {
        name: 'touch',
        value: {
          left: e => e.offsetX < -15 && this.isValidScroll(1, calculateTableDate) && this.touch(1, calculateTableDate),
          right: e => e.offsetX > 15 && this.isValidScroll(-1, calculateTableDate) && this.touch(-1, calculateTableDate)
        }
      };
      return this.$createElement('div', {
        staticClass,
        class: {
          'v-date-picker-table--disabled': this.disabled,
          ...this.themeClasses
        },
        on: !this.disabled && this.scrollable ? {
          wheel: e => {
            e.preventDefault();

            if (this.isValidScroll(e.deltaY, calculateTableDate)) {
              this.wheelThrottle(e, calculateTableDate);
            }
          }
        } : undefined,
        directives: [touchDirective]
      }, [transition]);
    },

    isSelected(value) {
      if (Array.isArray(this.value)) {
        if (this.range && this.value.length === 2) {
          const [from, to] = [...this.value].sort();
          return from <= value && value <= to;
        } else {
          return this.value.indexOf(value) !== -1;
        }
      }

      return value === this.value;
    }

  }
}));

/***/ }),
/* 377 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _src_components_VGrid_grid_sass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(123);
/* harmony import */ var _src_components_VGrid_grid_sass__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_components_VGrid_grid_sass__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _src_components_VGrid_VGrid_sass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(262);
/* harmony import */ var _src_components_VGrid_VGrid_sass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_src_components_VGrid_VGrid_sass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(299);
/* harmony import */ var _util_mergeData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(28);




/* @vue/component */

/* harmony default export */ __webpack_exports__["a"] = (Object(_grid__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])('container').extend({
  name: 'v-container',
  functional: true,
  props: {
    id: String,
    tag: {
      type: String,
      default: 'div'
    },
    fluid: {
      type: Boolean,
      default: false
    }
  },

  render(h, {
    props,
    data,
    children
  }) {
    let classes;
    const {
      attrs
    } = data;

    if (attrs) {
      // reset attrs to extract utility clases like pa-3
      data.attrs = {};
      classes = Object.keys(attrs).filter(key => {
        // TODO: Remove once resolved
        // https://github.com/vuejs/vue/issues/7841
        if (key === 'slot') return false;
        const value = attrs[key]; // add back data attributes like data-test="foo" but do not
        // add them as classes

        if (key.startsWith('data-')) {
          data.attrs[key] = value;
          return false;
        }

        return value || typeof value === 'string';
      });
    }

    if (props.id) {
      data.domProps = data.domProps || {};
      data.domProps.id = props.id;
    }

    return h(props.tag, Object(_util_mergeData__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(data, {
      staticClass: 'container',
      class: Array({
        'container--fluid': props.fluid
      }).concat(classes || [])
    }), children);
  }

}));

/***/ }),
/* 378 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _mixins_binds_attrs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _mixins_registrable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33);
// Mixins



/* @vue/component */

/* harmony default export */ __webpack_exports__["a"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(_mixins_binds_attrs__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"], Object(_mixins_registrable__WEBPACK_IMPORTED_MODULE_2__[/* provide */ "b"])('form')
/* @vue/component */
).extend({
  name: 'v-form',

  provide() {
    return {
      form: this
    };
  },

  inheritAttrs: false,
  props: {
    disabled: Boolean,
    lazyValidation: Boolean,
    readonly: Boolean,
    value: Boolean
  },
  data: () => ({
    inputs: [],
    watchers: [],
    errorBag: {}
  }),
  watch: {
    errorBag: {
      handler(val) {
        const errors = Object.values(val).includes(true);
        this.$emit('input', !errors);
      },

      deep: true,
      immediate: true
    }
  },
  methods: {
    watchInput(input) {
      const watcher = input => {
        return input.$watch('hasError', val => {
          this.$set(this.errorBag, input._uid, val);
        }, {
          immediate: true
        });
      };

      const watchers = {
        _uid: input._uid,
        valid: () => {},
        shouldValidate: () => {}
      };

      if (this.lazyValidation) {
        // Only start watching inputs if we need to
        watchers.shouldValidate = input.$watch('shouldValidate', val => {
          if (!val) return; // Only watch if we're not already doing it

          if (this.errorBag.hasOwnProperty(input._uid)) return;
          watchers.valid = watcher(input);
        });
      } else {
        watchers.valid = watcher(input);
      }

      return watchers;
    },

    /** @public */
    validate() {
      return this.inputs.filter(input => !input.validate(true)).length === 0;
    },

    /** @public */
    reset() {
      this.inputs.forEach(input => input.reset());
      this.resetErrorBag();
    },

    resetErrorBag() {
      if (this.lazyValidation) {
        // Account for timeout in validatable
        setTimeout(() => {
          this.errorBag = {};
        }, 0);
      }
    },

    /** @public */
    resetValidation() {
      this.inputs.forEach(input => input.resetValidation());
      this.resetErrorBag();
    },

    register(input) {
      this.inputs.push(input);
      this.watchers.push(this.watchInput(input));
    },

    unregister(input) {
      const found = this.inputs.find(i => i._uid === input._uid);
      if (!found) return;
      const unwatch = this.watchers.find(i => i._uid === found._uid);

      if (unwatch) {
        unwatch.valid();
        unwatch.shouldValidate();
      }

      this.watchers = this.watchers.filter(i => i._uid !== found._uid);
      this.inputs = this.inputs.filter(i => i._uid !== found._uid);
      this.$delete(this.errorBag, found._uid);
    }

  },

  render(h) {
    return h('form', {
      staticClass: 'v-form',
      attrs: {
        novalidate: true,
        ...this.attrs$
      },
      on: {
        submit: e => this.$emit('submit', e)
      }
    }, this.$slots.default);
  }

}));

/***/ }),
/* 379 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 380 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VForm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(378);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VForm__WEBPACK_IMPORTED_MODULE_0__["a"]; });



/* unused harmony default export */ var _unused_webpack_default_export = (_VForm__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ }),
/* 381 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 382 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _components_VPicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(313);
/* harmony import */ var _colorable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _mixins_elevatable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _themeable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2);
// Components
 // Mixins



 // Utils


/* harmony default export */ __webpack_exports__["a"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(_colorable__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"], _mixins_elevatable__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], _themeable__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]
/* @vue/component */
).extend({
  name: 'picker',
  props: {
    flat: Boolean,
    fullWidth: Boolean,
    headerColor: String,
    landscape: Boolean,
    noTitle: Boolean,
    width: {
      type: [Number, String],
      default: 290
    }
  },
  methods: {
    genPickerTitle() {
      return null;
    },

    genPickerBody() {
      return null;
    },

    genPickerActionsSlot() {
      return this.$scopedSlots.default ? this.$scopedSlots.default({
        save: this.save,
        cancel: this.cancel
      }) : this.$slots.default;
    },

    genPicker(staticClass) {
      const children = [];

      if (!this.noTitle) {
        const title = this.genPickerTitle();
        title && children.push(title);
      }

      const body = this.genPickerBody();
      body && children.push(body);
      children.push(this.$createElement('template', {
        slot: 'actions'
      }, [this.genPickerActionsSlot()]));
      return this.$createElement(_components_VPicker__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"], {
        staticClass,
        props: {
          color: this.headerColor || this.color,
          dark: this.dark,
          elevation: this.elevation,
          flat: this.flat,
          fullWidth: this.fullWidth,
          landscape: this.landscape,
          light: this.light,
          width: this.width,
          noTitle: this.noTitle
        }
      }, children);
    }

  }
}));

/***/ }),
/* 383 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VTimeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(393);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VTimeline__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony import */ var _VTimelineItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(394);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "b", function() { return _VTimelineItem__WEBPACK_IMPORTED_MODULE_1__["a"]; });




/* unused harmony default export */ var _unused_webpack_default_export = ({
  $_vuetify_subcomponents: {
    VTimeline: _VTimeline__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"],
    VTimelineItem: _VTimelineItem__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]
  }
});

/***/ }),
/* 384 */,
/* 385 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _src_components_VBottomNavigation_VBottomNavigation_sass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(412);
/* harmony import */ var _src_components_VBottomNavigation_VBottomNavigation_sass__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_components_VBottomNavigation_VBottomNavigation_sass__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _mixins_applicationable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _mixins_button_group__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(270);
/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);
/* harmony import */ var _mixins_measurable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(37);
/* harmony import */ var _mixins_proxyable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(38);
/* harmony import */ var _mixins_scrollable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(73);
/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(4);
/* harmony import */ var _mixins_toggleable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(9);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(2);
/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(3);
// Styles
 // Mixins








 // Utilities



/* harmony default export */ __webpack_exports__["a"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"])(Object(_mixins_applicationable__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])('bottom', ['height', 'inputValue']), _mixins_colorable__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], _mixins_measurable__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], Object(_mixins_toggleable__WEBPACK_IMPORTED_MODULE_8__[/* factory */ "b"])('inputValue'), _mixins_proxyable__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"], _mixins_scrollable__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"]
/* @vue/component */
).extend({
  name: 'v-bottom-navigation',
  props: {
    activeClass: {
      type: String,
      default: 'v-btn--active'
    },
    backgroundColor: String,
    grow: Boolean,
    height: {
      type: [Number, String],
      default: 56
    },
    hideOnScroll: Boolean,
    horizontal: Boolean,
    inputValue: {
      type: Boolean,
      default: true
    },
    mandatory: Boolean,
    shift: Boolean,
    tag: {
      type: String,
      default: 'div'
    }
  },

  data() {
    return {
      isActive: this.inputValue
    };
  },

  computed: {
    canScroll() {
      return _mixins_scrollable__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].options.computed.canScroll.call(this) && (this.hideOnScroll || !this.inputValue);
    },

    classes() {
      return {
        'v-bottom-navigation--absolute': this.absolute,
        'v-bottom-navigation--grow': this.grow,
        'v-bottom-navigation--fixed': !this.absolute && (this.app || this.fixed),
        'v-bottom-navigation--horizontal': this.horizontal,
        'v-bottom-navigation--shift': this.shift
      };
    },

    styles() {
      return { ...this.measurableStyles,
        transform: this.isActive ? 'none' : 'translateY(100%)'
      };
    }

  },

  created() {
    /* istanbul ignore next */
    if (this.$attrs.hasOwnProperty('active')) {
      Object(_util_console__WEBPACK_IMPORTED_MODULE_10__[/* breaking */ "a"])('active.sync', 'value or v-model', this);
    }
  },

  methods: {
    thresholdMet() {
      this.isActive = !this.isScrollingUp;
      this.$emit('update:input-value', this.isActive);
    },

    updateApplication() {
      return this.$el ? this.$el.clientHeight : 0;
    },

    updateValue(val) {
      this.$emit('change', val);
    }

  },

  render(h) {
    const data = this.setBackgroundColor(this.backgroundColor, {
      staticClass: 'v-bottom-navigation',
      class: this.classes,
      style: this.styles,
      props: {
        activeClass: this.activeClass,
        mandatory: Boolean(this.mandatory || this.value !== undefined),
        tag: this.tag,
        value: this.internalValue
      },
      on: {
        change: this.updateValue
      }
    });

    if (this.canScroll) {
      data.directives = data.directives || [];
      data.directives.push({
        arg: this.scrollTarget,
        name: 'scroll',
        value: this.onScroll
      });
    }

    return h(_mixins_button_group__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], this.setTextColor(this.color, data), this.$slots.default);
  }

}));

/***/ }),
/* 386 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VDatePickerTitle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(306);
/* harmony import */ var _VDatePickerHeader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(308);
/* harmony import */ var _VDatePickerDateTable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(309);
/* harmony import */ var _VDatePickerMonthTable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(310);
/* harmony import */ var _VDatePickerYears__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(311);
/* harmony import */ var _mixins_localable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(275);
/* harmony import */ var _mixins_picker__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(382);
/* harmony import */ var _util_isDateAllowed__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(375);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(2);
/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(0);
/* harmony import */ var _VCalendar_util_timestamp__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(263);
/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(3);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(487);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(282);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(488);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(490);
// Components




 // Mixins


 // Utils







/* harmony default export */ __webpack_exports__["a"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(_mixins_localable__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"], _mixins_picker__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]).extend({
  name: 'v-date-picker',
  props: {
    activePicker: String,
    allowedDates: Function,
    // Function formatting the day in date picker table
    dayFormat: Function,
    disabled: Boolean,
    events: {
      type: [Array, Function, Object],
      default: () => null
    },
    eventColor: {
      type: [Array, Function, Object, String],
      default: () => 'warning'
    },
    firstDayOfWeek: {
      type: [String, Number],
      default: 0
    },
    // Function formatting the tableDate in the day/month table header
    headerDateFormat: Function,
    localeFirstDayOfYear: {
      type: [String, Number],
      default: 0
    },
    max: String,
    min: String,
    // Function formatting month in the months table
    monthFormat: Function,
    multiple: Boolean,
    nextIcon: {
      type: String,
      default: '$next'
    },
    nextMonthAriaLabel: {
      type: String,
      default: '$vuetify.datePicker.nextMonthAriaLabel'
    },
    nextYearAriaLabel: {
      type: String,
      default: '$vuetify.datePicker.nextYearAriaLabel'
    },
    pickerDate: String,
    prevIcon: {
      type: String,
      default: '$prev'
    },
    prevMonthAriaLabel: {
      type: String,
      default: '$vuetify.datePicker.prevMonthAriaLabel'
    },
    prevYearAriaLabel: {
      type: String,
      default: '$vuetify.datePicker.prevYearAriaLabel'
    },
    range: Boolean,
    reactive: Boolean,
    readonly: Boolean,
    scrollable: Boolean,
    showCurrent: {
      type: [Boolean, String],
      default: true
    },
    selectedItemsText: {
      type: String,
      default: '$vuetify.datePicker.itemsSelected'
    },
    showAdjacentMonths: Boolean,
    showWeek: Boolean,
    // Function formatting currently selected date in the picker title
    titleDateFormat: Function,
    type: {
      type: String,
      default: 'date',
      validator: type => ['date', 'month'].includes(type)
    },
    value: [Array, String],
    weekdayFormat: Function,
    // Function formatting the year in table header and pickup title
    yearFormat: Function,
    yearIcon: String
  },

  data() {
    const now = new Date();
    return {
      internalActivePicker: this.type.toUpperCase(),
      inputDay: null,
      inputMonth: null,
      inputYear: null,
      isReversing: false,
      now,
      // tableDate is a string in 'YYYY' / 'YYYY-M' format (leading zero for month is not required)
      tableDate: (() => {
        if (this.pickerDate) {
          return this.pickerDate;
        }

        const multipleValue = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_9__[/* wrapInArray */ "L"])(this.value);
        const date = multipleValue[multipleValue.length - 1] || (typeof this.showCurrent === 'string' ? this.showCurrent : `${now.getFullYear()}-${now.getMonth() + 1}`);
        return Object(_util__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"])(date, this.type === 'date' ? 'month' : 'year');
      })()
    };
  },

  computed: {
    multipleValue() {
      return Object(_util_helpers__WEBPACK_IMPORTED_MODULE_9__[/* wrapInArray */ "L"])(this.value);
    },

    isMultiple() {
      return this.multiple || this.range;
    },

    lastValue() {
      return this.isMultiple ? this.multipleValue[this.multipleValue.length - 1] : this.value;
    },

    selectedMonths() {
      if (!this.value || this.type === 'month') {
        return this.value;
      } else if (this.isMultiple) {
        return this.multipleValue.map(val => val.substr(0, 7));
      } else {
        return this.value.substr(0, 7);
      }
    },

    current() {
      if (this.showCurrent === true) {
        return Object(_util__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"])(`${this.now.getFullYear()}-${this.now.getMonth() + 1}-${this.now.getDate()}`, this.type);
      }

      return this.showCurrent || null;
    },

    inputDate() {
      return this.type === 'date' ? `${this.inputYear}-${Object(_util__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"])(this.inputMonth + 1)}-${Object(_util__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"])(this.inputDay)}` : `${this.inputYear}-${Object(_util__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"])(this.inputMonth + 1)}`;
    },

    tableMonth() {
      return Number((this.pickerDate || this.tableDate).split('-')[1]) - 1;
    },

    tableYear() {
      return Number((this.pickerDate || this.tableDate).split('-')[0]);
    },

    minMonth() {
      return this.min ? Object(_util__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"])(this.min, 'month') : null;
    },

    maxMonth() {
      return this.max ? Object(_util__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"])(this.max, 'month') : null;
    },

    minYear() {
      return this.min ? Object(_util__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"])(this.min, 'year') : null;
    },

    maxYear() {
      return this.max ? Object(_util__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"])(this.max, 'year') : null;
    },

    formatters() {
      return {
        year: this.yearFormat || Object(_util__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"])(this.currentLocale, {
          year: 'numeric',
          timeZone: 'UTC'
        }, {
          length: 4
        }),
        titleDate: this.titleDateFormat || (this.isMultiple ? this.defaultTitleMultipleDateFormatter : this.defaultTitleDateFormatter)
      };
    },

    defaultTitleMultipleDateFormatter() {
      return dates => {
        if (!dates.length) {
          return '-';
        }

        if (dates.length === 1) {
          return this.defaultTitleDateFormatter(dates[0]);
        }

        return this.$vuetify.lang.t(this.selectedItemsText, dates.length);
      };
    },

    defaultTitleDateFormatter() {
      const titleFormats = {
        year: {
          year: 'numeric',
          timeZone: 'UTC'
        },
        month: {
          month: 'long',
          timeZone: 'UTC'
        },
        date: {
          weekday: 'short',
          month: 'short',
          day: 'numeric',
          timeZone: 'UTC'
        }
      };
      const titleDateFormatter = Object(_util__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"])(this.currentLocale, titleFormats[this.type], {
        start: 0,
        length: {
          date: 10,
          month: 7,
          year: 4
        }[this.type]
      });

      const landscapeFormatter = date => titleDateFormatter(date).replace(/([^\d\s])([\d])/g, (match, nonDigit, digit) => `${nonDigit} ${digit}`).replace(', ', ',<br>');

      return this.landscape ? landscapeFormatter : titleDateFormatter;
    }

  },
  watch: {
    internalActivePicker: {
      immediate: true,

      handler(val) {
        this.$emit('update:active-picker', val);
      }

    },

    activePicker(val) {
      this.internalActivePicker = val;
    },

    tableDate(val, prev) {
      // Make a ISO 8601 strings from val and prev for comparision, otherwise it will incorrectly
      // compare for example '2000-9' and '2000-10'
      const sanitizeType = this.type === 'month' ? 'year' : 'month';
      this.isReversing = Object(_util__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"])(val, sanitizeType) < Object(_util__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"])(prev, sanitizeType);
      this.$emit('update:picker-date', val);
    },

    pickerDate(val) {
      if (val) {
        this.tableDate = val;
      } else if (this.lastValue && this.type === 'date') {
        this.tableDate = Object(_util__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"])(this.lastValue, 'month');
      } else if (this.lastValue && this.type === 'month') {
        this.tableDate = Object(_util__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"])(this.lastValue, 'year');
      }
    },

    value(newValue, oldValue) {
      this.checkMultipleProp();
      this.setInputDate();

      if (!this.isMultiple && this.value && !this.pickerDate || this.isMultiple && this.multipleValue.length && (!oldValue || !oldValue.length) && !this.pickerDate) {
        this.tableDate = Object(_util__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"])(this.inputDate, this.type === 'month' ? 'year' : 'month');
      }
    },

    type(type) {
      this.internalActivePicker = type.toUpperCase();

      if (this.value && this.value.length) {
        const output = this.multipleValue.map(val => Object(_util__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"])(val, type)).filter(this.isDateAllowed);
        this.$emit('input', this.isMultiple ? output : output[0]);
      }
    }

  },

  created() {
    this.checkMultipleProp();

    if (this.pickerDate !== this.tableDate) {
      this.$emit('update:picker-date', this.tableDate);
    }

    this.setInputDate();
  },

  methods: {
    emitInput(newInput) {
      if (this.range) {
        if (this.multipleValue.length !== 1) {
          this.$emit('input', [newInput]);
        } else {
          const output = [this.multipleValue[0], newInput];
          this.$emit('input', output);
          this.$emit('change', output);
        }

        return;
      }

      const output = this.multiple ? this.multipleValue.indexOf(newInput) === -1 ? this.multipleValue.concat([newInput]) : this.multipleValue.filter(x => x !== newInput) : newInput;
      this.$emit('input', output);
      this.multiple || this.$emit('change', newInput);
    },

    checkMultipleProp() {
      if (this.value == null) return;
      const valueType = this.value.constructor.name;
      const expected = this.isMultiple ? 'Array' : 'String';

      if (valueType !== expected) {
        Object(_util_console__WEBPACK_IMPORTED_MODULE_11__[/* consoleWarn */ "c"])(`Value must be ${this.isMultiple ? 'an' : 'a'} ${expected}, got ${valueType}`, this);
      }
    },

    isDateAllowed(value) {
      return Object(_util_isDateAllowed__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(value, this.min, this.max, this.allowedDates);
    },

    yearClick(value) {
      this.inputYear = value;

      if (this.type === 'month') {
        this.tableDate = `${value}`;
      } else {
        this.tableDate = `${value}-${Object(_util__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"])((this.tableMonth || 0) + 1)}`;
      }

      this.internalActivePicker = 'MONTH';

      if (this.reactive && !this.readonly && !this.isMultiple && this.isDateAllowed(this.inputDate)) {
        this.$emit('input', this.inputDate);
      }
    },

    monthClick(value) {
      this.inputYear = parseInt(value.split('-')[0], 10);
      this.inputMonth = parseInt(value.split('-')[1], 10) - 1;

      if (this.type === 'date') {
        if (this.inputDay) {
          this.inputDay = Math.min(this.inputDay, Object(_VCalendar_util_timestamp__WEBPACK_IMPORTED_MODULE_10__[/* daysInMonth */ "i"])(this.inputYear, this.inputMonth + 1));
        }

        this.tableDate = value;
        this.internalActivePicker = 'DATE';

        if (this.reactive && !this.readonly && !this.isMultiple && this.isDateAllowed(this.inputDate)) {
          this.$emit('input', this.inputDate);
        }
      } else {
        this.emitInput(this.inputDate);
      }
    },

    dateClick(value) {
      this.inputYear = parseInt(value.split('-')[0], 10);
      this.inputMonth = parseInt(value.split('-')[1], 10) - 1;
      this.inputDay = parseInt(value.split('-')[2], 10);
      this.emitInput(this.inputDate);
    },

    genPickerTitle() {
      return this.$createElement(_VDatePickerTitle__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"], {
        props: {
          date: this.value ? this.formatters.titleDate(this.isMultiple ? this.multipleValue : this.value) : '',
          disabled: this.disabled,
          readonly: this.readonly,
          selectingYear: this.internalActivePicker === 'YEAR',
          year: this.formatters.year(this.multipleValue.length ? `${this.inputYear}` : this.tableDate),
          yearIcon: this.yearIcon,
          value: this.multipleValue[0]
        },
        slot: 'title',
        on: {
          'update:selecting-year': value => this.internalActivePicker = value ? 'YEAR' : this.type.toUpperCase()
        }
      });
    },

    genTableHeader() {
      return this.$createElement(_VDatePickerHeader__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"], {
        props: {
          nextIcon: this.nextIcon,
          color: this.color,
          dark: this.dark,
          disabled: this.disabled,
          format: this.headerDateFormat,
          light: this.light,
          locale: this.locale,
          min: this.internalActivePicker === 'DATE' ? this.minMonth : this.minYear,
          max: this.internalActivePicker === 'DATE' ? this.maxMonth : this.maxYear,
          nextAriaLabel: this.internalActivePicker === 'DATE' ? this.nextMonthAriaLabel : this.nextYearAriaLabel,
          prevAriaLabel: this.internalActivePicker === 'DATE' ? this.prevMonthAriaLabel : this.prevYearAriaLabel,
          prevIcon: this.prevIcon,
          readonly: this.readonly,
          value: this.internalActivePicker === 'DATE' ? `${Object(_util__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"])(this.tableYear, 4)}-${Object(_util__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"])(this.tableMonth + 1)}` : `${Object(_util__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"])(this.tableYear, 4)}`
        },
        on: {
          toggle: () => this.internalActivePicker = this.internalActivePicker === 'DATE' ? 'MONTH' : 'YEAR',
          input: value => this.tableDate = value
        }
      });
    },

    genDateTable() {
      return this.$createElement(_VDatePickerDateTable__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], {
        props: {
          allowedDates: this.allowedDates,
          color: this.color,
          current: this.current,
          dark: this.dark,
          disabled: this.disabled,
          events: this.events,
          eventColor: this.eventColor,
          firstDayOfWeek: this.firstDayOfWeek,
          format: this.dayFormat,
          light: this.light,
          locale: this.locale,
          localeFirstDayOfYear: this.localeFirstDayOfYear,
          min: this.min,
          max: this.max,
          range: this.range,
          readonly: this.readonly,
          scrollable: this.scrollable,
          showAdjacentMonths: this.showAdjacentMonths,
          showWeek: this.showWeek,
          tableDate: `${Object(_util__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"])(this.tableYear, 4)}-${Object(_util__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"])(this.tableMonth + 1)}`,
          value: this.value,
          weekdayFormat: this.weekdayFormat
        },
        ref: 'table',
        on: {
          input: this.dateClick,
          'update:table-date': value => this.tableDate = value,
          ...Object(_util__WEBPACK_IMPORTED_MODULE_15__[/* createItemTypeListeners */ "a"])(this, ':date')
        }
      });
    },

    genMonthTable() {
      return this.$createElement(_VDatePickerMonthTable__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], {
        props: {
          allowedDates: this.type === 'month' ? this.allowedDates : null,
          color: this.color,
          current: this.current ? Object(_util__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"])(this.current, 'month') : null,
          dark: this.dark,
          disabled: this.disabled,
          events: this.type === 'month' ? this.events : null,
          eventColor: this.type === 'month' ? this.eventColor : null,
          format: this.monthFormat,
          light: this.light,
          locale: this.locale,
          min: this.minMonth,
          max: this.maxMonth,
          range: this.range,
          readonly: this.readonly && this.type === 'month',
          scrollable: this.scrollable,
          value: this.selectedMonths,
          tableDate: `${Object(_util__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"])(this.tableYear, 4)}`
        },
        ref: 'table',
        on: {
          input: this.monthClick,
          'update:table-date': value => this.tableDate = value,
          ...Object(_util__WEBPACK_IMPORTED_MODULE_15__[/* createItemTypeListeners */ "a"])(this, ':month')
        }
      });
    },

    genYears() {
      return this.$createElement(_VDatePickerYears__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], {
        props: {
          color: this.color,
          format: this.yearFormat,
          locale: this.locale,
          min: this.minYear,
          max: this.maxYear,
          value: this.tableYear
        },
        on: {
          input: this.yearClick,
          ...Object(_util__WEBPACK_IMPORTED_MODULE_15__[/* createItemTypeListeners */ "a"])(this, ':year')
        }
      });
    },

    genPickerBody() {
      const children = this.internalActivePicker === 'YEAR' ? [this.genYears()] : [this.genTableHeader(), this.internalActivePicker === 'DATE' ? this.genDateTable() : this.genMonthTable()];
      return this.$createElement('div', {
        key: this.internalActivePicker
      }, children);
    },

    setInputDate() {
      if (this.lastValue) {
        const array = this.lastValue.split('-');
        this.inputYear = parseInt(array[0], 10);
        this.inputMonth = parseInt(array[1], 10) - 1;

        if (this.type === 'date') {
          this.inputDay = parseInt(array[2], 10);
        }
      } else {
        this.inputYear = this.inputYear || this.now.getFullYear();
        this.inputMonth = this.inputMonth == null ? this.inputMonth : this.now.getMonth();
        this.inputDay = this.inputDay || this.now.getDate();
      }
    }

  },

  render() {
    return this.genPicker('v-picker--date');
  }

}));

/***/ }),
/* 387 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _src_components_VTextarea_VTextarea_sass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(421);
/* harmony import */ var _src_components_VTextarea_VTextarea_sass__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_components_VTextarea_VTextarea_sass__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(201);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);
// Styles
 // Extensions

 // Utilities


const baseMixins = Object(_util_mixins__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(_VTextField_VTextField__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);
/* @vue/component */

/* harmony default export */ __webpack_exports__["a"] = (baseMixins.extend({
  name: 'v-textarea',
  props: {
    autoGrow: Boolean,
    noResize: Boolean,
    rowHeight: {
      type: [Number, String],
      default: 24,
      validator: v => !isNaN(parseFloat(v))
    },
    rows: {
      type: [Number, String],
      default: 5,
      validator: v => !isNaN(parseInt(v, 10))
    }
  },
  computed: {
    classes() {
      return {
        'v-textarea': true,
        'v-textarea--auto-grow': this.autoGrow,
        'v-textarea--no-resize': this.noResizeHandle,
        ..._VTextField_VTextField__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].options.computed.classes.call(this)
      };
    },

    noResizeHandle() {
      return this.noResize || this.autoGrow;
    }

  },
  watch: {
    autoGrow(val) {
      this.$nextTick(() => {
        var _this$$refs$input;

        val ? this.calculateInputHeight() : (_this$$refs$input = this.$refs.input) == null ? void 0 : _this$$refs$input.style.removeProperty('height');
      });
    },

    lazyValue() {
      this.autoGrow && this.$nextTick(this.calculateInputHeight);
    },

    rowHeight() {
      this.autoGrow && this.$nextTick(this.calculateInputHeight);
    }

  },

  mounted() {
    setTimeout(() => {
      this.autoGrow && this.calculateInputHeight();
    }, 0);
  },

  methods: {
    calculateInputHeight() {
      const input = this.$refs.input;
      if (!input) return;
      input.style.height = '0';
      const height = input.scrollHeight;
      const minHeight = parseInt(this.rows, 10) * parseFloat(this.rowHeight); // This has to be done ASAP, waiting for Vue
      // to update the DOM causes ugly layout jumping

      input.style.height = Math.max(minHeight, height) + 'px';
    },

    genInput() {
      const input = _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].options.methods.genInput.call(this);
      input.tag = 'textarea';
      delete input.data.attrs.type;
      input.data.attrs.rows = this.rows;
      return input;
    },

    onInput(e) {
      _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].options.methods.onInput.call(this, e);
      this.autoGrow && this.calculateInputHeight();
    },

    onKeyDown(e) {
      // Prevents closing of a
      // dialog when pressing
      // enter
      if (this.isFocused && e.keyCode === 13) {
        e.stopPropagation();
      }

      this.$emit('keydown', e);
    }

  }
}));

/***/ }),
/* 388 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VBottomNavigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(385);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _VBottomNavigation__WEBPACK_IMPORTED_MODULE_0__["a"]; });



/* unused harmony default export */ var _unused_webpack_default_export = (_VBottomNavigation__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);

/***/ }),
/* 389 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _src_components_VExpansionPanel_VExpansionPanel_sass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(423);
/* harmony import */ var _src_components_VExpansionPanel_VExpansionPanel_sass__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_components_VExpansionPanel_VExpansionPanel_sass__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _VItemGroup_VItemGroup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
// Styles
 // Components

 // Utilities


/* @vue/component */

/* harmony default export */ __webpack_exports__["a"] = (_VItemGroup_VItemGroup__WEBPACK_IMPORTED_MODULE_1__[/* BaseItemGroup */ "a"].extend({
  name: 'v-expansion-panels',

  provide() {
    return {
      expansionPanels: this
    };
  },

  props: {
    accordion: Boolean,
    disabled: Boolean,
    flat: Boolean,
    hover: Boolean,
    focusable: Boolean,
    inset: Boolean,
    popout: Boolean,
    readonly: Boolean,
    tile: Boolean
  },
  computed: {
    classes() {
      return { ..._VItemGroup_VItemGroup__WEBPACK_IMPORTED_MODULE_1__[/* BaseItemGroup */ "a"].options.computed.classes.call(this),
        'v-expansion-panels': true,
        'v-expansion-panels--accordion': this.accordion,
        'v-expansion-panels--flat': this.flat,
        'v-expansion-panels--hover': this.hover,
        'v-expansion-panels--focusable': this.focusable,
        'v-expansion-panels--inset': this.inset,
        'v-expansion-panels--popout': this.popout,
        'v-expansion-panels--tile': this.tile
      };
    }

  },

  created() {
    /* istanbul ignore next */
    if (this.$attrs.hasOwnProperty('expand')) {
      Object(_util_console__WEBPACK_IMPORTED_MODULE_2__[/* breaking */ "a"])('expand', 'multiple', this);
    }
    /* istanbul ignore next */


    if (Array.isArray(this.value) && this.value.length > 0 && typeof this.value[0] === 'boolean') {
      Object(_util_console__WEBPACK_IMPORTED_MODULE_2__[/* breaking */ "a"])(':value="[true, false, true]"', ':value="[0, 2]"', this);
    }
  },

  methods: {
    updateItem(item, index) {
      const value = this.getValue(item, index);
      const nextValue = this.getValue(item, index + 1);
      item.isActive = this.toggleMethod(value);
      item.nextIsActive = this.toggleMethod(nextValue);
    }

  }
}));

/***/ }),
/* 390 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mixins_groupable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34);
/* harmony import */ var _mixins_registrable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);
// Mixins

 // Utilities



/* harmony default export */ __webpack_exports__["a"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(Object(_mixins_groupable__WEBPACK_IMPORTED_MODULE_0__[/* factory */ "a"])('expansionPanels', 'v-expansion-panel', 'v-expansion-panels'), Object(_mixins_registrable__WEBPACK_IMPORTED_MODULE_1__[/* provide */ "b"])('expansionPanel', true)
/* @vue/component */
).extend({
  name: 'v-expansion-panel',
  props: {
    disabled: Boolean,
    readonly: Boolean
  },

  data() {
    return {
      content: null,
      header: null,
      nextIsActive: false
    };
  },

  computed: {
    classes() {
      return {
        'v-expansion-panel--active': this.isActive,
        'v-expansion-panel--next-active': this.nextIsActive,
        'v-expansion-panel--disabled': this.isDisabled,
        ...this.groupClasses
      };
    },

    isDisabled() {
      return this.expansionPanels.disabled || this.disabled;
    },

    isReadonly() {
      return this.expansionPanels.readonly || this.readonly;
    }

  },
  methods: {
    registerContent(vm) {
      this.content = vm;
    },

    unregisterContent() {
      this.content = null;
    },

    registerHeader(vm) {
      this.header = vm;
      vm.$on('click', this.onClick);
    },

    unregisterHeader() {
      this.header = null;
    },

    onClick(e) {
      if (e.detail) this.header.$el.blur();
      this.$emit('click', e);
      this.isReadonly || this.isDisabled || this.toggle();
    },

    toggle() {
      this.$nextTick(() => this.$emit('change'));
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'v-expansion-panel',
      class: this.classes,
      attrs: {
        'aria-expanded': String(this.isActive)
      }
    }, Object(_util_helpers__WEBPACK_IMPORTED_MODULE_2__[/* getSlot */ "v"])(this));
  }

}));

/***/ }),
/* 391 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _transitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var _mixins_registrable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33);
/* harmony import */ var _directives_ripple__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25);
/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(0);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2);
// Components

 // Mixins


 // Directives

 // Utilities



const baseMixins = Object(_util_mixins__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], Object(_mixins_registrable__WEBPACK_IMPORTED_MODULE_3__[/* inject */ "a"])('expansionPanel', 'v-expansion-panel-header', 'v-expansion-panel'));
/* harmony default export */ __webpack_exports__["a"] = (baseMixins.extend().extend({
  name: 'v-expansion-panel-header',
  directives: {
    ripple: _directives_ripple__WEBPACK_IMPORTED_MODULE_4__[/* default */ "b"]
  },
  props: {
    disableIconRotate: Boolean,
    expandIcon: {
      type: String,
      default: '$expand'
    },
    hideActions: Boolean,
    ripple: {
      type: [Boolean, Object],
      default: false
    }
  },
  data: () => ({
    hasMousedown: false
  }),
  computed: {
    classes() {
      return {
        'v-expansion-panel-header--active': this.isActive,
        'v-expansion-panel-header--mousedown': this.hasMousedown
      };
    },

    isActive() {
      return this.expansionPanel.isActive;
    },

    isDisabled() {
      return this.expansionPanel.isDisabled;
    },

    isReadonly() {
      return this.expansionPanel.isReadonly;
    }

  },

  created() {
    this.expansionPanel.registerHeader(this);
  },

  beforeDestroy() {
    this.expansionPanel.unregisterHeader();
  },

  methods: {
    onClick(e) {
      this.$emit('click', e);
    },

    genIcon() {
      const icon = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_5__[/* getSlot */ "v"])(this, 'actions') || [this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_1__[/* default */ "b"], this.expandIcon)];
      return this.$createElement(_transitions__WEBPACK_IMPORTED_MODULE_0__[/* VFadeTransition */ "i"], [this.$createElement('div', {
        staticClass: 'v-expansion-panel-header__icon',
        class: {
          'v-expansion-panel-header__icon--disable-rotate': this.disableIconRotate
        },
        directives: [{
          name: 'show',
          value: !this.isDisabled
        }]
      }, icon)]);
    }

  },

  render(h) {
    return h('button', this.setBackgroundColor(this.color, {
      staticClass: 'v-expansion-panel-header',
      class: this.classes,
      attrs: {
        tabindex: this.isDisabled ? -1 : null,
        type: 'button',
        'aria-expanded': this.isActive
      },
      directives: [{
        name: 'ripple',
        value: this.ripple
      }],
      on: { ...this.$listeners,
        click: this.onClick,
        mousedown: () => this.hasMousedown = true,
        mouseup: () => this.hasMousedown = false
      }
    }), [Object(_util_helpers__WEBPACK_IMPORTED_MODULE_5__[/* getSlot */ "v"])(this, 'default', {
      open: this.isActive
    }, true), this.hideActions || this.genIcon()]);
  }

}));

/***/ }),
/* 392 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _transitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
/* harmony import */ var _mixins_bootable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59);
/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var _mixins_registrable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33);
/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2);
 // Mixins



 // Utilities



const baseMixins = Object(_util_mixins__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(_mixins_bootable__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"], _mixins_colorable__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], Object(_mixins_registrable__WEBPACK_IMPORTED_MODULE_3__[/* inject */ "a"])('expansionPanel', 'v-expansion-panel-content', 'v-expansion-panel'));
/* @vue/component */

/* harmony default export */ __webpack_exports__["a"] = (baseMixins.extend().extend({
  name: 'v-expansion-panel-content',
  data: () => ({
    isActive: false
  }),
  computed: {
    parentIsActive() {
      return this.expansionPanel.isActive;
    }

  },
  watch: {
    parentIsActive: {
      immediate: true,

      handler(val, oldVal) {
        if (val) this.isBooted = true;
        if (oldVal == null) this.isActive = val;else this.$nextTick(() => this.isActive = val);
      }

    }
  },

  created() {
    this.expansionPanel.registerContent(this);
  },

  beforeDestroy() {
    this.expansionPanel.unregisterContent();
  },

  render(h) {
    return h(_transitions__WEBPACK_IMPORTED_MODULE_0__[/* VExpandTransition */ "f"], this.showLazyContent(() => [h('div', this.setBackgroundColor(this.color, {
      staticClass: 'v-expansion-panel-content',
      directives: [{
        name: 'show',
        value: this.isActive
      }]
    }), [h('div', {
      class: 'v-expansion-panel-content__wrap'
    }, Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__[/* getSlot */ "v"])(this))])]));
  }

}));

/***/ }),
/* 393 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _src_components_VTimeline_VTimeline_sass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(424);
/* harmony import */ var _src_components_VTimeline_VTimeline_sass__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_components_VTimeline_VTimeline_sass__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
// Styles

 // Mixins


/* harmony default export */ __webpack_exports__["a"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_mixins_themeable__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]
/* @vue/component */
).extend({
  name: 'v-timeline',

  provide() {
    return {
      timeline: this
    };
  },

  props: {
    alignTop: Boolean,
    dense: Boolean,
    reverse: Boolean
  },
  computed: {
    classes() {
      return {
        'v-timeline--align-top': this.alignTop,
        'v-timeline--dense': this.dense,
        'v-timeline--reverse': this.reverse,
        ...this.themeClasses
      };
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'v-timeline',
      class: this.classes
    }, this.$slots.default);
  }

}));

/***/ }),
/* 394 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);
// Types

 // Mixins



const baseMixins = Object(_util_mixins__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]
/* @vue/component */
);
/* harmony default export */ __webpack_exports__["a"] = (baseMixins.extend().extend({
  name: 'v-timeline-item',
  inject: ['timeline'],
  props: {
    color: {
      type: String,
      default: 'primary'
    },
    fillDot: Boolean,
    hideDot: Boolean,
    icon: String,
    iconColor: String,
    large: Boolean,
    left: Boolean,
    right: Boolean,
    small: Boolean
  },
  computed: {
    hasIcon() {
      return !!this.icon || !!this.$slots.icon;
    }

  },
  methods: {
    genBody() {
      return this.$createElement('div', {
        staticClass: 'v-timeline-item__body'
      }, this.$slots.default);
    },

    genIcon() {
      if (this.$slots.icon) {
        return this.$slots.icon;
      }

      return this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_1__[/* default */ "b"], {
        props: {
          color: this.iconColor,
          dark: !this.theme.isDark,
          small: this.small
        }
      }, this.icon);
    },

    genInnerDot() {
      const data = this.setBackgroundColor(this.color);
      return this.$createElement('div', {
        staticClass: 'v-timeline-item__inner-dot',
        ...data
      }, [this.hasIcon && this.genIcon()]);
    },

    genDot() {
      return this.$createElement('div', {
        staticClass: 'v-timeline-item__dot',
        class: {
          'v-timeline-item__dot--small': this.small,
          'v-timeline-item__dot--large': this.large
        }
      }, [this.genInnerDot()]);
    },

    genDivider() {
      const children = [];
      if (!this.hideDot) children.push(this.genDot());
      return this.$createElement('div', {
        staticClass: 'v-timeline-item__divider'
      }, children);
    },

    genOpposite() {
      return this.$createElement('div', {
        staticClass: 'v-timeline-item__opposite'
      }, this.$slots.opposite);
    }

  },

  render(h) {
    const children = [this.genBody(), this.genDivider()];
    if (this.$slots.opposite) children.push(this.genOpposite());
    return h('div', {
      staticClass: 'v-timeline-item',
      class: {
        'v-timeline-item--fill-dot': this.fillDot,
        'v-timeline-item--before': this.timeline.reverse ? this.right : this.left,
        'v-timeline-item--after': this.timeline.reverse ? this.left : this.right,
        ...this.themeClasses
      }
    }, children);
  }

}));

/***/ }),
/* 395 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "VApp", function() { return /* reexport */ VApp["a" /* VApp */]; });
__webpack_require__.d(__webpack_exports__, "VAppBar", function() { return /* reexport */ VAppBar["a" /* VAppBar */]; });
__webpack_require__.d(__webpack_exports__, "VAppBarNavIcon", function() { return /* reexport */ VAppBar["b" /* VAppBarNavIcon */]; });
__webpack_require__.d(__webpack_exports__, "VAppBarTitle", function() { return /* reexport */ VAppBar["c" /* VAppBarTitle */]; });
__webpack_require__.d(__webpack_exports__, "VAlert", function() { return /* reexport */ VAlert_VAlert; });
__webpack_require__.d(__webpack_exports__, "VAutocomplete", function() { return /* reexport */ VAutocomplete_VAutocomplete; });
__webpack_require__.d(__webpack_exports__, "VAvatar", function() { return /* reexport */ VAvatar["a" /* VAvatar */]; });
__webpack_require__.d(__webpack_exports__, "VBadge", function() { return /* reexport */ VBadge_VBadge; });
__webpack_require__.d(__webpack_exports__, "VBanner", function() { return /* reexport */ VBanner_VBanner; });
__webpack_require__.d(__webpack_exports__, "VBottomNavigation", function() { return /* reexport */ VBottomNavigation["a" /* VBottomNavigation */]; });
__webpack_require__.d(__webpack_exports__, "VBottomSheet", function() { return /* reexport */ VBottomSheet_VBottomSheet; });
__webpack_require__.d(__webpack_exports__, "VBreadcrumbs", function() { return /* reexport */ VBreadcrumbs_VBreadcrumbs; });
__webpack_require__.d(__webpack_exports__, "VBreadcrumbsItem", function() { return /* reexport */ VBreadcrumbsItem; });
__webpack_require__.d(__webpack_exports__, "VBreadcrumbsDivider", function() { return /* reexport */ VBreadcrumbsDivider; });
__webpack_require__.d(__webpack_exports__, "VBtn", function() { return /* reexport */ VBtn["a" /* VBtn */]; });
__webpack_require__.d(__webpack_exports__, "VBtnToggle", function() { return /* reexport */ VBtnToggle_VBtnToggle; });
__webpack_require__.d(__webpack_exports__, "VCalendar", function() { return /* reexport */ VCalendar; });
__webpack_require__.d(__webpack_exports__, "VCalendarCategory", function() { return /* reexport */ VCalendar_VCalendarCategory; });
__webpack_require__.d(__webpack_exports__, "VCalendarDaily", function() { return /* reexport */ VCalendar_VCalendarDaily; });
__webpack_require__.d(__webpack_exports__, "VCalendarWeekly", function() { return /* reexport */ VCalendar_VCalendarWeekly; });
__webpack_require__.d(__webpack_exports__, "VCalendarMonthly", function() { return /* reexport */ VCalendarMonthly; });
__webpack_require__.d(__webpack_exports__, "VCard", function() { return /* reexport */ VCard["a" /* VCard */]; });
__webpack_require__.d(__webpack_exports__, "VCardActions", function() { return /* reexport */ VCard["b" /* VCardActions */]; });
__webpack_require__.d(__webpack_exports__, "VCardSubtitle", function() { return /* reexport */ VCard["c" /* VCardSubtitle */]; });
__webpack_require__.d(__webpack_exports__, "VCardText", function() { return /* reexport */ VCard["d" /* VCardText */]; });
__webpack_require__.d(__webpack_exports__, "VCardTitle", function() { return /* reexport */ VCard["e" /* VCardTitle */]; });
__webpack_require__.d(__webpack_exports__, "VCarousel", function() { return /* reexport */ VCarousel["a" /* VCarousel */]; });
__webpack_require__.d(__webpack_exports__, "VCarouselItem", function() { return /* reexport */ VCarousel["b" /* VCarouselItem */]; });
__webpack_require__.d(__webpack_exports__, "VCheckbox", function() { return /* reexport */ VCheckbox["a" /* VCheckbox */]; });
__webpack_require__.d(__webpack_exports__, "VSimpleCheckbox", function() { return /* reexport */ VCheckbox["b" /* VSimpleCheckbox */]; });
__webpack_require__.d(__webpack_exports__, "VChip", function() { return /* reexport */ VChip["a" /* VChip */]; });
__webpack_require__.d(__webpack_exports__, "VChipGroup", function() { return /* reexport */ VChipGroup_VChipGroup; });
__webpack_require__.d(__webpack_exports__, "VColorPicker", function() { return /* reexport */ VColorPicker_VColorPicker; });
__webpack_require__.d(__webpack_exports__, "VColorPickerSwatches", function() { return /* reexport */ VColorPicker_VColorPickerSwatches; });
__webpack_require__.d(__webpack_exports__, "VColorPickerCanvas", function() { return /* reexport */ VColorPicker_VColorPickerCanvas; });
__webpack_require__.d(__webpack_exports__, "VContent", function() { return /* reexport */ VContent; });
__webpack_require__.d(__webpack_exports__, "VCombobox", function() { return /* reexport */ VCombobox; });
__webpack_require__.d(__webpack_exports__, "VCounter", function() { return /* reexport */ VCounter["a" /* VCounter */]; });
__webpack_require__.d(__webpack_exports__, "VData", function() { return /* reexport */ VData; });
__webpack_require__.d(__webpack_exports__, "VDataIterator", function() { return /* reexport */ VDataIterator; });
__webpack_require__.d(__webpack_exports__, "VDataFooter", function() { return /* reexport */ VDataIterator_VDataFooter; });
__webpack_require__.d(__webpack_exports__, "VDataTable", function() { return /* reexport */ VDataTable_VDataTable; });
__webpack_require__.d(__webpack_exports__, "VEditDialog", function() { return /* reexport */ VDataTable_VEditDialog; });
__webpack_require__.d(__webpack_exports__, "VTableOverflow", function() { return /* reexport */ VTableOverflow; });
__webpack_require__.d(__webpack_exports__, "VDataTableHeader", function() { return /* reexport */ VDataTable_VDataTableHeader; });
__webpack_require__.d(__webpack_exports__, "VSimpleTable", function() { return /* reexport */ VDataTable_VSimpleTable; });
__webpack_require__.d(__webpack_exports__, "VVirtualTable", function() { return /* reexport */ VDataTable_VVirtualTable; });
__webpack_require__.d(__webpack_exports__, "VDatePicker", function() { return /* reexport */ VDatePicker["a" /* VDatePicker */]; });
__webpack_require__.d(__webpack_exports__, "VDatePickerTitle", function() { return /* reexport */ VDatePicker["e" /* VDatePickerTitle */]; });
__webpack_require__.d(__webpack_exports__, "VDatePickerHeader", function() { return /* reexport */ VDatePicker["c" /* VDatePickerHeader */]; });
__webpack_require__.d(__webpack_exports__, "VDatePickerDateTable", function() { return /* reexport */ VDatePicker["b" /* VDatePickerDateTable */]; });
__webpack_require__.d(__webpack_exports__, "VDatePickerMonthTable", function() { return /* reexport */ VDatePicker["d" /* VDatePickerMonthTable */]; });
__webpack_require__.d(__webpack_exports__, "VDatePickerYears", function() { return /* reexport */ VDatePicker["f" /* VDatePickerYears */]; });
__webpack_require__.d(__webpack_exports__, "VDialog", function() { return /* reexport */ components_VDialog["a" /* VDialog */]; });
__webpack_require__.d(__webpack_exports__, "VDivider", function() { return /* reexport */ VDivider["a" /* VDivider */]; });
__webpack_require__.d(__webpack_exports__, "VExpansionPanels", function() { return /* reexport */ VExpansionPanel["d" /* VExpansionPanels */]; });
__webpack_require__.d(__webpack_exports__, "VExpansionPanel", function() { return /* reexport */ VExpansionPanel["a" /* VExpansionPanel */]; });
__webpack_require__.d(__webpack_exports__, "VExpansionPanelHeader", function() { return /* reexport */ VExpansionPanel["c" /* VExpansionPanelHeader */]; });
__webpack_require__.d(__webpack_exports__, "VExpansionPanelContent", function() { return /* reexport */ VExpansionPanel["b" /* VExpansionPanelContent */]; });
__webpack_require__.d(__webpack_exports__, "VFileInput", function() { return /* reexport */ VFileInput_VFileInput; });
__webpack_require__.d(__webpack_exports__, "VFooter", function() { return /* reexport */ VFooter["a" /* VFooter */]; });
__webpack_require__.d(__webpack_exports__, "VForm", function() { return /* reexport */ VForm["a" /* VForm */]; });
__webpack_require__.d(__webpack_exports__, "VContainer", function() { return /* reexport */ VGrid["b" /* VContainer */]; });
__webpack_require__.d(__webpack_exports__, "VCol", function() { return /* reexport */ VGrid["a" /* VCol */]; });
__webpack_require__.d(__webpack_exports__, "VRow", function() { return /* reexport */ VGrid["e" /* VRow */]; });
__webpack_require__.d(__webpack_exports__, "VSpacer", function() { return /* reexport */ VGrid["f" /* VSpacer */]; });
__webpack_require__.d(__webpack_exports__, "VLayout", function() { return /* reexport */ VGrid["d" /* VLayout */]; });
__webpack_require__.d(__webpack_exports__, "VFlex", function() { return /* reexport */ VGrid["c" /* VFlex */]; });
__webpack_require__.d(__webpack_exports__, "VHover", function() { return /* reexport */ VHover; });
__webpack_require__.d(__webpack_exports__, "VIcon", function() { return /* reexport */ VIcon["a" /* VIcon */]; });
__webpack_require__.d(__webpack_exports__, "VImg", function() { return /* reexport */ VImg["a" /* VImg */]; });
__webpack_require__.d(__webpack_exports__, "VInput", function() { return /* reexport */ VInput["a" /* VInput */]; });
__webpack_require__.d(__webpack_exports__, "VItem", function() { return /* reexport */ VItem; });
__webpack_require__.d(__webpack_exports__, "VItemGroup", function() { return /* reexport */ VItemGroup["b" /* default */]; });
__webpack_require__.d(__webpack_exports__, "VLabel", function() { return /* reexport */ VLabel["a" /* VLabel */]; });
__webpack_require__.d(__webpack_exports__, "VLazy", function() { return /* reexport */ VLazy; });
__webpack_require__.d(__webpack_exports__, "VListItemActionText", function() { return /* reexport */ VList["e" /* VListItemActionText */]; });
__webpack_require__.d(__webpack_exports__, "VListItemContent", function() { return /* reexport */ VList["g" /* VListItemContent */]; });
__webpack_require__.d(__webpack_exports__, "VListItemTitle", function() { return /* reexport */ VList["k" /* VListItemTitle */]; });
__webpack_require__.d(__webpack_exports__, "VListItemSubtitle", function() { return /* reexport */ VList["j" /* VListItemSubtitle */]; });
__webpack_require__.d(__webpack_exports__, "VList", function() { return /* reexport */ VList["a" /* VList */]; });
__webpack_require__.d(__webpack_exports__, "VListGroup", function() { return /* reexport */ VList["b" /* VListGroup */]; });
__webpack_require__.d(__webpack_exports__, "VListItem", function() { return /* reexport */ VList["c" /* VListItem */]; });
__webpack_require__.d(__webpack_exports__, "VListItemAction", function() { return /* reexport */ VList["d" /* VListItemAction */]; });
__webpack_require__.d(__webpack_exports__, "VListItemAvatar", function() { return /* reexport */ VList["f" /* VListItemAvatar */]; });
__webpack_require__.d(__webpack_exports__, "VListItemIcon", function() { return /* reexport */ VList["i" /* VListItemIcon */]; });
__webpack_require__.d(__webpack_exports__, "VListItemGroup", function() { return /* reexport */ VList["h" /* VListItemGroup */]; });
__webpack_require__.d(__webpack_exports__, "VMain", function() { return /* reexport */ components_VMain["a" /* VMain */]; });
__webpack_require__.d(__webpack_exports__, "VMenu", function() { return /* reexport */ VMenu["a" /* VMenu */]; });
__webpack_require__.d(__webpack_exports__, "VMessages", function() { return /* reexport */ VMessages["a" /* VMessages */]; });
__webpack_require__.d(__webpack_exports__, "VNavigationDrawer", function() { return /* reexport */ VNavigationDrawer["a" /* VNavigationDrawer */]; });
__webpack_require__.d(__webpack_exports__, "VOtpInput", function() { return /* reexport */ VOtpInput_VOtpInput; });
__webpack_require__.d(__webpack_exports__, "VOverflowBtn", function() { return /* reexport */ VOverflowBtn_VOverflowBtn; });
__webpack_require__.d(__webpack_exports__, "VOverlay", function() { return /* reexport */ VOverlay["a" /* VOverlay */]; });
__webpack_require__.d(__webpack_exports__, "VPagination", function() { return /* reexport */ VPagination_VPagination; });
__webpack_require__.d(__webpack_exports__, "VSheet", function() { return /* reexport */ VSheet["a" /* VSheet */]; });
__webpack_require__.d(__webpack_exports__, "VParallax", function() { return /* reexport */ VParallax["a" /* VParallax */]; });
__webpack_require__.d(__webpack_exports__, "VPicker", function() { return /* reexport */ VPicker["a" /* VPicker */]; });
__webpack_require__.d(__webpack_exports__, "VProgressCircular", function() { return /* reexport */ VProgressCircular["a" /* VProgressCircular */]; });
__webpack_require__.d(__webpack_exports__, "VProgressLinear", function() { return /* reexport */ VProgressLinear["a" /* VProgressLinear */]; });
__webpack_require__.d(__webpack_exports__, "VRadioGroup", function() { return /* reexport */ VRadioGroup_VRadioGroup; });
__webpack_require__.d(__webpack_exports__, "VRadio", function() { return /* reexport */ VRadioGroup_VRadio; });
__webpack_require__.d(__webpack_exports__, "VRangeSlider", function() { return /* reexport */ VRangeSlider_VRangeSlider; });
__webpack_require__.d(__webpack_exports__, "VRating", function() { return /* reexport */ VRating_VRating; });
__webpack_require__.d(__webpack_exports__, "VResponsive", function() { return /* reexport */ VResponsive["a" /* VResponsive */]; });
__webpack_require__.d(__webpack_exports__, "VSelect", function() { return /* reexport */ components_VSelect["a" /* VSelect */]; });
__webpack_require__.d(__webpack_exports__, "VSkeletonLoader", function() { return /* reexport */ VSkeletonLoader_VSkeletonLoader; });
__webpack_require__.d(__webpack_exports__, "VSlider", function() { return /* reexport */ VSlider_VSlider; });
__webpack_require__.d(__webpack_exports__, "VSlideGroup", function() { return /* reexport */ VSlideGroup["b" /* default */]; });
__webpack_require__.d(__webpack_exports__, "VSlideItem", function() { return /* reexport */ VSlideItem; });
__webpack_require__.d(__webpack_exports__, "VSnackbar", function() { return /* reexport */ VSnackbar["a" /* VSnackbar */]; });
__webpack_require__.d(__webpack_exports__, "VSparkline", function() { return /* reexport */ VSparkline; });
__webpack_require__.d(__webpack_exports__, "VSpeedDial", function() { return /* reexport */ VSpeedDial_VSpeedDial; });
__webpack_require__.d(__webpack_exports__, "VStepper", function() { return /* reexport */ VStepper_VStepper; });
__webpack_require__.d(__webpack_exports__, "VStepperContent", function() { return /* reexport */ VStepperContent; });
__webpack_require__.d(__webpack_exports__, "VStepperStep", function() { return /* reexport */ VStepperStep; });
__webpack_require__.d(__webpack_exports__, "VStepperHeader", function() { return /* reexport */ VStepperHeader; });
__webpack_require__.d(__webpack_exports__, "VStepperItems", function() { return /* reexport */ VStepperItems; });
__webpack_require__.d(__webpack_exports__, "VSubheader", function() { return /* reexport */ VSubheader["a" /* VSubheader */]; });
__webpack_require__.d(__webpack_exports__, "VSwitch", function() { return /* reexport */ VSwitch_VSwitch; });
__webpack_require__.d(__webpack_exports__, "VSystemBar", function() { return /* reexport */ VSystemBar_VSystemBar; });
__webpack_require__.d(__webpack_exports__, "VTabs", function() { return /* reexport */ VTabs["c" /* VTabs */]; });
__webpack_require__.d(__webpack_exports__, "VTab", function() { return /* reexport */ VTabs["a" /* VTab */]; });
__webpack_require__.d(__webpack_exports__, "VTabItem", function() { return /* reexport */ VTabs["b" /* VTabItem */]; });
__webpack_require__.d(__webpack_exports__, "VTabsItems", function() { return /* reexport */ VTabs["d" /* VTabsItems */]; });
__webpack_require__.d(__webpack_exports__, "VTabsSlider", function() { return /* reexport */ VTabs["e" /* VTabsSlider */]; });
__webpack_require__.d(__webpack_exports__, "VTextarea", function() { return /* reexport */ VTextarea["a" /* VTextarea */]; });
__webpack_require__.d(__webpack_exports__, "VTextField", function() { return /* reexport */ components_VTextField["a" /* VTextField */]; });
__webpack_require__.d(__webpack_exports__, "VThemeProvider", function() { return /* reexport */ VThemeProvider["a" /* VThemeProvider */]; });
__webpack_require__.d(__webpack_exports__, "VTimeline", function() { return /* reexport */ VTimeline["a" /* VTimeline */]; });
__webpack_require__.d(__webpack_exports__, "VTimelineItem", function() { return /* reexport */ VTimeline["b" /* VTimelineItem */]; });
__webpack_require__.d(__webpack_exports__, "VTimePicker", function() { return /* reexport */ VTimePicker; });
__webpack_require__.d(__webpack_exports__, "VTimePickerClock", function() { return /* reexport */ VTimePicker_VTimePickerClock; });
__webpack_require__.d(__webpack_exports__, "VTimePickerTitle", function() { return /* reexport */ VTimePicker_VTimePickerTitle; });
__webpack_require__.d(__webpack_exports__, "VToolbar", function() { return /* reexport */ VToolbar["a" /* VToolbar */]; });
__webpack_require__.d(__webpack_exports__, "VToolbarItems", function() { return /* reexport */ VToolbar["b" /* VToolbarItems */]; });
__webpack_require__.d(__webpack_exports__, "VToolbarTitle", function() { return /* reexport */ VToolbar["c" /* VToolbarTitle */]; });
__webpack_require__.d(__webpack_exports__, "VTooltip", function() { return /* reexport */ VTooltip_VTooltip; });
__webpack_require__.d(__webpack_exports__, "VTreeview", function() { return /* reexport */ VTreeview_VTreeview; });
__webpack_require__.d(__webpack_exports__, "VTreeviewNode", function() { return /* reexport */ VTreeview_VTreeviewNode; });
__webpack_require__.d(__webpack_exports__, "VVirtualScroll", function() { return /* reexport */ VVirtualScroll_VVirtualScroll; });
__webpack_require__.d(__webpack_exports__, "VWindow", function() { return /* reexport */ VWindow["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "VWindowItem", function() { return /* reexport */ VWindowItem["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "VCarouselTransition", function() { return /* reexport */ transitions["b" /* VCarouselTransition */]; });
__webpack_require__.d(__webpack_exports__, "VCarouselReverseTransition", function() { return /* reexport */ transitions["a" /* VCarouselReverseTransition */]; });
__webpack_require__.d(__webpack_exports__, "VTabTransition", function() { return /* reexport */ transitions["u" /* VTabTransition */]; });
__webpack_require__.d(__webpack_exports__, "VTabReverseTransition", function() { return /* reexport */ transitions["t" /* VTabReverseTransition */]; });
__webpack_require__.d(__webpack_exports__, "VMenuTransition", function() { return /* reexport */ transitions["j" /* VMenuTransition */]; });
__webpack_require__.d(__webpack_exports__, "VFabTransition", function() { return /* reexport */ transitions["h" /* VFabTransition */]; });
__webpack_require__.d(__webpack_exports__, "VDialogTransition", function() { return /* reexport */ transitions["e" /* VDialogTransition */]; });
__webpack_require__.d(__webpack_exports__, "VDialogBottomTransition", function() { return /* reexport */ transitions["c" /* VDialogBottomTransition */]; });
__webpack_require__.d(__webpack_exports__, "VDialogTopTransition", function() { return /* reexport */ transitions["d" /* VDialogTopTransition */]; });
__webpack_require__.d(__webpack_exports__, "VFadeTransition", function() { return /* reexport */ transitions["i" /* VFadeTransition */]; });
__webpack_require__.d(__webpack_exports__, "VScaleTransition", function() { return /* reexport */ transitions["k" /* VScaleTransition */]; });
__webpack_require__.d(__webpack_exports__, "VScrollXTransition", function() { return /* reexport */ transitions["m" /* VScrollXTransition */]; });
__webpack_require__.d(__webpack_exports__, "VScrollXReverseTransition", function() { return /* reexport */ transitions["l" /* VScrollXReverseTransition */]; });
__webpack_require__.d(__webpack_exports__, "VScrollYTransition", function() { return /* reexport */ transitions["o" /* VScrollYTransition */]; });
__webpack_require__.d(__webpack_exports__, "VScrollYReverseTransition", function() { return /* reexport */ transitions["n" /* VScrollYReverseTransition */]; });
__webpack_require__.d(__webpack_exports__, "VSlideXTransition", function() { return /* reexport */ transitions["q" /* VSlideXTransition */]; });
__webpack_require__.d(__webpack_exports__, "VSlideXReverseTransition", function() { return /* reexport */ transitions["p" /* VSlideXReverseTransition */]; });
__webpack_require__.d(__webpack_exports__, "VSlideYTransition", function() { return /* reexport */ transitions["s" /* VSlideYTransition */]; });
__webpack_require__.d(__webpack_exports__, "VSlideYReverseTransition", function() { return /* reexport */ transitions["r" /* VSlideYReverseTransition */]; });
__webpack_require__.d(__webpack_exports__, "VExpandTransition", function() { return /* reexport */ transitions["f" /* VExpandTransition */]; });
__webpack_require__.d(__webpack_exports__, "VExpandXTransition", function() { return /* reexport */ transitions["g" /* VExpandXTransition */]; });
__webpack_require__.d(__webpack_exports__, "ClickOutside", function() { return /* reexport */ directives["a" /* ClickOutside */]; });
__webpack_require__.d(__webpack_exports__, "Intersect", function() { return /* reexport */ directives["b" /* Intersect */]; });
__webpack_require__.d(__webpack_exports__, "Mutate", function() { return /* reexport */ directives["c" /* Mutate */]; });
__webpack_require__.d(__webpack_exports__, "Resize", function() { return /* reexport */ directives["d" /* Resize */]; });
__webpack_require__.d(__webpack_exports__, "Ripple", function() { return /* reexport */ directives["e" /* Ripple */]; });
__webpack_require__.d(__webpack_exports__, "Scroll", function() { return /* reexport */ directives["f" /* Scroll */]; });
__webpack_require__.d(__webpack_exports__, "Touch", function() { return /* reexport */ directives["g" /* Touch */]; });
__webpack_require__.d(__webpack_exports__, "colors", function() { return /* reexport */ colors; });
__webpack_require__.d(__webpack_exports__, "default", function() { return /* reexport */ framework["a" /* default */]; });

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VApp/index.js
var VApp = __webpack_require__(124);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VAppBar/index.js + 1 modules
var VAppBar = __webpack_require__(69);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VAlert/VAlert.sass
var VAlert = __webpack_require__(432);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VSheet/index.js
var VSheet = __webpack_require__(36);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VBtn/index.js
var VBtn = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VIcon/index.js
var VIcon = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/toggleable/index.js
var toggleable = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/themeable/index.js
var themeable = __webpack_require__(4);

// EXTERNAL MODULE: external "vue"
var external_vue_ = __webpack_require__(1);
var external_vue_default = /*#__PURE__*/__webpack_require__.n(external_vue_);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/mixins/transitionable/index.js

/* harmony default export */ var transitionable = (external_vue_default.a.extend({
  name: 'transitionable',
  props: {
    mode: String,
    origin: String,
    transition: String
  }
}));
// EXTERNAL MODULE: ./node_modules/vuetify/lib/util/mixins.js
var mixins = __webpack_require__(2);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/util/console.js
var console = __webpack_require__(3);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VAlert/VAlert.js
// Styles
 // Extensions

 // Components


 // Mixins



 // Utilities



/* @vue/component */

/* harmony default export */ var VAlert_VAlert = (Object(mixins["a" /* default */])(VSheet["b" /* default */], toggleable["a" /* default */], transitionable).extend({
  name: 'v-alert',
  props: {
    border: {
      type: String,

      validator(val) {
        return ['top', 'right', 'bottom', 'left'].includes(val);
      }

    },
    closeLabel: {
      type: String,
      default: '$vuetify.close'
    },
    coloredBorder: Boolean,
    dense: Boolean,
    dismissible: Boolean,
    closeIcon: {
      type: String,
      default: '$cancel'
    },
    icon: {
      default: '',
      type: [Boolean, String],

      validator(val) {
        return typeof val === 'string' || val === false;
      }

    },
    outlined: Boolean,
    prominent: Boolean,
    text: Boolean,
    type: {
      type: String,

      validator(val) {
        return ['info', 'error', 'success', 'warning'].includes(val);
      }

    },
    value: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    __cachedBorder() {
      if (!this.border) return null;
      let data = {
        staticClass: 'v-alert__border',
        class: {
          [`v-alert__border--${this.border}`]: true
        }
      };

      if (this.coloredBorder) {
        data = this.setBackgroundColor(this.computedColor, data);
        data.class['v-alert__border--has-color'] = true;
      }

      return this.$createElement('div', data);
    },

    __cachedDismissible() {
      if (!this.dismissible) return null;
      const color = this.iconColor;
      return this.$createElement(VBtn["b" /* default */], {
        staticClass: 'v-alert__dismissible',
        props: {
          color,
          icon: true,
          small: true
        },
        attrs: {
          'aria-label': this.$vuetify.lang.t(this.closeLabel)
        },
        on: {
          click: () => this.isActive = false
        }
      }, [this.$createElement(VIcon["b" /* default */], {
        props: {
          color
        }
      }, this.closeIcon)]);
    },

    __cachedIcon() {
      if (!this.computedIcon) return null;
      return this.$createElement(VIcon["b" /* default */], {
        staticClass: 'v-alert__icon',
        props: {
          color: this.iconColor
        }
      }, this.computedIcon);
    },

    classes() {
      const classes = { ...VSheet["b" /* default */].options.computed.classes.call(this),
        'v-alert--border': Boolean(this.border),
        'v-alert--dense': this.dense,
        'v-alert--outlined': this.outlined,
        'v-alert--prominent': this.prominent,
        'v-alert--text': this.text
      };

      if (this.border) {
        classes[`v-alert--border-${this.border}`] = true;
      }

      return classes;
    },

    computedColor() {
      return this.color || this.type;
    },

    computedIcon() {
      if (this.icon === false) return false;
      if (typeof this.icon === 'string' && this.icon) return this.icon;
      if (!['error', 'info', 'success', 'warning'].includes(this.type)) return false;
      return `$${this.type}`;
    },

    hasColoredIcon() {
      return this.hasText || Boolean(this.border) && this.coloredBorder;
    },

    hasText() {
      return this.text || this.outlined;
    },

    iconColor() {
      return this.hasColoredIcon ? this.computedColor : undefined;
    },

    isDark() {
      if (this.type && !this.coloredBorder && !this.outlined) return true;
      return themeable["a" /* default */].options.computed.isDark.call(this);
    }

  },

  created() {
    /* istanbul ignore next */
    if (this.$attrs.hasOwnProperty('outline')) {
      Object(console["a" /* breaking */])('outline', 'outlined', this);
    }
  },

  methods: {
    genWrapper() {
      const children = [this.$slots.prepend || this.__cachedIcon, this.genContent(), this.__cachedBorder, this.$slots.append, this.$scopedSlots.close ? this.$scopedSlots.close({
        toggle: this.toggle
      }) : this.__cachedDismissible];
      const data = {
        staticClass: 'v-alert__wrapper'
      };
      return this.$createElement('div', data, children);
    },

    genContent() {
      return this.$createElement('div', {
        staticClass: 'v-alert__content'
      }, this.$slots.default);
    },

    genAlert() {
      let data = {
        staticClass: 'v-alert',
        attrs: {
          role: 'alert'
        },
        on: this.listeners$,
        class: this.classes,
        style: this.styles,
        directives: [{
          name: 'show',
          value: this.isActive
        }]
      };

      if (!this.coloredBorder) {
        const setColor = this.hasText ? this.setTextColor : this.setBackgroundColor;
        data = setColor(this.computedColor, data);
      }

      return this.$createElement('div', data, [this.genWrapper()]);
    },

    /** @public */
    toggle() {
      this.isActive = !this.isActive;
    }

  },

  render(h) {
    const render = this.genAlert();
    if (!this.transition) return render;
    return h('transition', {
      props: {
        name: this.transition,
        origin: this.origin,
        mode: this.mode
      }
    }, [render]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VAlert/index.js


/* harmony default export */ var components_VAlert = (VAlert_VAlert);
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VAutocomplete/VAutocomplete.sass
var VAutocomplete = __webpack_require__(396);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VSelect/VSelect.js + 2 modules
var VSelect = __webpack_require__(266);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VTextField/VTextField.js
var VTextField = __webpack_require__(201);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/util/mergeData.js
var mergeData = __webpack_require__(28);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/util/helpers.js
var helpers = __webpack_require__(0);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VAutocomplete/VAutocomplete.js
// Styles
 // Extensions


 // Utilities



const defaultMenuProps = { ...VSelect["b" /* defaultMenuProps */],
  offsetY: true,
  offsetOverflow: true,
  transition: false
};
/* @vue/component */

/* harmony default export */ var VAutocomplete_VAutocomplete = (VSelect["a" /* default */].extend({
  name: 'v-autocomplete',
  props: {
    allowOverflow: {
      type: Boolean,
      default: true
    },
    autoSelectFirst: {
      type: Boolean,
      default: false
    },
    filter: {
      type: Function,
      default: (item, queryText, itemText) => {
        return itemText.toLocaleLowerCase().indexOf(queryText.toLocaleLowerCase()) > -1;
      }
    },
    hideNoData: Boolean,
    menuProps: {
      type: VSelect["a" /* default */].options.props.menuProps.type,
      default: () => defaultMenuProps
    },
    noFilter: Boolean,
    searchInput: {
      type: String
    }
  },

  data() {
    return {
      lazySearch: this.searchInput
    };
  },

  computed: {
    classes() {
      return { ...VSelect["a" /* default */].options.computed.classes.call(this),
        'v-autocomplete': true,
        'v-autocomplete--is-selecting-index': this.selectedIndex > -1
      };
    },

    computedItems() {
      return this.filteredItems;
    },

    selectedValues() {
      return this.selectedItems.map(item => this.getValue(item));
    },

    hasDisplayedItems() {
      return this.hideSelected ? this.filteredItems.some(item => !this.hasItem(item)) : this.filteredItems.length > 0;
    },

    currentRange() {
      if (this.selectedItem == null) return 0;
      return String(this.getText(this.selectedItem)).length;
    },

    filteredItems() {
      if (!this.isSearching || this.noFilter || this.internalSearch == null) return this.allItems;
      return this.allItems.filter(item => {
        const value = Object(helpers["u" /* getPropertyFromItem */])(item, this.itemText);
        const text = value != null ? String(value) : '';
        return this.filter(item, String(this.internalSearch), text);
      });
    },

    internalSearch: {
      get() {
        return this.lazySearch;
      },

      set(val) {
        // emit update event only when the new
        // search value is different from previous
        if (this.lazySearch !== val) {
          this.lazySearch = val;
          this.$emit('update:search-input', val);
        }
      }

    },

    isAnyValueAllowed() {
      return false;
    },

    isDirty() {
      return this.searchIsDirty || this.selectedItems.length > 0;
    },

    isSearching() {
      return this.multiple && this.searchIsDirty || this.searchIsDirty && this.internalSearch !== this.getText(this.selectedItem);
    },

    menuCanShow() {
      if (!this.isFocused) return false;
      return this.hasDisplayedItems || !this.hideNoData;
    },

    $_menuProps() {
      const props = VSelect["a" /* default */].options.computed.$_menuProps.call(this);
      props.contentClass = `v-autocomplete__content ${props.contentClass || ''}`.trim();
      return { ...defaultMenuProps,
        ...props
      };
    },

    searchIsDirty() {
      return this.internalSearch != null && this.internalSearch !== '';
    },

    selectedItem() {
      if (this.multiple) return null;
      return this.selectedItems.find(i => {
        return this.valueComparator(this.getValue(i), this.getValue(this.internalValue));
      });
    },

    listData() {
      const data = VSelect["a" /* default */].options.computed.listData.call(this);
      data.props = { ...data.props,
        items: this.virtualizedItems,
        noFilter: this.noFilter || !this.isSearching || !this.filteredItems.length,
        searchInput: this.internalSearch
      };
      return data;
    }

  },
  watch: {
    filteredItems: 'onFilteredItemsChanged',
    internalValue: 'setSearch',

    isFocused(val) {
      if (val) {
        document.addEventListener('copy', this.onCopy);
        this.$refs.input && this.$refs.input.select();
      } else {
        document.removeEventListener('copy', this.onCopy);
        this.blur();
        this.updateSelf();
      }
    },

    isMenuActive(val) {
      if (val || !this.hasSlot) return;
      this.lazySearch = null;
    },

    items(val, oldVal) {
      // If we are focused, the menu
      // is not active, hide no data is enabled,
      // and items change
      // User is probably async loading
      // items, try to activate the menu
      if (!(oldVal && oldVal.length) && this.hideNoData && this.isFocused && !this.isMenuActive && val.length) this.activateMenu();
    },

    searchInput(val) {
      this.lazySearch = val;
    },

    internalSearch: 'onInternalSearchChanged',
    itemText: 'updateSelf'
  },

  created() {
    this.setSearch();
  },

  destroyed() {
    document.removeEventListener('copy', this.onCopy);
  },

  methods: {
    onFilteredItemsChanged(val, oldVal) {
      // TODO: How is the watcher triggered
      // for duplicate items? no idea
      if (val === oldVal) return;

      if (!this.autoSelectFirst) {
        const preSelectedItem = oldVal[this.$refs.menu.listIndex];

        if (preSelectedItem) {
          this.setMenuIndex(val.findIndex(i => i === preSelectedItem));
        } else {
          this.setMenuIndex(-1);
        }

        this.$emit('update:list-index', this.$refs.menu.listIndex);
      }

      this.$nextTick(() => {
        if (!this.internalSearch || val.length !== 1 && !this.autoSelectFirst) return;
        this.$refs.menu.getTiles();

        if (this.autoSelectFirst && val.length) {
          this.setMenuIndex(0);
          this.$emit('update:list-index', this.$refs.menu.listIndex);
        }
      });
    },

    onInternalSearchChanged() {
      this.updateMenuDimensions();
    },

    updateMenuDimensions() {
      // Type from menuable is not making it through
      this.isMenuActive && this.$refs.menu && this.$refs.menu.updateDimensions();
    },

    changeSelectedIndex(keyCode) {
      // Do not allow changing of selectedIndex
      // when search is dirty
      if (this.searchIsDirty) return;

      if (this.multiple && keyCode === helpers["B" /* keyCodes */].left) {
        if (this.selectedIndex === -1) {
          this.selectedIndex = this.selectedItems.length - 1;
        } else {
          this.selectedIndex--;
        }
      } else if (this.multiple && keyCode === helpers["B" /* keyCodes */].right) {
        if (this.selectedIndex >= this.selectedItems.length - 1) {
          this.selectedIndex = -1;
        } else {
          this.selectedIndex++;
        }
      } else if (keyCode === helpers["B" /* keyCodes */].backspace || keyCode === helpers["B" /* keyCodes */].delete) {
        this.deleteCurrentItem();
      }
    },

    deleteCurrentItem() {
      const curIndex = this.selectedIndex;
      const curItem = this.selectedItems[curIndex]; // Do nothing if input or item is disabled

      if (!this.isInteractive || this.getDisabled(curItem)) return;
      const lastIndex = this.selectedItems.length - 1; // Select the last item if
      // there is no selection

      if (this.selectedIndex === -1 && lastIndex !== 0) {
        this.selectedIndex = lastIndex;
        return;
      }

      const length = this.selectedItems.length;
      const nextIndex = curIndex !== length - 1 ? curIndex : curIndex - 1;
      const nextItem = this.selectedItems[nextIndex];

      if (!nextItem) {
        this.setValue(this.multiple ? [] : null);
      } else {
        this.selectItem(curItem);
      }

      this.selectedIndex = nextIndex;
    },

    clearableCallback() {
      this.internalSearch = null;
      VSelect["a" /* default */].options.methods.clearableCallback.call(this);
    },

    genInput() {
      const input = VTextField["a" /* default */].options.methods.genInput.call(this);
      input.data = Object(mergeData["a" /* default */])(input.data, {
        attrs: {
          'aria-activedescendant': Object(helpers["s" /* getObjectValueByPath */])(this.$refs.menu, 'activeTile.id'),
          autocomplete: Object(helpers["s" /* getObjectValueByPath */])(input.data, 'attrs.autocomplete', 'off')
        },
        domProps: {
          value: this.internalSearch
        }
      });
      return input;
    },

    genInputSlot() {
      const slot = VSelect["a" /* default */].options.methods.genInputSlot.call(this);
      slot.data.attrs.role = 'combobox';
      return slot;
    },

    genSelections() {
      return this.hasSlot || this.multiple ? VSelect["a" /* default */].options.methods.genSelections.call(this) : [];
    },

    onClick(e) {
      if (!this.isInteractive) return;
      this.selectedIndex > -1 ? this.selectedIndex = -1 : this.onFocus();
      if (!this.isAppendInner(e.target)) this.activateMenu();
    },

    onInput(e) {
      if (this.selectedIndex > -1 || !e.target) return;
      const target = e.target;
      const value = target.value; // If typing and menu is not currently active

      if (target.value) this.activateMenu();
      if (!this.multiple && value === '') this.deleteCurrentItem();
      this.internalSearch = value;
      this.badInput = target.validity && target.validity.badInput;
    },

    onKeyDown(e) {
      const keyCode = e.keyCode;

      if (e.ctrlKey || ![helpers["B" /* keyCodes */].home, helpers["B" /* keyCodes */].end].includes(keyCode)) {
        VSelect["a" /* default */].options.methods.onKeyDown.call(this, e);
      } // The ordering is important here
      // allows new value to be updated
      // and then moves the index to the
      // proper location


      this.changeSelectedIndex(keyCode);
    },

    onSpaceDown(e) {},

    onTabDown(e) {
      VSelect["a" /* default */].options.methods.onTabDown.call(this, e);
      this.updateSelf();
    },

    onUpDown(e) {
      // Prevent screen from scrolling
      e.preventDefault(); // For autocomplete / combobox, cycling
      // interfers with native up/down behavior
      // instead activate the menu

      this.activateMenu();
    },

    selectItem(item) {
      VSelect["a" /* default */].options.methods.selectItem.call(this, item);
      this.setSearch();
    },

    setSelectedItems() {
      VSelect["a" /* default */].options.methods.setSelectedItems.call(this); // #4273 Don't replace if searching
      // #4403 Don't replace if focused

      if (!this.isFocused) this.setSearch();
    },

    setSearch() {
      // Wait for nextTick so selectedItem
      // has had time to update
      this.$nextTick(() => {
        if (!this.multiple || !this.internalSearch || !this.isMenuActive) {
          this.internalSearch = !this.selectedItems.length || this.multiple || this.hasSlot ? null : this.getText(this.selectedItem);
        }
      });
    },

    updateSelf() {
      if (!this.searchIsDirty && !this.internalValue) return;

      if (!this.multiple && !this.valueComparator(this.internalSearch, this.getValue(this.internalValue))) {
        this.setSearch();
      }
    },

    hasItem(item) {
      return this.selectedValues.indexOf(this.getValue(item)) > -1;
    },

    onCopy(event) {
      var _event$clipboardData, _event$clipboardData2;

      if (this.selectedIndex === -1) return;
      const currentItem = this.selectedItems[this.selectedIndex];
      const currentItemText = this.getText(currentItem);
      (_event$clipboardData = event.clipboardData) == null ? void 0 : _event$clipboardData.setData('text/plain', currentItemText);
      (_event$clipboardData2 = event.clipboardData) == null ? void 0 : _event$clipboardData2.setData('text/vnd.vuetify.autocomplete.item+plain', currentItemText);
      event.preventDefault();
    }

  }
}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VAutocomplete/index.js


/* harmony default export */ var components_VAutocomplete = (VAutocomplete_VAutocomplete);
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VAvatar/index.js
var VAvatar = __webpack_require__(30);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VBadge/VBadge.sass
var VBadge = __webpack_require__(433);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VIcon/VIcon.js
var VIcon_VIcon = __webpack_require__(72);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/colorable/index.js
var colorable = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/positionable/index.js
var positionable = __webpack_require__(21);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VBadge/VBadge.js
// Styles
 // Components

 // Mixins





 // Utilities



/* harmony default export */ var VBadge_VBadge = (Object(mixins["a" /* default */])(colorable["a" /* default */], Object(positionable["b" /* factory */])(['left', 'bottom']), themeable["a" /* default */], toggleable["a" /* default */], transitionable).extend({
  name: 'v-badge',
  props: {
    avatar: Boolean,
    bordered: Boolean,
    color: {
      type: String,
      default: 'primary'
    },
    content: {
      required: false
    },
    dot: Boolean,
    label: {
      type: String,
      default: '$vuetify.badge'
    },
    icon: String,
    inline: Boolean,
    offsetX: [Number, String],
    offsetY: [Number, String],
    overlap: Boolean,
    tile: Boolean,
    transition: {
      type: String,
      default: 'scale-rotate-transition'
    },
    value: {
      default: true
    }
  },
  computed: {
    classes() {
      return {
        'v-badge--avatar': this.avatar,
        'v-badge--bordered': this.bordered,
        'v-badge--bottom': this.bottom,
        'v-badge--dot': this.dot,
        'v-badge--icon': this.icon != null,
        'v-badge--inline': this.inline,
        'v-badge--left': this.left,
        'v-badge--overlap': this.overlap,
        'v-badge--tile': this.tile,
        ...this.themeClasses
      };
    },

    computedBottom() {
      return this.bottom ? 'auto' : this.computedYOffset;
    },

    computedLeft() {
      if (this.isRtl) {
        return this.left ? this.computedXOffset : 'auto';
      }

      return this.left ? 'auto' : this.computedXOffset;
    },

    computedRight() {
      if (this.isRtl) {
        return this.left ? 'auto' : this.computedXOffset;
      }

      return !this.left ? 'auto' : this.computedXOffset;
    },

    computedTop() {
      return this.bottom ? this.computedYOffset : 'auto';
    },

    computedXOffset() {
      return this.calcPosition(this.offsetX);
    },

    computedYOffset() {
      return this.calcPosition(this.offsetY);
    },

    isRtl() {
      return this.$vuetify.rtl;
    },

    // Default fallback if offsetX
    // or offsetY are undefined.
    offset() {
      if (this.overlap) return this.dot ? 8 : 12;
      return this.dot ? 2 : 4;
    },

    styles() {
      if (this.inline) return {};
      return {
        bottom: this.computedBottom,
        left: this.computedLeft,
        right: this.computedRight,
        top: this.computedTop
      };
    }

  },
  methods: {
    calcPosition(offset) {
      return `calc(100% - ${Object(helpers["i" /* convertToUnit */])(offset || this.offset)})`;
    },

    genBadge() {
      const lang = this.$vuetify.lang;
      const label = this.$attrs['aria-label'] || lang.t(this.label);
      const data = this.setBackgroundColor(this.color, {
        staticClass: 'v-badge__badge',
        style: this.styles,
        attrs: {
          'aria-atomic': this.$attrs['aria-atomic'] || 'true',
          'aria-label': label,
          'aria-live': this.$attrs['aria-live'] || 'polite',
          title: this.$attrs.title,
          role: this.$attrs.role || 'status'
        },
        directives: [{
          name: 'show',
          value: this.isActive
        }]
      });
      const badge = this.$createElement('span', data, [this.genBadgeContent()]);
      if (!this.transition) return badge;
      return this.$createElement('transition', {
        props: {
          name: this.transition,
          origin: this.origin,
          mode: this.mode
        }
      }, [badge]);
    },

    genBadgeContent() {
      // Dot prop shows no content
      if (this.dot) return undefined;
      const slot = Object(helpers["v" /* getSlot */])(this, 'badge');
      if (slot) return slot;
      if (this.content) return String(this.content);
      if (this.icon) return this.$createElement(VIcon_VIcon["a" /* default */], this.icon);
      return undefined;
    },

    genBadgeWrapper() {
      return this.$createElement('span', {
        staticClass: 'v-badge__wrapper'
      }, [this.genBadge()]);
    }

  },

  render(h) {
    const badge = [this.genBadgeWrapper()];
    const children = [Object(helpers["v" /* getSlot */])(this)];
    const {
      'aria-atomic': _x,
      'aria-label': _y,
      'aria-live': _z,
      role,
      title,
      ...attrs
    } = this.$attrs;
    if (this.inline && this.left) children.unshift(badge);else children.push(badge);
    return h('span', {
      staticClass: 'v-badge',
      attrs,
      class: this.classes
    }, children);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VBadge/index.js


/* harmony default export */ var components_VBadge = (VBadge_VBadge);
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VBanner/VBanner.sass
var VBanner = __webpack_require__(434);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/transitions/index.js + 2 modules
var transitions = __webpack_require__(29);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/mobile/index.js
var mobile = __webpack_require__(49);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VBanner/VBanner.js
// Styles
 // Extensions

 // Components



 // Mixins


 // Utilities



/* @vue/component */

/* harmony default export */ var VBanner_VBanner = (Object(mixins["a" /* default */])(VSheet["b" /* default */], mobile["a" /* default */], toggleable["a" /* default */]).extend({
  name: 'v-banner',
  inheritAttrs: false,
  props: {
    app: Boolean,
    icon: String,
    iconColor: String,
    singleLine: Boolean,
    sticky: Boolean,
    value: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    classes() {
      return { ...VSheet["b" /* default */].options.computed.classes.call(this),
        'v-banner--has-icon': this.hasIcon,
        'v-banner--is-mobile': this.isMobile,
        'v-banner--single-line': this.singleLine,
        'v-banner--sticky': this.isSticky
      };
    },

    hasIcon() {
      return Boolean(this.icon || this.$slots.icon);
    },

    isSticky() {
      return this.sticky || this.app;
    },

    styles() {
      const styles = { ...VSheet["b" /* default */].options.computed.styles.call(this)
      };

      if (this.isSticky) {
        const top = !this.app ? 0 : this.$vuetify.application.bar + this.$vuetify.application.top;
        styles.top = Object(helpers["i" /* convertToUnit */])(top);
        styles.position = 'sticky';
        styles.zIndex = 1;
      }

      return styles;
    }

  },
  methods: {
    /** @public */
    toggle() {
      this.isActive = !this.isActive;
    },

    iconClick(e) {
      this.$emit('click:icon', e);
    },

    genIcon() {
      if (!this.hasIcon) return undefined;
      let content;

      if (this.icon) {
        content = this.$createElement(VIcon["b" /* default */], {
          props: {
            color: this.iconColor,
            size: 28
          }
        }, [this.icon]);
      } else {
        content = this.$slots.icon;
      }

      return this.$createElement(VAvatar["b" /* default */], {
        staticClass: 'v-banner__icon',
        props: {
          color: this.color,
          size: 40
        },
        on: {
          click: this.iconClick
        }
      }, [content]);
    },

    genText() {
      return this.$createElement('div', {
        staticClass: 'v-banner__text'
      }, this.$slots.default);
    },

    genActions() {
      const children = Object(helpers["v" /* getSlot */])(this, 'actions', {
        dismiss: () => this.isActive = false
      });
      if (!children) return undefined;
      return this.$createElement('div', {
        staticClass: 'v-banner__actions'
      }, children);
    },

    genContent() {
      return this.$createElement('div', {
        staticClass: 'v-banner__content'
      }, [this.genIcon(), this.genText()]);
    },

    genWrapper() {
      return this.$createElement('div', {
        staticClass: 'v-banner__wrapper'
      }, [this.genContent(), this.genActions()]);
    }

  },

  render(h) {
    const data = {
      staticClass: 'v-banner',
      attrs: this.attrs$,
      class: this.classes,
      style: this.styles,
      directives: [{
        name: 'show',
        value: this.isActive
      }]
    };
    return h(transitions["f" /* VExpandTransition */], [h('div', this.outlined ? data : this.setBackgroundColor(this.color, data), [this.genWrapper()])]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VBanner/index.js


/* harmony default export */ var components_VBanner = (VBanner_VBanner);
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VBottomNavigation/index.js
var VBottomNavigation = __webpack_require__(388);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VBottomSheet/VBottomSheet.sass
var VBottomSheet = __webpack_require__(435);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VDialog/VDialog.js
var VDialog = __webpack_require__(281);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VBottomSheet/VBottomSheet.js
 // Extensions


/* @vue/component */

/* harmony default export */ var VBottomSheet_VBottomSheet = (VDialog["a" /* default */].extend({
  name: 'v-bottom-sheet',
  props: {
    inset: Boolean,
    maxWidth: [String, Number],
    transition: {
      type: String,
      default: 'bottom-sheet-transition'
    }
  },
  computed: {
    classes() {
      return { ...VDialog["a" /* default */].options.computed.classes.call(this),
        'v-bottom-sheet': true,
        'v-bottom-sheet--inset': this.inset
      };
    }

  }
}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VBottomSheet/index.js


/* harmony default export */ var components_VBottomSheet = (VBottomSheet_VBottomSheet);
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VBreadcrumbs/VBreadcrumbs.sass
var VBreadcrumbs = __webpack_require__(436);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/routable/index.js
var routable = __webpack_require__(15);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbsItem.js


/* @vue/component */

/* harmony default export */ var VBreadcrumbsItem = (Object(mixins["a" /* default */])(routable["a" /* default */]).extend({
  name: 'v-breadcrumbs-item',
  props: {
    // In a breadcrumb, the currently
    // active item should be dimmed
    activeClass: {
      type: String,
      default: 'v-breadcrumbs__item--disabled'
    },
    ripple: {
      type: [Boolean, Object],
      default: false
    }
  },
  computed: {
    classes() {
      return {
        'v-breadcrumbs__item': true,
        [this.activeClass]: this.disabled
      };
    }

  },

  render(h) {
    const {
      tag,
      data
    } = this.generateRouteLink();
    return h('li', [h(tag, { ...data,
      attrs: { ...data.attrs,
        'aria-current': this.isActive && this.isLink ? 'page' : undefined
      }
    }, this.$slots.default)]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbsDivider.js

/* harmony default export */ var VBreadcrumbsDivider = (Object(helpers["k" /* createSimpleFunctional */])('v-breadcrumbs__divider', 'li'));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbs.js
// Styles
 // Components


 // Mixins

 // Utils


/* harmony default export */ var VBreadcrumbs_VBreadcrumbs = (Object(mixins["a" /* default */])(themeable["a" /* default */]
/* @vue/component */
).extend({
  name: 'v-breadcrumbs',
  props: {
    divider: {
      type: String,
      default: '/'
    },
    items: {
      type: Array,
      default: () => []
    },
    large: Boolean
  },
  computed: {
    classes() {
      return {
        'v-breadcrumbs--large': this.large,
        ...this.themeClasses
      };
    }

  },
  methods: {
    genDivider() {
      return this.$createElement(VBreadcrumbsDivider, this.$slots.divider ? this.$slots.divider : this.divider);
    },

    genItems() {
      const items = [];
      const hasSlot = !!this.$scopedSlots.item;
      const keys = [];

      for (let i = 0; i < this.items.length; i++) {
        const item = this.items[i];
        keys.push(item.text);
        if (hasSlot) items.push(this.$scopedSlots.item({
          item
        }));else items.push(this.$createElement(VBreadcrumbsItem, {
          key: keys.join('.'),
          props: item
        }, [item.text]));
        if (i < this.items.length - 1) items.push(this.genDivider());
      }

      return items;
    }

  },

  render(h) {
    const children = this.$slots.default || this.genItems();
    return h('ul', {
      staticClass: 'v-breadcrumbs',
      class: this.classes
    }, children);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VBreadcrumbs/index.js




/* harmony default export */ var components_VBreadcrumbs = ({
  $_vuetify_subcomponents: {
    VBreadcrumbs: VBreadcrumbs_VBreadcrumbs,
    VBreadcrumbsItem: VBreadcrumbsItem,
    VBreadcrumbsDivider: VBreadcrumbsDivider
  }
});
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VBtnToggle/VBtnToggle.sass
var VBtnToggle = __webpack_require__(437);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/button-group/index.js
var button_group = __webpack_require__(270);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VBtnToggle/VBtnToggle.js
// Styles
 // Mixins


 // Utilities


/* @vue/component */

/* harmony default export */ var VBtnToggle_VBtnToggle = (Object(mixins["a" /* default */])(button_group["a" /* default */], colorable["a" /* default */]).extend({
  name: 'v-btn-toggle',
  props: {
    backgroundColor: String,
    borderless: Boolean,
    dense: Boolean,
    group: Boolean,
    rounded: Boolean,
    shaped: Boolean,
    tile: Boolean
  },
  computed: {
    classes() {
      return { ...button_group["a" /* default */].options.computed.classes.call(this),
        'v-btn-toggle': true,
        'v-btn-toggle--borderless': this.borderless,
        'v-btn-toggle--dense': this.dense,
        'v-btn-toggle--group': this.group,
        'v-btn-toggle--rounded': this.rounded,
        'v-btn-toggle--shaped': this.shaped,
        'v-btn-toggle--tile': this.tile,
        ...this.themeClasses
      };
    }

  },
  methods: {
    genData() {
      const data = this.setTextColor(this.color, { ...button_group["a" /* default */].options.methods.genData.call(this)
      });
      if (this.group) return data;
      return this.setBackgroundColor(this.backgroundColor, data);
    }

  }
}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VBtnToggle/index.js


/* harmony default export */ var components_VBtnToggle = (VBtnToggle_VBtnToggle);
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VCalendar/mixins/calendar-with-events.sass
var calendar_with_events = __webpack_require__(438);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/directives/ripple/index.js
var ripple = __webpack_require__(25);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/localable/index.js
var localable = __webpack_require__(275);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/mixins/mouse.js

/* harmony default export */ var mouse = (external_vue_default.a.extend({
  name: 'mouse',
  methods: {
    getDefaultMouseEventHandlers(suffix, getEvent) {
      return this.getMouseEventHandlers({
        ['click' + suffix]: {
          event: 'click'
        },
        ['contextmenu' + suffix]: {
          event: 'contextmenu',
          prevent: true,
          result: false
        },
        ['mousedown' + suffix]: {
          event: 'mousedown'
        },
        ['mousemove' + suffix]: {
          event: 'mousemove'
        },
        ['mouseup' + suffix]: {
          event: 'mouseup'
        },
        ['mouseenter' + suffix]: {
          event: 'mouseenter'
        },
        ['mouseleave' + suffix]: {
          event: 'mouseleave'
        },
        ['touchstart' + suffix]: {
          event: 'touchstart'
        },
        ['touchmove' + suffix]: {
          event: 'touchmove'
        },
        ['touchend' + suffix]: {
          event: 'touchend'
        }
      }, getEvent);
    },

    getMouseEventHandlers(events, getEvent) {
      const on = {};

      for (const event in events) {
        const eventOptions = events[event];
        if (!this.$listeners[event]) continue; // TODO somehow pull in modifiers

        const prefix = eventOptions.passive ? '&' : (eventOptions.once ? '~' : '') + (eventOptions.capture ? '!' : '');
        const key = prefix + eventOptions.event;

        const handler = e => {
          const mouseEvent = e;

          if (eventOptions.button === undefined || mouseEvent.buttons > 0 && mouseEvent.button === eventOptions.button) {
            if (eventOptions.prevent) {
              e.preventDefault();
            }

            if (eventOptions.stop) {
              e.stopPropagation();
            } // Due to TouchEvent target always returns the element that is first placed
            // Even if touch point has since moved outside the interactive area of that element
            // Ref: https://developer.mozilla.org/en-US/docs/Web/API/Touch/target
            // This block of code aims to make sure touchEvent is always dispatched from the element that is being pointed at


            if (e && 'touches' in e) {
              var _e$currentTarget, _e$target;

              const classSeparator = ' ';
              const eventTargetClasses = (_e$currentTarget = e.currentTarget) == null ? void 0 : _e$currentTarget.className.split(classSeparator);
              const currentTargets = document.elementsFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY); // Get "the same kind" current hovering target by checking
              // If element has the same class of initial touch start element (which has touch event listener registered)

              const currentTarget = currentTargets.find(t => t.className.split(classSeparator).some(c => eventTargetClasses.includes(c)));

              if (currentTarget && !((_e$target = e.target) != null && _e$target.isSameNode(currentTarget))) {
                currentTarget.dispatchEvent(new TouchEvent(e.type, {
                  changedTouches: e.changedTouches,
                  targetTouches: e.targetTouches,
                  touches: e.touches
                }));
                return;
              }
            }

            this.$emit(event, getEvent(e), e);
          }

          return eventOptions.result;
        };

        if (key in on) {
          /* istanbul ignore next */
          if (Array.isArray(on[key])) {
            on[key].push(handler);
          } else {
            on[key] = [on[key], handler];
          }
        } else {
          on[key] = handler;
        }
      }

      return on;
    }

  }
}));
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VCalendar/util/timestamp.js
var util_timestamp = __webpack_require__(263);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/mixins/times.js


/* harmony default export */ var mixins_times = (external_vue_default.a.extend({
  name: 'times',
  props: {
    now: {
      type: String,
      validator: util_timestamp["F" /* validateTimestamp */]
    }
  },
  data: () => ({
    times: {
      now: Object(util_timestamp["v" /* parseTimestamp */])('0000-00-00 00:00', true),
      today: Object(util_timestamp["v" /* parseTimestamp */])('0000-00-00', true)
    }
  }),
  computed: {
    parsedNow() {
      return this.now ? Object(util_timestamp["v" /* parseTimestamp */])(this.now, true) : null;
    }

  },
  watch: {
    parsedNow: 'updateTimes'
  },

  created() {
    this.updateTimes();
    this.setPresent();
  },

  methods: {
    setPresent() {
      this.times.now.present = this.times.today.present = true;
      this.times.now.past = this.times.today.past = false;
      this.times.now.future = this.times.today.future = false;
    },

    updateTimes() {
      const now = this.parsedNow || this.getNow();
      this.updateDay(now, this.times.now);
      this.updateTime(now, this.times.now);
      this.updateDay(now, this.times.today);
    },

    getNow() {
      return Object(util_timestamp["t" /* parseDate */])(new Date());
    },

    updateDay(now, target) {
      if (now.date !== target.date) {
        target.year = now.year;
        target.month = now.month;
        target.day = now.day;
        target.weekday = now.weekday;
        target.date = now.date;
      }
    },

    updateTime(now, target) {
      if (now.time !== target.time) {
        target.hour = now.hour;
        target.minute = now.minute;
        target.time = now.time;
      }
    }

  }
}));
// EXTERNAL MODULE: ./node_modules/vuetify/lib/directives/resize/index.js
var resize = __webpack_require__(20);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/modes/common.js

const MILLIS_IN_DAY = 86400000;
function getVisuals(events, minStart = 0) {
  const visuals = events.map(event => ({
    event,
    columnCount: 0,
    column: 0,
    left: 0,
    width: 100
  }));
  visuals.sort((a, b) => {
    return Math.max(minStart, a.event.startTimestampIdentifier) - Math.max(minStart, b.event.startTimestampIdentifier) || b.event.endTimestampIdentifier - a.event.endTimestampIdentifier;
  });
  return visuals;
}
function hasOverlap(s0, e0, s1, e1, exclude = true) {
  return exclude ? !(s0 >= e1 || e0 <= s1) : !(s0 > e1 || e0 < s1);
}
function setColumnCount(groups) {
  groups.forEach(group => {
    group.visuals.forEach(groupVisual => {
      groupVisual.columnCount = groups.length;
    });
  });
}
function getRange(event) {
  return [event.startTimestampIdentifier, event.endTimestampIdentifier];
}
function getDayRange(event) {
  return [event.startIdentifier, event.endIdentifier];
}
function getNormalizedRange(event, dayStart) {
  return [Math.max(dayStart, event.startTimestampIdentifier), Math.min(dayStart + MILLIS_IN_DAY, event.endTimestampIdentifier)];
}
function getOpenGroup(groups, start, end, timed) {
  for (let i = 0; i < groups.length; i++) {
    const group = groups[i];
    let intersected = false;

    if (hasOverlap(start, end, group.start, group.end, timed)) {
      for (let k = 0; k < group.visuals.length; k++) {
        const groupVisual = group.visuals[k];
        const [groupStart, groupEnd] = timed ? getRange(groupVisual.event) : getDayRange(groupVisual.event);

        if (hasOverlap(start, end, groupStart, groupEnd, timed)) {
          intersected = true;
          break;
        }
      }
    }

    if (!intersected) {
      return i;
    }
  }

  return -1;
}
function getOverlapGroupHandler(firstWeekday) {
  const handler = {
    groups: [],
    min: -1,
    max: -1,
    reset: () => {
      handler.groups = [];
      handler.min = handler.max = -1;
    },
    getVisuals: (day, dayEvents, timed, reset = false) => {
      if (day.weekday === firstWeekday || reset) {
        handler.reset();
      }

      const dayStart = Object(util_timestamp["p" /* getTimestampIdentifier */])(day);
      const visuals = getVisuals(dayEvents, dayStart);
      visuals.forEach(visual => {
        const [start, end] = timed ? getRange(visual.event) : getDayRange(visual.event);

        if (handler.groups.length > 0 && !hasOverlap(start, end, handler.min, handler.max, timed)) {
          setColumnCount(handler.groups);
          handler.reset();
        }

        let targetGroup = getOpenGroup(handler.groups, start, end, timed);

        if (targetGroup === -1) {
          targetGroup = handler.groups.length;
          handler.groups.push({
            start,
            end,
            visuals: []
          });
        }

        const target = handler.groups[targetGroup];
        target.visuals.push(visual);
        target.start = Math.min(target.start, start);
        target.end = Math.max(target.end, end);
        visual.column = targetGroup;

        if (handler.min === -1) {
          handler.min = start;
          handler.max = end;
        } else {
          handler.min = Math.min(handler.min, start);
          handler.max = Math.max(handler.max, end);
        }
      });
      setColumnCount(handler.groups);

      if (timed) {
        handler.reset();
      }

      return visuals;
    }
  };
  return handler;
}
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/modes/stack.js


const FULL_WIDTH = 100;
const DEFAULT_OFFSET = 5;
const WIDTH_MULTIPLIER = 1.7;
/**
 * Variation of column mode where events can be stacked. The priority of this
 * mode is to stack events together taking up the least amount of space while
 * trying to ensure the content of the event is always visible as well as its
 * start and end. A sibling column has intersecting event content and must be
 * placed beside each other. Non-sibling columns are offset by 5% from the
 * previous column. The width is scaled by 1.7 so the events overlap and
 * whitespace is reduced. If there is a hole in columns the event width is
 * scaled up so it intersects with the next column. The columns have equal
 * width in the space they are given. If the event doesn't have any to the
 * right of it that intersect with it's content it's right side is extended
 * to the right side.
 */

const stack = (events, firstWeekday, overlapThreshold) => {
  const handler = getOverlapGroupHandler(firstWeekday); // eslint-disable-next-line max-statements

  return (day, dayEvents, timed, reset) => {
    if (!timed) {
      return handler.getVisuals(day, dayEvents, timed, reset);
    }

    const dayStart = Object(util_timestamp["p" /* getTimestampIdentifier */])(day);
    const visuals = getVisuals(dayEvents, dayStart);
    const groups = getGroups(visuals, dayStart);

    for (const group of groups) {
      const nodes = [];

      for (const visual of group.visuals) {
        const child = getNode(visual, dayStart);
        const index = getNextIndex(child, nodes);

        if (index === false) {
          const parent = getParent(child, nodes);

          if (parent) {
            child.parent = parent;
            child.sibling = hasOverlap(child.start, child.end, parent.start, addTime(parent.start, overlapThreshold));
            child.index = parent.index + 1;
            parent.children.push(child);
          }
        } else {
          const [parent] = getOverlappingRange(child, nodes, index - 1, index - 1);
          const children = getOverlappingRange(child, nodes, index + 1, index + nodes.length, true);
          child.children = children;
          child.index = index;

          if (parent) {
            child.parent = parent;
            child.sibling = hasOverlap(child.start, child.end, parent.start, addTime(parent.start, overlapThreshold));
            parent.children.push(child);
          }

          for (const grand of children) {
            if (grand.parent === parent) {
              grand.parent = child;
            }

            const grandNext = grand.index - child.index <= 1;

            if (grandNext && child.sibling && hasOverlap(child.start, addTime(child.start, overlapThreshold), grand.start, grand.end)) {
              grand.sibling = true;
            }
          }
        }

        nodes.push(child);
      }

      calculateBounds(nodes, overlapThreshold);
    }

    visuals.sort((a, b) => a.left - b.left || a.event.startTimestampIdentifier - b.event.startTimestampIdentifier);
    return visuals;
  };
};

function calculateBounds(nodes, overlapThreshold) {
  for (const node of nodes) {
    const {
      visual,
      parent
    } = node;
    const columns = getMaxChildIndex(node) + 1;
    const spaceLeft = parent ? parent.visual.left : 0;
    const spaceWidth = FULL_WIDTH - spaceLeft;
    const offset = Math.min(DEFAULT_OFFSET, FULL_WIDTH / columns);
    const columnWidthMultiplier = getColumnWidthMultiplier(node, nodes);
    const columnOffset = spaceWidth / (columns - node.index + 1);
    const columnWidth = spaceWidth / (columns - node.index + (node.sibling ? 1 : 0)) * columnWidthMultiplier;

    if (parent) {
      visual.left = node.sibling ? spaceLeft + columnOffset : spaceLeft + offset;
    }

    visual.width = hasFullWidth(node, nodes, overlapThreshold) ? FULL_WIDTH - visual.left : Math.min(FULL_WIDTH - visual.left, columnWidth * WIDTH_MULTIPLIER);
  }
}

function getColumnWidthMultiplier(node, nodes) {
  if (!node.children.length) {
    return 1;
  }

  const maxColumn = node.index + nodes.length;
  const minColumn = node.children.reduce((min, c) => Math.min(min, c.index), maxColumn);
  return minColumn - node.index;
}

function getOverlappingIndices(node, nodes) {
  const indices = [];

  for (const other of nodes) {
    if (hasOverlap(node.start, node.end, other.start, other.end)) {
      indices.push(other.index);
    }
  }

  return indices;
}

function getNextIndex(node, nodes) {
  const indices = getOverlappingIndices(node, nodes);
  indices.sort();

  for (let i = 0; i < indices.length; i++) {
    if (i < indices[i]) {
      return i;
    }
  }

  return false;
}

function getOverlappingRange(node, nodes, indexMin, indexMax, returnFirstColumn = false) {
  const overlapping = [];

  for (const other of nodes) {
    if (other.index >= indexMin && other.index <= indexMax && hasOverlap(node.start, node.end, other.start, other.end)) {
      overlapping.push(other);
    }
  }

  if (returnFirstColumn && overlapping.length > 0) {
    const first = overlapping.reduce((min, n) => Math.min(min, n.index), overlapping[0].index);
    return overlapping.filter(n => n.index === first);
  }

  return overlapping;
}

function getParent(node, nodes) {
  let parent = null;

  for (const other of nodes) {
    if (hasOverlap(node.start, node.end, other.start, other.end) && (parent === null || other.index > parent.index)) {
      parent = other;
    }
  }

  return parent;
}

function hasFullWidth(node, nodes, overlapThreshold) {
  for (const other of nodes) {
    if (other !== node && other.index > node.index && hasOverlap(node.start, addTime(node.start, overlapThreshold), other.start, other.end)) {
      return false;
    }
  }

  return true;
}

function getGroups(visuals, dayStart) {
  const groups = [];

  for (const visual of visuals) {
    const [start, end] = getNormalizedRange(visual.event, dayStart);
    let added = false;

    for (const group of groups) {
      if (hasOverlap(start, end, group.start, group.end)) {
        group.visuals.push(visual);
        group.end = Math.max(group.end, end);
        added = true;
        break;
      }
    }

    if (!added) {
      groups.push({
        start,
        end,
        visuals: [visual]
      });
    }
  }

  return groups;
}

function getNode(visual, dayStart) {
  const [start, end] = getNormalizedRange(visual.event, dayStart);
  return {
    parent: null,
    sibling: true,
    index: 0,
    visual,
    start,
    end,
    children: []
  };
}

function getMaxChildIndex(node) {
  let max = node.index;

  for (const child of node.children) {
    const childMax = getMaxChildIndex(child);

    if (childMax > max) {
      max = childMax;
    }
  }

  return max;
}

function addTime(identifier, minutes) {
  const removeMinutes = identifier % 100;
  const totalMinutes = removeMinutes + minutes;
  const addHours = Math.floor(totalMinutes / 60);
  const addMinutes = totalMinutes % 60;
  return identifier - removeMinutes + addHours * 100 + addMinutes;
}
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/modes/column.js

const column_FULL_WIDTH = 100;
const column_column = (events, firstWeekday, overlapThreshold) => {
  const handler = getOverlapGroupHandler(firstWeekday);
  return (day, dayEvents, timed, reset) => {
    const visuals = handler.getVisuals(day, dayEvents, timed, reset);

    if (timed) {
      visuals.forEach(visual => {
        visual.left = visual.column * column_FULL_WIDTH / visual.columnCount;
        visual.width = column_FULL_WIDTH / visual.columnCount;
      });
    }

    return visuals;
  };
};
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/modes/index.js


const CalendarEventOverlapModes = {
  stack: stack,
  column: column_column
};
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/util/props.js


/* harmony default export */ var util_props = ({
  base: {
    start: {
      type: [String, Number, Date],
      validate: util_timestamp["F" /* validateTimestamp */],
      default: () => Object(util_timestamp["t" /* parseDate */])(new Date()).date
    },
    end: {
      type: [String, Number, Date],
      validate: util_timestamp["F" /* validateTimestamp */]
    },
    weekdays: {
      type: [Array, String],
      default: () => [0, 1, 2, 3, 4, 5, 6],
      validate: validateWeekdays
    },
    hideHeader: {
      type: Boolean
    },
    shortWeekdays: {
      type: Boolean,
      default: true
    },
    weekdayFormat: {
      type: Function,
      default: null
    },
    dayFormat: {
      type: Function,
      default: null
    }
  },
  intervals: {
    maxDays: {
      type: Number,
      default: 7
    },
    shortIntervals: {
      type: Boolean,
      default: true
    },
    intervalHeight: {
      type: [Number, String],
      default: 48,
      validate: validateNumber
    },
    intervalWidth: {
      type: [Number, String],
      default: 60,
      validate: validateNumber
    },
    intervalMinutes: {
      type: [Number, String],
      default: 60,
      validate: validateNumber
    },
    firstInterval: {
      type: [Number, String],
      default: 0,
      validate: validateNumber
    },
    firstTime: {
      type: [Number, String, Object],
      validate: util_timestamp["E" /* validateTime */]
    },
    intervalCount: {
      type: [Number, String],
      default: 24,
      validate: validateNumber
    },
    intervalFormat: {
      type: Function,
      default: null
    },
    intervalStyle: {
      type: Function,
      default: null
    },
    showIntervalLabel: {
      type: Function,
      default: null
    }
  },
  weeks: {
    localeFirstDayOfYear: {
      type: [String, Number],
      default: 0
    },
    minWeeks: {
      validate: validateNumber,
      default: 1
    },
    shortMonths: {
      type: Boolean,
      default: true
    },
    showMonthOnFirst: {
      type: Boolean,
      default: true
    },
    showWeek: Boolean,
    monthFormat: {
      type: Function,
      default: null
    }
  },
  calendar: {
    type: {
      type: String,
      default: 'month'
    },
    value: {
      type: [String, Number, Date],
      validate: util_timestamp["F" /* validateTimestamp */]
    }
  },
  category: {
    categories: {
      type: [Array, String],
      default: ''
    },
    categoryText: {
      type: [String, Function]
    },
    categoryHideDynamic: {
      type: Boolean
    },
    categoryShowAll: {
      type: Boolean
    },
    categoryForInvalid: {
      type: String,
      default: ''
    },
    categoryDays: {
      type: [Number, String],
      default: 1,
      validate: x => isFinite(parseInt(x)) && parseInt(x) > 0
    }
  },
  events: {
    events: {
      type: Array,
      default: () => []
    },
    eventStart: {
      type: String,
      default: 'start'
    },
    eventEnd: {
      type: String,
      default: 'end'
    },
    eventTimed: {
      type: [String, Function],
      default: 'timed'
    },
    eventCategory: {
      type: [String, Function],
      default: 'category'
    },
    eventHeight: {
      type: Number,
      default: 20
    },
    eventColor: {
      type: [String, Function],
      default: 'primary'
    },
    eventTextColor: {
      type: [String, Function],
      default: 'white'
    },
    eventName: {
      type: [String, Function],
      default: 'name'
    },
    eventOverlapThreshold: {
      type: [String, Number],
      default: 60
    },
    eventOverlapMode: {
      type: [String, Function],
      default: 'stack',
      validate: mode => mode in CalendarEventOverlapModes || typeof mode === 'function'
    },
    eventMore: {
      type: Boolean,
      default: true
    },
    eventMoreText: {
      type: String,
      default: '$vuetify.calendar.moreEvents'
    },
    eventRipple: {
      type: [Boolean, Object],
      default: null
    },
    eventMarginBottom: {
      type: Number,
      default: 1
    }
  }
});
function validateNumber(input) {
  return isFinite(parseInt(input));
}
function validateWeekdays(input) {
  if (typeof input === 'string') {
    input = input.split(',');
  }

  if (Array.isArray(input)) {
    const ints = input.map(x => parseInt(x));

    if (ints.length > util_timestamp["b" /* DAYS_IN_WEEK */] || ints.length === 0) {
      return false;
    }

    const visited = {};
    let wrapped = false;

    for (let i = 0; i < ints.length; i++) {
      const x = ints[i];

      if (!isFinite(x) || x < 0 || x >= util_timestamp["b" /* DAYS_IN_WEEK */]) {
        return false;
      }

      if (i > 0) {
        const d = x - ints[i - 1];

        if (d < 0) {
          if (wrapped) {
            return false;
          }

          wrapped = true;
        } else if (d === 0) {
          return false;
        }
      }

      if (visited[x]) {
        return false;
      }

      visited[x] = true;
    }

    return true;
  }

  return false;
}
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/mixins/calendar-base.js
// Mixins





 // Directives

 // Util



/* harmony default export */ var calendar_base = (Object(mixins["a" /* default */])(colorable["a" /* default */], localable["a" /* default */], mouse, themeable["a" /* default */], mixins_times
/* @vue/component */
).extend({
  name: 'calendar-base',
  directives: {
    Resize: resize["b" /* default */]
  },
  props: util_props.base,
  computed: {
    parsedWeekdays() {
      return Array.isArray(this.weekdays) ? this.weekdays : (this.weekdays || '').split(',').map(x => parseInt(x, 10));
    },

    weekdaySkips() {
      return Object(util_timestamp["q" /* getWeekdaySkips */])(this.parsedWeekdays);
    },

    weekdaySkipsReverse() {
      const reversed = this.weekdaySkips.slice();
      reversed.reverse();
      return reversed;
    },

    parsedStart() {
      return Object(util_timestamp["v" /* parseTimestamp */])(this.start, true);
    },

    parsedEnd() {
      const start = this.parsedStart;
      const end = this.end ? Object(util_timestamp["v" /* parseTimestamp */])(this.end) || start : start;
      return Object(util_timestamp["p" /* getTimestampIdentifier */])(end) < Object(util_timestamp["p" /* getTimestampIdentifier */])(start) ? start : end;
    },

    days() {
      return Object(util_timestamp["f" /* createDayList */])(this.parsedStart, this.parsedEnd, this.times.today, this.weekdaySkips);
    },

    dayFormatter() {
      if (this.dayFormat) {
        return this.dayFormat;
      }

      const options = {
        timeZone: 'UTC',
        day: 'numeric'
      };
      return Object(util_timestamp["h" /* createNativeLocaleFormatter */])(this.currentLocale, (_tms, _short) => options);
    },

    weekdayFormatter() {
      if (this.weekdayFormat) {
        return this.weekdayFormat;
      }

      const longOptions = {
        timeZone: 'UTC',
        weekday: 'long'
      };
      const shortOptions = {
        timeZone: 'UTC',
        weekday: 'short'
      };
      return Object(util_timestamp["h" /* createNativeLocaleFormatter */])(this.currentLocale, (_tms, short) => short ? shortOptions : longOptions);
    }

  },
  methods: {
    getRelativeClasses(timestamp, outside = false) {
      return {
        'v-present': timestamp.present,
        'v-past': timestamp.past,
        'v-future': timestamp.future,
        'v-outside': outside
      };
    },

    getStartOfWeek(timestamp) {
      return Object(util_timestamp["o" /* getStartOfWeek */])(timestamp, this.parsedWeekdays, this.times.today);
    },

    getEndOfWeek(timestamp) {
      return Object(util_timestamp["m" /* getEndOfWeek */])(timestamp, this.parsedWeekdays, this.times.today);
    },

    getFormatter(options) {
      return Object(util_timestamp["h" /* createNativeLocaleFormatter */])(this.locale, (_tms, _short) => options);
    }

  }
}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/util/events.js

function parseEvent(input, index, startProperty, endProperty, timed = false, category = false) {
  const startInput = input[startProperty];
  const endInput = input[endProperty];
  const startParsed = Object(util_timestamp["v" /* parseTimestamp */])(startInput, true);
  const endParsed = endInput ? Object(util_timestamp["v" /* parseTimestamp */])(endInput, true) : startParsed;
  const start = Object(util_timestamp["r" /* isTimedless */])(startInput) ? Object(util_timestamp["A" /* updateHasTime */])(startParsed, timed) : startParsed;
  const end = Object(util_timestamp["r" /* isTimedless */])(endInput) ? Object(util_timestamp["A" /* updateHasTime */])(endParsed, timed) : endParsed;
  const startIdentifier = Object(util_timestamp["k" /* getDayIdentifier */])(start);
  const startTimestampIdentifier = Object(util_timestamp["p" /* getTimestampIdentifier */])(start);
  const endIdentifier = Object(util_timestamp["k" /* getDayIdentifier */])(end);
  const endOffset = start.hasTime ? 0 : 2359;
  const endTimestampIdentifier = Object(util_timestamp["p" /* getTimestampIdentifier */])(end) + endOffset;
  const allDay = !start.hasTime;
  return {
    input,
    start,
    startIdentifier,
    startTimestampIdentifier,
    end,
    endIdentifier,
    endTimestampIdentifier,
    allDay,
    index,
    category
  };
}
function isEventOn(event, dayIdentifier) {
  return dayIdentifier >= event.startIdentifier && dayIdentifier <= event.endIdentifier;
}
function isEventHiddenOn(event, day) {
  return event.end.time === '00:00' && event.end.date === day.date && event.start.date !== day.date;
}
function isEventStart(event, day, dayIdentifier, firstWeekday) {
  return dayIdentifier === event.startIdentifier || firstWeekday === day.weekday && isEventOn(event, dayIdentifier);
}
function isEventOverlapping(event, startIdentifier, endIdentifier) {
  return startIdentifier <= event.endIdentifier && endIdentifier >= event.startIdentifier;
}
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/mixins/calendar-with-events.js
// Styles
 // Directives

 // Mixins

 // Helpers

 // Util





const WIDTH_FULL = 100;
const WIDTH_START = 95;
const MINUTES_IN_DAY = 1440;
/* @vue/component */

/* harmony default export */ var mixins_calendar_with_events = (calendar_base.extend({
  name: 'calendar-with-events',
  directives: {
    ripple: ripple["b" /* default */]
  },
  props: { ...util_props.events,
    ...util_props.calendar,
    ...util_props.category
  },
  computed: {
    noEvents() {
      return this.events.length === 0;
    },

    parsedEvents() {
      return this.events.map(this.parseEvent);
    },

    parsedEventOverlapThreshold() {
      return parseInt(this.eventOverlapThreshold);
    },

    eventTimedFunction() {
      return typeof this.eventTimed === 'function' ? this.eventTimed : event => !!event[this.eventTimed];
    },

    eventCategoryFunction() {
      return typeof this.eventCategory === 'function' ? this.eventCategory : event => event[this.eventCategory];
    },

    eventTextColorFunction() {
      return typeof this.eventTextColor === 'function' ? this.eventTextColor : () => this.eventTextColor;
    },

    eventNameFunction() {
      return typeof this.eventName === 'function' ? this.eventName : (event, timedEvent) => Object(helpers["o" /* escapeHTML */])(event.input[this.eventName] || '');
    },

    eventModeFunction() {
      return typeof this.eventOverlapMode === 'function' ? this.eventOverlapMode : CalendarEventOverlapModes[this.eventOverlapMode];
    },

    eventWeekdays() {
      return this.parsedWeekdays;
    },

    categoryMode() {
      return this.type === 'category';
    }

  },
  methods: {
    eventColorFunction(e) {
      return typeof this.eventColor === 'function' ? this.eventColor(e) : e.color || this.eventColor;
    },

    parseEvent(input, index = 0) {
      return parseEvent(input, index, this.eventStart, this.eventEnd, this.eventTimedFunction(input), this.categoryMode ? this.eventCategoryFunction(input) : false);
    },

    formatTime(withTime, ampm) {
      const formatter = this.getFormatter({
        timeZone: 'UTC',
        hour: 'numeric',
        minute: withTime.minute > 0 ? 'numeric' : undefined
      });
      return formatter(withTime, true);
    },

    updateEventVisibility() {
      if (this.noEvents || !this.eventMore) {
        return;
      }

      const eventHeight = this.eventHeight;
      const eventsMap = this.getEventsMap();

      for (const date in eventsMap) {
        const {
          parent,
          events,
          more
        } = eventsMap[date];

        if (!more) {
          break;
        }

        const parentBounds = parent.getBoundingClientRect();
        const last = events.length - 1;
        const eventsSorted = events.map(event => ({
          event,
          bottom: event.getBoundingClientRect().bottom
        })).sort((a, b) => a.bottom - b.bottom);
        let hidden = 0;

        for (let i = 0; i <= last; i++) {
          const bottom = eventsSorted[i].bottom;
          const hide = i === last ? bottom > parentBounds.bottom : bottom + eventHeight > parentBounds.bottom;

          if (hide) {
            eventsSorted[i].event.style.display = 'none';
            hidden++;
          }
        }

        if (hidden) {
          more.style.display = '';
          more.innerHTML = this.$vuetify.lang.t(this.eventMoreText, hidden);
        } else {
          more.style.display = 'none';
        }
      }
    },

    getEventsMap() {
      const eventsMap = {};
      const elements = this.$refs.events;

      if (!elements || !elements.forEach) {
        return eventsMap;
      }

      elements.forEach(el => {
        const date = el.getAttribute('data-date');

        if (el.parentElement && date) {
          if (!(date in eventsMap)) {
            eventsMap[date] = {
              parent: el.parentElement,
              more: null,
              events: []
            };
          }

          if (el.getAttribute('data-more')) {
            eventsMap[date].more = el;
          } else {
            eventsMap[date].events.push(el);
            el.style.display = '';
          }
        }
      });
      return eventsMap;
    },

    genDayEvent({
      event
    }, day) {
      const eventHeight = this.eventHeight;
      const eventMarginBottom = this.eventMarginBottom;
      const dayIdentifier = Object(util_timestamp["k" /* getDayIdentifier */])(day);
      const week = day.week;
      const start = dayIdentifier === event.startIdentifier;
      let end = dayIdentifier === event.endIdentifier;
      let width = WIDTH_START;

      if (!this.categoryMode) {
        for (let i = day.index + 1; i < week.length; i++) {
          const weekdayIdentifier = Object(util_timestamp["k" /* getDayIdentifier */])(week[i]);

          if (event.endIdentifier >= weekdayIdentifier) {
            width += WIDTH_FULL;
            end = end || weekdayIdentifier === event.endIdentifier;
          } else {
            end = true;
            break;
          }
        }
      }

      const scope = {
        eventParsed: event,
        day,
        start,
        end,
        timed: false
      };
      return this.genEvent(event, scope, false, {
        staticClass: 'v-event',
        class: {
          'v-event-start': start,
          'v-event-end': end
        },
        style: {
          height: `${eventHeight}px`,
          width: `${width}%`,
          'margin-bottom': `${eventMarginBottom}px`
        },
        attrs: {
          'data-date': day.date
        },
        key: event.index,
        ref: 'events',
        refInFor: true
      });
    },

    genTimedEvent({
      event,
      left,
      width
    }, day) {
      if (day.timeDelta(event.end) < 0 || day.timeDelta(event.start) >= 1 || isEventHiddenOn(event, day)) {
        return false;
      }

      const dayIdentifier = Object(util_timestamp["k" /* getDayIdentifier */])(day);
      const start = event.startIdentifier >= dayIdentifier;
      const end = event.endIdentifier > dayIdentifier;
      const top = start ? day.timeToY(event.start) : 0;
      const bottom = end ? day.timeToY(MINUTES_IN_DAY) : day.timeToY(event.end);
      const height = Math.max(this.eventHeight, bottom - top);
      const scope = {
        eventParsed: event,
        day,
        start,
        end,
        timed: true
      };
      return this.genEvent(event, scope, true, {
        staticClass: 'v-event-timed',
        style: {
          top: `${top}px`,
          height: `${height}px`,
          left: `${left}%`,
          width: `${width}%`
        }
      });
    },

    genEvent(event, scopeInput, timedEvent, data) {
      var _this$eventRipple;

      const slot = this.$scopedSlots.event;
      const text = this.eventTextColorFunction(event.input);
      const background = this.eventColorFunction(event.input);
      const overlapsNoon = event.start.hour < 12 && event.end.hour >= 12;
      const singline = Object(util_timestamp["j" /* diffMinutes */])(event.start, event.end) <= this.parsedEventOverlapThreshold;
      const formatTime = this.formatTime;

      const timeSummary = () => formatTime(event.start, overlapsNoon) + ' - ' + formatTime(event.end, true);

      const eventSummary = () => {
        const name = this.eventNameFunction(event, timedEvent);

        if (event.start.hasTime) {
          const eventSummaryClass = 'v-event-summary';

          if (timedEvent) {
            const time = timeSummary();
            const delimiter = singline ? ', ' : '<br>';
            return `<span class="${eventSummaryClass}"><strong>${name}</strong>${delimiter}${time}</span>`;
          } else {
            const time = formatTime(event.start, true);
            return `<span class="${eventSummaryClass}"><strong>${time}</strong> ${name}</span>`;
          }
        }

        return name;
      };

      const scope = { ...scopeInput,
        event: event.input,
        outside: scopeInput.day.outside,
        singline,
        overlapsNoon,
        formatTime,
        timeSummary,
        eventSummary
      };
      return this.$createElement('div', this.setTextColor(text, this.setBackgroundColor(background, {
        on: this.getDefaultMouseEventHandlers(':event', nativeEvent => ({ ...scope,
          nativeEvent
        })),
        directives: [{
          name: 'ripple',
          value: (_this$eventRipple = this.eventRipple) != null ? _this$eventRipple : true
        }],
        ...data
      })), slot ? slot(scope) : [this.genName(eventSummary)]);
    },

    genName(eventSummary) {
      return this.$createElement('div', {
        staticClass: 'pl-1',
        domProps: {
          innerHTML: eventSummary()
        }
      });
    },

    genPlaceholder(day) {
      const height = this.eventHeight + this.eventMarginBottom;
      return this.$createElement('div', {
        style: {
          height: `${height}px`
        },
        attrs: {
          'data-date': day.date
        },
        ref: 'events',
        refInFor: true
      });
    },

    genMore(day) {
      var _this$eventRipple2;

      const eventHeight = this.eventHeight;
      const eventMarginBottom = this.eventMarginBottom;
      return this.$createElement('div', {
        staticClass: 'v-event-more pl-1',
        class: {
          'v-outside': day.outside
        },
        attrs: {
          'data-date': day.date,
          'data-more': 1
        },
        directives: [{
          name: 'ripple',
          value: (_this$eventRipple2 = this.eventRipple) != null ? _this$eventRipple2 : true
        }],
        on: this.getDefaultMouseEventHandlers(':more', nativeEvent => {
          return {
            nativeEvent,
            ...day
          };
        }),
        style: {
          display: 'none',
          height: `${eventHeight}px`,
          'margin-bottom': `${eventMarginBottom}px`
        },
        ref: 'events',
        refInFor: true
      });
    },

    getVisibleEvents() {
      const start = Object(util_timestamp["k" /* getDayIdentifier */])(this.days[0]);
      const end = Object(util_timestamp["k" /* getDayIdentifier */])(this.days[this.days.length - 1]);
      return this.parsedEvents.filter(event => isEventOverlapping(event, start, end));
    },

    isEventForCategory(event, category) {
      return !this.categoryMode || typeof category === 'object' && category.categoryName && category.categoryName === event.category || typeof event.category === 'string' && category === event.category || typeof event.category !== 'string' && category === null;
    },

    getEventsForDay(day) {
      const identifier = Object(util_timestamp["k" /* getDayIdentifier */])(day);
      const firstWeekday = this.eventWeekdays[0];
      return this.parsedEvents.filter(event => isEventStart(event, day, identifier, firstWeekday));
    },

    getEventsForDayAll(day) {
      const identifier = Object(util_timestamp["k" /* getDayIdentifier */])(day);
      const firstWeekday = this.eventWeekdays[0];
      return this.parsedEvents.filter(event => event.allDay && (this.categoryMode ? isEventOn(event, identifier) : isEventStart(event, day, identifier, firstWeekday)) && this.isEventForCategory(event, day.category));
    },

    getEventsForDayTimed(day) {
      const identifier = Object(util_timestamp["k" /* getDayIdentifier */])(day);
      return this.parsedEvents.filter(event => !event.allDay && isEventOn(event, identifier) && this.isEventForCategory(event, day.category));
    },

    getScopedSlots() {
      if (this.noEvents) {
        return { ...this.$scopedSlots
        };
      }

      const mode = this.eventModeFunction(this.parsedEvents, this.eventWeekdays[0], this.parsedEventOverlapThreshold);

      const isNode = input => !!input;

      const getSlotChildren = (day, getter, mapper, timed) => {
        const events = getter(day);
        const visuals = mode(day, events, timed, this.categoryMode);

        if (timed) {
          return visuals.map(visual => mapper(visual, day)).filter(isNode);
        }

        const children = [];
        visuals.forEach((visual, index) => {
          while (children.length < visual.column) {
            children.push(this.genPlaceholder(day));
          }

          const mapped = mapper(visual, day);

          if (mapped) {
            children.push(mapped);
          }
        });
        return children;
      };

      const slots = this.$scopedSlots;
      const slotDay = slots.day;
      const slotDayHeader = slots['day-header'];
      const slotDayBody = slots['day-body'];
      return { ...slots,
        day: day => {
          let children = getSlotChildren(day, this.getEventsForDay, this.genDayEvent, false);

          if (children && children.length > 0 && this.eventMore) {
            children.push(this.genMore(day));
          }

          if (slotDay) {
            const slot = slotDay(day);

            if (slot) {
              children = children ? children.concat(slot) : slot;
            }
          }

          return children;
        },
        'day-header': day => {
          let children = getSlotChildren(day, this.getEventsForDayAll, this.genDayEvent, false);

          if (slotDayHeader) {
            const slot = slotDayHeader(day);

            if (slot) {
              children = children ? children.concat(slot) : slot;
            }
          }

          return children;
        },
        'day-body': day => {
          const events = getSlotChildren(day, this.getEventsForDayTimed, this.genTimedEvent, true);
          let children = [this.$createElement('div', {
            staticClass: 'v-event-timed-container'
          }, events)];

          if (slotDayBody) {
            const slot = slotDayBody(day);

            if (slot) {
              children = children.concat(slot);
            }
          }

          return children;
        }
      };
    }

  }
}));
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VCalendar/VCalendarWeekly.sass
var VCalendarWeekly = __webpack_require__(397);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/util/dateTimeUtils.js
var dateTimeUtils = __webpack_require__(303);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/VCalendarWeekly.js
// Styles
 // Components

 // Mixins

 // Util





/* @vue/component */

/* harmony default export */ var VCalendar_VCalendarWeekly = (calendar_base.extend({
  name: 'v-calendar-weekly',
  props: util_props.weeks,
  computed: {
    staticClass() {
      return 'v-calendar-weekly';
    },

    classes() {
      return this.themeClasses;
    },

    parsedMinWeeks() {
      return parseInt(this.minWeeks);
    },

    days() {
      const minDays = this.parsedMinWeeks * this.parsedWeekdays.length;
      const start = this.getStartOfWeek(this.parsedStart);
      const end = this.getEndOfWeek(this.parsedEnd);
      return Object(util_timestamp["f" /* createDayList */])(start, end, this.times.today, this.weekdaySkips, Number.MAX_SAFE_INTEGER, minDays);
    },

    todayWeek() {
      const today = this.times.today;
      const start = this.getStartOfWeek(today);
      const end = this.getEndOfWeek(today);
      return Object(util_timestamp["f" /* createDayList */])(start, end, today, this.weekdaySkips, this.parsedWeekdays.length, this.parsedWeekdays.length);
    },

    monthFormatter() {
      if (this.monthFormat) {
        return this.monthFormat;
      }

      const longOptions = {
        timeZone: 'UTC',
        month: 'long'
      };
      const shortOptions = {
        timeZone: 'UTC',
        month: 'short'
      };
      return Object(util_timestamp["h" /* createNativeLocaleFormatter */])(this.currentLocale, (_tms, short) => short ? shortOptions : longOptions);
    }

  },
  methods: {
    isOutside(day) {
      const dayIdentifier = Object(util_timestamp["k" /* getDayIdentifier */])(day);
      return dayIdentifier < Object(util_timestamp["k" /* getDayIdentifier */])(this.parsedStart) || dayIdentifier > Object(util_timestamp["k" /* getDayIdentifier */])(this.parsedEnd);
    },

    genHead() {
      return this.$createElement('div', {
        staticClass: 'v-calendar-weekly__head'
      }, this.genHeadDays());
    },

    genHeadDays() {
      const header = this.todayWeek.map(this.genHeadDay);

      if (this.showWeek) {
        header.unshift(this.$createElement('div', {
          staticClass: 'v-calendar-weekly__head-weeknumber'
        }));
      }

      return header;
    },

    genHeadDay(day, index) {
      const outside = this.isOutside(this.days[index]);
      const color = day.present ? this.color : undefined;
      return this.$createElement('div', this.setTextColor(color, {
        key: day.date,
        staticClass: 'v-calendar-weekly__head-weekday',
        class: this.getRelativeClasses(day, outside)
      }), this.weekdayFormatter(day, this.shortWeekdays));
    },

    genWeeks() {
      const days = this.days;
      const weekDays = this.parsedWeekdays.length;
      const weeks = [];

      for (let i = 0; i < days.length; i += weekDays) {
        weeks.push(this.genWeek(days.slice(i, i + weekDays), this.getWeekNumber(days[i])));
      }

      return weeks;
    },

    genWeek(week, weekNumber) {
      const weekNodes = week.map((day, index) => this.genDay(day, index, week));

      if (this.showWeek) {
        weekNodes.unshift(this.genWeekNumber(weekNumber));
      }

      return this.$createElement('div', {
        key: week[0].date,
        staticClass: 'v-calendar-weekly__week'
      }, weekNodes);
    },

    getWeekNumber(determineDay) {
      return Object(dateTimeUtils["b" /* weekNumber */])(determineDay.year, determineDay.month - 1, determineDay.day, this.parsedWeekdays[0], parseInt(this.localeFirstDayOfYear));
    },

    genWeekNumber(weekNumber) {
      return this.$createElement('div', {
        staticClass: 'v-calendar-weekly__weeknumber'
      }, [this.$createElement('small', String(weekNumber))]);
    },

    genDay(day, index, week) {
      const outside = this.isOutside(day);
      return this.$createElement('div', {
        key: day.date,
        staticClass: 'v-calendar-weekly__day',
        class: this.getRelativeClasses(day, outside),
        on: this.getDefaultMouseEventHandlers(':day', nativeEvent => {
          return {
            nativeEvent,
            ...day
          };
        })
      }, [this.genDayLabel(day), ...(Object(helpers["v" /* getSlot */])(this, 'day', () => ({
        outside,
        index,
        week,
        ...day
      })) || [])]);
    },

    genDayLabel(day) {
      return this.$createElement('div', {
        staticClass: 'v-calendar-weekly__day-label'
      }, Object(helpers["v" /* getSlot */])(this, 'day-label', day) || [this.genDayLabelButton(day)]);
    },

    genDayLabelButton(day) {
      const color = day.present ? this.color : 'transparent';
      const hasMonth = day.day === 1 && this.showMonthOnFirst;
      return this.$createElement(VBtn["b" /* default */], {
        props: {
          color,
          fab: true,
          depressed: true,
          small: true
        },
        on: this.getMouseEventHandlers({
          'click:date': {
            event: 'click',
            stop: true
          },
          'contextmenu:date': {
            event: 'contextmenu',
            stop: true,
            prevent: true,
            result: false
          }
        }, nativeEvent => ({
          nativeEvent,
          ...day
        }))
      }, hasMonth ? this.monthFormatter(day, this.shortMonths) + ' ' + this.dayFormatter(day, false) : this.dayFormatter(day, false));
    },

    genDayMonth(day) {
      const color = day.present ? this.color : undefined;
      return this.$createElement('div', this.setTextColor(color, {
        staticClass: 'v-calendar-weekly__day-month'
      }), Object(helpers["v" /* getSlot */])(this, 'day-month', day) || this.monthFormatter(day, this.shortMonths));
    }

  },

  render(h) {
    return h('div', {
      staticClass: this.staticClass,
      class: this.classes,
      on: {
        dragstart: e => {
          e.preventDefault();
        }
      }
    }, [!this.hideHeader ? this.genHead() : '', ...this.genWeeks()]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/VCalendarMonthly.js
// Styles
 // Mixins

 // Util


/* @vue/component */

/* harmony default export */ var VCalendarMonthly = (VCalendar_VCalendarWeekly.extend({
  name: 'v-calendar-monthly',
  computed: {
    staticClass() {
      return 'v-calendar-monthly v-calendar-weekly';
    },

    parsedStart() {
      return Object(util_timestamp["n" /* getStartOfMonth */])(Object(util_timestamp["v" /* parseTimestamp */])(this.start, true));
    },

    parsedEnd() {
      return Object(util_timestamp["l" /* getEndOfMonth */])(Object(util_timestamp["v" /* parseTimestamp */])(this.end, true));
    }

  }
}));
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VCalendar/VCalendarDaily.sass
var VCalendarDaily = __webpack_require__(439);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/mixins/calendar-with-intervals.js
// Mixins
 // Util



/* @vue/component */

/* harmony default export */ var calendar_with_intervals = (calendar_base.extend({
  name: 'calendar-with-intervals',
  props: util_props.intervals,
  computed: {
    parsedFirstInterval() {
      return parseInt(this.firstInterval);
    },

    parsedIntervalMinutes() {
      return parseInt(this.intervalMinutes);
    },

    parsedIntervalCount() {
      return parseInt(this.intervalCount);
    },

    parsedIntervalHeight() {
      return parseFloat(this.intervalHeight);
    },

    parsedFirstTime() {
      return Object(util_timestamp["u" /* parseTime */])(this.firstTime);
    },

    firstMinute() {
      const time = this.parsedFirstTime;
      return time !== false && time >= 0 && time <= util_timestamp["d" /* MINUTES_IN_DAY */] ? time : this.parsedFirstInterval * this.parsedIntervalMinutes;
    },

    bodyHeight() {
      return this.parsedIntervalCount * this.parsedIntervalHeight;
    },

    days() {
      return Object(util_timestamp["f" /* createDayList */])(this.parsedStart, this.parsedEnd, this.times.today, this.weekdaySkips, this.maxDays);
    },

    intervals() {
      const days = this.days;
      const first = this.firstMinute;
      const minutes = this.parsedIntervalMinutes;
      const count = this.parsedIntervalCount;
      const now = this.times.now;
      return days.map(d => Object(util_timestamp["g" /* createIntervalList */])(d, first, minutes, count, now));
    },

    intervalFormatter() {
      if (this.intervalFormat) {
        return this.intervalFormat;
      }

      const longOptions = {
        timeZone: 'UTC',
        hour: '2-digit',
        minute: '2-digit'
      };
      const shortOptions = {
        timeZone: 'UTC',
        hour: 'numeric',
        minute: '2-digit'
      };
      const shortHourOptions = {
        timeZone: 'UTC',
        hour: 'numeric'
      };
      return Object(util_timestamp["h" /* createNativeLocaleFormatter */])(this.currentLocale, (tms, short) => short ? tms.minute === 0 ? shortHourOptions : shortOptions : longOptions);
    }

  },
  methods: {
    showIntervalLabelDefault(interval) {
      const first = this.intervals[0][0];
      const isFirst = first.hour === interval.hour && first.minute === interval.minute;
      return !isFirst;
    },

    intervalStyleDefault(_interval) {
      return undefined;
    },

    getTimestampAtEvent(e, day) {
      const timestamp = Object(util_timestamp["e" /* copyTimestamp */])(day);
      const bounds = e.currentTarget.getBoundingClientRect();
      const baseMinutes = this.firstMinute;
      const touchEvent = e;
      const mouseEvent = e;
      const touches = touchEvent.changedTouches || touchEvent.touches;
      const clientY = touches && touches[0] ? touches[0].clientY : mouseEvent.clientY;
      const addIntervals = (clientY - bounds.top) / this.parsedIntervalHeight;
      const addMinutes = Math.floor(addIntervals * this.parsedIntervalMinutes);
      const minutes = baseMinutes + addMinutes;
      return Object(util_timestamp["B" /* updateMinutes */])(timestamp, minutes, this.times.now);
    },

    getSlotScope(timestamp) {
      const scope = Object(util_timestamp["e" /* copyTimestamp */])(timestamp);
      scope.timeToY = this.timeToY;
      scope.timeDelta = this.timeDelta;
      scope.minutesToPixels = this.minutesToPixels;
      scope.week = this.days;
      return scope;
    },

    scrollToTime(time) {
      const y = this.timeToY(time);
      const pane = this.$refs.scrollArea;

      if (y === false || !pane) {
        return false;
      }

      pane.scrollTop = y;
      return true;
    },

    minutesToPixels(minutes) {
      return minutes / this.parsedIntervalMinutes * this.parsedIntervalHeight;
    },

    timeToY(time, clamp = true) {
      let y = this.timeDelta(time);

      if (y !== false) {
        y *= this.bodyHeight;

        if (clamp) {
          if (y < 0) {
            y = 0;
          }

          if (y > this.bodyHeight) {
            y = this.bodyHeight;
          }
        }
      }

      return y;
    },

    timeDelta(time) {
      const minutes = Object(util_timestamp["u" /* parseTime */])(time);

      if (minutes === false) {
        return false;
      }

      const min = this.firstMinute;
      const gap = this.parsedIntervalCount * this.parsedIntervalMinutes;
      return (minutes - min) / gap;
    }

  }
}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/VCalendarDaily.js
// Styles
 // Directives

 // Components

 // Mixins

 // Util


/* @vue/component */

/* harmony default export */ var VCalendar_VCalendarDaily = (calendar_with_intervals.extend({
  name: 'v-calendar-daily',
  directives: {
    Resize: resize["b" /* default */]
  },
  data: () => ({
    scrollPush: 0
  }),
  computed: {
    classes() {
      return {
        'v-calendar-daily': true,
        ...this.themeClasses
      };
    }

  },

  mounted() {
    this.init();
  },

  methods: {
    init() {
      this.$nextTick(this.onResize);
    },

    onResize() {
      this.scrollPush = this.getScrollPush();
    },

    getScrollPush() {
      const area = this.$refs.scrollArea;
      const pane = this.$refs.pane;
      return area && pane ? area.offsetWidth - pane.offsetWidth : 0;
    },

    genHead() {
      return this.$createElement('div', {
        staticClass: 'v-calendar-daily__head',
        style: {
          marginRight: this.scrollPush + 'px'
        }
      }, [this.genHeadIntervals(), ...this.genHeadDays()]);
    },

    genHeadIntervals() {
      const width = Object(helpers["i" /* convertToUnit */])(this.intervalWidth);
      return this.$createElement('div', {
        staticClass: 'v-calendar-daily__intervals-head',
        style: {
          width
        }
      }, Object(helpers["v" /* getSlot */])(this, 'interval-header'));
    },

    genHeadDays() {
      return this.days.map(this.genHeadDay);
    },

    genHeadDay(day, index) {
      return this.$createElement('div', {
        key: day.date,
        staticClass: 'v-calendar-daily_head-day',
        class: this.getRelativeClasses(day),
        on: this.getDefaultMouseEventHandlers(':day', nativeEvent => {
          return {
            nativeEvent,
            ...this.getSlotScope(day)
          };
        })
      }, [this.genHeadWeekday(day), this.genHeadDayLabel(day), ...this.genDayHeader(day, index)]);
    },

    genDayHeader(day, index) {
      return Object(helpers["v" /* getSlot */])(this, 'day-header', () => ({
        week: this.days,
        ...day,
        index
      })) || [];
    },

    genHeadWeekday(day) {
      const color = day.present ? this.color : undefined;
      return this.$createElement('div', this.setTextColor(color, {
        staticClass: 'v-calendar-daily_head-weekday'
      }), this.weekdayFormatter(day, this.shortWeekdays));
    },

    genHeadDayLabel(day) {
      return this.$createElement('div', {
        staticClass: 'v-calendar-daily_head-day-label'
      }, Object(helpers["v" /* getSlot */])(this, 'day-label-header', day) || [this.genHeadDayButton(day)]);
    },

    genHeadDayButton(day) {
      const color = day.present ? this.color : 'transparent';
      return this.$createElement(VBtn["b" /* default */], {
        props: {
          color,
          fab: true,
          depressed: true
        },
        on: this.getMouseEventHandlers({
          'click:date': {
            event: 'click',
            stop: true
          },
          'contextmenu:date': {
            event: 'contextmenu',
            stop: true,
            prevent: true,
            result: false
          }
        }, nativeEvent => {
          return {
            nativeEvent,
            ...day
          };
        })
      }, this.dayFormatter(day, false));
    },

    genBody() {
      return this.$createElement('div', {
        staticClass: 'v-calendar-daily__body'
      }, [this.genScrollArea()]);
    },

    genScrollArea() {
      return this.$createElement('div', {
        ref: 'scrollArea',
        staticClass: 'v-calendar-daily__scroll-area'
      }, [this.genPane()]);
    },

    genPane() {
      return this.$createElement('div', {
        ref: 'pane',
        staticClass: 'v-calendar-daily__pane',
        style: {
          height: Object(helpers["i" /* convertToUnit */])(this.bodyHeight)
        }
      }, [this.genDayContainer()]);
    },

    genDayContainer() {
      return this.$createElement('div', {
        staticClass: 'v-calendar-daily__day-container'
      }, [this.genBodyIntervals(), ...this.genDays()]);
    },

    genDays() {
      return this.days.map(this.genDay);
    },

    genDay(day, index) {
      return this.$createElement('div', {
        key: day.date,
        staticClass: 'v-calendar-daily__day',
        class: this.getRelativeClasses(day),
        on: this.getDefaultMouseEventHandlers(':time', nativeEvent => {
          return {
            nativeEvent,
            ...this.getSlotScope(this.getTimestampAtEvent(nativeEvent, day))
          };
        })
      }, [...this.genDayIntervals(index), ...this.genDayBody(day)]);
    },

    genDayBody(day) {
      return Object(helpers["v" /* getSlot */])(this, 'day-body', () => this.getSlotScope(day)) || [];
    },

    genDayIntervals(index) {
      return this.intervals[index].map(this.genDayInterval);
    },

    genDayInterval(interval) {
      const height = Object(helpers["i" /* convertToUnit */])(this.intervalHeight);
      const styler = this.intervalStyle || this.intervalStyleDefault;
      const data = {
        key: interval.time,
        staticClass: 'v-calendar-daily__day-interval',
        style: {
          height,
          ...styler(interval)
        }
      };
      const children = Object(helpers["v" /* getSlot */])(this, 'interval', () => this.getSlotScope(interval));
      return this.$createElement('div', data, children);
    },

    genBodyIntervals() {
      const width = Object(helpers["i" /* convertToUnit */])(this.intervalWidth);
      const data = {
        staticClass: 'v-calendar-daily__intervals-body',
        style: {
          width
        },
        on: this.getDefaultMouseEventHandlers(':interval', nativeEvent => {
          return {
            nativeEvent,
            ...this.getTimestampAtEvent(nativeEvent, this.parsedStart)
          };
        })
      };
      return this.$createElement('div', data, this.genIntervalLabels());
    },

    genIntervalLabels() {
      if (!this.intervals.length) return null;
      return this.intervals[0].map(this.genIntervalLabel);
    },

    genIntervalLabel(interval) {
      const height = Object(helpers["i" /* convertToUnit */])(this.intervalHeight);
      const short = this.shortIntervals;
      const shower = this.showIntervalLabel || this.showIntervalLabelDefault;
      const show = shower(interval);
      const label = show ? this.intervalFormatter(interval, short) : undefined;
      return this.$createElement('div', {
        key: interval.time,
        staticClass: 'v-calendar-daily__interval',
        style: {
          height
        }
      }, [this.$createElement('div', {
        staticClass: 'v-calendar-daily__interval-text'
      }, label)]);
    }

  },

  render(h) {
    return h('div', {
      class: this.classes,
      on: {
        dragstart: e => {
          e.preventDefault();
        }
      },
      directives: [{
        modifiers: {
          quiet: true
        },
        name: 'resize',
        value: this.onResize
      }]
    }, [!this.hideHeader ? this.genHead() : '', this.genBody()]);
  }

}));
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VCalendar/VCalendarCategory.sass
var VCalendarCategory = __webpack_require__(440);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/util/parser.js
function parsedCategoryText(category, categoryText) {
  return typeof categoryText === 'string' && typeof category === 'object' && category ? category[categoryText] : typeof categoryText === 'function' ? categoryText(category) : category;
}
function getParsedCategories(categories, categoryText) {
  if (typeof categories === 'string') return categories.split(/\s*,\s/);

  if (Array.isArray(categories)) {
    return categories.map(category => {
      if (typeof category === 'string') return category;
      const categoryName = typeof category.categoryName === 'string' ? category.categoryName : parsedCategoryText(category, categoryText);
      return { ...category,
        categoryName
      };
    });
  }

  return [];
}
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/VCalendarCategory.js
// Styles
 // Mixins

 // Util




/* @vue/component */

/* harmony default export */ var VCalendar_VCalendarCategory = (VCalendar_VCalendarDaily.extend({
  name: 'v-calendar-category',
  props: util_props.category,
  computed: {
    classes() {
      return {
        'v-calendar-daily': true,
        'v-calendar-category': true,
        ...this.themeClasses
      };
    },

    parsedCategories() {
      return getParsedCategories(this.categories, this.categoryText);
    }

  },
  methods: {
    genDayHeader(day, index) {
      const data = {
        staticClass: 'v-calendar-category__columns'
      };
      const scope = {
        week: this.days,
        ...day,
        index
      };
      const children = this.parsedCategories.map(category => {
        return this.genDayHeaderCategory(day, this.getCategoryScope(scope, category));
      });
      return [this.$createElement('div', data, children)];
    },

    getCategoryScope(scope, category) {
      const cat = typeof category === 'object' && category && category.categoryName === this.categoryForInvalid ? null : category;
      return { ...scope,
        category: cat
      };
    },

    genDayHeaderCategory(day, scope) {
      const headerTitle = typeof scope.category === 'object' ? scope.category.categoryName : scope.category;
      return this.$createElement('div', {
        staticClass: 'v-calendar-category__column-header',
        on: this.getDefaultMouseEventHandlers(':day-category', e => {
          return this.getCategoryScope(this.getSlotScope(day), scope.category);
        })
      }, [Object(helpers["v" /* getSlot */])(this, 'category', scope) || this.genDayHeaderCategoryTitle(headerTitle), Object(helpers["v" /* getSlot */])(this, 'day-header', scope)]);
    },

    genDayHeaderCategoryTitle(categoryName) {
      return this.$createElement('div', {
        staticClass: 'v-calendar-category__category'
      }, categoryName === null ? this.categoryForInvalid : categoryName);
    },

    genDays() {
      const days = [];
      this.days.forEach((d, j) => {
        const day = new Array(this.parsedCategories.length || 1);
        day.fill(d);
        days.push(...day.map((v, i) => this.genDay(v, j, i)));
      });
      return days;
    },

    genDay(day, index, categoryIndex) {
      const category = this.parsedCategories[categoryIndex];
      return this.$createElement('div', {
        key: day.date + '-' + categoryIndex,
        staticClass: 'v-calendar-daily__day',
        class: this.getRelativeClasses(day),
        on: this.getDefaultMouseEventHandlers(':time', e => {
          return this.getSlotScope(this.getTimestampAtEvent(e, day));
        })
      }, [...this.genDayIntervals(index, category), ...this.genDayBody(day, category)]);
    },

    genDayIntervals(index, category) {
      return this.intervals[index].map(v => this.genDayInterval(v, category));
    },

    genDayInterval(interval, category) {
      const height = Object(helpers["i" /* convertToUnit */])(this.intervalHeight);
      const styler = this.intervalStyle || this.intervalStyleDefault;
      const data = {
        key: interval.time,
        staticClass: 'v-calendar-daily__day-interval',
        style: {
          height,
          ...styler({ ...interval,
            category
          })
        }
      };
      const children = Object(helpers["v" /* getSlot */])(this, 'interval', () => this.getCategoryScope(this.getSlotScope(interval), category));
      return this.$createElement('div', data, children);
    },

    genDayBody(day, category) {
      const data = {
        staticClass: 'v-calendar-category__columns'
      };
      const children = [this.genDayBodyCategory(day, category)];
      return [this.$createElement('div', data, children)];
    },

    genDayBodyCategory(day, category) {
      const data = {
        staticClass: 'v-calendar-category__column',
        on: this.getDefaultMouseEventHandlers(':time-category', e => {
          return this.getCategoryScope(this.getSlotScope(this.getTimestampAtEvent(e, day)), category);
        })
      };
      const children = Object(helpers["v" /* getSlot */])(this, 'day-body', () => this.getCategoryScope(this.getSlotScope(day), category));
      return this.$createElement('div', data, children);
    }

  }
}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/VCalendar.js
// Styles
// import '../../stylus/components/_calendar-daily.styl'
// Mixins
 // Util


 // Calendars






/* @vue/component */

/* harmony default export */ var VCalendar = (mixins_calendar_with_events.extend({
  name: 'v-calendar',
  props: { ...util_props.calendar,
    ...util_props.weeks,
    ...util_props.intervals,
    ...util_props.category
  },
  data: () => ({
    lastStart: null,
    lastEnd: null
  }),
  computed: {
    parsedValue() {
      return Object(util_timestamp["F" /* validateTimestamp */])(this.value) ? Object(util_timestamp["v" /* parseTimestamp */])(this.value, true) : this.parsedStart || this.times.today;
    },

    parsedCategoryDays() {
      return parseInt(this.categoryDays) || 1;
    },

    renderProps() {
      const around = this.parsedValue;
      let component = null;
      let maxDays = this.maxDays;
      let weekdays = this.parsedWeekdays;
      let categories = this.parsedCategories;
      let start = around;
      let end = around;

      switch (this.type) {
        case 'month':
          component = VCalendarMonthly;
          start = Object(util_timestamp["n" /* getStartOfMonth */])(around);
          end = Object(util_timestamp["l" /* getEndOfMonth */])(around);
          break;

        case 'week':
          component = VCalendar_VCalendarDaily;
          start = this.getStartOfWeek(around);
          end = this.getEndOfWeek(around);
          maxDays = 7;
          break;

        case 'day':
          component = VCalendar_VCalendarDaily;
          maxDays = 1;
          weekdays = [start.weekday];
          break;

        case '4day':
          component = VCalendar_VCalendarDaily;
          end = Object(util_timestamp["x" /* relativeDays */])(Object(util_timestamp["e" /* copyTimestamp */])(end), util_timestamp["s" /* nextDay */], 3);
          Object(util_timestamp["z" /* updateFormatted */])(end);
          maxDays = 4;
          weekdays = [start.weekday, (start.weekday + 1) % 7, (start.weekday + 2) % 7, (start.weekday + 3) % 7];
          break;

        case 'custom-weekly':
          component = VCalendar_VCalendarWeekly;
          start = this.parsedStart || around;
          end = this.parsedEnd;
          break;

        case 'custom-daily':
          component = VCalendar_VCalendarDaily;
          start = this.parsedStart || around;
          end = this.parsedEnd;
          break;

        case 'category':
          const days = this.parsedCategoryDays;
          component = VCalendar_VCalendarCategory;
          end = Object(util_timestamp["x" /* relativeDays */])(Object(util_timestamp["e" /* copyTimestamp */])(end), util_timestamp["s" /* nextDay */], days);
          Object(util_timestamp["z" /* updateFormatted */])(end);
          maxDays = days;
          weekdays = [];

          for (let i = 0; i < days; i++) {
            weekdays.push((start.weekday + i) % 7);
          }

          categories = this.getCategoryList(categories);
          break;

        default:
          throw new Error(this.type + ' is not a valid Calendar type');
      }

      return {
        component,
        start,
        end,
        maxDays,
        weekdays,
        categories
      };
    },

    eventWeekdays() {
      return this.renderProps.weekdays;
    },

    categoryMode() {
      return this.type === 'category';
    },

    title() {
      const {
        start,
        end
      } = this.renderProps;
      const spanYears = start.year !== end.year;
      const spanMonths = spanYears || start.month !== end.month;

      if (spanYears) {
        return this.monthShortFormatter(start, true) + ' ' + start.year + ' - ' + this.monthShortFormatter(end, true) + ' ' + end.year;
      }

      if (spanMonths) {
        return this.monthShortFormatter(start, true) + ' - ' + this.monthShortFormatter(end, true) + ' ' + end.year;
      } else {
        return this.monthLongFormatter(start, false) + ' ' + start.year;
      }
    },

    monthLongFormatter() {
      return this.getFormatter({
        timeZone: 'UTC',
        month: 'long'
      });
    },

    monthShortFormatter() {
      return this.getFormatter({
        timeZone: 'UTC',
        month: 'short'
      });
    },

    parsedCategories() {
      return getParsedCategories(this.categories, this.categoryText);
    }

  },
  watch: {
    renderProps: 'checkChange'
  },

  mounted() {
    this.updateEventVisibility();
    this.checkChange();
  },

  updated() {
    window.requestAnimationFrame(this.updateEventVisibility);
  },

  methods: {
    checkChange() {
      const {
        lastStart,
        lastEnd
      } = this;
      const {
        start,
        end
      } = this.renderProps;

      if (!lastStart || !lastEnd || start.date !== lastStart.date || end.date !== lastEnd.date) {
        this.lastStart = start;
        this.lastEnd = end;
        this.$emit('change', {
          start,
          end
        });
      }
    },

    move(amount = 1) {
      const moved = Object(util_timestamp["e" /* copyTimestamp */])(this.parsedValue);
      const forward = amount > 0;
      const mover = forward ? util_timestamp["s" /* nextDay */] : util_timestamp["w" /* prevDay */];
      const limit = forward ? util_timestamp["a" /* DAYS_IN_MONTH_MAX */] : util_timestamp["c" /* DAY_MIN */];
      let times = forward ? amount : -amount;

      while (--times >= 0) {
        switch (this.type) {
          case 'month':
            moved.day = limit;
            mover(moved);
            break;

          case 'week':
            Object(util_timestamp["x" /* relativeDays */])(moved, mover, util_timestamp["b" /* DAYS_IN_WEEK */]);
            break;

          case 'day':
            Object(util_timestamp["x" /* relativeDays */])(moved, mover, 1);
            break;

          case '4day':
            Object(util_timestamp["x" /* relativeDays */])(moved, mover, 4);
            break;

          case 'category':
            Object(util_timestamp["x" /* relativeDays */])(moved, mover, this.parsedCategoryDays);
            break;
        }
      }

      Object(util_timestamp["D" /* updateWeekday */])(moved);
      Object(util_timestamp["z" /* updateFormatted */])(moved);
      Object(util_timestamp["C" /* updateRelative */])(moved, this.times.now);

      if (this.value instanceof Date) {
        this.$emit('input', Object(util_timestamp["y" /* timestampToDate */])(moved));
      } else if (typeof this.value === 'number') {
        this.$emit('input', Object(util_timestamp["y" /* timestampToDate */])(moved).getTime());
      } else {
        this.$emit('input', moved.date);
      }

      this.$emit('moved', moved);
    },

    next(amount = 1) {
      this.move(amount);
    },

    prev(amount = 1) {
      this.move(-amount);
    },

    timeToY(time, clamp = true) {
      const c = this.$children[0];

      if (c && c.timeToY) {
        return c.timeToY(time, clamp);
      } else {
        return false;
      }
    },

    timeDelta(time) {
      const c = this.$children[0];

      if (c && c.timeDelta) {
        return c.timeDelta(time);
      } else {
        return false;
      }
    },

    minutesToPixels(minutes) {
      const c = this.$children[0];

      if (c && c.minutesToPixels) {
        return c.minutesToPixels(minutes);
      } else {
        return -1;
      }
    },

    scrollToTime(time) {
      const c = this.$children[0];

      if (c && c.scrollToTime) {
        return c.scrollToTime(time);
      } else {
        return false;
      }
    },

    parseTimestamp(input, required) {
      return Object(util_timestamp["v" /* parseTimestamp */])(input, required, this.times.now);
    },

    timestampToDate(timestamp) {
      return Object(util_timestamp["y" /* timestampToDate */])(timestamp);
    },

    getCategoryList(categories) {
      if (!this.noEvents) {
        const categoryMap = categories.reduce((map, category, index) => {
          if (typeof category === 'object' && category.categoryName) map[category.categoryName] = {
            index,
            count: 0
          };else if (typeof category === 'string') map[category] = {
            index,
            count: 0
          };
          return map;
        }, {});

        if (!this.categoryHideDynamic || !this.categoryShowAll) {
          let categoryLength = categories.length;
          this.parsedEvents.forEach(ev => {
            let category = ev.category;

            if (typeof category !== 'string') {
              category = this.categoryForInvalid;
            }

            if (!category) {
              return;
            }

            if (category in categoryMap) {
              categoryMap[category].count++;
            } else if (!this.categoryHideDynamic) {
              categoryMap[category] = {
                index: categoryLength++,
                count: 1
              };
            }
          });
        }

        if (!this.categoryShowAll) {
          for (const category in categoryMap) {
            if (categoryMap[category].count === 0) {
              delete categoryMap[category];
            }
          }
        }

        categories = categories.filter(category => {
          if (typeof category === 'object' && category.categoryName) {
            return categoryMap.hasOwnProperty(category.categoryName);
          } else if (typeof category === 'string') {
            return categoryMap.hasOwnProperty(category);
          }

          return false;
        });
      }

      return categories;
    }

  },

  render(h) {
    const {
      start,
      end,
      maxDays,
      component,
      weekdays,
      categories
    } = this.renderProps;
    return h(component, {
      staticClass: 'v-calendar',
      class: {
        'v-calendar-events': !this.noEvents
      },
      props: { ...this.$props,
        start: start.date,
        end: end.date,
        maxDays,
        weekdays,
        categories
      },
      directives: [{
        modifiers: {
          quiet: true
        },
        name: 'resize',
        value: this.updateEventVisibility
      }],
      on: { ...this.$listeners,
        'click:date': (day, e) => {
          if (this.$listeners.input) {
            this.$emit('input', day.date);
          }

          if (this.$listeners['click:date']) {
            this.$emit('click:date', day, e);
          }
        }
      },
      scopedSlots: this.getScopedSlots()
    });
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCalendar/index.js






/* harmony default export */ var components_VCalendar = ({
  $_vuetify_subcomponents: {
    VCalendar: VCalendar,
    VCalendarCategory: VCalendar_VCalendarCategory,
    VCalendarDaily: VCalendar_VCalendarDaily,
    VCalendarWeekly: VCalendar_VCalendarWeekly,
    VCalendarMonthly: VCalendarMonthly
  }
});
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VCard/index.js
var VCard = __webpack_require__(31);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VCarousel/index.js
var VCarousel = __webpack_require__(283);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VCheckbox/index.js
var VCheckbox = __webpack_require__(368);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VChip/index.js
var VChip = __webpack_require__(267);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VChipGroup/VChipGroup.sass
var VChipGroup = __webpack_require__(442);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VSlideGroup/VSlideGroup.js
var VSlideGroup = __webpack_require__(47);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VChipGroup/VChipGroup.js
// Styles
 // Extensions

 // Mixins

 // Utilities


/* @vue/component */

/* harmony default export */ var VChipGroup_VChipGroup = (Object(mixins["a" /* default */])(VSlideGroup["a" /* BaseSlideGroup */], colorable["a" /* default */]).extend({
  name: 'v-chip-group',

  provide() {
    return {
      chipGroup: this
    };
  },

  props: {
    column: Boolean
  },
  computed: {
    classes() {
      return { ...VSlideGroup["a" /* BaseSlideGroup */].options.computed.classes.call(this),
        'v-chip-group': true,
        'v-chip-group--column': this.column
      };
    }

  },
  watch: {
    column(val) {
      if (val) this.scrollOffset = 0;
      this.$nextTick(this.onResize);
    }

  },
  methods: {
    genData() {
      return this.setTextColor(this.color, { ...VSlideGroup["a" /* BaseSlideGroup */].options.methods.genData.call(this)
      });
    }

  }
}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VChipGroup/index.js


/* harmony default export */ var components_VChipGroup = (VChipGroup_VChipGroup);
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VColorPicker/VColorPicker.sass
var VColorPicker = __webpack_require__(443);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VSheet/VSheet.js
var VSheet_VSheet = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VColorPicker/VColorPickerPreview.sass
var VColorPickerPreview = __webpack_require__(446);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VSlider/VSlider.sass
var VSlider = __webpack_require__(447);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VInput/index.js + 1 modules
var VInput = __webpack_require__(23);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/loadable/index.js
var loadable = __webpack_require__(48);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/directives/click-outside/index.js
var click_outside = __webpack_require__(55);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSlider/VSlider.js
 // Components


 // Mixins


 // Directives

 // Helpers



/* harmony default export */ var VSlider_VSlider = (Object(mixins["a" /* default */])(VInput["b" /* default */], loadable["a" /* default */]
/* @vue/component */
).extend({
  name: 'v-slider',
  directives: {
    ClickOutside: click_outside["b" /* default */]
  },
  mixins: [loadable["a" /* default */]],
  props: {
    disabled: Boolean,
    inverseLabel: Boolean,
    max: {
      type: [Number, String],
      default: 100
    },
    min: {
      type: [Number, String],
      default: 0
    },
    step: {
      type: [Number, String],
      default: 1
    },
    thumbColor: String,
    thumbLabel: {
      type: [Boolean, String],
      default: undefined,
      validator: v => typeof v === 'boolean' || v === 'always'
    },
    thumbSize: {
      type: [Number, String],
      default: 32
    },
    tickLabels: {
      type: Array,
      default: () => []
    },
    ticks: {
      type: [Boolean, String],
      default: false,
      validator: v => typeof v === 'boolean' || v === 'always'
    },
    tickSize: {
      type: [Number, String],
      default: 2
    },
    trackColor: String,
    trackFillColor: String,
    value: [Number, String],
    vertical: Boolean
  },
  data: () => ({
    app: null,
    oldValue: null,
    thumbPressed: false,
    mouseTimeout: -1,
    isFocused: false,
    isActive: false,
    noClick: false,
    startOffset: 0
  }),
  computed: {
    classes() {
      return { ...VInput["b" /* default */].options.computed.classes.call(this),
        'v-input__slider': true,
        'v-input__slider--vertical': this.vertical,
        'v-input__slider--inverse-label': this.inverseLabel
      };
    },

    internalValue: {
      get() {
        return this.lazyValue;
      },

      set(val) {
        val = isNaN(val) ? this.minValue : val; // Round value to ensure the
        // entire slider range can
        // be selected with step

        const value = this.roundValue(Math.min(Math.max(val, this.minValue), this.maxValue));
        if (value === this.lazyValue) return;
        this.lazyValue = value;
        this.$emit('input', value);
      }

    },

    trackTransition() {
      return this.thumbPressed ? this.showTicks || this.stepNumeric ? '0.1s cubic-bezier(0.25, 0.8, 0.5, 1)' : 'none' : '';
    },

    minValue() {
      return parseFloat(this.min);
    },

    maxValue() {
      return parseFloat(this.max);
    },

    stepNumeric() {
      return this.step > 0 ? parseFloat(this.step) : 0;
    },

    inputWidth() {
      const inputWidth = (this.roundValue(this.internalValue) - this.minValue) / (this.maxValue - this.minValue) * 100;
      return isNaN(inputWidth) ? 0 : inputWidth;
    },

    trackFillStyles() {
      const startDir = this.vertical ? 'bottom' : 'left';
      const endDir = this.vertical ? 'top' : 'right';
      const valueDir = this.vertical ? 'height' : 'width';
      const start = this.$vuetify.rtl ? 'auto' : '0';
      const end = this.$vuetify.rtl ? '0' : 'auto';
      const value = this.isDisabled ? `calc(${this.inputWidth}% - 10px)` : `${this.inputWidth}%`;
      return {
        transition: this.trackTransition,
        [startDir]: start,
        [endDir]: end,
        [valueDir]: value
      };
    },

    trackStyles() {
      const startDir = this.vertical ? this.$vuetify.rtl ? 'bottom' : 'top' : this.$vuetify.rtl ? 'left' : 'right';
      const endDir = this.vertical ? 'height' : 'width';
      const start = '0px';
      const end = this.isDisabled ? `calc(${100 - this.inputWidth}% - 10px)` : `calc(${100 - this.inputWidth}%)`;
      return {
        transition: this.trackTransition,
        [startDir]: start,
        [endDir]: end
      };
    },

    showTicks() {
      return this.tickLabels.length > 0 || !!(!this.isDisabled && this.stepNumeric && this.ticks);
    },

    numTicks() {
      return Math.ceil((this.maxValue - this.minValue) / this.stepNumeric);
    },

    showThumbLabel() {
      return !this.isDisabled && !!(this.thumbLabel || this.$scopedSlots['thumb-label']);
    },

    computedTrackColor() {
      if (this.isDisabled) return undefined;
      if (this.trackColor) return this.trackColor;
      if (this.isDark) return this.validationState;
      return this.validationState || 'primary lighten-3';
    },

    computedTrackFillColor() {
      if (this.isDisabled) return undefined;
      if (this.trackFillColor) return this.trackFillColor;
      return this.validationState || this.computedColor;
    },

    computedThumbColor() {
      if (this.thumbColor) return this.thumbColor;
      return this.validationState || this.computedColor;
    }

  },
  watch: {
    min(val) {
      const parsed = parseFloat(val);
      parsed > this.internalValue && this.$emit('input', parsed);
    },

    max(val) {
      const parsed = parseFloat(val);
      parsed < this.internalValue && this.$emit('input', parsed);
    },

    value: {
      handler(v) {
        this.internalValue = v;
      }

    }
  },

  // If done in as immediate in
  // value watcher, causes issues
  // with vue-test-utils
  beforeMount() {
    this.internalValue = this.value;
  },

  mounted() {
    // Without a v-app, iOS does not work with body selectors
    this.app = document.querySelector('[data-app]') || Object(console["c" /* consoleWarn */])('Missing v-app or a non-body wrapping element with the [data-app] attribute', this);
  },

  methods: {
    genDefaultSlot() {
      const children = [this.genLabel()];
      const slider = this.genSlider();
      this.inverseLabel ? children.unshift(slider) : children.push(slider);
      children.push(this.genProgress());
      return children;
    },

    genSlider() {
      return this.$createElement('div', {
        class: {
          'v-slider': true,
          'v-slider--horizontal': !this.vertical,
          'v-slider--vertical': this.vertical,
          'v-slider--focused': this.isFocused,
          'v-slider--active': this.isActive,
          'v-slider--disabled': this.isDisabled,
          'v-slider--readonly': this.isReadonly,
          ...this.themeClasses
        },
        directives: [{
          name: 'click-outside',
          value: this.onBlur
        }],
        on: {
          click: this.onSliderClick,
          mousedown: this.onSliderMouseDown,
          touchstart: this.onSliderMouseDown
        }
      }, this.genChildren());
    },

    genChildren() {
      return [this.genInput(), this.genTrackContainer(), this.genSteps(), this.genThumbContainer(this.internalValue, this.inputWidth, this.isActive, this.isFocused, this.onFocus, this.onBlur)];
    },

    genInput() {
      return this.$createElement('input', {
        attrs: {
          value: this.internalValue,
          id: this.computedId,
          disabled: true,
          readonly: true,
          tabindex: -1,
          ...this.$attrs
        }
      });
    },

    genTrackContainer() {
      const children = [this.$createElement('div', this.setBackgroundColor(this.computedTrackColor, {
        staticClass: 'v-slider__track-background',
        style: this.trackStyles
      })), this.$createElement('div', this.setBackgroundColor(this.computedTrackFillColor, {
        staticClass: 'v-slider__track-fill',
        style: this.trackFillStyles
      }))];
      return this.$createElement('div', {
        staticClass: 'v-slider__track-container',
        ref: 'track'
      }, children);
    },

    genSteps() {
      if (!this.step || !this.showTicks) return null;
      const tickSize = parseFloat(this.tickSize);
      const range = Object(helpers["j" /* createRange */])(this.numTicks + 1);
      const direction = this.vertical ? 'bottom' : this.$vuetify.rtl ? 'right' : 'left';
      const offsetDirection = this.vertical ? this.$vuetify.rtl ? 'left' : 'right' : 'top';
      if (this.vertical) range.reverse();
      const ticks = range.map(index => {
        const children = [];

        if (this.tickLabels[index]) {
          children.push(this.$createElement('div', {
            staticClass: 'v-slider__tick-label'
          }, this.tickLabels[index]));
        }

        const width = index * (100 / this.numTicks);
        const filled = this.$vuetify.rtl ? 100 - this.inputWidth < width : width < this.inputWidth;
        return this.$createElement('span', {
          key: index,
          staticClass: 'v-slider__tick',
          class: {
            'v-slider__tick--filled': filled
          },
          style: {
            width: `${tickSize}px`,
            height: `${tickSize}px`,
            [direction]: `calc(${width}% - ${tickSize / 2}px)`,
            [offsetDirection]: `calc(50% - ${tickSize / 2}px)`
          }
        }, children);
      });
      return this.$createElement('div', {
        staticClass: 'v-slider__ticks-container',
        class: {
          'v-slider__ticks-container--always-show': this.ticks === 'always' || this.tickLabels.length > 0
        }
      }, ticks);
    },

    genThumbContainer(value, valueWidth, isActive, isFocused, onFocus, onBlur, ref = 'thumb') {
      const children = [this.genThumb()];
      const thumbLabelContent = this.genThumbLabelContent(value);
      this.showThumbLabel && children.push(this.genThumbLabel(thumbLabelContent));
      return this.$createElement('div', this.setTextColor(this.computedThumbColor, {
        ref,
        key: ref,
        staticClass: 'v-slider__thumb-container',
        class: {
          'v-slider__thumb-container--active': isActive,
          'v-slider__thumb-container--focused': isFocused,
          'v-slider__thumb-container--show-label': this.showThumbLabel
        },
        style: this.getThumbContainerStyles(valueWidth),
        attrs: {
          role: 'slider',
          tabindex: this.isDisabled ? -1 : this.$attrs.tabindex ? this.$attrs.tabindex : 0,
          'aria-label': this.$attrs['aria-label'] || this.label,
          'aria-valuemin': this.min,
          'aria-valuemax': this.max,
          'aria-valuenow': this.internalValue,
          'aria-readonly': String(this.isReadonly),
          'aria-orientation': this.vertical ? 'vertical' : 'horizontal'
        },
        on: {
          focus: onFocus,
          blur: onBlur,
          keydown: this.onKeyDown
        }
      }), children);
    },

    genThumbLabelContent(value) {
      return this.$scopedSlots['thumb-label'] ? this.$scopedSlots['thumb-label']({
        value
      }) : [this.$createElement('span', [String(value)])];
    },

    genThumbLabel(content) {
      const size = Object(helpers["i" /* convertToUnit */])(this.thumbSize);
      const transform = this.vertical ? `translateY(20%) translateY(${Number(this.thumbSize) / 3 - 1}px) translateX(55%) rotate(135deg)` : `translateY(-20%) translateY(-12px) translateX(-50%) rotate(45deg)`;
      return this.$createElement(transitions["k" /* VScaleTransition */], {
        props: {
          origin: 'bottom center'
        }
      }, [this.$createElement('div', {
        staticClass: 'v-slider__thumb-label-container',
        directives: [{
          name: 'show',
          value: this.isFocused || this.isActive || this.thumbLabel === 'always'
        }]
      }, [this.$createElement('div', this.setBackgroundColor(this.computedThumbColor, {
        staticClass: 'v-slider__thumb-label',
        style: {
          height: size,
          width: size,
          transform
        }
      }), [this.$createElement('div', content)])])]);
    },

    genThumb() {
      return this.$createElement('div', this.setBackgroundColor(this.computedThumbColor, {
        staticClass: 'v-slider__thumb'
      }));
    },

    getThumbContainerStyles(width) {
      const direction = this.vertical ? 'top' : 'left';
      let value = this.$vuetify.rtl ? 100 - width : width;
      value = this.vertical ? 100 - value : value;
      return {
        transition: this.trackTransition,
        [direction]: `${value}%`
      };
    },

    onSliderMouseDown(e) {
      var _e$target;

      e.preventDefault();
      this.oldValue = this.internalValue;
      this.isActive = true;

      if ((_e$target = e.target) != null && _e$target.matches('.v-slider__thumb-container, .v-slider__thumb-container *')) {
        this.thumbPressed = true;
        const domRect = e.target.getBoundingClientRect();
        const touch = 'touches' in e ? e.touches[0] : e;
        this.startOffset = this.vertical ? touch.clientY - (domRect.top + domRect.height / 2) : touch.clientX - (domRect.left + domRect.width / 2);
      } else {
        this.startOffset = 0;
        window.clearTimeout(this.mouseTimeout);
        this.mouseTimeout = window.setTimeout(() => {
          this.thumbPressed = true;
        }, 300);
      }

      const mouseUpOptions = helpers["F" /* passiveSupported */] ? {
        passive: true,
        capture: true
      } : true;
      const mouseMoveOptions = helpers["F" /* passiveSupported */] ? {
        passive: true
      } : false;
      const isTouchEvent = ('touches' in e);
      this.onMouseMove(e);
      this.app.addEventListener(isTouchEvent ? 'touchmove' : 'mousemove', this.onMouseMove, mouseMoveOptions);
      Object(helpers["a" /* addOnceEventListener */])(this.app, isTouchEvent ? 'touchend' : 'mouseup', this.onSliderMouseUp, mouseUpOptions);
      this.$emit('start', this.internalValue);
    },

    onSliderMouseUp(e) {
      e.stopPropagation();
      window.clearTimeout(this.mouseTimeout);
      this.thumbPressed = false;
      const mouseMoveOptions = helpers["F" /* passiveSupported */] ? {
        passive: true
      } : false;
      this.app.removeEventListener('touchmove', this.onMouseMove, mouseMoveOptions);
      this.app.removeEventListener('mousemove', this.onMouseMove, mouseMoveOptions);
      this.$emit('mouseup', e);
      this.$emit('end', this.internalValue);

      if (!Object(helpers["m" /* deepEqual */])(this.oldValue, this.internalValue)) {
        this.$emit('change', this.internalValue);
        this.noClick = true;
      }

      this.isActive = false;
    },

    onMouseMove(e) {
      if (e.type === 'mousemove') {
        this.thumbPressed = true;
      }

      this.internalValue = this.parseMouseMove(e);
    },

    onKeyDown(e) {
      if (!this.isInteractive) return;
      const value = this.parseKeyDown(e, this.internalValue);
      if (value == null || value < this.minValue || value > this.maxValue) return;
      this.internalValue = value;
      this.$emit('change', value);
    },

    onSliderClick(e) {
      if (this.noClick) {
        this.noClick = false;
        return;
      }

      const thumb = this.$refs.thumb;
      thumb.focus();
      this.onMouseMove(e);
      this.$emit('change', this.internalValue);
    },

    onBlur(e) {
      this.isFocused = false;
      this.$emit('blur', e);
    },

    onFocus(e) {
      this.isFocused = true;
      this.$emit('focus', e);
    },

    parseMouseMove(e) {
      const start = this.vertical ? 'top' : 'left';
      const length = this.vertical ? 'height' : 'width';
      const click = this.vertical ? 'clientY' : 'clientX';
      const {
        [start]: trackStart,
        [length]: trackLength
      } = this.$refs.track.getBoundingClientRect();
      const clickOffset = 'touches' in e ? e.touches[0][click] : e[click]; // It is possible for left to be NaN, force to number

      let clickPos = Math.min(Math.max((clickOffset - trackStart - this.startOffset) / trackLength, 0), 1) || 0;
      if (this.vertical) clickPos = 1 - clickPos;
      if (this.$vuetify.rtl) clickPos = 1 - clickPos;
      return parseFloat(this.min) + clickPos * (this.maxValue - this.minValue);
    },

    parseKeyDown(e, value) {
      if (!this.isInteractive) return;
      const {
        pageup,
        pagedown,
        end,
        home,
        left,
        right,
        down,
        up
      } = helpers["B" /* keyCodes */];
      if (![pageup, pagedown, end, home, left, right, down, up].includes(e.keyCode)) return;
      e.preventDefault();
      const step = this.stepNumeric || 1;
      const steps = (this.maxValue - this.minValue) / step;

      if ([left, right, down, up].includes(e.keyCode)) {
        const increase = this.$vuetify.rtl ? [left, up] : [right, up];
        const direction = increase.includes(e.keyCode) ? 1 : -1;
        const multiplier = e.shiftKey ? 3 : e.ctrlKey ? 2 : 1;
        value = value + direction * step * multiplier;
      } else if (e.keyCode === home) {
        value = this.minValue;
      } else if (e.keyCode === end) {
        value = this.maxValue;
      } else {
        const direction = e.keyCode === pagedown ? 1 : -1;
        value = value - direction * step * (steps > 100 ? steps / 10 : 10);
      }

      return value;
    },

    roundValue(value) {
      if (!this.stepNumeric) return value; // Format input value using the same number
      // of decimals places as in the step prop

      const trimmedStep = this.step.toString().trim();
      const decimals = trimmedStep.indexOf('.') > -1 ? trimmedStep.length - trimmedStep.indexOf('.') - 1 : 0;
      const offset = this.minValue % this.stepNumeric;
      const newValue = Math.round((value - offset) / this.stepNumeric) * this.stepNumeric + offset;
      return parseFloat(Math.min(newValue, this.maxValue).toFixed(decimals));
    }

  }
}));
// EXTERNAL MODULE: ./node_modules/vuetify/lib/util/colorUtils.js
var colorUtils = __webpack_require__(18);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VColorPicker/util/index.js
// Utilities

function fromHSVA(hsva) {
  hsva = { ...hsva
  };
  const hexa = Object(colorUtils["c" /* HSVAtoHex */])(hsva);
  const hsla = Object(colorUtils["b" /* HSVAtoHSLA */])(hsva);
  const rgba = Object(colorUtils["d" /* HSVAtoRGBA */])(hsva);
  return {
    alpha: hsva.a,
    hex: hexa.substr(0, 7),
    hexa,
    hsla,
    hsva,
    hue: hsva.h,
    rgba
  };
}
function fromHSLA(hsla) {
  const hsva = Object(colorUtils["a" /* HSLAtoHSVA */])(hsla);
  const hexa = Object(colorUtils["c" /* HSVAtoHex */])(hsva);
  const rgba = Object(colorUtils["d" /* HSVAtoRGBA */])(hsva);
  return {
    alpha: hsva.a,
    hex: hexa.substr(0, 7),
    hexa,
    hsla,
    hsva,
    hue: hsva.h,
    rgba
  };
}
function fromRGBA(rgba) {
  const hsva = Object(colorUtils["g" /* RGBAtoHSVA */])(rgba);
  const hexa = Object(colorUtils["h" /* RGBAtoHex */])(rgba);
  const hsla = Object(colorUtils["b" /* HSVAtoHSLA */])(hsva);
  return {
    alpha: hsva.a,
    hex: hexa.substr(0, 7),
    hexa,
    hsla,
    hsva,
    hue: hsva.h,
    rgba
  };
}
function fromHexa(hexa) {
  const hsva = Object(colorUtils["e" /* HexToHSVA */])(hexa);
  const hsla = Object(colorUtils["b" /* HSVAtoHSLA */])(hsva);
  const rgba = Object(colorUtils["d" /* HSVAtoRGBA */])(hsva);
  return {
    alpha: hsva.a,
    hex: hexa.substr(0, 7),
    hexa,
    hsla,
    hsva,
    hue: hsva.h,
    rgba
  };
}
function fromHex(hex) {
  return fromHexa(Object(colorUtils["o" /* parseHex */])(hex));
}

function has(obj, key) {
  return key.every(k => obj.hasOwnProperty(k));
}

function parseColor(color, oldColor) {
  if (!color) return fromRGBA({
    r: 255,
    g: 0,
    b: 0,
    a: 1
  });

  if (typeof color === 'string') {
    if (color === 'transparent') return fromHexa('#00000000');
    const hex = Object(colorUtils["o" /* parseHex */])(color);
    if (oldColor && hex === oldColor.hexa) return oldColor;else return fromHexa(hex);
  }

  if (typeof color === 'object') {
    if (color.hasOwnProperty('alpha')) return color;
    const a = color.hasOwnProperty('a') ? parseFloat(color.a) : 1;

    if (has(color, ['r', 'g', 'b'])) {
      if (oldColor && color === oldColor.rgba) return oldColor;else return fromRGBA({ ...color,
        a
      });
    } else if (has(color, ['h', 's', 'l'])) {
      if (oldColor && color === oldColor.hsla) return oldColor;else return fromHSLA({ ...color,
        a
      });
    } else if (has(color, ['h', 's', 'v'])) {
      if (oldColor && color === oldColor.hsva) return oldColor;else return fromHSVA({ ...color,
        a
      });
    }
  }

  return fromRGBA({
    r: 255,
    g: 0,
    b: 0,
    a: 1
  });
}

function stripAlpha(color, stripAlpha) {
  if (stripAlpha) {
    const {
      a,
      ...rest
    } = color;
    return rest;
  }

  return color;
}

function extractColor(color, input) {
  if (input == null) return color;

  if (typeof input === 'string') {
    return input.length === 7 ? color.hex : color.hexa;
  }

  if (typeof input === 'object') {
    const shouldStrip = typeof input.a === 'number' && input.a === 0 ? !!input.a : !input.a;
    if (has(input, ['r', 'g', 'b'])) return stripAlpha(color.rgba, shouldStrip);else if (has(input, ['h', 's', 'l'])) return stripAlpha(color.hsla, shouldStrip);else if (has(input, ['h', 's', 'v'])) return stripAlpha(color.hsva, shouldStrip);
  }

  return color;
}
function hasAlpha(color) {
  if (!color) return false;

  if (typeof color === 'string') {
    return color.length > 7;
  }

  if (typeof color === 'object') {
    return has(color, ['a']) || has(color, ['alpha']);
  }

  return false;
}
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VColorPicker/VColorPickerPreview.js
// Styles
 // Components

 // Utilities

 // Types



/* harmony default export */ var VColorPicker_VColorPickerPreview = (external_vue_default.a.extend({
  name: 'v-color-picker-preview',
  props: {
    color: Object,
    disabled: Boolean,
    hideAlpha: Boolean
  },
  methods: {
    genAlpha() {
      return this.genTrack({
        staticClass: 'v-color-picker__alpha',
        props: {
          thumbColor: 'grey lighten-2',
          hideDetails: true,
          value: this.color.alpha,
          step: 0,
          min: 0,
          max: 1
        },
        style: {
          backgroundImage: this.disabled ? undefined : `linear-gradient(to ${this.$vuetify.rtl ? 'left' : 'right'}, transparent, ${Object(colorUtils["i" /* RGBtoCSS */])(this.color.rgba)})`
        },
        on: {
          input: val => this.color.alpha !== val && this.$emit('update:color', fromHSVA({ ...this.color.hsva,
            a: val
          }))
        }
      });
    },

    genSliders() {
      return this.$createElement('div', {
        staticClass: 'v-color-picker__sliders'
      }, [this.genHue(), !this.hideAlpha && this.genAlpha()]);
    },

    genDot() {
      return this.$createElement('div', {
        staticClass: 'v-color-picker__dot'
      }, [this.$createElement('div', {
        style: {
          background: Object(colorUtils["f" /* RGBAtoCSS */])(this.color.rgba)
        }
      })]);
    },

    genHue() {
      return this.genTrack({
        staticClass: 'v-color-picker__hue',
        props: {
          thumbColor: 'grey lighten-2',
          hideDetails: true,
          value: this.color.hue,
          step: 0,
          min: 0,
          max: 360
        },
        on: {
          input: val => this.color.hue !== val && this.$emit('update:color', fromHSVA({ ...this.color.hsva,
            h: val
          }))
        }
      });
    },

    genTrack(options) {
      return this.$createElement(VSlider_VSlider, {
        class: 'v-color-picker__track',
        ...options,
        props: {
          disabled: this.disabled,
          ...options.props
        }
      });
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'v-color-picker__preview',
      class: {
        'v-color-picker__preview--hide-alpha': this.hideAlpha
      }
    }, [this.genDot(), this.genSliders()]);
  }

}));
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VColorPicker/VColorPickerCanvas.sass
var VColorPickerCanvas = __webpack_require__(445);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VColorPicker/VColorPickerCanvas.js
// Styles
 // Helpers


 // Types


/* harmony default export */ var VColorPicker_VColorPickerCanvas = (external_vue_default.a.extend({
  name: 'v-color-picker-canvas',
  props: {
    color: {
      type: Object,
      default: () => fromRGBA({
        r: 255,
        g: 0,
        b: 0,
        a: 1
      })
    },
    disabled: Boolean,
    dotSize: {
      type: [Number, String],
      default: 10
    },
    height: {
      type: [Number, String],
      default: 150
    },
    width: {
      type: [Number, String],
      default: 300
    }
  },

  data() {
    return {
      boundingRect: {
        width: 0,
        height: 0,
        left: 0,
        top: 0
      }
    };
  },

  computed: {
    dot() {
      if (!this.color) return {
        x: 0,
        y: 0
      };
      return {
        x: this.color.hsva.s * parseInt(this.width, 10),
        y: (1 - this.color.hsva.v) * parseInt(this.height, 10)
      };
    }

  },
  watch: {
    'color.hue': 'updateCanvas'
  },

  mounted() {
    this.updateCanvas();
  },

  methods: {
    emitColor(x, y) {
      const {
        left,
        top,
        width,
        height
      } = this.boundingRect;
      this.$emit('update:color', fromHSVA({
        h: this.color.hue,
        s: Object(helpers["g" /* clamp */])(x - left, 0, width) / width,
        v: 1 - Object(helpers["g" /* clamp */])(y - top, 0, height) / height,
        a: this.color.alpha
      }));
    },

    updateCanvas() {
      if (!this.color) return;
      const canvas = this.$refs.canvas;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      const saturationGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
      saturationGradient.addColorStop(0, 'hsla(0, 0%, 100%, 1)'); // white

      saturationGradient.addColorStop(1, `hsla(${this.color.hue}, 100%, 50%, 1)`);
      ctx.fillStyle = saturationGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const valueGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      valueGradient.addColorStop(0, 'hsla(0, 0%, 100%, 0)'); // transparent

      valueGradient.addColorStop(1, 'hsla(0, 0%, 0%, 1)'); // black

      ctx.fillStyle = valueGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    },

    handleClick(e) {
      if (this.disabled) return;
      this.boundingRect = this.$el.getBoundingClientRect();
      this.emitColor(e.clientX, e.clientY);
    },

    handleMouseDown(e) {
      // To prevent selection while moving cursor
      e.preventDefault();
      if (this.disabled) return;
      this.boundingRect = this.$el.getBoundingClientRect();
      window.addEventListener('mousemove', this.handleMouseMove);
      window.addEventListener('mouseup', this.handleMouseUp);
    },

    handleMouseMove(e) {
      if (this.disabled) return;
      this.emitColor(e.clientX, e.clientY);
    },

    handleMouseUp() {
      window.removeEventListener('mousemove', this.handleMouseMove);
      window.removeEventListener('mouseup', this.handleMouseUp);
    },

    genCanvas() {
      return this.$createElement('canvas', {
        ref: 'canvas',
        attrs: {
          width: this.width,
          height: this.height
        }
      });
    },

    genDot() {
      const radius = parseInt(this.dotSize, 10) / 2;
      const x = Object(helpers["i" /* convertToUnit */])(this.dot.x - radius);
      const y = Object(helpers["i" /* convertToUnit */])(this.dot.y - radius);
      return this.$createElement('div', {
        staticClass: 'v-color-picker__canvas-dot',
        class: {
          'v-color-picker__canvas-dot--disabled': this.disabled
        },
        style: {
          width: Object(helpers["i" /* convertToUnit */])(this.dotSize),
          height: Object(helpers["i" /* convertToUnit */])(this.dotSize),
          transform: `translate(${x}, ${y})`
        }
      });
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'v-color-picker__canvas',
      style: {
        width: Object(helpers["i" /* convertToUnit */])(this.width),
        height: Object(helpers["i" /* convertToUnit */])(this.height)
      },
      on: {
        click: this.handleClick,
        mousedown: this.handleMouseDown
      }
    }, [this.genCanvas(), this.genDot()]);
  }

}));
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VColorPicker/VColorPickerEdit.sass
var VColorPickerEdit = __webpack_require__(444);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VColorPicker/VColorPickerEdit.js
// Styles
 // Components


 // Helpers

 // Types



const modes = {
  rgba: {
    inputs: [['r', 255, 'int'], ['g', 255, 'int'], ['b', 255, 'int'], ['a', 1, 'float']],
    from: fromRGBA
  },
  hsla: {
    inputs: [['h', 360, 'int'], ['s', 1, 'float'], ['l', 1, 'float'], ['a', 1, 'float']],
    from: fromHSLA
  },
  hexa: {
    from: fromHexa
  }
};
/* harmony default export */ var VColorPicker_VColorPickerEdit = (external_vue_default.a.extend({
  name: 'v-color-picker-edit',
  props: {
    color: Object,
    disabled: Boolean,
    hideAlpha: Boolean,
    hideModeSwitch: Boolean,
    mode: {
      type: String,
      default: 'rgba',
      validator: v => Object.keys(modes).includes(v)
    }
  },

  data() {
    return {
      modes,
      internalMode: this.mode
    };
  },

  computed: {
    currentMode() {
      return this.modes[this.internalMode];
    }

  },
  watch: {
    mode(mode) {
      this.internalMode = mode;
    }

  },

  created() {
    this.internalMode = this.mode;
  },

  methods: {
    getValue(v, type) {
      if (type === 'float') return Math.round(v * 100) / 100;else if (type === 'int') return Math.round(v);else return 0;
    },

    parseValue(v, type) {
      if (type === 'float') return parseFloat(v);else if (type === 'int') return parseInt(v, 10) || 0;else return 0;
    },

    changeMode() {
      const modes = Object.keys(this.modes);
      const index = modes.indexOf(this.internalMode);
      const newMode = modes[(index + 1) % modes.length];
      this.internalMode = newMode;
      this.$emit('update:mode', newMode);
    },

    genInput(target, attrs, value, on) {
      return this.$createElement('div', {
        staticClass: 'v-color-picker__input'
      }, [this.$createElement('input', {
        key: target,
        attrs,
        domProps: {
          value
        },
        on
      }), this.$createElement('span', target.toUpperCase())]);
    },

    genInputs() {
      if (this.internalMode === 'hexa') {
        const hex = this.color.hexa;
        const value = this.hideAlpha && hex.endsWith('FF') ? hex.substr(0, 7) : hex;
        return this.genInput('hex', {
          maxlength: this.hideAlpha ? 7 : 9,
          disabled: this.disabled
        }, value, {
          change: e => {
            const el = e.target;
            this.$emit('update:color', this.currentMode.from(Object(colorUtils["o" /* parseHex */])(el.value)));
          }
        });
      } else {
        const inputs = this.hideAlpha ? this.currentMode.inputs.slice(0, -1) : this.currentMode.inputs;
        return inputs.map(([target, max, type]) => {
          const value = this.color[this.internalMode];
          return this.genInput(target, {
            type: 'number',
            min: 0,
            max,
            step: type === 'float' ? '0.01' : type === 'int' ? '1' : undefined,
            disabled: this.disabled
          }, this.getValue(value[target], type), {
            input: e => {
              const el = e.target;
              const newVal = this.parseValue(el.value || '0', type);
              this.$emit('update:color', this.currentMode.from(Object.assign({}, value, {
                [target]: newVal
              }), this.color.alpha));
            }
          });
        });
      }
    },

    genSwitch() {
      return this.$createElement(VBtn["b" /* default */], {
        props: {
          small: true,
          icon: true,
          disabled: this.disabled
        },
        on: {
          click: this.changeMode
        }
      }, [this.$createElement(VIcon["b" /* default */], '$unfold')]);
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'v-color-picker__edit'
    }, [this.genInputs(), !this.hideModeSwitch && this.genSwitch()]);
  }

}));
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VColorPicker/VColorPickerSwatches.sass
var VColorPickerSwatches = __webpack_require__(448);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/util/colors.js
const red = Object.freeze({
  base: '#f44336',
  lighten5: '#ffebee',
  lighten4: '#ffcdd2',
  lighten3: '#ef9a9a',
  lighten2: '#e57373',
  lighten1: '#ef5350',
  darken1: '#e53935',
  darken2: '#d32f2f',
  darken3: '#c62828',
  darken4: '#b71c1c',
  accent1: '#ff8a80',
  accent2: '#ff5252',
  accent3: '#ff1744',
  accent4: '#d50000'
});
const pink = Object.freeze({
  base: '#e91e63',
  lighten5: '#fce4ec',
  lighten4: '#f8bbd0',
  lighten3: '#f48fb1',
  lighten2: '#f06292',
  lighten1: '#ec407a',
  darken1: '#d81b60',
  darken2: '#c2185b',
  darken3: '#ad1457',
  darken4: '#880e4f',
  accent1: '#ff80ab',
  accent2: '#ff4081',
  accent3: '#f50057',
  accent4: '#c51162'
});
const purple = Object.freeze({
  base: '#9c27b0',
  lighten5: '#f3e5f5',
  lighten4: '#e1bee7',
  lighten3: '#ce93d8',
  lighten2: '#ba68c8',
  lighten1: '#ab47bc',
  darken1: '#8e24aa',
  darken2: '#7b1fa2',
  darken3: '#6a1b9a',
  darken4: '#4a148c',
  accent1: '#ea80fc',
  accent2: '#e040fb',
  accent3: '#d500f9',
  accent4: '#aa00ff'
});
const deepPurple = Object.freeze({
  base: '#673ab7',
  lighten5: '#ede7f6',
  lighten4: '#d1c4e9',
  lighten3: '#b39ddb',
  lighten2: '#9575cd',
  lighten1: '#7e57c2',
  darken1: '#5e35b1',
  darken2: '#512da8',
  darken3: '#4527a0',
  darken4: '#311b92',
  accent1: '#b388ff',
  accent2: '#7c4dff',
  accent3: '#651fff',
  accent4: '#6200ea'
});
const indigo = Object.freeze({
  base: '#3f51b5',
  lighten5: '#e8eaf6',
  lighten4: '#c5cae9',
  lighten3: '#9fa8da',
  lighten2: '#7986cb',
  lighten1: '#5c6bc0',
  darken1: '#3949ab',
  darken2: '#303f9f',
  darken3: '#283593',
  darken4: '#1a237e',
  accent1: '#8c9eff',
  accent2: '#536dfe',
  accent3: '#3d5afe',
  accent4: '#304ffe'
});
const blue = Object.freeze({
  base: '#2196f3',
  lighten5: '#e3f2fd',
  lighten4: '#bbdefb',
  lighten3: '#90caf9',
  lighten2: '#64b5f6',
  lighten1: '#42a5f5',
  darken1: '#1e88e5',
  darken2: '#1976d2',
  darken3: '#1565c0',
  darken4: '#0d47a1',
  accent1: '#82b1ff',
  accent2: '#448aff',
  accent3: '#2979ff',
  accent4: '#2962ff'
});
const lightBlue = Object.freeze({
  base: '#03a9f4',
  lighten5: '#e1f5fe',
  lighten4: '#b3e5fc',
  lighten3: '#81d4fa',
  lighten2: '#4fc3f7',
  lighten1: '#29b6f6',
  darken1: '#039be5',
  darken2: '#0288d1',
  darken3: '#0277bd',
  darken4: '#01579b',
  accent1: '#80d8ff',
  accent2: '#40c4ff',
  accent3: '#00b0ff',
  accent4: '#0091ea'
});
const cyan = Object.freeze({
  base: '#00bcd4',
  lighten5: '#e0f7fa',
  lighten4: '#b2ebf2',
  lighten3: '#80deea',
  lighten2: '#4dd0e1',
  lighten1: '#26c6da',
  darken1: '#00acc1',
  darken2: '#0097a7',
  darken3: '#00838f',
  darken4: '#006064',
  accent1: '#84ffff',
  accent2: '#18ffff',
  accent3: '#00e5ff',
  accent4: '#00b8d4'
});
const teal = Object.freeze({
  base: '#009688',
  lighten5: '#e0f2f1',
  lighten4: '#b2dfdb',
  lighten3: '#80cbc4',
  lighten2: '#4db6ac',
  lighten1: '#26a69a',
  darken1: '#00897b',
  darken2: '#00796b',
  darken3: '#00695c',
  darken4: '#004d40',
  accent1: '#a7ffeb',
  accent2: '#64ffda',
  accent3: '#1de9b6',
  accent4: '#00bfa5'
});
const green = Object.freeze({
  base: '#4caf50',
  lighten5: '#e8f5e9',
  lighten4: '#c8e6c9',
  lighten3: '#a5d6a7',
  lighten2: '#81c784',
  lighten1: '#66bb6a',
  darken1: '#43a047',
  darken2: '#388e3c',
  darken3: '#2e7d32',
  darken4: '#1b5e20',
  accent1: '#b9f6ca',
  accent2: '#69f0ae',
  accent3: '#00e676',
  accent4: '#00c853'
});
const lightGreen = Object.freeze({
  base: '#8bc34a',
  lighten5: '#f1f8e9',
  lighten4: '#dcedc8',
  lighten3: '#c5e1a5',
  lighten2: '#aed581',
  lighten1: '#9ccc65',
  darken1: '#7cb342',
  darken2: '#689f38',
  darken3: '#558b2f',
  darken4: '#33691e',
  accent1: '#ccff90',
  accent2: '#b2ff59',
  accent3: '#76ff03',
  accent4: '#64dd17'
});
const lime = Object.freeze({
  base: '#cddc39',
  lighten5: '#f9fbe7',
  lighten4: '#f0f4c3',
  lighten3: '#e6ee9c',
  lighten2: '#dce775',
  lighten1: '#d4e157',
  darken1: '#c0ca33',
  darken2: '#afb42b',
  darken3: '#9e9d24',
  darken4: '#827717',
  accent1: '#f4ff81',
  accent2: '#eeff41',
  accent3: '#c6ff00',
  accent4: '#aeea00'
});
const yellow = Object.freeze({
  base: '#ffeb3b',
  lighten5: '#fffde7',
  lighten4: '#fff9c4',
  lighten3: '#fff59d',
  lighten2: '#fff176',
  lighten1: '#ffee58',
  darken1: '#fdd835',
  darken2: '#fbc02d',
  darken3: '#f9a825',
  darken4: '#f57f17',
  accent1: '#ffff8d',
  accent2: '#ffff00',
  accent3: '#ffea00',
  accent4: '#ffd600'
});
const amber = Object.freeze({
  base: '#ffc107',
  lighten5: '#fff8e1',
  lighten4: '#ffecb3',
  lighten3: '#ffe082',
  lighten2: '#ffd54f',
  lighten1: '#ffca28',
  darken1: '#ffb300',
  darken2: '#ffa000',
  darken3: '#ff8f00',
  darken4: '#ff6f00',
  accent1: '#ffe57f',
  accent2: '#ffd740',
  accent3: '#ffc400',
  accent4: '#ffab00'
});
const orange = Object.freeze({
  base: '#ff9800',
  lighten5: '#fff3e0',
  lighten4: '#ffe0b2',
  lighten3: '#ffcc80',
  lighten2: '#ffb74d',
  lighten1: '#ffa726',
  darken1: '#fb8c00',
  darken2: '#f57c00',
  darken3: '#ef6c00',
  darken4: '#e65100',
  accent1: '#ffd180',
  accent2: '#ffab40',
  accent3: '#ff9100',
  accent4: '#ff6d00'
});
const deepOrange = Object.freeze({
  base: '#ff5722',
  lighten5: '#fbe9e7',
  lighten4: '#ffccbc',
  lighten3: '#ffab91',
  lighten2: '#ff8a65',
  lighten1: '#ff7043',
  darken1: '#f4511e',
  darken2: '#e64a19',
  darken3: '#d84315',
  darken4: '#bf360c',
  accent1: '#ff9e80',
  accent2: '#ff6e40',
  accent3: '#ff3d00',
  accent4: '#dd2c00'
});
const brown = Object.freeze({
  base: '#795548',
  lighten5: '#efebe9',
  lighten4: '#d7ccc8',
  lighten3: '#bcaaa4',
  lighten2: '#a1887f',
  lighten1: '#8d6e63',
  darken1: '#6d4c41',
  darken2: '#5d4037',
  darken3: '#4e342e',
  darken4: '#3e2723'
});
const blueGrey = Object.freeze({
  base: '#607d8b',
  lighten5: '#eceff1',
  lighten4: '#cfd8dc',
  lighten3: '#b0bec5',
  lighten2: '#90a4ae',
  lighten1: '#78909c',
  darken1: '#546e7a',
  darken2: '#455a64',
  darken3: '#37474f',
  darken4: '#263238'
});
const grey = Object.freeze({
  base: '#9e9e9e',
  lighten5: '#fafafa',
  lighten4: '#f5f5f5',
  lighten3: '#eeeeee',
  lighten2: '#e0e0e0',
  lighten1: '#bdbdbd',
  darken1: '#757575',
  darken2: '#616161',
  darken3: '#424242',
  darken4: '#212121'
});
const shades = Object.freeze({
  black: '#000000',
  white: '#ffffff',
  transparent: 'transparent'
});
/* harmony default export */ var colors = (Object.freeze({
  red,
  pink,
  purple,
  deepPurple,
  indigo,
  blue,
  lightBlue,
  cyan,
  teal,
  green,
  lightGreen,
  lime,
  yellow,
  amber,
  orange,
  deepOrange,
  brown,
  blueGrey,
  grey,
  shades
}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VColorPicker/VColorPickerSwatches.js
// Styles
 // Components

 // Helpers








function parseDefaultColors(colors) {
  return Object.keys(colors).map(key => {
    const color = colors[key];
    return color.base ? [color.base, color.darken4, color.darken3, color.darken2, color.darken1, color.lighten1, color.lighten2, color.lighten3, color.lighten4, color.lighten5] : [color.black, color.white, color.transparent];
  });
}

const white = fromHex('#FFFFFF').rgba;
const black = fromHex('#000000').rgba;
/* harmony default export */ var VColorPicker_VColorPickerSwatches = (Object(mixins["a" /* default */])(themeable["a" /* default */]).extend({
  name: 'v-color-picker-swatches',
  props: {
    swatches: {
      type: Array,
      default: () => parseDefaultColors(colors)
    },
    disabled: Boolean,
    color: Object,
    maxWidth: [Number, String],
    maxHeight: [Number, String]
  },
  methods: {
    genColor(color) {
      const content = this.$createElement('div', {
        style: {
          background: color
        }
      }, [Object(helpers["m" /* deepEqual */])(this.color, parseColor(color, null)) && this.$createElement(VIcon["b" /* default */], {
        props: {
          small: true,
          dark: Object(colorUtils["l" /* contrastRatio */])(this.color.rgba, white) > 2 && this.color.alpha > 0.5,
          light: Object(colorUtils["l" /* contrastRatio */])(this.color.rgba, black) > 2 && this.color.alpha > 0.5
        }
      }, '$success')]);
      return this.$createElement('div', {
        staticClass: 'v-color-picker__color',
        on: {
          // TODO: Less hacky way of catching transparent
          click: () => this.disabled || this.$emit('update:color', fromHex(color === 'transparent' ? '#00000000' : color))
        }
      }, [content]);
    },

    genSwatches() {
      return this.swatches.map(swatch => {
        const colors = swatch.map(this.genColor);
        return this.$createElement('div', {
          staticClass: 'v-color-picker__swatch'
        }, colors);
      });
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'v-color-picker__swatches',
      style: {
        maxWidth: Object(helpers["i" /* convertToUnit */])(this.maxWidth),
        maxHeight: Object(helpers["i" /* convertToUnit */])(this.maxHeight)
      }
    }, [this.$createElement('div', this.genSwatches())]);
  }

}));
// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/elevatable/index.js
var elevatable = __webpack_require__(57);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VColorPicker/VColorPicker.js
// Styles
 // Components





 // Helpers



 // Mixins



/* harmony default export */ var VColorPicker_VColorPicker = (Object(mixins["a" /* default */])(elevatable["a" /* default */], themeable["a" /* default */]).extend({
  name: 'v-color-picker',
  props: {
    canvasHeight: {
      type: [String, Number],
      default: 150
    },
    disabled: Boolean,
    dotSize: {
      type: [Number, String],
      default: 10
    },
    flat: Boolean,
    hideCanvas: Boolean,
    hideSliders: Boolean,
    hideInputs: Boolean,
    hideModeSwitch: Boolean,
    mode: {
      type: String,
      default: 'rgba',
      validator: v => Object.keys(modes).includes(v)
    },
    showSwatches: Boolean,
    swatches: Array,
    swatchesMaxHeight: {
      type: [Number, String],
      default: 150
    },
    value: {
      type: [Object, String]
    },
    width: {
      type: [Number, String],
      default: 300
    }
  },
  data: () => ({
    internalValue: fromRGBA({
      r: 255,
      g: 0,
      b: 0,
      a: 1
    })
  }),
  computed: {
    hideAlpha() {
      if (!this.value) return false;
      return !hasAlpha(this.value);
    }

  },
  watch: {
    value: {
      handler(color) {
        this.updateColor(parseColor(color, this.internalValue));
      },

      immediate: true
    }
  },
  methods: {
    updateColor(color) {
      this.internalValue = color;
      const value = extractColor(this.internalValue, this.value);

      if (!Object(helpers["m" /* deepEqual */])(value, this.value)) {
        this.$emit('input', value);
        this.$emit('update:color', this.internalValue);
      }
    },

    genCanvas() {
      return this.$createElement(VColorPicker_VColorPickerCanvas, {
        props: {
          color: this.internalValue,
          disabled: this.disabled,
          dotSize: this.dotSize,
          width: this.width,
          height: this.canvasHeight
        },
        on: {
          'update:color': this.updateColor
        }
      });
    },

    genControls() {
      return this.$createElement('div', {
        staticClass: 'v-color-picker__controls'
      }, [!this.hideSliders && this.genPreview(), !this.hideInputs && this.genEdit()]);
    },

    genEdit() {
      return this.$createElement(VColorPicker_VColorPickerEdit, {
        props: {
          color: this.internalValue,
          disabled: this.disabled,
          hideAlpha: this.hideAlpha,
          hideModeSwitch: this.hideModeSwitch,
          mode: this.mode
        },
        on: {
          'update:color': this.updateColor,
          'update:mode': v => this.$emit('update:mode', v)
        }
      });
    },

    genPreview() {
      return this.$createElement(VColorPicker_VColorPickerPreview, {
        props: {
          color: this.internalValue,
          disabled: this.disabled,
          hideAlpha: this.hideAlpha
        },
        on: {
          'update:color': this.updateColor
        }
      });
    },

    genSwatches() {
      return this.$createElement(VColorPicker_VColorPickerSwatches, {
        props: {
          dark: this.dark,
          light: this.light,
          disabled: this.disabled,
          swatches: this.swatches,
          color: this.internalValue,
          maxHeight: this.swatchesMaxHeight
        },
        on: {
          'update:color': this.updateColor
        }
      });
    }

  },

  render(h) {
    return h(VSheet_VSheet["a" /* default */], {
      staticClass: 'v-color-picker',
      class: {
        'v-color-picker--flat': this.flat,
        ...this.themeClasses,
        ...this.elevationClasses
      },
      props: {
        maxWidth: this.width
      }
    }, [!this.hideCanvas && this.genCanvas(), (!this.hideSliders || !this.hideInputs) && this.genControls(), this.showSwatches && this.genSwatches()]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VColorPicker/index.js




/* harmony default export */ var components_VColorPicker = (VColorPicker_VColorPicker);
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VMain/VMain.js
var VMain = __webpack_require__(206);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VContent/VContent.js
// Extensions


/* @vue/component */

/* harmony default export */ var VContent = (VMain["a" /* default */].extend({
  name: 'v-main',

  created() {
    Object(console["d" /* deprecate */])('v-content', 'v-main', this);
  },

  render(h) {
    // Add the legacy class names
    const node = VMain["a" /* default */].options.render.call(this, h);
    node.data.staticClass += ' v-content';
    node.children[0].data.staticClass += ' v-content__wrap';
    return h(node.tag, node.data, node.children);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VContent/index.js


/* harmony default export */ var components_VContent = (VContent);
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCombobox/VCombobox.js
// Styles
 // Extensions


 // Utils


/* @vue/component */

/* harmony default export */ var VCombobox = (VAutocomplete_VAutocomplete.extend({
  name: 'v-combobox',
  props: {
    delimiters: {
      type: Array,
      default: () => []
    },
    returnObject: {
      type: Boolean,
      default: true
    }
  },
  data: () => ({
    editingIndex: -1
  }),
  computed: {
    computedCounterValue() {
      return this.multiple ? this.selectedItems.length : (this.internalSearch || '').toString().length;
    },

    hasSlot() {
      return VSelect["a" /* default */].options.computed.hasSlot.call(this) || this.multiple;
    },

    isAnyValueAllowed() {
      return true;
    },

    menuCanShow() {
      if (!this.isFocused) return false;
      return this.hasDisplayedItems || !!this.$slots['no-data'] && !this.hideNoData;
    },

    searchIsDirty() {
      return this.internalSearch != null;
    }

  },
  methods: {
    onInternalSearchChanged(val) {
      if (val && this.multiple && this.delimiters.length) {
        const delimiter = this.delimiters.find(d => val.endsWith(d));

        if (delimiter != null) {
          this.internalSearch = val.slice(0, val.length - delimiter.length);
          this.updateTags();
        }
      }

      this.updateMenuDimensions();
    },

    genInput() {
      const input = VAutocomplete_VAutocomplete.options.methods.genInput.call(this);
      delete input.data.attrs.name;
      input.data.on.paste = this.onPaste;
      return input;
    },

    genChipSelection(item, index) {
      const chip = VSelect["a" /* default */].options.methods.genChipSelection.call(this, item, index); // Allow user to update an existing value

      if (this.multiple) {
        chip.componentOptions.listeners = { ...chip.componentOptions.listeners,
          dblclick: () => {
            this.editingIndex = index;
            this.internalSearch = this.getText(item);
            this.selectedIndex = -1;
          }
        };
      }

      return chip;
    },

    onChipInput(item) {
      VSelect["a" /* default */].options.methods.onChipInput.call(this, item);
      this.editingIndex = -1;
    },

    // Requires a manual definition
    // to overwrite removal in v-autocomplete
    onEnterDown(e) {
      e.preventDefault(); // If has menu index, let v-select-list handle

      if (this.getMenuIndex() > -1) return;
      this.$nextTick(this.updateSelf);
    },

    onKeyDown(e) {
      const keyCode = e.keyCode;

      if (e.ctrlKey || ![helpers["B" /* keyCodes */].home, helpers["B" /* keyCodes */].end].includes(keyCode)) {
        VSelect["a" /* default */].options.methods.onKeyDown.call(this, e);
      } // If user is at selection index of 0
      // create a new tag


      if (this.multiple && keyCode === helpers["B" /* keyCodes */].left && this.$refs.input.selectionStart === 0) {
        this.updateSelf();
      } else if (keyCode === helpers["B" /* keyCodes */].enter) {
        this.onEnterDown(e);
      } // The ordering is important here
      // allows new value to be updated
      // and then moves the index to the
      // proper location


      this.changeSelectedIndex(keyCode);
    },

    onTabDown(e) {
      // When adding tags, if searching and
      // there is not a filtered options,
      // add the value to the tags list
      if (this.multiple && this.internalSearch && this.getMenuIndex() === -1) {
        e.preventDefault();
        e.stopPropagation();
        return this.updateTags();
      }

      VAutocomplete_VAutocomplete.options.methods.onTabDown.call(this, e);
    },

    selectItem(item) {
      // Currently only supports items:<string[]>
      if (this.editingIndex > -1) {
        this.updateEditing();
      } else {
        VAutocomplete_VAutocomplete.options.methods.selectItem.call(this, item); // if selected item contains search value,
        // remove the search string

        if (this.internalSearch && this.multiple && this.getText(item).toLocaleLowerCase().includes(this.internalSearch.toLocaleLowerCase())) {
          this.internalSearch = null;
        }
      }
    },

    setSelectedItems() {
      if (this.internalValue == null || this.internalValue === '') {
        this.selectedItems = [];
      } else {
        this.selectedItems = this.multiple ? this.internalValue : [this.internalValue];
      }
    },

    setValue(value) {
      VSelect["a" /* default */].options.methods.setValue.call(this, value != null ? value : this.internalSearch);
    },

    updateEditing() {
      const value = this.internalValue.slice();
      const index = this.selectedItems.findIndex(item => this.getText(item) === this.internalSearch); // If user enters a duplicate text on chip edit,
      // don't add it, move it to the end of the list

      if (index > -1) {
        const item = typeof value[index] === 'object' ? Object.assign({}, value[index]) : value[index];
        value.splice(index, 1);
        value.push(item);
      } else {
        value[this.editingIndex] = this.internalSearch;
      }

      this.setValue(value);
      this.editingIndex = -1;
      this.internalSearch = null;
    },

    updateCombobox() {
      // If search is not dirty, do nothing
      if (!this.searchIsDirty) return; // The internal search is not matching
      // the internal value, update the input

      if (this.internalSearch !== this.getText(this.internalValue)) this.setValue(); // Reset search if using slot to avoid a double input

      const isUsingSlot = Boolean(this.$scopedSlots.selection) || this.hasChips;
      if (isUsingSlot) this.internalSearch = null;
    },

    updateSelf() {
      this.multiple ? this.updateTags() : this.updateCombobox();
    },

    updateTags() {
      const menuIndex = this.getMenuIndex(); // If the user is not searching
      // and no menu item is selected
      // or if the search is empty
      // do nothing

      if (menuIndex < 0 && !this.searchIsDirty || !this.internalSearch) return;

      if (this.editingIndex > -1) {
        return this.updateEditing();
      }

      const index = this.selectedItems.findIndex(item => this.internalSearch === this.getText(item)); // If the duplicate item is an object,
      // copy it, so that it can be added again later

      const itemToSelect = index > -1 && typeof this.selectedItems[index] === 'object' ? Object.assign({}, this.selectedItems[index]) : this.internalSearch; // If it already exists, do nothing
      // this might need to change to bring
      // the duplicated item to the last entered

      if (index > -1) {
        const internalValue = this.internalValue.slice();
        internalValue.splice(index, 1);
        this.setValue(internalValue);
      } // If menu index is greater than 1
      // the selection is handled elsewhere
      // TODO: find out where


      if (menuIndex > -1) return this.internalSearch = null;
      this.selectItem(itemToSelect);
      this.internalSearch = null;
    },

    onPaste(event) {
      var _event$clipboardData;

      if (!this.multiple || this.searchIsDirty) return;
      const pastedItemText = (_event$clipboardData = event.clipboardData) == null ? void 0 : _event$clipboardData.getData('text/vnd.vuetify.autocomplete.item+plain');

      if (pastedItemText && this.findExistingIndex(pastedItemText) === -1) {
        event.preventDefault();
        VSelect["a" /* default */].options.methods.selectItem.call(this, pastedItemText);
      }
    },

    clearableCallback() {
      this.editingIndex = -1;
      VAutocomplete_VAutocomplete.options.methods.clearableCallback.call(this);
    }

  }
}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VCombobox/index.js


/* harmony default export */ var components_VCombobox = (VCombobox);
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VCounter/index.js + 1 modules
var VCounter = __webpack_require__(101);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VData/VData.js
// Helpers


/* harmony default export */ var VData = (external_vue_default.a.extend({
  name: 'v-data',
  inheritAttrs: false,
  props: {
    items: {
      type: Array,
      default: () => []
    },
    options: {
      type: Object,
      default: () => ({})
    },
    sortBy: {
      type: [String, Array],
      default: () => []
    },
    sortDesc: {
      type: [Boolean, Array],
      default: () => []
    },
    customSort: {
      type: Function,
      default: helpers["I" /* sortItems */]
    },
    mustSort: Boolean,
    multiSort: Boolean,
    page: {
      type: Number,
      default: 1
    },
    itemsPerPage: {
      type: Number,
      default: 10
    },
    groupBy: {
      type: [String, Array],
      default: () => []
    },
    groupDesc: {
      type: [Boolean, Array],
      default: () => []
    },
    customGroup: {
      type: Function,
      default: helpers["y" /* groupItems */]
    },
    locale: {
      type: String,
      default: 'en-US'
    },
    disableSort: Boolean,
    disablePagination: Boolean,
    disableFiltering: Boolean,
    search: String,
    customFilter: {
      type: Function,
      default: helpers["H" /* searchItems */]
    },
    serverItemsLength: {
      type: Number,
      default: -1
    }
  },

  data() {
    let internalOptions = {
      page: this.page,
      itemsPerPage: this.itemsPerPage,
      sortBy: Object(helpers["L" /* wrapInArray */])(this.sortBy),
      sortDesc: Object(helpers["L" /* wrapInArray */])(this.sortDesc),
      groupBy: Object(helpers["L" /* wrapInArray */])(this.groupBy),
      groupDesc: Object(helpers["L" /* wrapInArray */])(this.groupDesc),
      mustSort: this.mustSort,
      multiSort: this.multiSort
    };

    if (this.options) {
      internalOptions = Object.assign(internalOptions, this.options);
    }

    const {
      sortBy,
      sortDesc,
      groupBy,
      groupDesc
    } = internalOptions;
    const sortDiff = sortBy.length - sortDesc.length;
    const groupDiff = groupBy.length - groupDesc.length;

    if (sortDiff > 0) {
      internalOptions.sortDesc.push(...Object(helpers["p" /* fillArray */])(sortDiff, false));
    }

    if (groupDiff > 0) {
      internalOptions.groupDesc.push(...Object(helpers["p" /* fillArray */])(groupDiff, false));
    }

    return {
      internalOptions
    };
  },

  computed: {
    itemsLength() {
      return this.serverItemsLength >= 0 ? this.serverItemsLength : this.filteredItems.length;
    },

    pageCount() {
      return this.internalOptions.itemsPerPage <= 0 ? 1 : Math.ceil(this.itemsLength / this.internalOptions.itemsPerPage);
    },

    pageStart() {
      if (this.internalOptions.itemsPerPage === -1 || !this.items.length) return 0;
      return (this.internalOptions.page - 1) * this.internalOptions.itemsPerPage;
    },

    pageStop() {
      if (this.internalOptions.itemsPerPage === -1) return this.itemsLength;
      if (!this.items.length) return 0;
      return Math.min(this.itemsLength, this.internalOptions.page * this.internalOptions.itemsPerPage);
    },

    isGrouped() {
      return !!this.internalOptions.groupBy.length;
    },

    pagination() {
      return {
        page: this.internalOptions.page,
        itemsPerPage: this.internalOptions.itemsPerPage,
        pageStart: this.pageStart,
        pageStop: this.pageStop,
        pageCount: this.pageCount,
        itemsLength: this.itemsLength
      };
    },

    filteredItems() {
      let items = this.items.slice();

      if (!this.disableFiltering && this.serverItemsLength <= 0) {
        items = this.customFilter(items, this.search);
      }

      return items;
    },

    computedItems() {
      let items = this.filteredItems.slice();

      if ((!this.disableSort || this.internalOptions.groupBy.length) && this.serverItemsLength <= 0) {
        items = this.sortItems(items);
      }

      if (!this.disablePagination && this.serverItemsLength <= 0) {
        items = this.paginateItems(items);
      }

      return items;
    },

    groupedItems() {
      return this.isGrouped ? this.groupItems(this.computedItems) : null;
    },

    scopedProps() {
      return {
        sort: this.sort,
        sortArray: this.sortArray,
        group: this.group,
        items: this.computedItems,
        options: this.internalOptions,
        updateOptions: this.updateOptions,
        pagination: this.pagination,
        groupedItems: this.groupedItems,
        originalItemsLength: this.items.length
      };
    },

    computedOptions() {
      return { ...this.options
      };
    }

  },
  watch: {
    computedOptions: {
      handler(options, old) {
        if (Object(helpers["m" /* deepEqual */])(options, old)) return;
        this.updateOptions(options);
      },

      deep: true,
      immediate: true
    },
    internalOptions: {
      handler(options, old) {
        if (Object(helpers["m" /* deepEqual */])(options, old)) return;
        this.$emit('update:options', options);
      },

      deep: true,
      immediate: true
    },

    page(page) {
      this.updateOptions({
        page
      });
    },

    'internalOptions.page'(page) {
      this.$emit('update:page', page);
    },

    itemsPerPage(itemsPerPage) {
      this.updateOptions({
        itemsPerPage
      });
    },

    'internalOptions.itemsPerPage'(itemsPerPage) {
      this.$emit('update:items-per-page', itemsPerPage);
    },

    sortBy(sortBy) {
      this.updateOptions({
        sortBy: Object(helpers["L" /* wrapInArray */])(sortBy)
      });
    },

    'internalOptions.sortBy'(sortBy, old) {
      !Object(helpers["m" /* deepEqual */])(sortBy, old) && this.$emit('update:sort-by', Array.isArray(this.sortBy) ? sortBy : sortBy[0]);
    },

    sortDesc(sortDesc) {
      this.updateOptions({
        sortDesc: Object(helpers["L" /* wrapInArray */])(sortDesc)
      });
    },

    'internalOptions.sortDesc'(sortDesc, old) {
      !Object(helpers["m" /* deepEqual */])(sortDesc, old) && this.$emit('update:sort-desc', Array.isArray(this.sortDesc) ? sortDesc : sortDesc[0]);
    },

    groupBy(groupBy) {
      this.updateOptions({
        groupBy: Object(helpers["L" /* wrapInArray */])(groupBy)
      });
    },

    'internalOptions.groupBy'(groupBy, old) {
      !Object(helpers["m" /* deepEqual */])(groupBy, old) && this.$emit('update:group-by', Array.isArray(this.groupBy) ? groupBy : groupBy[0]);
    },

    groupDesc(groupDesc) {
      this.updateOptions({
        groupDesc: Object(helpers["L" /* wrapInArray */])(groupDesc)
      });
    },

    'internalOptions.groupDesc'(groupDesc, old) {
      !Object(helpers["m" /* deepEqual */])(groupDesc, old) && this.$emit('update:group-desc', Array.isArray(this.groupDesc) ? groupDesc : groupDesc[0]);
    },

    multiSort(multiSort) {
      this.updateOptions({
        multiSort
      });
    },

    'internalOptions.multiSort'(multiSort) {
      this.$emit('update:multi-sort', multiSort);
    },

    mustSort(mustSort) {
      this.updateOptions({
        mustSort
      });
    },

    'internalOptions.mustSort'(mustSort) {
      this.$emit('update:must-sort', mustSort);
    },

    pageCount: {
      handler(pageCount) {
        this.$emit('page-count', pageCount);
      },

      immediate: true
    },
    computedItems: {
      handler(computedItems) {
        this.$emit('current-items', computedItems);
      },

      immediate: true
    },
    pagination: {
      handler(pagination, old) {
        if (Object(helpers["m" /* deepEqual */])(pagination, old)) return;
        this.$emit('pagination', this.pagination);
      },

      immediate: true
    }
  },
  methods: {
    toggle(key, oldBy, oldDesc, page, mustSort, multiSort) {
      let by = oldBy.slice();
      let desc = oldDesc.slice();
      const byIndex = by.findIndex(k => k === key);

      if (byIndex < 0) {
        if (!multiSort) {
          by = [];
          desc = [];
        }

        by.push(key);
        desc.push(false);
      } else if (byIndex >= 0 && !desc[byIndex]) {
        desc[byIndex] = true;
      } else if (!mustSort) {
        by.splice(byIndex, 1);
        desc.splice(byIndex, 1);
      } else {
        desc[byIndex] = false;
      } // Reset page to 1 if sortBy or sortDesc have changed


      if (!Object(helpers["m" /* deepEqual */])(by, oldBy) || !Object(helpers["m" /* deepEqual */])(desc, oldDesc)) {
        page = 1;
      }

      return {
        by,
        desc,
        page
      };
    },

    group(key) {
      const {
        by: groupBy,
        desc: groupDesc,
        page
      } = this.toggle(key, this.internalOptions.groupBy, this.internalOptions.groupDesc, this.internalOptions.page, true, false);
      this.updateOptions({
        groupBy,
        groupDesc,
        page
      });
    },

    sort(key) {
      if (Array.isArray(key)) return this.sortArray(key);
      const {
        by: sortBy,
        desc: sortDesc,
        page
      } = this.toggle(key, this.internalOptions.sortBy, this.internalOptions.sortDesc, this.internalOptions.page, this.internalOptions.mustSort, this.internalOptions.multiSort);
      this.updateOptions({
        sortBy,
        sortDesc,
        page
      });
    },

    sortArray(sortBy) {
      const sortDesc = sortBy.map(s => {
        const i = this.internalOptions.sortBy.findIndex(k => k === s);
        return i > -1 ? this.internalOptions.sortDesc[i] : false;
      });
      this.updateOptions({
        sortBy,
        sortDesc
      });
    },

    updateOptions(options) {
      this.internalOptions = { ...this.internalOptions,
        ...options,
        page: this.serverItemsLength < 0 ? Math.max(1, Math.min(options.page || this.internalOptions.page, this.pageCount)) : options.page || this.internalOptions.page
      };
    },

    sortItems(items) {
      let sortBy = [];
      let sortDesc = [];

      if (!this.disableSort) {
        sortBy = this.internalOptions.sortBy;
        sortDesc = this.internalOptions.sortDesc;
      }

      if (this.internalOptions.groupBy.length) {
        sortBy = [...this.internalOptions.groupBy, ...sortBy];
        sortDesc = [...this.internalOptions.groupDesc, ...sortDesc];
      }

      return this.customSort(items, sortBy, sortDesc, this.locale);
    },

    groupItems(items) {
      return this.customGroup(items, this.internalOptions.groupBy, this.internalOptions.groupDesc);
    },

    paginateItems(items) {
      // Make sure we don't try to display non-existant page if items suddenly change
      // TODO: Could possibly move this to pageStart/pageStop?
      if (this.serverItemsLength === -1 && items.length <= this.pageStart) {
        this.internalOptions.page = Math.max(1, Math.ceil(items.length / this.internalOptions.itemsPerPage)) || 1; // Prevent NaN
      }

      return items.slice(this.pageStart, this.pageStop);
    }

  },

  render() {
    return this.$scopedSlots.default && this.$scopedSlots.default(this.scopedProps);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VData/index.js


/* harmony default export */ var components_VData = (VData);
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VDataIterator/VDataFooter.sass
var VDataFooter = __webpack_require__(449);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VDataIterator/VDataFooter.js
 // Components



 // Types



/* harmony default export */ var VDataIterator_VDataFooter = (external_vue_default.a.extend({
  name: 'v-data-footer',
  props: {
    options: {
      type: Object,
      required: true
    },
    pagination: {
      type: Object,
      required: true
    },
    itemsPerPageOptions: {
      type: Array,
      default: () => [5, 10, 15, -1]
    },
    prevIcon: {
      type: String,
      default: '$prev'
    },
    nextIcon: {
      type: String,
      default: '$next'
    },
    firstIcon: {
      type: String,
      default: '$first'
    },
    lastIcon: {
      type: String,
      default: '$last'
    },
    itemsPerPageText: {
      type: String,
      default: '$vuetify.dataFooter.itemsPerPageText'
    },
    itemsPerPageAllText: {
      type: String,
      default: '$vuetify.dataFooter.itemsPerPageAll'
    },
    showFirstLastPage: Boolean,
    showCurrentPage: Boolean,
    disablePagination: Boolean,
    disableItemsPerPage: Boolean,
    pageText: {
      type: String,
      default: '$vuetify.dataFooter.pageText'
    }
  },
  computed: {
    disableNextPageIcon() {
      return this.options.itemsPerPage <= 0 || this.options.page * this.options.itemsPerPage >= this.pagination.itemsLength || this.pagination.pageStop < 0;
    },

    computedDataItemsPerPageOptions() {
      return this.itemsPerPageOptions.map(option => {
        if (typeof option === 'object') return option;else return this.genDataItemsPerPageOption(option);
      });
    }

  },
  methods: {
    updateOptions(obj) {
      this.$emit('update:options', Object.assign({}, this.options, obj));
    },

    onFirstPage() {
      this.updateOptions({
        page: 1
      });
    },

    onPreviousPage() {
      this.updateOptions({
        page: this.options.page - 1
      });
    },

    onNextPage() {
      this.updateOptions({
        page: this.options.page + 1
      });
    },

    onLastPage() {
      this.updateOptions({
        page: this.pagination.pageCount
      });
    },

    onChangeItemsPerPage(itemsPerPage) {
      this.updateOptions({
        itemsPerPage,
        page: 1
      });
    },

    genDataItemsPerPageOption(option) {
      return {
        text: option === -1 ? this.$vuetify.lang.t(this.itemsPerPageAllText) : String(option),
        value: option
      };
    },

    genItemsPerPageSelect() {
      let value = this.options.itemsPerPage;
      const computedIPPO = this.computedDataItemsPerPageOptions;
      if (computedIPPO.length <= 1) return null;
      if (!computedIPPO.find(ippo => ippo.value === value)) value = computedIPPO[0];
      return this.$createElement('div', {
        staticClass: 'v-data-footer__select'
      }, [this.$vuetify.lang.t(this.itemsPerPageText), this.$createElement(VSelect["a" /* default */], {
        attrs: {
          'aria-label': this.$vuetify.lang.t(this.itemsPerPageText)
        },
        props: {
          disabled: this.disableItemsPerPage,
          items: computedIPPO,
          value,
          hideDetails: true,
          auto: true,
          minWidth: '75px'
        },
        on: {
          input: this.onChangeItemsPerPage
        }
      })]);
    },

    genPaginationInfo() {
      let children = ['–'];
      const itemsLength = this.pagination.itemsLength;
      let pageStart = this.pagination.pageStart;
      let pageStop = this.pagination.pageStop;

      if (this.pagination.itemsLength && this.pagination.itemsPerPage) {
        pageStart = this.pagination.pageStart + 1;
        pageStop = itemsLength < this.pagination.pageStop || this.pagination.pageStop < 0 ? itemsLength : this.pagination.pageStop;
        children = this.$scopedSlots['page-text'] ? [this.$scopedSlots['page-text']({
          pageStart,
          pageStop,
          itemsLength
        })] : [this.$vuetify.lang.t(this.pageText, pageStart, pageStop, itemsLength)];
      } else if (this.$scopedSlots['page-text']) {
        children = [this.$scopedSlots['page-text']({
          pageStart,
          pageStop,
          itemsLength
        })];
      }

      return this.$createElement('div', {
        class: 'v-data-footer__pagination'
      }, children);
    },

    genIcon(click, disabled, label, icon) {
      return this.$createElement(VBtn["b" /* default */], {
        props: {
          disabled: disabled || this.disablePagination,
          icon: true,
          text: true
        },
        on: {
          click
        },
        attrs: {
          'aria-label': label
        }
      }, [this.$createElement(VIcon["b" /* default */], icon)]);
    },

    genIcons() {
      const before = [];
      const after = [];
      before.push(this.genIcon(this.onPreviousPage, this.options.page === 1, this.$vuetify.lang.t('$vuetify.dataFooter.prevPage'), this.$vuetify.rtl ? this.nextIcon : this.prevIcon));
      after.push(this.genIcon(this.onNextPage, this.disableNextPageIcon, this.$vuetify.lang.t('$vuetify.dataFooter.nextPage'), this.$vuetify.rtl ? this.prevIcon : this.nextIcon));

      if (this.showFirstLastPage) {
        before.unshift(this.genIcon(this.onFirstPage, this.options.page === 1, this.$vuetify.lang.t('$vuetify.dataFooter.firstPage'), this.$vuetify.rtl ? this.lastIcon : this.firstIcon));
        after.push(this.genIcon(this.onLastPage, this.options.page >= this.pagination.pageCount || this.options.itemsPerPage === -1, this.$vuetify.lang.t('$vuetify.dataFooter.lastPage'), this.$vuetify.rtl ? this.firstIcon : this.lastIcon));
      }

      return [this.$createElement('div', {
        staticClass: 'v-data-footer__icons-before'
      }, before), this.showCurrentPage && this.$createElement('span', [this.options.page.toString()]), this.$createElement('div', {
        staticClass: 'v-data-footer__icons-after'
      }, after)];
    }

  },

  render() {
    return this.$createElement('div', {
      staticClass: 'v-data-footer'
    }, [Object(helpers["v" /* getSlot */])(this, 'prepend'), this.genItemsPerPageSelect(), this.genPaginationInfo(), this.genIcons()]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VDataIterator/VDataIterator.js
// Components

 // Mixins


 // Helpers




/* @vue/component */

/* harmony default export */ var VDataIterator = (Object(mixins["a" /* default */])(mobile["a" /* default */], themeable["a" /* default */]).extend({
  name: 'v-data-iterator',
  props: { ...VData.options.props,
    itemKey: {
      type: String,
      default: 'id'
    },
    value: {
      type: Array,
      default: () => []
    },
    singleSelect: Boolean,
    expanded: {
      type: Array,
      default: () => []
    },
    mobileBreakpoint: { ...mobile["a" /* default */].options.props.mobileBreakpoint,
      default: 600
    },
    singleExpand: Boolean,
    loading: [Boolean, String],
    noResultsText: {
      type: String,
      default: '$vuetify.dataIterator.noResultsText'
    },
    noDataText: {
      type: String,
      default: '$vuetify.noDataText'
    },
    loadingText: {
      type: String,
      default: '$vuetify.dataIterator.loadingText'
    },
    hideDefaultFooter: Boolean,
    footerProps: Object,
    selectableKey: {
      type: String,
      default: 'isSelectable'
    }
  },
  data: () => ({
    selection: {},
    expansion: {},
    internalCurrentItems: [],
    shiftKeyDown: false,
    lastEntry: -1
  }),
  computed: {
    everyItem() {
      return !!this.selectableItems.length && this.selectableItems.every(i => this.isSelected(i));
    },

    someItems() {
      return this.selectableItems.some(i => this.isSelected(i));
    },

    sanitizedFooterProps() {
      return Object(helpers["e" /* camelizeObjectKeys */])(this.footerProps);
    },

    selectableItems() {
      return this.internalCurrentItems.filter(item => this.isSelectable(item));
    }

  },
  watch: {
    value: {
      handler(value) {
        this.selection = value.reduce((selection, item) => {
          selection[Object(helpers["s" /* getObjectValueByPath */])(item, this.itemKey)] = item;
          return selection;
        }, {});
      },

      immediate: true
    },

    selection(value, old) {
      if (Object(helpers["m" /* deepEqual */])(Object.keys(value), Object.keys(old))) return;
      this.$emit('input', Object.values(value));
    },

    expanded: {
      handler(value) {
        this.expansion = value.reduce((expansion, item) => {
          expansion[Object(helpers["s" /* getObjectValueByPath */])(item, this.itemKey)] = true;
          return expansion;
        }, {});
      },

      immediate: true
    },

    expansion(value, old) {
      if (Object(helpers["m" /* deepEqual */])(value, old)) return;
      const keys = Object.keys(value).filter(k => value[k]);
      const expanded = !keys.length ? [] : this.items.filter(i => keys.includes(String(Object(helpers["s" /* getObjectValueByPath */])(i, this.itemKey))));
      this.$emit('update:expanded', expanded);
    }

  },

  created() {
    const breakingProps = [['disable-initial-sort', 'sort-by'], ['filter', 'custom-filter'], ['pagination', 'options'], ['total-items', 'server-items-length'], ['hide-actions', 'hide-default-footer'], ['rows-per-page-items', 'footer-props.items-per-page-options'], ['rows-per-page-text', 'footer-props.items-per-page-text'], ['prev-icon', 'footer-props.prev-icon'], ['next-icon', 'footer-props.next-icon']];
    /* istanbul ignore next */

    breakingProps.forEach(([original, replacement]) => {
      if (this.$attrs.hasOwnProperty(original)) Object(console["a" /* breaking */])(original, replacement, this);
    });
    const removedProps = ['expand', 'content-class', 'content-props', 'content-tag'];
    /* istanbul ignore next */

    removedProps.forEach(prop => {
      if (this.$attrs.hasOwnProperty(prop)) Object(console["e" /* removed */])(prop);
    });
  },

  mounted() {
    window.addEventListener('keydown', this.onKeyDown);
    window.addEventListener('keyup', this.onKeyUp);
  },

  beforeDestroy() {
    window.removeEventListener('keydown', this.onKeyDown);
    window.removeEventListener('keyup', this.onKeyUp);
  },

  methods: {
    onKeyDown(e) {
      if (e.keyCode !== helpers["B" /* keyCodes */].shift) return;
      this.shiftKeyDown = true;
    },

    onKeyUp(e) {
      if (e.keyCode !== helpers["B" /* keyCodes */].shift) return;
      this.shiftKeyDown = false;
    },

    toggleSelectAll(value) {
      const selection = Object.assign({}, this.selection);

      for (let i = 0; i < this.selectableItems.length; i++) {
        const item = this.selectableItems[i];
        if (!this.isSelectable(item)) continue;
        const key = Object(helpers["s" /* getObjectValueByPath */])(item, this.itemKey);
        if (value) selection[key] = item;else delete selection[key];
      }

      this.selection = selection;
      this.$emit('toggle-select-all', {
        items: this.internalCurrentItems,
        value
      });
    },

    isSelectable(item) {
      return Object(helpers["s" /* getObjectValueByPath */])(item, this.selectableKey) !== false;
    },

    isSelected(item) {
      return !!this.selection[Object(helpers["s" /* getObjectValueByPath */])(item, this.itemKey)] || false;
    },

    select(item, value = true, emit = true) {
      if (!this.isSelectable(item)) return;
      const selection = this.singleSelect ? {} : Object.assign({}, this.selection);
      const key = Object(helpers["s" /* getObjectValueByPath */])(item, this.itemKey);
      if (value) selection[key] = item;else delete selection[key];
      const index = this.selectableItems.findIndex(x => Object(helpers["s" /* getObjectValueByPath */])(x, this.itemKey) === key);
      if (this.lastEntry === -1) this.lastEntry = index;else if (this.shiftKeyDown && !this.singleSelect && emit) {
        const lastEntryKey = Object(helpers["s" /* getObjectValueByPath */])(this.selectableItems[this.lastEntry], this.itemKey);
        const lastEntryKeySelected = Object.keys(this.selection).includes(String(lastEntryKey));
        this.multipleSelect(lastEntryKeySelected, emit, selection, index);
      }
      this.lastEntry = index;

      if (this.singleSelect && emit) {
        const keys = Object.keys(this.selection);
        const old = keys.length && Object(helpers["s" /* getObjectValueByPath */])(this.selection[keys[0]], this.itemKey);
        old && old !== key && this.$emit('item-selected', {
          item: this.selection[old],
          value: false
        });
      }

      this.selection = selection;
      emit && this.$emit('item-selected', {
        item,
        value
      });
    },

    multipleSelect(value = true, emit = true, selection, index) {
      const start = index < this.lastEntry ? index : this.lastEntry;
      const end = index < this.lastEntry ? this.lastEntry : index;

      for (let i = start; i <= end; i++) {
        const currentItem = this.selectableItems[i];
        const key = Object(helpers["s" /* getObjectValueByPath */])(currentItem, this.itemKey);
        if (value) selection[key] = currentItem;else delete selection[key];
        emit && this.$emit('item-selected', {
          currentItem,
          value
        });
      }
    },

    isExpanded(item) {
      return this.expansion[Object(helpers["s" /* getObjectValueByPath */])(item, this.itemKey)] || false;
    },

    expand(item, value = true) {
      const expansion = this.singleExpand ? {} : Object.assign({}, this.expansion);
      const key = Object(helpers["s" /* getObjectValueByPath */])(item, this.itemKey);
      if (value) expansion[key] = true;else delete expansion[key];
      this.expansion = expansion;
      this.$emit('item-expanded', {
        item,
        value
      });
    },

    createItemProps(item, index) {
      return {
        item,
        index,
        select: v => this.select(item, v),
        isSelected: this.isSelected(item),
        expand: v => this.expand(item, v),
        isExpanded: this.isExpanded(item),
        isMobile: this.isMobile
      };
    },

    genEmptyWrapper(content) {
      return this.$createElement('div', content);
    },

    genEmpty(originalItemsLength, filteredItemsLength) {
      if (originalItemsLength === 0 && this.loading) {
        const loading = this.$slots.loading || this.$vuetify.lang.t(this.loadingText);
        return this.genEmptyWrapper(loading);
      } else if (originalItemsLength === 0) {
        const noData = this.$slots['no-data'] || this.$vuetify.lang.t(this.noDataText);
        return this.genEmptyWrapper(noData);
      } else if (filteredItemsLength === 0) {
        const noResults = this.$slots['no-results'] || this.$vuetify.lang.t(this.noResultsText);
        return this.genEmptyWrapper(noResults);
      }

      return null;
    },

    genItems(props) {
      const empty = this.genEmpty(props.originalItemsLength, props.pagination.itemsLength);
      if (empty) return [empty];

      if (this.$scopedSlots.default) {
        return this.$scopedSlots.default({ ...props,
          isSelected: this.isSelected,
          select: this.select,
          isExpanded: this.isExpanded,
          isMobile: this.isMobile,
          expand: this.expand
        });
      }

      if (this.$scopedSlots.item) {
        return props.items.map((item, index) => this.$scopedSlots.item(this.createItemProps(item, index)));
      }

      return [];
    },

    genFooter(props) {
      if (this.hideDefaultFooter) return null;
      const data = {
        props: { ...this.sanitizedFooterProps,
          options: props.options,
          pagination: props.pagination
        },
        on: {
          'update:options': value => props.updateOptions(value)
        }
      };
      const scopedSlots = Object(helpers["t" /* getPrefixedScopedSlots */])('footer.', this.$scopedSlots);
      return this.$createElement(VDataIterator_VDataFooter, {
        scopedSlots,
        ...data
      });
    },

    genDefaultScopedSlot(props) {
      const outerProps = { ...props,
        someItems: this.someItems,
        everyItem: this.everyItem,
        toggleSelectAll: this.toggleSelectAll
      };
      return this.$createElement('div', {
        staticClass: 'v-data-iterator'
      }, [Object(helpers["v" /* getSlot */])(this, 'header', outerProps, true), this.genItems(props), this.genFooter(props), Object(helpers["v" /* getSlot */])(this, 'footer', outerProps, true)]);
    }

  },

  render() {
    return this.$createElement(VData, {
      props: this.$props,
      on: {
        'update:options': (v, old) => !Object(helpers["m" /* deepEqual */])(v, old) && this.$emit('update:options', v),
        'update:page': v => this.$emit('update:page', v),
        'update:items-per-page': v => this.$emit('update:items-per-page', v),
        'update:sort-by': v => this.$emit('update:sort-by', v),
        'update:sort-desc': v => this.$emit('update:sort-desc', v),
        'update:group-by': v => this.$emit('update:group-by', v),
        'update:group-desc': v => this.$emit('update:group-desc', v),
        pagination: (v, old) => !Object(helpers["m" /* deepEqual */])(v, old) && this.$emit('pagination', v),
        'current-items': v => {
          this.internalCurrentItems = v;
          this.$emit('current-items', v);
        },
        'page-count': v => this.$emit('page-count', v)
      },
      scopedSlots: {
        default: this.genDefaultScopedSlot
      }
    });
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VDataIterator/index.js



/* harmony default export */ var components_VDataIterator = ({
  $_vuetify_subcomponents: {
    VDataIterator: VDataIterator,
    VDataFooter: VDataIterator_VDataFooter
  }
});
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VDataTable/VDataTable.sass
var VDataTable = __webpack_require__(450);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VDataTable/VDataTableHeader.sass
var VDataTableHeader = __webpack_require__(451);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VCheckbox/VSimpleCheckbox.js
var VSimpleCheckbox = __webpack_require__(280);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VDataTable/mixins/header.js




/* harmony default export */ var mixins_header = (Object(mixins["a" /* default */])().extend({
  // https://github.com/vuejs/vue/issues/6872
  directives: {
    ripple: ripple["b" /* default */]
  },
  props: {
    headers: {
      type: Array,
      default: () => []
    },
    options: {
      type: Object,
      default: () => ({
        page: 1,
        itemsPerPage: 10,
        sortBy: [],
        sortDesc: [],
        groupBy: [],
        groupDesc: [],
        multiSort: false,
        mustSort: false
      })
    },
    checkboxColor: String,
    sortIcon: {
      type: String,
      default: '$sort'
    },
    everyItem: Boolean,
    someItems: Boolean,
    showGroupBy: Boolean,
    singleSelect: Boolean,
    disableSort: Boolean
  },
  methods: {
    genSelectAll() {
      var _this$checkboxColor;

      const data = {
        props: {
          value: this.everyItem,
          indeterminate: !this.everyItem && this.someItems,
          color: (_this$checkboxColor = this.checkboxColor) != null ? _this$checkboxColor : ''
        },
        on: {
          input: v => this.$emit('toggle-select-all', v)
        }
      };

      if (this.$scopedSlots['data-table-select']) {
        return this.$scopedSlots['data-table-select'](data);
      }

      return this.$createElement(VSimpleCheckbox["a" /* default */], {
        staticClass: 'v-data-table__checkbox',
        ...data
      });
    },

    genSortIcon() {
      return this.$createElement(VIcon["b" /* default */], {
        staticClass: 'v-data-table-header__icon',
        props: {
          size: 18
        }
      }, [this.sortIcon]);
    }

  }
}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VDataTable/VDataTableHeaderMobile.js





/* harmony default export */ var VDataTableHeaderMobile = (Object(mixins["a" /* default */])(mixins_header).extend({
  name: 'v-data-table-header-mobile',
  props: {
    sortByText: {
      type: String,
      default: '$vuetify.dataTable.sortBy'
    }
  },
  methods: {
    genSortChip(props) {
      const children = [props.item.text];
      const sortIndex = this.options.sortBy.findIndex(k => k === props.item.value);
      const beingSorted = sortIndex >= 0;
      const isDesc = this.options.sortDesc[sortIndex];
      children.push(this.$createElement('div', {
        staticClass: 'v-chip__close',
        class: {
          sortable: true,
          active: beingSorted,
          asc: beingSorted && !isDesc,
          desc: beingSorted && isDesc
        }
      }, [this.genSortIcon()]));
      return this.$createElement(VChip["b" /* default */], {
        staticClass: 'sortable',
        on: {
          click: e => {
            e.stopPropagation();
            this.$emit('sort', props.item.value);
          }
        }
      }, children);
    },

    genSortSelect(items) {
      return this.$createElement(VSelect["a" /* default */], {
        props: {
          label: this.$vuetify.lang.t(this.sortByText),
          items,
          hideDetails: true,
          multiple: this.options.multiSort,
          value: this.options.multiSort ? this.options.sortBy : this.options.sortBy[0],
          menuProps: {
            closeOnContentClick: true
          }
        },
        on: {
          change: v => this.$emit('sort', v)
        },
        scopedSlots: {
          selection: props => this.genSortChip(props)
        }
      });
    }

  },

  render(h) {
    const children = [];
    const header = this.headers.find(h => h.value === 'data-table-select');

    if (header && !this.singleSelect) {
      children.push(this.$createElement('div', {
        class: ['v-data-table-header-mobile__select', ...Object(helpers["L" /* wrapInArray */])(header.class)],
        attrs: {
          width: header.width
        }
      }, [this.genSelectAll()]));
    }

    const sortHeaders = this.headers.filter(h => h.sortable !== false && h.value !== 'data-table-select').map(h => ({
      text: h.text,
      value: h.value
    }));

    if (!this.disableSort && sortHeaders.length) {
      children.push(this.genSortSelect(sortHeaders));
    }

    const th = children.length ? h('th', [h('div', {
      staticClass: 'v-data-table-header-mobile__wrapper'
    }, children)]) : undefined;
    const tr = h('tr', [th]);
    return h('thead', {
      staticClass: 'v-data-table-header v-data-table-header-mobile'
    }, [tr]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VDataTable/VDataTableHeaderDesktop.js



/* harmony default export */ var VDataTableHeaderDesktop = (Object(mixins["a" /* default */])(mixins_header).extend({
  name: 'v-data-table-header-desktop',
  methods: {
    genGroupByToggle(header) {
      return this.$createElement('span', {
        on: {
          click: e => {
            e.stopPropagation();
            this.$emit('group', header.value);
          }
        }
      }, ['group']);
    },

    getAria(beingSorted, isDesc) {
      const $t = key => this.$vuetify.lang.t(`$vuetify.dataTable.ariaLabel.${key}`);

      let ariaSort = 'none';
      let ariaLabel = [$t('sortNone'), $t('activateAscending')];

      if (!beingSorted) {
        return {
          ariaSort,
          ariaLabel: ariaLabel.join(' ')
        };
      }

      if (isDesc) {
        ariaSort = 'descending';
        ariaLabel = [$t('sortDescending'), $t(this.options.mustSort ? 'activateAscending' : 'activateNone')];
      } else {
        ariaSort = 'ascending';
        ariaLabel = [$t('sortAscending'), $t('activateDescending')];
      }

      return {
        ariaSort,
        ariaLabel: ariaLabel.join(' ')
      };
    },

    genHeader(header) {
      const data = {
        attrs: {
          role: 'columnheader',
          scope: 'col',
          'aria-label': header.text || ''
        },
        style: {
          width: Object(helpers["i" /* convertToUnit */])(header.width),
          minWidth: Object(helpers["i" /* convertToUnit */])(header.width)
        },
        class: [`text-${header.align || 'start'}`, ...Object(helpers["L" /* wrapInArray */])(header.class), header.divider && 'v-data-table__divider'],
        on: {}
      };
      const children = [];

      if (header.value === 'data-table-select' && !this.singleSelect) {
        return this.$createElement('th', data, [this.genSelectAll()]);
      }

      children.push(this.$scopedSlots.hasOwnProperty(header.value) ? this.$scopedSlots[header.value]({
        header
      }) : this.$createElement('span', [header.text]));

      if (!this.disableSort && (header.sortable || !header.hasOwnProperty('sortable'))) {
        data.on.click = () => this.$emit('sort', header.value);

        const sortIndex = this.options.sortBy.findIndex(k => k === header.value);
        const beingSorted = sortIndex >= 0;
        const isDesc = this.options.sortDesc[sortIndex];
        data.class.push('sortable');
        const {
          ariaLabel,
          ariaSort
        } = this.getAria(beingSorted, isDesc);
        data.attrs['aria-label'] += `${header.text ? ': ' : ''}${ariaLabel}`;
        data.attrs['aria-sort'] = ariaSort;

        if (beingSorted) {
          data.class.push('active');
          data.class.push(isDesc ? 'desc' : 'asc');
        }

        if (header.align === 'end') children.unshift(this.genSortIcon());else children.push(this.genSortIcon());

        if (this.options.multiSort && beingSorted) {
          children.push(this.$createElement('span', {
            class: 'v-data-table-header__sort-badge'
          }, [String(sortIndex + 1)]));
        }
      }

      if (this.showGroupBy && header.groupable !== false) children.push(this.genGroupByToggle(header));
      return this.$createElement('th', data, children);
    }

  },

  render() {
    return this.$createElement('thead', {
      staticClass: 'v-data-table-header'
    }, [this.$createElement('tr', this.headers.map(header => this.genHeader(header)))]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/util/dedupeModelListeners.js
/**
 * Removes duplicate `@input` listeners when
 * using v-model with functional components
 *
 * @see https://github.com/vuetifyjs/vuetify/issues/4460
 */
function dedupeModelListeners(data) {
  if (data.model && data.on && data.on.input) {
    if (Array.isArray(data.on.input)) {
      const i = data.on.input.indexOf(data.model.callback);
      if (i > -1) data.on.input.splice(i, 1);
    } else {
      delete data.on.input;
    }
  }
}
// CONCATENATED MODULE: ./node_modules/vuetify/lib/util/rebuildFunctionalSlots.js
function rebuildFunctionalSlots(slots, h) {
  const children = [];

  for (const slot in slots) {
    if (slots.hasOwnProperty(slot)) {
      children.push(h('template', {
        slot
      }, slots[slot]));
    }
  }

  return children;
}
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VDataTable/VDataTableHeader.js
// Styles
 // Components


 // Mixins

 // Utilities



 // Types


/* @vue/component */

/* harmony default export */ var VDataTable_VDataTableHeader = (external_vue_default.a.extend({
  name: 'v-data-table-header',
  functional: true,
  props: { ...mixins_header.options.props,
    mobile: Boolean
  },

  render(h, {
    props,
    data,
    slots
  }) {
    dedupeModelListeners(data);
    const children = rebuildFunctionalSlots(slots(), h);
    data = Object(mergeData["a" /* default */])(data, {
      props
    });

    if (props.mobile) {
      return h(VDataTableHeaderMobile, data, children);
    } else {
      return h(VDataTableHeaderDesktop, data, children);
    }
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VDataTable/Row.js
// Types
 // Utils



function needsTd(slot) {
  var _slot$;

  return slot.length !== 1 || !['td', 'th'].includes((_slot$ = slot[0]) == null ? void 0 : _slot$.tag);
}

/* harmony default export */ var Row = (external_vue_default.a.extend({
  name: 'row',
  functional: true,
  props: {
    headers: Array,
    index: Number,
    item: Object,
    rtl: Boolean
  },

  render(h, {
    props,
    slots,
    data
  }) {
    const computedSlots = slots();
    const columns = props.headers.map(header => {
      const children = [];
      const value = Object(helpers["s" /* getObjectValueByPath */])(props.item, header.value);
      const slotName = header.value;
      const scopedSlot = data.scopedSlots && data.scopedSlots.hasOwnProperty(slotName) && data.scopedSlots[slotName];
      const regularSlot = computedSlots.hasOwnProperty(slotName) && computedSlots[slotName];

      if (scopedSlot) {
        children.push(...Object(helpers["L" /* wrapInArray */])(scopedSlot({
          item: props.item,
          isMobile: false,
          header,
          index: props.index,
          value
        })));
      } else if (regularSlot) {
        children.push(...Object(helpers["L" /* wrapInArray */])(regularSlot));
      } else {
        children.push(value == null ? value : String(value));
      }

      const textAlign = `text-${header.align || 'start'}`;
      return needsTd(children) ? h('td', {
        class: [textAlign, header.cellClass, {
          'v-data-table__divider': header.divider
        }]
      }, children) : children;
    });
    return h('tr', data, columns);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VDataTable/RowGroup.js

/* harmony default export */ var RowGroup = (external_vue_default.a.extend({
  name: 'row-group',
  functional: true,
  props: {
    value: {
      type: Boolean,
      default: true
    },
    headerClass: {
      type: String,
      default: 'v-row-group__header'
    },
    contentClass: String,
    summaryClass: {
      type: String,
      default: 'v-row-group__summary'
    }
  },

  render(h, {
    slots,
    props
  }) {
    const computedSlots = slots();
    const children = [];

    if (computedSlots['column.header']) {
      children.push(h('tr', {
        staticClass: props.headerClass
      }, computedSlots['column.header']));
    } else if (computedSlots['row.header']) {
      children.push(...computedSlots['row.header']);
    }

    if (computedSlots['row.content'] && props.value) children.push(...computedSlots['row.content']);

    if (computedSlots['column.summary']) {
      children.push(h('tr', {
        staticClass: props.summaryClass
      }, computedSlots['column.summary']));
    } else if (computedSlots['row.summary']) {
      children.push(...computedSlots['row.summary']);
    }

    return children;
  }

}));
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VDataTable/VSimpleTable.sass
var VSimpleTable = __webpack_require__(452);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VDataTable/VSimpleTable.js




/* harmony default export */ var VDataTable_VSimpleTable = (Object(mixins["a" /* default */])(themeable["a" /* default */]).extend({
  name: 'v-simple-table',
  props: {
    dense: Boolean,
    fixedHeader: Boolean,
    height: [Number, String]
  },
  computed: {
    classes() {
      return {
        'v-data-table--dense': this.dense,
        'v-data-table--fixed-height': !!this.height && !this.fixedHeader,
        'v-data-table--fixed-header': this.fixedHeader,
        'v-data-table--has-top': !!this.$slots.top,
        'v-data-table--has-bottom': !!this.$slots.bottom,
        ...this.themeClasses
      };
    }

  },
  methods: {
    genWrapper() {
      return this.$slots.wrapper || this.$createElement('div', {
        staticClass: 'v-data-table__wrapper',
        style: {
          height: Object(helpers["i" /* convertToUnit */])(this.height)
        }
      }, [this.$createElement('table', this.$slots.default)]);
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'v-data-table',
      class: this.classes
    }, [this.$slots.top, this.genWrapper(), this.$slots.bottom]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VDataTable/MobileRow.js


/* harmony default export */ var MobileRow = (external_vue_default.a.extend({
  name: 'row',
  functional: true,
  props: {
    headers: Array,
    hideDefaultHeader: Boolean,
    index: Number,
    item: Object,
    rtl: Boolean
  },

  render(h, {
    props,
    slots,
    data
  }) {
    const computedSlots = slots();
    const columns = props.headers.map(header => {
      const classes = {
        'v-data-table__mobile-row': true
      };
      const children = [];
      const value = Object(helpers["s" /* getObjectValueByPath */])(props.item, header.value);
      const slotName = header.value;
      const scopedSlot = data.scopedSlots && data.scopedSlots.hasOwnProperty(slotName) && data.scopedSlots[slotName];
      const regularSlot = computedSlots.hasOwnProperty(slotName) && computedSlots[slotName];

      if (scopedSlot) {
        children.push(scopedSlot({
          item: props.item,
          isMobile: true,
          header,
          index: props.index,
          value
        }));
      } else if (regularSlot) {
        children.push(regularSlot);
      } else {
        children.push(value == null ? value : String(value));
      }

      const mobileRowChildren = [h('div', {
        staticClass: 'v-data-table__mobile-row__cell'
      }, children)];

      if (header.value !== 'dataTableSelect' && !props.hideDefaultHeader) {
        mobileRowChildren.unshift(h('div', {
          staticClass: 'v-data-table__mobile-row__header'
        }, [header.text]));
      }

      return h('td', {
        class: classes
      }, mobileRowChildren);
    });
    return h('tr', { ...data,
      staticClass: 'v-data-table__mobile-table-row'
    }, columns);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VDataTable/VDataTable.js
 // Components




 // import VVirtualTable from './VVirtualTable'






 // Mixins

 // Directives

 // Helpers






function filterFn(item, search, filter) {
  return header => {
    const value = Object(helpers["s" /* getObjectValueByPath */])(item, header.value);
    return header.filter ? header.filter(value, search, item) : filter(value, search, item);
  };
}

function searchTableItems(items, search, headersWithCustomFilters, headersWithoutCustomFilters, customFilter) {
  search = typeof search === 'string' ? search.trim() : null;
  return items.filter(item => {
    // Headers with custom filters are evaluated whether or not a search term has been provided.
    // We need to match every filter to be included in the results.
    const matchesColumnFilters = headersWithCustomFilters.every(filterFn(item, search, helpers["n" /* defaultFilter */])); // Headers without custom filters are only filtered by the `search` property if it is defined.
    // We only need a single column to match the search term to be included in the results.

    const matchesSearchTerm = !search || headersWithoutCustomFilters.some(filterFn(item, search, customFilter));
    return matchesColumnFilters && matchesSearchTerm;
  });
}
/* @vue/component */


/* harmony default export */ var VDataTable_VDataTable = (Object(mixins["a" /* default */])(VDataIterator, loadable["a" /* default */]).extend({
  name: 'v-data-table',
  // https://github.com/vuejs/vue/issues/6872
  directives: {
    ripple: ripple["b" /* default */]
  },
  props: {
    headers: {
      type: Array,
      default: () => []
    },
    showSelect: Boolean,
    checkboxColor: String,
    showExpand: Boolean,
    showGroupBy: Boolean,
    // TODO: Fix
    // virtualRows: Boolean,
    height: [Number, String],
    hideDefaultHeader: Boolean,
    caption: String,
    dense: Boolean,
    headerProps: Object,
    calculateWidths: Boolean,
    fixedHeader: Boolean,
    headersLength: Number,
    expandIcon: {
      type: String,
      default: '$expand'
    },
    customFilter: {
      type: Function,
      default: helpers["n" /* defaultFilter */]
    },
    itemClass: {
      type: [String, Function],
      default: () => ''
    },
    loaderHeight: {
      type: [Number, String],
      default: 4
    }
  },

  data() {
    return {
      internalGroupBy: [],
      openCache: {},
      widths: []
    };
  },

  computed: {
    computedHeaders() {
      if (!this.headers) return [];
      const headers = this.headers.filter(h => h.value === undefined || !this.internalGroupBy.find(v => v === h.value));
      const defaultHeader = {
        text: '',
        sortable: false,
        width: '1px'
      };

      if (this.showSelect) {
        const index = headers.findIndex(h => h.value === 'data-table-select');
        if (index < 0) headers.unshift({ ...defaultHeader,
          value: 'data-table-select'
        });else headers.splice(index, 1, { ...defaultHeader,
          ...headers[index]
        });
      }

      if (this.showExpand) {
        const index = headers.findIndex(h => h.value === 'data-table-expand');
        if (index < 0) headers.unshift({ ...defaultHeader,
          value: 'data-table-expand'
        });else headers.splice(index, 1, { ...defaultHeader,
          ...headers[index]
        });
      }

      return headers;
    },

    colspanAttrs() {
      return this.isMobile ? undefined : {
        colspan: this.headersLength || this.computedHeaders.length
      };
    },

    columnSorters() {
      return this.computedHeaders.reduce((acc, header) => {
        if (header.sort) acc[header.value] = header.sort;
        return acc;
      }, {});
    },

    headersWithCustomFilters() {
      return this.headers.filter(header => header.filter && (!header.hasOwnProperty('filterable') || header.filterable === true));
    },

    headersWithoutCustomFilters() {
      return this.headers.filter(header => !header.filter && (!header.hasOwnProperty('filterable') || header.filterable === true));
    },

    sanitizedHeaderProps() {
      return Object(helpers["e" /* camelizeObjectKeys */])(this.headerProps);
    },

    computedItemsPerPage() {
      const itemsPerPage = this.options && this.options.itemsPerPage ? this.options.itemsPerPage : this.itemsPerPage;
      const itemsPerPageOptions = this.sanitizedFooterProps.itemsPerPageOptions;

      if (itemsPerPageOptions && !itemsPerPageOptions.find(item => typeof item === 'number' ? item === itemsPerPage : item.value === itemsPerPage)) {
        const firstOption = itemsPerPageOptions[0];
        return typeof firstOption === 'object' ? firstOption.value : firstOption;
      }

      return itemsPerPage;
    }

  },

  created() {
    const breakingProps = [['sort-icon', 'header-props.sort-icon'], ['hide-headers', 'hide-default-header'], ['select-all', 'show-select']];
    /* istanbul ignore next */

    breakingProps.forEach(([original, replacement]) => {
      if (this.$attrs.hasOwnProperty(original)) Object(console["a" /* breaking */])(original, replacement, this);
    });
  },

  mounted() {
    // if ((!this.sortBy || !this.sortBy.length) && (!this.options.sortBy || !this.options.sortBy.length)) {
    //   const firstSortable = this.headers.find(h => !('sortable' in h) || !!h.sortable)
    //   if (firstSortable) this.updateOptions({ sortBy: [firstSortable.value], sortDesc: [false] })
    // }
    if (this.calculateWidths) {
      window.addEventListener('resize', this.calcWidths);
      this.calcWidths();
    }
  },

  beforeDestroy() {
    if (this.calculateWidths) {
      window.removeEventListener('resize', this.calcWidths);
    }
  },

  methods: {
    calcWidths() {
      this.widths = Array.from(this.$el.querySelectorAll('th')).map(e => e.clientWidth);
    },

    customFilterWithColumns(items, search) {
      return searchTableItems(items, search, this.headersWithCustomFilters, this.headersWithoutCustomFilters, this.customFilter);
    },

    customSortWithHeaders(items, sortBy, sortDesc, locale) {
      return this.customSort(items, sortBy, sortDesc, locale, this.columnSorters);
    },

    createItemProps(item, index) {
      const props = VDataIterator.options.methods.createItemProps.call(this, item, index);
      return Object.assign(props, {
        headers: this.computedHeaders
      });
    },

    genCaption(props) {
      if (this.caption) return [this.$createElement('caption', [this.caption])];
      return Object(helpers["v" /* getSlot */])(this, 'caption', props, true);
    },

    genColgroup(props) {
      return this.$createElement('colgroup', this.computedHeaders.map(header => {
        return this.$createElement('col', {
          class: {
            divider: header.divider
          }
        });
      }));
    },

    genLoading() {
      const th = this.$createElement('th', {
        staticClass: 'column',
        attrs: this.colspanAttrs
      }, [this.genProgress()]);
      const tr = this.$createElement('tr', {
        staticClass: 'v-data-table__progress'
      }, [th]);
      return this.$createElement('thead', [tr]);
    },

    genHeaders(props) {
      const data = {
        props: { ...this.sanitizedHeaderProps,
          headers: this.computedHeaders,
          options: props.options,
          mobile: this.isMobile,
          showGroupBy: this.showGroupBy,
          checkboxColor: this.checkboxColor,
          someItems: this.someItems,
          everyItem: this.everyItem,
          singleSelect: this.singleSelect,
          disableSort: this.disableSort
        },
        on: {
          sort: props.sort,
          group: props.group,
          'toggle-select-all': this.toggleSelectAll
        }
      }; // TODO: rename to 'head'? (thead, tbody, tfoot)

      const children = [Object(helpers["v" /* getSlot */])(this, 'header', { ...data,
        isMobile: this.isMobile
      })];

      if (!this.hideDefaultHeader) {
        const scopedSlots = Object(helpers["t" /* getPrefixedScopedSlots */])('header.', this.$scopedSlots);
        children.push(this.$createElement(VDataTable_VDataTableHeader, { ...data,
          scopedSlots
        }));
      }

      if (this.loading) children.push(this.genLoading());
      return children;
    },

    genEmptyWrapper(content) {
      return this.$createElement('tr', {
        staticClass: 'v-data-table__empty-wrapper'
      }, [this.$createElement('td', {
        attrs: this.colspanAttrs
      }, content)]);
    },

    genItems(items, props) {
      const empty = this.genEmpty(props.originalItemsLength, props.pagination.itemsLength);
      if (empty) return [empty];
      return props.groupedItems ? this.genGroupedRows(props.groupedItems, props) : this.genRows(items, props);
    },

    genGroupedRows(groupedItems, props) {
      return groupedItems.map(group => {
        if (!this.openCache.hasOwnProperty(group.name)) this.$set(this.openCache, group.name, true);

        if (this.$scopedSlots.group) {
          return this.$scopedSlots.group({
            group: group.name,
            options: props.options,
            isMobile: this.isMobile,
            items: group.items,
            headers: this.computedHeaders
          });
        } else {
          return this.genDefaultGroupedRow(group.name, group.items, props);
        }
      });
    },

    genDefaultGroupedRow(group, items, props) {
      const isOpen = !!this.openCache[group];
      const children = [this.$createElement('template', {
        slot: 'row.content'
      }, this.genRows(items, props))];

      const toggleFn = () => this.$set(this.openCache, group, !this.openCache[group]);

      const removeFn = () => props.updateOptions({
        groupBy: [],
        groupDesc: []
      });

      if (this.$scopedSlots['group.header']) {
        children.unshift(this.$createElement('template', {
          slot: 'column.header'
        }, [this.$scopedSlots['group.header']({
          group,
          groupBy: props.options.groupBy,
          isMobile: this.isMobile,
          items,
          headers: this.computedHeaders,
          isOpen,
          toggle: toggleFn,
          remove: removeFn
        })]));
      } else {
        const toggle = this.$createElement(VBtn["b" /* default */], {
          staticClass: 'ma-0',
          props: {
            icon: true,
            small: true
          },
          on: {
            click: toggleFn
          }
        }, [this.$createElement(VIcon["b" /* default */], [isOpen ? '$minus' : '$plus'])]);
        const remove = this.$createElement(VBtn["b" /* default */], {
          staticClass: 'ma-0',
          props: {
            icon: true,
            small: true
          },
          on: {
            click: removeFn
          }
        }, [this.$createElement(VIcon["b" /* default */], ['$close'])]);
        const column = this.$createElement('td', {
          staticClass: 'text-start',
          attrs: this.colspanAttrs
        }, [toggle, `${props.options.groupBy[0]}: ${group}`, remove]);
        children.unshift(this.$createElement('template', {
          slot: 'column.header'
        }, [column]));
      }

      if (this.$scopedSlots['group.summary']) {
        children.push(this.$createElement('template', {
          slot: 'column.summary'
        }, [this.$scopedSlots['group.summary']({
          group,
          groupBy: props.options.groupBy,
          isMobile: this.isMobile,
          items,
          headers: this.computedHeaders,
          isOpen,
          toggle: toggleFn
        })]));
      }

      return this.$createElement(RowGroup, {
        key: group,
        props: {
          value: isOpen
        }
      }, children);
    },

    genRows(items, props) {
      return this.$scopedSlots.item ? this.genScopedRows(items, props) : this.genDefaultRows(items, props);
    },

    genScopedRows(items, props) {
      const rows = [];

      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        rows.push(this.$scopedSlots.item({ ...this.createItemProps(item, i),
          isMobile: this.isMobile
        }));

        if (this.isExpanded(item)) {
          rows.push(this.$scopedSlots['expanded-item']({
            headers: this.computedHeaders,
            isMobile: this.isMobile,
            index: i,
            item
          }));
        }
      }

      return rows;
    },

    genDefaultRows(items, props) {
      return this.$scopedSlots['expanded-item'] ? items.map((item, index) => this.genDefaultExpandedRow(item, index)) : items.map((item, index) => this.genDefaultSimpleRow(item, index));
    },

    genDefaultExpandedRow(item, index) {
      const isExpanded = this.isExpanded(item);
      const classes = {
        'v-data-table__expanded v-data-table__expanded__row': isExpanded
      };
      const headerRow = this.genDefaultSimpleRow(item, index, classes);
      const expandedRow = this.$createElement('tr', {
        staticClass: 'v-data-table__expanded v-data-table__expanded__content'
      }, [this.$scopedSlots['expanded-item']({
        headers: this.computedHeaders,
        isMobile: this.isMobile,
        item
      })]);
      return this.$createElement(RowGroup, {
        props: {
          value: isExpanded
        }
      }, [this.$createElement('template', {
        slot: 'row.header'
      }, [headerRow]), this.$createElement('template', {
        slot: 'row.content'
      }, [expandedRow])]);
    },

    genDefaultSimpleRow(item, index, classes = {}) {
      const scopedSlots = Object(helpers["t" /* getPrefixedScopedSlots */])('item.', this.$scopedSlots);
      const data = this.createItemProps(item, index);

      if (this.showSelect) {
        const slot = scopedSlots['data-table-select'];
        scopedSlots['data-table-select'] = slot ? () => slot({ ...data,
          isMobile: this.isMobile
        }) : () => {
          var _this$checkboxColor;

          return this.$createElement(VSimpleCheckbox["a" /* default */], {
            staticClass: 'v-data-table__checkbox',
            props: {
              value: data.isSelected,
              disabled: !this.isSelectable(item),
              color: (_this$checkboxColor = this.checkboxColor) != null ? _this$checkboxColor : ''
            },
            on: {
              input: val => data.select(val)
            }
          });
        };
      }

      if (this.showExpand) {
        const slot = scopedSlots['data-table-expand'];
        scopedSlots['data-table-expand'] = slot ? () => slot(data) : () => this.$createElement(VIcon["b" /* default */], {
          staticClass: 'v-data-table__expand-icon',
          class: {
            'v-data-table__expand-icon--active': data.isExpanded
          },
          on: {
            click: e => {
              e.stopPropagation();
              data.expand(!data.isExpanded);
            }
          }
        }, [this.expandIcon]);
      }

      return this.$createElement(this.isMobile ? MobileRow : Row, {
        key: Object(helpers["s" /* getObjectValueByPath */])(item, this.itemKey),
        class: Object(mergeData["b" /* mergeClasses */])({ ...classes,
          'v-data-table__selected': data.isSelected
        }, Object(helpers["u" /* getPropertyFromItem */])(item, this.itemClass)),
        props: {
          headers: this.computedHeaders,
          hideDefaultHeader: this.hideDefaultHeader,
          index,
          item,
          rtl: this.$vuetify.rtl
        },
        scopedSlots,
        on: {
          // TODO: for click, the first argument should be the event, and the second argument should be data,
          // but this is a breaking change so it's for v3
          click: () => this.$emit('click:row', item, data),
          contextmenu: event => this.$emit('contextmenu:row', event, data),
          dblclick: event => this.$emit('dblclick:row', event, data)
        }
      });
    },

    genBody(props) {
      const data = { ...props,
        expand: this.expand,
        headers: this.computedHeaders,
        isExpanded: this.isExpanded,
        isMobile: this.isMobile,
        isSelected: this.isSelected,
        select: this.select
      };

      if (this.$scopedSlots.body) {
        return this.$scopedSlots.body(data);
      }

      return this.$createElement('tbody', [Object(helpers["v" /* getSlot */])(this, 'body.prepend', data, true), this.genItems(props.items, props), Object(helpers["v" /* getSlot */])(this, 'body.append', data, true)]);
    },

    genFoot(props) {
      var _this$$scopedSlots$fo, _this$$scopedSlots;

      return (_this$$scopedSlots$fo = (_this$$scopedSlots = this.$scopedSlots).foot) == null ? void 0 : _this$$scopedSlots$fo.call(_this$$scopedSlots, props);
    },

    genFooters(props) {
      const data = {
        props: {
          options: props.options,
          pagination: props.pagination,
          itemsPerPageText: '$vuetify.dataTable.itemsPerPageText',
          ...this.sanitizedFooterProps
        },
        on: {
          'update:options': value => props.updateOptions(value)
        },
        widths: this.widths,
        headers: this.computedHeaders
      };
      const children = [Object(helpers["v" /* getSlot */])(this, 'footer', data, true)];

      if (!this.hideDefaultFooter) {
        children.push(this.$createElement(VDataIterator_VDataFooter, { ...data,
          scopedSlots: Object(helpers["t" /* getPrefixedScopedSlots */])('footer.', this.$scopedSlots)
        }));
      }

      return children;
    },

    genDefaultScopedSlot(props) {
      const simpleProps = {
        height: this.height,
        fixedHeader: this.fixedHeader,
        dense: this.dense
      }; // if (this.virtualRows) {
      //   return this.$createElement(VVirtualTable, {
      //     props: Object.assign(simpleProps, {
      //       items: props.items,
      //       height: this.height,
      //       rowHeight: this.dense ? 24 : 48,
      //       headerHeight: this.dense ? 32 : 48,
      //       // TODO: expose rest of props from virtual table?
      //     }),
      //     scopedSlots: {
      //       items: ({ items }) => this.genItems(items, props) as any,
      //     },
      //   }, [
      //     this.proxySlot('body.before', [this.genCaption(props), this.genHeaders(props)]),
      //     this.proxySlot('bottom', this.genFooters(props)),
      //   ])
      // }

      return this.$createElement(VDataTable_VSimpleTable, {
        props: simpleProps,
        class: {
          'v-data-table--mobile': this.isMobile
        }
      }, [this.proxySlot('top', Object(helpers["v" /* getSlot */])(this, 'top', { ...props,
        isMobile: this.isMobile
      }, true)), this.genCaption(props), this.genColgroup(props), this.genHeaders(props), this.genBody(props), this.genFoot(props), this.proxySlot('bottom', this.genFooters(props))]);
    },

    proxySlot(slot, content) {
      return this.$createElement('template', {
        slot
      }, content);
    }

  },

  render() {
    return this.$createElement(VData, {
      props: { ...this.$props,
        customFilter: this.customFilterWithColumns,
        customSort: this.customSortWithHeaders,
        itemsPerPage: this.computedItemsPerPage
      },
      on: {
        'update:options': (v, old) => {
          this.internalGroupBy = v.groupBy || [];
          !Object(helpers["m" /* deepEqual */])(v, old) && this.$emit('update:options', v);
        },
        'update:page': v => this.$emit('update:page', v),
        'update:items-per-page': v => this.$emit('update:items-per-page', v),
        'update:sort-by': v => this.$emit('update:sort-by', v),
        'update:sort-desc': v => this.$emit('update:sort-desc', v),
        'update:group-by': v => this.$emit('update:group-by', v),
        'update:group-desc': v => this.$emit('update:group-desc', v),
        pagination: (v, old) => !Object(helpers["m" /* deepEqual */])(v, old) && this.$emit('pagination', v),
        'current-items': v => {
          this.internalCurrentItems = v;
          this.$emit('current-items', v);
        },
        'page-count': v => this.$emit('page-count', v)
      },
      scopedSlots: {
        default: this.genDefaultScopedSlot
      }
    });
  }

}));
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VDataTable/VEditDialog.sass
var VEditDialog = __webpack_require__(453);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/returnable/index.js
var returnable = __webpack_require__(92);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VMenu/index.js
var VMenu = __webpack_require__(204);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VDataTable/VEditDialog.js
// Styles
 // Mixins


 // Utils

 // Component




/* @vue/component */

/* harmony default export */ var VDataTable_VEditDialog = (Object(mixins["a" /* default */])(returnable["a" /* default */], themeable["a" /* default */]).extend({
  name: 'v-edit-dialog',
  props: {
    cancelText: {
      default: 'Cancel'
    },
    large: Boolean,
    eager: Boolean,
    persistent: Boolean,
    saveText: {
      default: 'Save'
    },
    transition: {
      type: String,
      default: 'slide-x-reverse-transition'
    }
  },

  data() {
    return {
      isActive: false
    };
  },

  watch: {
    isActive(val) {
      if (val) {
        this.$emit('open');
        setTimeout(this.focus, 50); // Give DOM time to paint
      } else {
        this.$emit('close');
      }
    }

  },
  methods: {
    cancel() {
      this.isActive = false;
      this.$emit('cancel');
    },

    focus() {
      const input = this.$refs.content.querySelector('input');
      input && input.focus();
    },

    genButton(fn, text) {
      return this.$createElement(VBtn["b" /* default */], {
        props: {
          text: true,
          color: 'primary',
          light: true
        },
        on: {
          click: fn
        }
      }, text);
    },

    genActions() {
      return this.$createElement('div', {
        class: 'v-small-dialog__actions'
      }, [this.genButton(this.cancel, this.cancelText), this.genButton(() => {
        this.save(this.returnValue);
        this.$emit('save');
      }, this.saveText)]);
    },

    genContent() {
      return this.$createElement('div', {
        staticClass: 'v-small-dialog__content',
        on: {
          keydown: e => {
            e.keyCode === helpers["B" /* keyCodes */].esc && this.cancel();

            if (e.keyCode === helpers["B" /* keyCodes */].enter) {
              this.save(this.returnValue);
              this.$emit('save');
            }
          }
        },
        ref: 'content'
      }, [this.$slots.input]);
    }

  },

  render(h) {
    return h(VMenu["b" /* default */], {
      staticClass: 'v-small-dialog',
      class: this.themeClasses,
      props: {
        contentClass: 'v-small-dialog__menu-content',
        transition: this.transition,
        origin: 'top right',
        right: true,
        value: this.isActive,
        closeOnClick: !this.persistent,
        closeOnContentClick: false,
        eager: this.eager,
        light: this.light,
        dark: this.dark
      },
      on: {
        input: val => this.isActive = val
      },
      scopedSlots: {
        activator: ({
          on
        }) => {
          return h('div', {
            staticClass: 'v-small-dialog__activator',
            on
          }, [h('span', {
            staticClass: 'v-small-dialog__activator__content'
          }, this.$slots.default)]);
        }
      }
    }, [this.genContent(), this.large ? this.genActions() : null]);
  }

}));
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VDataTable/VVirtualTable.sass
var VVirtualTable = __webpack_require__(454);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VDataTable/VVirtualTable.js
 // Components


 // Utiltiies

 // Types

const baseMixins = Object(mixins["a" /* default */])(VDataTable_VSimpleTable);
/* harmony default export */ var VDataTable_VVirtualTable = (baseMixins.extend().extend({
  name: 'v-virtual-table',
  props: {
    chunkSize: {
      type: Number,
      default: 25
    },
    headerHeight: {
      type: Number,
      default: 48
    },
    items: {
      type: Array,
      default: () => []
    },
    rowHeight: {
      type: Number,
      default: 48
    }
  },
  data: () => ({
    scrollTop: 0,
    oldChunk: 0,
    scrollDebounce: null,
    invalidateCache: false
  }),
  computed: {
    itemsLength() {
      return this.items.length;
    },

    totalHeight() {
      return this.itemsLength * this.rowHeight + this.headerHeight;
    },

    topIndex() {
      return Math.floor(this.scrollTop / this.rowHeight);
    },

    chunkIndex() {
      return Math.floor(this.topIndex / this.chunkSize);
    },

    startIndex() {
      return Math.max(0, this.chunkIndex * this.chunkSize - this.chunkSize);
    },

    offsetTop() {
      return Math.max(0, this.startIndex * this.rowHeight);
    },

    stopIndex() {
      return Math.min(this.startIndex + this.chunkSize * 3, this.itemsLength);
    },

    offsetBottom() {
      return Math.max(0, (this.itemsLength - this.stopIndex - this.startIndex) * this.rowHeight);
    }

  },
  watch: {
    chunkIndex(newValue, oldValue) {
      this.oldChunk = oldValue;
    },

    items() {
      this.cachedItems = null;
      this.$refs.table.scrollTop = 0;
    }

  },

  created() {
    this.cachedItems = null;
  },

  mounted() {
    this.scrollDebounce = Object(helpers["l" /* debounce */])(this.onScroll, 50);
    this.$refs.table.addEventListener('scroll', this.scrollDebounce, {
      passive: true
    });
  },

  beforeDestroy() {
    this.$refs.table.removeEventListener('scroll', this.scrollDebounce);
  },

  methods: {
    createStyleHeight(height) {
      return {
        height: `${height}px`
      };
    },

    genBody() {
      if (this.cachedItems === null || this.chunkIndex !== this.oldChunk) {
        this.cachedItems = this.genItems();
        this.oldChunk = this.chunkIndex;
      }

      return this.$createElement('tbody', [this.$createElement('tr', {
        style: this.createStyleHeight(this.offsetTop)
      }), this.cachedItems, this.$createElement('tr', {
        style: this.createStyleHeight(this.offsetBottom)
      })]);
    },

    genItems() {
      return this.$scopedSlots.items({
        items: this.items.slice(this.startIndex, this.stopIndex)
      });
    },

    onScroll(e) {
      const target = e.target;
      this.scrollTop = target.scrollTop;
    },

    genTable() {
      return this.$createElement('div', {
        ref: 'table',
        staticClass: 'v-virtual-table__table'
      }, [this.$createElement('table', [this.$slots['body.before'], this.genBody(), this.$slots['body.after']])]);
    },

    genWrapper() {
      return this.$createElement('div', {
        staticClass: 'v-virtual-table__wrapper',
        style: {
          height: Object(helpers["i" /* convertToUnit */])(this.height)
        }
      }, [this.genTable()]);
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'v-data-table v-virtual-table',
      class: this.classes
    }, [this.$slots.top, this.genWrapper(), this.$slots.bottom]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VDataTable/index.js






const VTableOverflow = Object(helpers["k" /* createSimpleFunctional */])('v-table__overflow');

/* harmony default export */ var components_VDataTable = ({
  $_vuetify_subcomponents: {
    VDataTable: VDataTable_VDataTable,
    VDataTableHeader: VDataTable_VDataTableHeader,
    VEditDialog: VDataTable_VEditDialog,
    VTableOverflow,
    VSimpleTable: VDataTable_VSimpleTable,
    VVirtualTable: VDataTable_VVirtualTable
  }
});
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VDatePicker/index.js
var VDatePicker = __webpack_require__(365);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VDialog/index.js
var components_VDialog = __webpack_require__(269);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VDivider/index.js
var VDivider = __webpack_require__(89);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VExpansionPanel/index.js
var VExpansionPanel = __webpack_require__(369);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VFileInput/VFileInput.sass
var VFileInput = __webpack_require__(455);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VTextField/index.js
var components_VTextField = __webpack_require__(200);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VChip/VChip.js
var VChip_VChip = __webpack_require__(300);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VFileInput/VFileInput.js
// Styles
 // Extensions

 // Components

 // Utilities




/* harmony default export */ var VFileInput_VFileInput = (components_VTextField["b" /* default */].extend({
  name: 'v-file-input',
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    chips: Boolean,
    clearable: {
      type: Boolean,
      default: true
    },
    counterSizeString: {
      type: String,
      default: '$vuetify.fileInput.counterSize'
    },
    counterString: {
      type: String,
      default: '$vuetify.fileInput.counter'
    },
    hideInput: Boolean,
    multiple: Boolean,
    placeholder: String,
    prependIcon: {
      type: String,
      default: '$file'
    },
    readonly: {
      type: Boolean,
      default: false
    },
    showSize: {
      type: [Boolean, Number],
      default: false,
      validator: v => {
        return typeof v === 'boolean' || [1000, 1024].includes(v);
      }
    },
    smallChips: Boolean,
    truncateLength: {
      type: [Number, String],
      default: 22
    },
    type: {
      type: String,
      default: 'file'
    },
    value: {
      default: undefined,
      validator: val => {
        return Object(helpers["L" /* wrapInArray */])(val).every(v => v != null && typeof v === 'object');
      }
    }
  },
  computed: {
    classes() {
      return { ...components_VTextField["b" /* default */].options.computed.classes.call(this),
        'v-file-input': true
      };
    },

    computedCounterValue() {
      const fileCount = this.multiple && this.lazyValue ? this.lazyValue.length : this.lazyValue instanceof File ? 1 : 0;
      if (!this.showSize) return this.$vuetify.lang.t(this.counterString, fileCount);
      const bytes = this.internalArrayValue.reduce((bytes, {
        size = 0
      }) => {
        return bytes + size;
      }, 0);
      return this.$vuetify.lang.t(this.counterSizeString, fileCount, Object(helpers["z" /* humanReadableFileSize */])(bytes, this.base === 1024));
    },

    internalArrayValue() {
      return Object(helpers["L" /* wrapInArray */])(this.internalValue);
    },

    internalValue: {
      get() {
        return this.lazyValue;
      },

      set(val) {
        this.lazyValue = val;
        this.$emit('change', this.lazyValue);
      }

    },

    isDirty() {
      return this.internalArrayValue.length > 0;
    },

    isLabelActive() {
      return this.isDirty;
    },

    text() {
      if (!this.isDirty && (this.persistentPlaceholder || this.isFocused || !this.hasLabel)) return [this.placeholder];
      return this.internalArrayValue.map(file => {
        const {
          name = '',
          size = 0
        } = file;
        const truncatedText = this.truncateText(name);
        return !this.showSize ? truncatedText : `${truncatedText} (${Object(helpers["z" /* humanReadableFileSize */])(size, this.base === 1024)})`;
      });
    },

    base() {
      return typeof this.showSize !== 'boolean' ? this.showSize : undefined;
    },

    hasChips() {
      return this.chips || this.smallChips;
    }

  },
  watch: {
    readonly: {
      handler(v) {
        if (v === true) Object(console["b" /* consoleError */])('readonly is not supported on <v-file-input>', this);
      },

      immediate: true
    },

    value(v) {
      const value = this.multiple ? v : v ? [v] : [];

      if (!Object(helpers["m" /* deepEqual */])(value, this.$refs.input.files)) {
        // When the input value is changed programatically, clear the
        // internal input's value so that the `onInput` handler
        // can be triggered again if the user re-selects the exact
        // same file(s). Ideally, `input.files` should be
        // manipulated directly but that property is readonly.
        this.$refs.input.value = '';
      }
    }

  },
  methods: {
    clearableCallback() {
      this.internalValue = this.multiple ? [] : null;
      this.$refs.input.value = '';
    },

    genChips() {
      if (!this.isDirty) return [];
      return this.text.map((text, index) => this.$createElement(VChip_VChip["a" /* default */], {
        props: {
          small: this.smallChips
        },
        on: {
          'click:close': () => {
            const internalValue = this.internalValue;
            internalValue.splice(index, 1);
            this.internalValue = internalValue; // Trigger the watcher
          }
        }
      }, [text]));
    },

    genControl() {
      const render = components_VTextField["b" /* default */].options.methods.genControl.call(this);

      if (this.hideInput) {
        render.data.style = Object(mergeData["d" /* mergeStyles */])(render.data.style, {
          display: 'none'
        });
      }

      return render;
    },

    genInput() {
      const input = components_VTextField["b" /* default */].options.methods.genInput.call(this);
      input.data.attrs.multiple = this.multiple; // We should not be setting value
      // programmatically on the input
      // when it is using type="file"

      delete input.data.domProps.value; // This solves an issue in Safari where
      // nothing happens when adding a file
      // do to the input event not firing
      // https://github.com/vuetifyjs/vuetify/issues/7941

      delete input.data.on.input;
      input.data.on.change = this.onInput;
      return [this.genSelections(), input];
    },

    genPrependSlot() {
      if (!this.prependIcon) return null;
      const icon = this.genIcon('prepend', () => {
        this.$refs.input.click();
      });
      return this.genSlot('prepend', 'outer', [icon]);
    },

    genSelectionText() {
      const length = this.text.length;
      if (length < 2) return this.text;
      if (this.showSize && !this.counter) return [this.computedCounterValue];
      return [this.$vuetify.lang.t(this.counterString, length)];
    },

    genSelections() {
      const children = [];

      if (this.isDirty && this.$scopedSlots.selection) {
        this.internalArrayValue.forEach((file, index) => {
          if (!this.$scopedSlots.selection) return;
          children.push(this.$scopedSlots.selection({
            text: this.text[index],
            file,
            index
          }));
        });
      } else {
        children.push(this.hasChips && this.isDirty ? this.genChips() : this.genSelectionText());
      }

      return this.$createElement('div', {
        staticClass: 'v-file-input__text',
        class: {
          'v-file-input__text--placeholder': this.placeholder && !this.isDirty,
          'v-file-input__text--chips': this.hasChips && !this.$scopedSlots.selection
        }
      }, children);
    },

    genTextFieldSlot() {
      const node = components_VTextField["b" /* default */].options.methods.genTextFieldSlot.call(this);
      node.data.on = { ...(node.data.on || {}),
        click: () => this.$refs.input.click()
      };
      return node;
    },

    onInput(e) {
      const files = [...(e.target.files || [])];
      this.internalValue = this.multiple ? files : files[0]; // Set initialValue here otherwise isFocused
      // watcher in VTextField will emit a change
      // event whenever the component is blurred

      this.initialValue = this.internalValue;
    },

    onKeyDown(e) {
      this.$emit('keydown', e);
    },

    truncateText(str) {
      if (str.length < Number(this.truncateLength)) return str;
      const charsKeepOneSide = Math.floor((Number(this.truncateLength) - 1) / 2);
      return `${str.slice(0, charsKeepOneSide)}…${str.slice(str.length - charsKeepOneSide)}`;
    }

  }
}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VFileInput/index.js


/* harmony default export */ var components_VFileInput = (VFileInput_VFileInput);
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VFooter/index.js
var VFooter = __webpack_require__(207);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VForm/index.js
var VForm = __webpack_require__(380);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VGrid/index.js + 2 modules
var VGrid = __webpack_require__(88);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/delayable/index.js
var delayable = __webpack_require__(60);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VHover/VHover.js
// Mixins

 // Utilities



/* harmony default export */ var VHover = (Object(mixins["a" /* default */])(delayable["a" /* default */], toggleable["a" /* default */]
/* @vue/component */
).extend({
  name: 'v-hover',
  props: {
    disabled: {
      type: Boolean,
      default: false
    },
    value: {
      type: Boolean,
      default: undefined
    }
  },
  methods: {
    onMouseEnter() {
      this.runDelay('open');
    },

    onMouseLeave() {
      this.runDelay('close');
    }

  },

  render() {
    if (!this.$scopedSlots.default && this.value === undefined) {
      Object(console["c" /* consoleWarn */])('v-hover is missing a default scopedSlot or bound value', this);
      return null;
    }

    let element;
    /* istanbul ignore else */

    if (this.$scopedSlots.default) {
      element = this.$scopedSlots.default({
        hover: this.isActive
      });
    }

    if (Array.isArray(element) && element.length === 1) {
      element = element[0];
    }

    if (!element || Array.isArray(element) || !element.tag) {
      Object(console["c" /* consoleWarn */])('v-hover should only contain a single element', this);
      return element;
    }

    if (!this.disabled) {
      element.data = element.data || {};

      this._g(element.data, {
        mouseenter: this.onMouseEnter,
        mouseleave: this.onMouseLeave
      });
    }

    return element;
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VHover/index.js


/* harmony default export */ var components_VHover = (VHover);
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VImg/index.js
var VImg = __webpack_require__(90);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/groupable/index.js
var groupable = __webpack_require__(34);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VItemGroup/VItem.js
// Mixins
 // Utilities


 // Types


/* @vue/component */

const BaseItem = external_vue_default.a.extend({
  props: {
    activeClass: String,
    value: {
      required: false
    }
  },
  data: () => ({
    isActive: false
  }),
  methods: {
    toggle() {
      this.isActive = !this.isActive;
    }

  },

  render() {
    if (!this.$scopedSlots.default) {
      Object(console["c" /* consoleWarn */])('v-item is missing a default scopedSlot', this);
      return null;
    }

    let element;
    /* istanbul ignore else */

    if (this.$scopedSlots.default) {
      element = this.$scopedSlots.default({
        active: this.isActive,
        toggle: this.toggle
      });
    }

    if (Array.isArray(element) && element.length === 1) {
      element = element[0];
    }

    if (!element || Array.isArray(element) || !element.tag) {
      Object(console["c" /* consoleWarn */])('v-item should only contain a single element', this);
      return element;
    }

    element.data = this._b(element.data || {}, element.tag, {
      class: {
        [this.activeClass]: this.isActive
      }
    });
    return element;
  }

});
/* harmony default export */ var VItem = (Object(mixins["a" /* default */])(BaseItem, Object(groupable["a" /* factory */])('itemGroup', 'v-item', 'v-item-group')).extend({
  name: 'v-item'
}));
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VItemGroup/VItemGroup.js
var VItemGroup = __webpack_require__(17);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VItemGroup/index.js



/* harmony default export */ var components_VItemGroup = ({
  $_vuetify_subcomponents: {
    VItem: VItem,
    VItemGroup: VItemGroup["b" /* default */]
  }
});
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VLabel/index.js + 1 modules
var VLabel = __webpack_require__(61);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/measurable/index.js
var measurable = __webpack_require__(37);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/directives/intersect/index.js
var intersect = __webpack_require__(24);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VLazy/VLazy.js
// Mixins

 // Directives

 // Utilities



/* harmony default export */ var VLazy = (Object(mixins["a" /* default */])(measurable["a" /* default */], toggleable["a" /* default */]).extend({
  name: 'VLazy',
  directives: {
    intersect: intersect["b" /* default */]
  },
  props: {
    options: {
      type: Object,
      // For more information on types, navigate to:
      // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
      default: () => ({
        root: undefined,
        rootMargin: undefined,
        threshold: undefined
      })
    },
    tag: {
      type: String,
      default: 'div'
    },
    transition: {
      type: String,
      default: 'fade-transition'
    }
  },
  computed: {
    styles() {
      return { ...this.measurableStyles
      };
    }

  },
  methods: {
    genContent() {
      const children = this.isActive && Object(helpers["v" /* getSlot */])(this);
      return this.transition ? this.$createElement('transition', {
        props: {
          name: this.transition
        }
      }, children) : children;
    },

    onObserve(entries, observer, isIntersecting) {
      if (this.isActive) return;
      this.isActive = isIntersecting;
    }

  },

  render(h) {
    return h(this.tag, {
      staticClass: 'v-lazy',
      attrs: this.$attrs,
      directives: [{
        name: 'intersect',
        value: {
          handler: this.onObserve,
          options: this.options
        }
      }],
      on: this.$listeners,
      style: this.styles
    }, [this.genContent()]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VLazy/index.js


/* harmony default export */ var components_VLazy = (VLazy);
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VList/index.js + 2 modules
var VList = __webpack_require__(11);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VMain/index.js
var components_VMain = __webpack_require__(125);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VMessages/index.js + 1 modules
var VMessages = __webpack_require__(103);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VNavigationDrawer/index.js
var VNavigationDrawer = __webpack_require__(126);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VTextField/VTextField.sass
var VTextField_VTextField = __webpack_require__(127);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VOtpInput/VOtpInput.sass
var VOtpInput = __webpack_require__(456);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VOtpInput/VOtpInput.js
// Styles

 // Extensions


 // Directives

 // Utilities


 // Types


const VOtpInput_baseMixins = Object(mixins["a" /* default */])(VInput["b" /* default */]);
/* @vue/component */

/* harmony default export */ var VOtpInput_VOtpInput = (VOtpInput_baseMixins.extend().extend({
  name: 'v-otp-input',
  directives: {
    ripple: ripple["b" /* default */]
  },
  inheritAttrs: false,
  props: {
    length: {
      type: [Number, String],
      default: 6
    },
    type: {
      type: String,
      default: 'text'
    },
    plain: Boolean
  },
  data: () => ({
    badInput: false,
    initialValue: null,
    isBooted: false,
    otp: []
  }),
  computed: {
    outlined() {
      return !this.plain;
    },

    classes() {
      return { ...VInput["b" /* default */].options.computed.classes.call(this),
        ...VTextField["a" /* default */].options.computed.classes.call(this),
        'v-otp-input--plain': this.plain
      };
    },

    isDirty() {
      return VInput["b" /* default */].options.computed.isDirty.call(this) || this.badInput;
    }

  },
  watch: {
    isFocused: 'updateValue',

    value(val) {
      this.lazyValue = val;
    }

  },

  created() {
    var _this$internalValue;
    /* istanbul ignore next */


    if (this.$attrs.hasOwnProperty('browser-autocomplete')) {
      Object(console["a" /* breaking */])('browser-autocomplete', 'autocomplete', this);
    }

    this.otp = ((_this$internalValue = this.internalValue) == null ? void 0 : _this$internalValue.split('')) || [];
  },

  mounted() {
    requestAnimationFrame(() => this.isBooted = true);
  },

  methods: {
    /** @public */
    focus(e, otpIdx) {
      this.onFocus(e, otpIdx || 0);
    },

    genInputSlot(otpIdx) {
      return this.$createElement('div', this.setBackgroundColor(this.backgroundColor, {
        staticClass: 'v-input__slot',
        style: {
          height: Object(helpers["i" /* convertToUnit */])(this.height)
        },
        on: {
          click: () => this.onClick(otpIdx),
          mousedown: e => this.onMouseDown(e, otpIdx),
          mouseup: e => this.onMouseUp(e, otpIdx)
        }
      }), [this.genDefaultSlot(otpIdx)]);
    },

    genControl(otpIdx) {
      return this.$createElement('div', {
        staticClass: 'v-input__control'
      }, [this.genInputSlot(otpIdx)]);
    },

    genDefaultSlot(otpIdx) {
      return [this.genFieldset(), this.genTextFieldSlot(otpIdx)];
    },

    genContent() {
      return Array.from({
        length: +this.length
      }, (_, i) => {
        return this.$createElement('div', this.setTextColor(this.validationState, {
          staticClass: 'v-input',
          class: this.classes
        }), [this.genControl(i)]);
      });
    },

    genFieldset() {
      return this.$createElement('fieldset', {
        attrs: {
          'aria-hidden': true
        }
      }, [this.genLegend()]);
    },

    genLegend() {
      const span = this.$createElement('span', {
        domProps: {
          innerHTML: '&#8203;'
        }
      });
      return this.$createElement('legend', {
        style: {
          width: '0px'
        }
      }, [span]);
    },

    genInput(otpIdx) {
      const listeners = Object.assign({}, this.listeners$);
      delete listeners.change; // Change should not be bound externally

      return this.$createElement('input', {
        style: {},
        domProps: {
          value: this.otp[otpIdx],
          min: this.type === 'number' ? 0 : null
        },
        attrs: { ...this.attrs$,
          disabled: this.isDisabled,
          readonly: this.isReadonly,
          type: this.type,
          id: `${this.computedId}--${otpIdx}`,
          class: `otp-field-box--${otpIdx}`,
          maxlength: 1
        },
        on: Object.assign(listeners, {
          blur: this.onBlur,
          input: e => this.onInput(e, otpIdx),
          focus: e => this.onFocus(e, otpIdx),
          paste: e => this.onPaste(e, otpIdx),
          keydown: this.onKeyDown,
          keyup: e => this.onKeyUp(e, otpIdx)
        }),
        ref: 'input',
        refInFor: true
      });
    },

    genTextFieldSlot(otpIdx) {
      return this.$createElement('div', {
        staticClass: 'v-text-field__slot'
      }, [this.genInput(otpIdx)]);
    },

    onBlur(e) {
      this.isFocused = false;
      e && this.$nextTick(() => this.$emit('blur', e));
    },

    onClick(otpIdx) {
      if (this.isFocused || this.isDisabled || !this.$refs.input[otpIdx]) return;
      this.onFocus(undefined, otpIdx);
    },

    onFocus(e, otpIdx) {
      e == null ? void 0 : e.preventDefault();
      e == null ? void 0 : e.stopPropagation();
      const elements = this.$refs.input;
      const ref = this.$refs.input && elements[otpIdx || 0];
      if (!ref) return;

      if (document.activeElement !== ref) {
        ref.focus();
        return ref.select();
      }

      if (!this.isFocused) {
        this.isFocused = true;
        ref.select();
        e && this.$emit('focus', e);
      }
    },

    onInput(e, otpIdx) {
      const target = e.target;
      const value = target.value;
      this.applyValue(otpIdx, target.value, () => {
        this.internalValue = this.otp.join('');
      });
      this.badInput = target.validity && target.validity.badInput;
      const nextIndex = otpIdx + 1;

      if (value) {
        if (nextIndex < +this.length) {
          this.changeFocus(nextIndex);
        } else {
          this.clearFocus(otpIdx);
          this.onCompleted();
        }
      }
    },

    clearFocus(index) {
      const input = this.$refs.input[index];
      input.blur();
    },

    onKeyDown(e) {
      if (e.keyCode === helpers["B" /* keyCodes */].enter) {
        this.$emit('change', this.internalValue);
      }

      this.$emit('keydown', e);
    },

    onMouseDown(e, otpIdx) {
      // Prevent input from being blurred
      if (e.target !== this.$refs.input[otpIdx]) {
        e.preventDefault();
        e.stopPropagation();
      }

      VInput["b" /* default */].options.methods.onMouseDown.call(this, e);
    },

    onMouseUp(e, otpIdx) {
      if (this.hasMouseDown) this.focus(e, otpIdx);
      VInput["b" /* default */].options.methods.onMouseUp.call(this, e);
    },

    onPaste(event, index) {
      var _event$clipboardData;

      const maxCursor = +this.length - 1;
      const inputVal = event == null ? void 0 : (_event$clipboardData = event.clipboardData) == null ? void 0 : _event$clipboardData.getData('Text');
      const inputDataArray = (inputVal == null ? void 0 : inputVal.split('')) || [];
      event.preventDefault();
      const newOtp = [...this.otp];

      for (let i = 0; i < inputDataArray.length; i++) {
        const appIdx = index + i;
        if (appIdx > maxCursor) break;
        newOtp[appIdx] = inputDataArray[i].toString();
      }

      this.otp = newOtp;
      const targetFocus = Math.min(index + inputDataArray.length, maxCursor);
      this.changeFocus(targetFocus);

      if (newOtp.length === +this.length) {
        this.onCompleted();
        this.clearFocus(targetFocus);
      }
    },

    applyValue(index, inputVal, next) {
      const newOtp = [...this.otp];
      newOtp[index] = inputVal;
      this.otp = newOtp;
      next();
    },

    changeFocus(index) {
      this.onFocus(undefined, index || 0);
    },

    updateValue(val) {
      // Sets validationState from validatable
      this.hasColor = val;

      if (val) {
        this.initialValue = this.lazyValue;
      } else if (this.initialValue !== this.lazyValue) {
        this.$emit('change', this.lazyValue);
      }
    },

    onKeyUp(event, index) {
      event.preventDefault();
      const eventKey = event.key;

      if (['Tab', 'Shift', 'Meta', 'Control', 'Alt'].includes(eventKey)) {
        return;
      }

      if (['Delete'].includes(eventKey)) {
        return;
      }

      if (eventKey === 'ArrowLeft' || eventKey === 'Backspace' && !this.otp[index]) {
        return index > 0 && this.changeFocus(index - 1);
      }

      if (eventKey === 'ArrowRight') {
        return index + 1 < +this.length && this.changeFocus(index + 1);
      }
    },

    onCompleted() {
      const rsp = this.otp.join('');

      if (rsp.length === +this.length) {
        this.$emit('finish', rsp);
      }
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'v-otp-input',
      class: this.themeClasses
    }, this.genContent());
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VOtpInput/index.js


/* harmony default export */ var components_VOtpInput = (VOtpInput_VOtpInput);
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VOverflowBtn/VOverflowBtn.sass
var VOverflowBtn = __webpack_require__(457);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VOverflowBtn/VOverflowBtn.js
// Styles
 // Extensions



 // Components

 // Utilities


/* @vue/component */

/* harmony default export */ var VOverflowBtn_VOverflowBtn = (components_VAutocomplete.extend({
  name: 'v-overflow-btn',
  props: {
    editable: Boolean,
    segmented: Boolean
  },
  computed: {
    classes() {
      return { ...components_VAutocomplete.options.computed.classes.call(this),
        'v-overflow-btn': true,
        'v-overflow-btn--segmented': this.segmented,
        'v-overflow-btn--editable': this.editable
      };
    },

    isAnyValueAllowed() {
      return this.editable || components_VAutocomplete.options.computed.isAnyValueAllowed.call(this);
    },

    isSingle() {
      return true;
    },

    computedItems() {
      return this.segmented ? this.allItems : this.filteredItems;
    }

  },
  methods: {
    genSelections() {
      return this.editable ? components_VAutocomplete.options.methods.genSelections.call(this) : VSelect["a" /* default */].options.methods.genSelections.call(this); // Override v-autocomplete's override
    },

    genCommaSelection(item, index, last) {
      return this.segmented ? this.genSegmentedBtn(item) : VSelect["a" /* default */].options.methods.genCommaSelection.call(this, item, index, last);
    },

    genInput() {
      const input = VTextField["a" /* default */].options.methods.genInput.call(this);
      input.data = input.data || {};
      input.data.domProps.value = this.editable ? this.internalSearch : '';
      input.data.attrs.readonly = !this.isAnyValueAllowed;
      return input;
    },

    genLabel() {
      if (this.editable && this.isFocused) return null;
      const label = VTextField["a" /* default */].options.methods.genLabel.call(this);
      if (!label) return label;
      label.data = label.data || {}; // Reset previously set styles from parent

      label.data.style = {};
      return label;
    },

    genSegmentedBtn(item) {
      const itemValue = this.getValue(item);
      const itemObj = this.computedItems.find(i => this.getValue(i) === itemValue) || item;

      if (!itemObj.text || !itemObj.callback) {
        Object(console["c" /* consoleWarn */])('When using "segmented" prop without a selection slot, items must contain both a text and callback property', this);
        return null;
      }

      return this.$createElement(VBtn["b" /* default */], {
        props: {
          text: true
        },
        on: {
          click(e) {
            e.stopPropagation();
            itemObj.callback(e);
          }

        }
      }, [itemObj.text]);
    },

    updateValue(val) {
      if (val) {
        this.initialValue = this.lazyValue;
      } else if (this.initialValue !== this.lazyValue) {
        this.$emit('change', this.lazyValue);
      }
    }

  }
}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VOverflowBtn/index.js


/* harmony default export */ var components_VOverflowBtn = (VOverflowBtn_VOverflowBtn);
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VOverlay/index.js + 1 modules
var VOverlay = __webpack_require__(102);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VPagination/VPagination.sass
var VPagination = __webpack_require__(458);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/intersectable/index.js
var intersectable = __webpack_require__(105);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VPagination/VPagination.js

 // Directives

 // Mixins



 // Utilities


/* @vue/component */

/* harmony default export */ var VPagination_VPagination = (Object(mixins["a" /* default */])(colorable["a" /* default */], Object(intersectable["a" /* default */])({
  onVisible: ['init']
}), themeable["a" /* default */]).extend({
  name: 'v-pagination',
  directives: {
    Resize: resize["b" /* default */]
  },
  props: {
    circle: Boolean,
    disabled: Boolean,
    length: {
      type: Number,
      default: 0,
      validator: val => val % 1 === 0
    },
    nextIcon: {
      type: String,
      default: '$next'
    },
    prevIcon: {
      type: String,
      default: '$prev'
    },
    totalVisible: [Number, String],
    value: {
      type: Number,
      default: 0
    },
    pageAriaLabel: {
      type: String,
      default: '$vuetify.pagination.ariaLabel.page'
    },
    currentPageAriaLabel: {
      type: String,
      default: '$vuetify.pagination.ariaLabel.currentPage'
    },
    previousAriaLabel: {
      type: String,
      default: '$vuetify.pagination.ariaLabel.previous'
    },
    nextAriaLabel: {
      type: String,
      default: '$vuetify.pagination.ariaLabel.next'
    },
    wrapperAriaLabel: {
      type: String,
      default: '$vuetify.pagination.ariaLabel.wrapper'
    }
  },

  data() {
    return {
      maxButtons: 0,
      selected: null
    };
  },

  computed: {
    classes() {
      return {
        'v-pagination': true,
        'v-pagination--circle': this.circle,
        'v-pagination--disabled': this.disabled,
        ...this.themeClasses
      };
    },

    items() {
      const totalVisible = parseInt(this.totalVisible, 10);

      if (totalVisible === 0) {
        return [];
      }

      const maxLength = Math.min(Math.max(0, totalVisible) || this.length, Math.max(0, this.maxButtons) || this.length, this.length);

      if (this.length <= maxLength) {
        return this.range(1, this.length);
      }

      const even = maxLength % 2 === 0 ? 1 : 0;
      const left = Math.floor(maxLength / 2);
      const right = this.length - left + 1 + even;

      if (this.value > left && this.value < right) {
        const firstItem = 1;
        const lastItem = this.length;
        const start = this.value - left + 2;
        const end = this.value + left - 2 - even;
        const secondItem = start - 1 === firstItem + 1 ? 2 : '...';
        const beforeLastItem = end + 1 === lastItem - 1 ? end + 1 : '...';
        return [1, secondItem, ...this.range(start, end), beforeLastItem, this.length];
      } else if (this.value === left) {
        const end = this.value + left - 1 - even;
        return [...this.range(1, end), '...', this.length];
      } else if (this.value === right) {
        const start = this.value - left + 1;
        return [1, '...', ...this.range(start, this.length)];
      } else {
        return [...this.range(1, left), '...', ...this.range(right, this.length)];
      }
    }

  },
  watch: {
    value() {
      this.init();
    }

  },

  mounted() {
    this.init();
  },

  methods: {
    init() {
      this.selected = null;
      this.$nextTick(this.onResize); // TODO: Change this (f75dee3a, cbdf7caa)

      setTimeout(() => this.selected = this.value, 100);
    },

    onResize() {
      const width = this.$el && this.$el.parentElement ? this.$el.parentElement.clientWidth : window.innerWidth;
      this.maxButtons = Math.floor((width - 96) / 42);
    },

    next(e) {
      e.preventDefault();
      this.$emit('input', this.value + 1);
      this.$emit('next');
    },

    previous(e) {
      e.preventDefault();
      this.$emit('input', this.value - 1);
      this.$emit('previous');
    },

    range(from, to) {
      const range = [];
      from = from > 0 ? from : 1;

      for (let i = from; i <= to; i++) {
        range.push(i);
      }

      return range;
    },

    genIcon(h, icon, disabled, fn, label) {
      return h('li', [h('button', {
        staticClass: 'v-pagination__navigation',
        class: {
          'v-pagination__navigation--disabled': disabled
        },
        attrs: {
          disabled,
          type: 'button',
          'aria-label': label
        },
        on: disabled ? {} : {
          click: fn
        }
      }, [h(VIcon["b" /* default */], [icon])])]);
    },

    genItem(h, i) {
      const color = i === this.value && (this.color || 'primary');
      const isCurrentPage = i === this.value;
      const ariaLabel = isCurrentPage ? this.currentPageAriaLabel : this.pageAriaLabel;
      return h('button', this.setBackgroundColor(color, {
        staticClass: 'v-pagination__item',
        class: {
          'v-pagination__item--active': i === this.value
        },
        attrs: {
          type: 'button',
          'aria-current': isCurrentPage,
          'aria-label': this.$vuetify.lang.t(ariaLabel, i)
        },
        on: {
          click: () => this.$emit('input', i)
        }
      }), [i.toString()]);
    },

    genItems(h) {
      return this.items.map((i, index) => {
        return h('li', {
          key: index
        }, [isNaN(Number(i)) ? h('span', {
          class: 'v-pagination__more'
        }, [i.toString()]) : this.genItem(h, i)]);
      });
    },

    genList(h, children) {
      return h('ul', {
        directives: [{
          modifiers: {
            quiet: true
          },
          name: 'resize',
          value: this.onResize
        }],
        class: this.classes
      }, children);
    }

  },

  render(h) {
    const children = [this.genIcon(h, this.$vuetify.rtl ? this.nextIcon : this.prevIcon, this.value <= 1, this.previous, this.$vuetify.lang.t(this.previousAriaLabel)), this.genItems(h), this.genIcon(h, this.$vuetify.rtl ? this.prevIcon : this.nextIcon, this.value >= this.length, this.next, this.$vuetify.lang.t(this.nextAriaLabel))];
    return h('nav', {
      attrs: {
        role: 'navigation',
        'aria-label': this.$vuetify.lang.t(this.wrapperAriaLabel)
      }
    }, [this.genList(h, children)]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VPagination/index.js


/* harmony default export */ var components_VPagination = (VPagination_VPagination);
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VParallax/index.js
var VParallax = __webpack_require__(370);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VPicker/index.js + 1 modules
var VPicker = __webpack_require__(313);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VProgressCircular/index.js
var VProgressCircular = __webpack_require__(94);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VProgressLinear/index.js + 1 modules
var VProgressLinear = __webpack_require__(91);

// EXTERNAL MODULE: ./node_modules/vuetify/src/styles/components/_selection-controls.sass
var _selection_controls = __webpack_require__(362);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VRadioGroup/VRadioGroup.sass
var VRadioGroup = __webpack_require__(459);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VRadioGroup/VRadioGroup.js
// Styles

 // Extensions


 // Types


const VRadioGroup_baseMixins = Object(mixins["a" /* default */])(VItemGroup["a" /* BaseItemGroup */], VInput["b" /* default */]);
/* @vue/component */

/* harmony default export */ var VRadioGroup_VRadioGroup = (VRadioGroup_baseMixins.extend({
  name: 'v-radio-group',

  provide() {
    return {
      radioGroup: this
    };
  },

  props: {
    column: {
      type: Boolean,
      default: true
    },
    height: {
      type: [Number, String],
      default: 'auto'
    },
    name: String,
    row: Boolean,
    // If no value set on VRadio
    // will match valueComparator
    // force default to null
    value: null
  },
  computed: {
    classes() {
      return { ...VInput["b" /* default */].options.computed.classes.call(this),
        'v-input--selection-controls v-input--radio-group': true,
        'v-input--radio-group--column': this.column && !this.row,
        'v-input--radio-group--row': this.row
      };
    }

  },
  methods: {
    genDefaultSlot() {
      return this.$createElement('div', {
        staticClass: 'v-input--radio-group__input',
        attrs: {
          id: this.id,
          role: 'radiogroup',
          'aria-labelledby': this.computedId
        }
      }, VInput["b" /* default */].options.methods.genDefaultSlot.call(this));
    },

    genInputSlot() {
      const render = VInput["b" /* default */].options.methods.genInputSlot.call(this);
      delete render.data.on.click;
      return render;
    },

    genLabel() {
      const label = VInput["b" /* default */].options.methods.genLabel.call(this);
      if (!label) return null;
      label.data.attrs.id = this.computedId; // WAI considers this an orphaned label

      delete label.data.attrs.for;
      label.tag = 'legend';
      return label;
    },

    onClick: VItemGroup["a" /* BaseItemGroup */].options.methods.onClick
  },

  render(h) {
    const vnode = VInput["b" /* default */].options.render.call(this, h);

    this._b(vnode.data, 'div', this.attrs$);

    return vnode;
  }

}));
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VRadioGroup/VRadio.sass
var VRadio = __webpack_require__(460);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/binds-attrs/index.js
var binds_attrs = __webpack_require__(26);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/rippleable/index.js
var rippleable = __webpack_require__(364);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/selectable/index.js
var selectable = __webpack_require__(363);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VRadioGroup/VRadio.js
// Styles



 // Mixins






 // Utilities




const VRadio_baseMixins = Object(mixins["a" /* default */])(binds_attrs["a" /* default */], colorable["a" /* default */], rippleable["a" /* default */], Object(groupable["a" /* factory */])('radioGroup'), themeable["a" /* default */]);
/* @vue/component */

/* harmony default export */ var VRadioGroup_VRadio = (VRadio_baseMixins.extend().extend({
  name: 'v-radio',
  inheritAttrs: false,
  props: {
    disabled: Boolean,
    id: String,
    label: String,
    name: String,
    offIcon: {
      type: String,
      default: '$radioOff'
    },
    onIcon: {
      type: String,
      default: '$radioOn'
    },
    readonly: Boolean,
    value: {
      default: null
    }
  },
  data: () => ({
    isFocused: false
  }),
  computed: {
    classes() {
      return {
        'v-radio--is-disabled': this.isDisabled,
        'v-radio--is-focused': this.isFocused,
        ...this.themeClasses,
        ...this.groupClasses
      };
    },

    computedColor() {
      return selectable["a" /* default */].options.computed.computedColor.call(this);
    },

    computedIcon() {
      return this.isActive ? this.onIcon : this.offIcon;
    },

    computedId() {
      return VInput["b" /* default */].options.computed.computedId.call(this);
    },

    hasLabel: VInput["b" /* default */].options.computed.hasLabel,

    hasState() {
      return (this.radioGroup || {}).hasState;
    },

    isDisabled() {
      return this.disabled || !!this.radioGroup && this.radioGroup.isDisabled;
    },

    isReadonly() {
      return this.readonly || !!this.radioGroup && this.radioGroup.isReadonly;
    },

    computedName() {
      if (this.name || !this.radioGroup) {
        return this.name;
      }

      return this.radioGroup.name || `radio-${this.radioGroup._uid}`;
    },

    rippleState() {
      return selectable["a" /* default */].options.computed.rippleState.call(this);
    },

    validationState() {
      return (this.radioGroup || {}).validationState || this.computedColor;
    }

  },
  methods: {
    genInput(args) {
      // We can't actually use the mixin directly because
      // it's made for standalone components, but its
      // genInput method is exactly what we need
      return selectable["a" /* default */].options.methods.genInput.call(this, 'radio', args);
    },

    genLabel() {
      if (!this.hasLabel) return null;
      return this.$createElement(VLabel["b" /* default */], {
        on: {
          // Label shouldn't cause the input to focus
          click: selectable["b" /* prevent */]
        },
        attrs: {
          for: this.computedId
        },
        props: {
          color: this.validationState,
          focused: this.hasState
        }
      }, Object(helpers["v" /* getSlot */])(this, 'label') || this.label);
    },

    genRadio() {
      const {
        title,
        ...radioAttrs
      } = this.attrs$;
      return this.$createElement('div', {
        staticClass: 'v-input--selection-controls__input'
      }, [this.$createElement(VIcon["b" /* default */], this.setTextColor(this.validationState, {
        props: {
          dense: this.radioGroup && this.radioGroup.dense
        }
      }), this.computedIcon), this.genInput({
        name: this.computedName,
        value: this.value,
        ...radioAttrs
      }), this.genRipple(this.setTextColor(this.rippleState))]);
    },

    onFocus(e) {
      this.isFocused = true;
      this.$emit('focus', e);
    },

    onBlur(e) {
      this.isFocused = false;
      this.$emit('blur', e);
    },

    onChange() {
      if (this.isDisabled || this.isReadonly || this.isActive) return;
      this.toggle();
    },

    onKeydown: () => {}
  },

  render(h) {
    const data = {
      staticClass: 'v-radio',
      class: this.classes,
      on: Object(mergeData["c" /* mergeListeners */])({
        click: this.onChange
      }, this.listeners$),
      attrs: {
        title: this.attrs$.title
      }
    };
    return h('div', data, [this.genRadio(), this.genLabel()]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VRadioGroup/index.js



/* harmony default export */ var components_VRadioGroup = ({
  $_vuetify_subcomponents: {
    VRadioGroup: VRadioGroup_VRadioGroup,
    VRadio: VRadioGroup_VRadio
  }
});
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VRangeSlider/VRangeSlider.sass
var VRangeSlider = __webpack_require__(461);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSlider/index.js


/* harmony default export */ var components_VSlider = (VSlider_VSlider);
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VRangeSlider/VRangeSlider.js
// Styles
 // Components

 // Helpers


/* @vue/component */

/* harmony default export */ var VRangeSlider_VRangeSlider = (components_VSlider.extend({
  name: 'v-range-slider',
  props: {
    value: {
      type: Array,
      default: () => [0, 0]
    }
  },

  data() {
    return {
      activeThumb: null,
      lazyValue: this.value
    };
  },

  computed: {
    classes() {
      return { ...components_VSlider.options.computed.classes.call(this),
        'v-input--range-slider': true
      };
    },

    internalValue: {
      get() {
        return this.lazyValue;
      },

      set(val) {
        // Round value to ensure the
        // entire slider range can
        // be selected with step
        let value = val.map((v = 0) => this.roundValue(Math.min(Math.max(v, this.minValue), this.maxValue))); // Switch values if range and wrong order

        if (value[0] > value[1] || value[1] < value[0]) {
          if (this.activeThumb !== null) {
            const toFocus = this.activeThumb === 1 ? 0 : 1;
            const el = this.$refs[`thumb_${toFocus}`];
            el.focus();
          }

          value = [value[1], value[0]];
        }

        this.lazyValue = value;
        if (!Object(helpers["m" /* deepEqual */])(value, this.value)) this.$emit('input', value);
        this.validate();
      }

    },

    inputWidth() {
      return this.internalValue.map(v => (this.roundValue(v) - this.minValue) / (this.maxValue - this.minValue) * 100);
    }

  },
  methods: {
    getTrackStyle(startLength, endLength, startPadding = 0, endPadding = 0) {
      const startDir = this.vertical ? this.$vuetify.rtl ? 'top' : 'bottom' : this.$vuetify.rtl ? 'right' : 'left';
      const endDir = this.vertical ? 'height' : 'width';
      const start = `calc(${startLength}% + ${startPadding}px)`;
      const end = `calc(${endLength}% + ${endPadding}px)`;
      return {
        transition: this.trackTransition,
        [startDir]: start,
        [endDir]: end
      };
    },

    getIndexOfClosestValue(arr, v) {
      if (Math.abs(arr[0] - v) < Math.abs(arr[1] - v)) return 0;else return 1;
    },

    genInput() {
      return Object(helpers["j" /* createRange */])(2).map(i => {
        const input = components_VSlider.options.methods.genInput.call(this);
        input.data = input.data || {};
        input.data.attrs = input.data.attrs || {};
        input.data.attrs.value = this.internalValue[i];
        input.data.attrs.id = `input-${i ? 'max' : 'min'}-${this._uid}`;
        return input;
      });
    },

    genTrackContainer() {
      const children = [];
      const padding = this.isDisabled ? 10 : 0;
      const sections = [{
        class: 'v-slider__track-background',
        color: this.computedTrackColor,
        styles: [0, this.inputWidth[0], 0, -padding]
      }, {
        class: this.isDisabled ? 'v-slider__track-background' : 'v-slider__track-fill',
        color: this.isDisabled ? this.computedTrackColor : this.computedTrackFillColor,
        styles: [this.inputWidth[0], Math.abs(this.inputWidth[1] - this.inputWidth[0]), padding, padding * -2]
      }, {
        class: 'v-slider__track-background',
        color: this.computedTrackColor,
        styles: [this.inputWidth[1], Math.abs(100 - this.inputWidth[1]), padding, -padding]
      }];
      if (this.$vuetify.rtl) sections.reverse();
      children.push(...sections.map(section => this.$createElement('div', this.setBackgroundColor(section.color, {
        staticClass: section.class,
        style: this.getTrackStyle(...section.styles)
      }))));
      return this.$createElement('div', {
        staticClass: 'v-slider__track-container',
        ref: 'track'
      }, children);
    },

    genChildren() {
      return [this.genInput(), this.genTrackContainer(), this.genSteps(), Object(helpers["j" /* createRange */])(2).map(index => {
        const value = this.internalValue[index];

        const onFocus = e => {
          this.isFocused = true;
          this.activeThumb = index;
          this.$emit('focus', e);
        };

        const onBlur = e => {
          this.isFocused = false;
          this.activeThumb = null;
          this.$emit('blur', e);
        };

        const valueWidth = this.inputWidth[index];
        const isActive = this.isActive && this.activeThumb === index;
        const isFocused = this.isFocused && this.activeThumb === index;
        return this.genThumbContainer(value, valueWidth, isActive, isFocused, onFocus, onBlur, `thumb_${index}`);
      })];
    },

    reevaluateSelected(value) {
      this.activeThumb = this.getIndexOfClosestValue(this.internalValue, value);
      const refName = `thumb_${this.activeThumb}`;
      const thumbRef = this.$refs[refName];
      thumbRef.focus();
    },

    onSliderMouseDown(e) {
      var _e$target;

      const value = this.parseMouseMove(e);
      this.reevaluateSelected(value);
      this.oldValue = this.internalValue;
      this.isActive = true;

      if ((_e$target = e.target) != null && _e$target.matches('.v-slider__thumb-container, .v-slider__thumb-container *')) {
        this.thumbPressed = true;
        const domRect = e.target.getBoundingClientRect();
        const touch = 'touches' in e ? e.touches[0] : e;
        this.startOffset = this.vertical ? touch.clientY - (domRect.top + domRect.height / 2) : touch.clientX - (domRect.left + domRect.width / 2);
      } else {
        this.startOffset = 0;
        window.clearTimeout(this.mouseTimeout);
        this.mouseTimeout = window.setTimeout(() => {
          this.thumbPressed = true;
        }, 300);
      }

      const mouseUpOptions = helpers["F" /* passiveSupported */] ? {
        passive: true,
        capture: true
      } : true;
      const mouseMoveOptions = helpers["F" /* passiveSupported */] ? {
        passive: true
      } : false;
      const isTouchEvent = ('touches' in e);
      this.onMouseMove(e);
      this.app.addEventListener(isTouchEvent ? 'touchmove' : 'mousemove', this.onMouseMove, mouseMoveOptions);
      Object(helpers["a" /* addOnceEventListener */])(this.app, isTouchEvent ? 'touchend' : 'mouseup', this.onSliderMouseUp, mouseUpOptions);
      this.$emit('start', this.internalValue);
    },

    onSliderClick(e) {
      if (!this.isActive) {
        if (this.noClick) {
          this.noClick = false;
          return;
        }

        const value = this.parseMouseMove(e);
        this.reevaluateSelected(value);
        this.setInternalValue(value);
        this.$emit('change', this.internalValue);
      }
    },

    onMouseMove(e) {
      const value = this.parseMouseMove(e);

      if (e.type === 'mousemove') {
        this.thumbPressed = true;
      }

      if (this.activeThumb === null) {
        this.activeThumb = this.getIndexOfClosestValue(this.internalValue, value);
      }

      this.setInternalValue(value);
    },

    onKeyDown(e) {
      if (this.activeThumb === null) return;
      const value = this.parseKeyDown(e, this.internalValue[this.activeThumb]);
      if (value == null) return;
      this.setInternalValue(value);
      this.$emit('change', this.internalValue);
    },

    setInternalValue(value) {
      this.internalValue = this.internalValue.map((v, i) => {
        if (i === this.activeThumb) return value;else return Number(v);
      });
    }

  }
}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VRangeSlider/index.js


/* harmony default export */ var components_VRangeSlider = (VRangeSlider_VRangeSlider);
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VRating/VRating.sass
var VRating = __webpack_require__(462);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/sizeable/index.js
var sizeable = __webpack_require__(58);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VRating/VRating.js
// Styles
 // Components

 // Mixins





 // Utilities



/* @vue/component */

/* harmony default export */ var VRating_VRating = (Object(mixins["a" /* default */])(colorable["a" /* default */], delayable["a" /* default */], rippleable["a" /* default */], sizeable["a" /* default */], themeable["a" /* default */]).extend({
  name: 'v-rating',
  props: {
    backgroundColor: {
      type: String,
      default: 'accent'
    },
    color: {
      type: String,
      default: 'primary'
    },
    clearable: Boolean,
    dense: Boolean,
    emptyIcon: {
      type: String,
      default: '$ratingEmpty'
    },
    fullIcon: {
      type: String,
      default: '$ratingFull'
    },
    halfIcon: {
      type: String,
      default: '$ratingHalf'
    },
    halfIncrements: Boolean,
    hover: Boolean,
    length: {
      type: [Number, String],
      default: 5
    },
    readonly: Boolean,
    size: [Number, String],
    value: {
      type: Number,
      default: 0
    },
    iconLabel: {
      type: String,
      default: '$vuetify.rating.ariaLabel.icon'
    }
  },

  data() {
    return {
      hoverIndex: -1,
      internalValue: this.value
    };
  },

  computed: {
    directives() {
      if (this.readonly || !this.ripple) return [];
      return [{
        name: 'ripple',
        value: {
          circle: true
        }
      }];
    },

    iconProps() {
      const {
        dark,
        large,
        light,
        medium,
        small,
        size,
        xLarge,
        xSmall
      } = this.$props;
      return {
        dark,
        large,
        light,
        medium,
        size,
        small,
        xLarge,
        xSmall
      };
    },

    isHovering() {
      return this.hover && this.hoverIndex >= 0;
    }

  },
  watch: {
    internalValue(val) {
      val !== this.value && this.$emit('input', val);
    },

    value(val) {
      this.internalValue = val;
    }

  },
  methods: {
    createClickFn(i) {
      return e => {
        if (this.readonly) return;
        const newValue = this.genHoverIndex(e, i);

        if (this.clearable && this.internalValue === newValue) {
          this.internalValue = 0;
        } else {
          this.internalValue = newValue;
        }
      };
    },

    createProps(i) {
      const props = {
        index: i,
        value: this.internalValue,
        click: this.createClickFn(i),
        isFilled: Math.floor(this.internalValue) > i,
        isHovered: Math.floor(this.hoverIndex) > i
      };

      if (this.halfIncrements) {
        props.isHalfHovered = !props.isHovered && (this.hoverIndex - i) % 1 > 0;
        props.isHalfFilled = !props.isFilled && (this.internalValue - i) % 1 > 0;
      }

      return props;
    },

    genHoverIndex(e, i) {
      let isHalf = this.isHalfEvent(e);

      if (this.halfIncrements && this.$vuetify.rtl) {
        isHalf = !isHalf;
      }

      return i + (isHalf ? 0.5 : 1);
    },

    getIconName(props) {
      const isFull = this.isHovering ? props.isHovered : props.isFilled;
      const isHalf = this.isHovering ? props.isHalfHovered : props.isHalfFilled;
      return isFull ? this.fullIcon : isHalf ? this.halfIcon : this.emptyIcon;
    },

    getColor(props) {
      if (this.isHovering) {
        if (props.isHovered || props.isHalfHovered) return this.color;
      } else {
        if (props.isFilled || props.isHalfFilled) return this.color;
      }

      return this.backgroundColor;
    },

    isHalfEvent(e) {
      if (this.halfIncrements) {
        const rect = e.target && e.target.getBoundingClientRect();
        if (rect && e.pageX - rect.left < rect.width / 2) return true;
      }

      return false;
    },

    onMouseEnter(e, i) {
      this.runDelay('open', () => {
        this.hoverIndex = this.genHoverIndex(e, i);
      });
    },

    onMouseLeave() {
      this.runDelay('close', () => this.hoverIndex = -1);
    },

    genItem(i) {
      const props = this.createProps(i);
      if (this.$scopedSlots.item) return this.$scopedSlots.item(props);
      const listeners = {
        click: props.click
      };

      if (this.hover) {
        listeners.mouseenter = e => this.onMouseEnter(e, i);

        listeners.mouseleave = this.onMouseLeave;

        if (this.halfIncrements) {
          listeners.mousemove = e => this.onMouseEnter(e, i);
        }
      }

      return this.$createElement(VIcon["b" /* default */], this.setTextColor(this.getColor(props), {
        attrs: {
          'aria-label': this.$vuetify.lang.t(this.iconLabel, i + 1, Number(this.length))
        },
        directives: this.directives,
        props: this.iconProps,
        on: listeners
      }), [this.getIconName(props)]);
    }

  },

  render(h) {
    const children = Object(helpers["j" /* createRange */])(Number(this.length)).map(i => this.genItem(i));
    return h('div', {
      staticClass: 'v-rating',
      class: {
        'v-rating--readonly': this.readonly,
        'v-rating--dense': this.dense
      }
    }, children);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VRating/index.js


/* harmony default export */ var components_VRating = (VRating_VRating);
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VResponsive/index.js
var VResponsive = __webpack_require__(62);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VSelect/index.js
var components_VSelect = __webpack_require__(366);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VSkeletonLoader/VSkeletonLoader.sass
var VSkeletonLoader = __webpack_require__(463);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSkeletonLoader/VSkeletonLoader.js
// Styles
 // Mixins



 // Utilities



/* @vue/component */

/* harmony default export */ var VSkeletonLoader_VSkeletonLoader = (Object(mixins["a" /* default */])(elevatable["a" /* default */], measurable["a" /* default */], themeable["a" /* default */]).extend({
  name: 'VSkeletonLoader',
  props: {
    boilerplate: Boolean,
    loading: Boolean,
    tile: Boolean,
    transition: String,
    type: String,
    types: {
      type: Object,
      default: () => ({})
    }
  },
  computed: {
    attrs() {
      if (!this.isLoading) return this.$attrs;
      return !this.boilerplate ? {
        'aria-busy': true,
        'aria-live': 'polite',
        role: 'alert',
        ...this.$attrs
      } : {};
    },

    classes() {
      return {
        'v-skeleton-loader--boilerplate': this.boilerplate,
        'v-skeleton-loader--is-loading': this.isLoading,
        'v-skeleton-loader--tile': this.tile,
        ...this.themeClasses,
        ...this.elevationClasses
      };
    },

    isLoading() {
      return !('default' in this.$scopedSlots) || this.loading;
    },

    rootTypes() {
      return {
        actions: 'button@2',
        article: 'heading, paragraph',
        avatar: 'avatar',
        button: 'button',
        card: 'image, card-heading',
        'card-avatar': 'image, list-item-avatar',
        'card-heading': 'heading',
        chip: 'chip',
        'date-picker': 'list-item, card-heading, divider, date-picker-options, date-picker-days, actions',
        'date-picker-options': 'text, avatar@2',
        'date-picker-days': 'avatar@28',
        heading: 'heading',
        image: 'image',
        'list-item': 'text',
        'list-item-avatar': 'avatar, text',
        'list-item-two-line': 'sentences',
        'list-item-avatar-two-line': 'avatar, sentences',
        'list-item-three-line': 'paragraph',
        'list-item-avatar-three-line': 'avatar, paragraph',
        paragraph: 'text@3',
        sentences: 'text@2',
        table: 'table-heading, table-thead, table-tbody, table-tfoot',
        'table-heading': 'heading, text',
        'table-thead': 'heading@6',
        'table-tbody': 'table-row-divider@6',
        'table-row-divider': 'table-row, divider',
        'table-row': 'table-cell@6',
        'table-cell': 'text',
        'table-tfoot': 'text@2, avatar@2',
        text: 'text',
        ...this.types
      };
    }

  },
  methods: {
    genBone(text, children) {
      return this.$createElement('div', {
        staticClass: `v-skeleton-loader__${text} v-skeleton-loader__bone`
      }, children);
    },

    genBones(bone) {
      // e.g. 'text@3'
      const [type, length] = bone.split('@');

      const generator = () => this.genStructure(type); // Generate a length array based upon
      // value after @ in the bone string


      return Array.from({
        length
      }).map(generator);
    },

    // Fix type when this is merged
    // https://github.com/microsoft/TypeScript/pull/33050
    genStructure(type) {
      let children = [];
      type = type || this.type || '';
      const bone = this.rootTypes[type] || ''; // End of recursion, do nothing

      /* eslint-disable-next-line no-empty, brace-style */

      if (type === bone) {} // Array of values - e.g. 'heading, paragraph, text@2'
      else if (type.indexOf(',') > -1) return this.mapBones(type); // Array of values - e.g. 'paragraph@4'
      else if (type.indexOf('@') > -1) return this.genBones(type); // Array of values - e.g. 'card@2'
      else if (bone.indexOf(',') > -1) children = this.mapBones(bone); // Array of values - e.g. 'list-item@2'
      else if (bone.indexOf('@') > -1) children = this.genBones(bone); // Single value - e.g. 'card-heading'
      else if (bone) children.push(this.genStructure(bone));

      return [this.genBone(type, children)];
    },

    genSkeleton() {
      const children = [];
      if (!this.isLoading) children.push(Object(helpers["v" /* getSlot */])(this));else children.push(this.genStructure());
      /* istanbul ignore else */

      if (!this.transition) return children;
      /* istanbul ignore next */

      return this.$createElement('transition', {
        props: {
          name: this.transition
        },
        // Only show transition when
        // content has been loaded
        on: {
          afterEnter: this.resetStyles,
          beforeEnter: this.onBeforeEnter,
          beforeLeave: this.onBeforeLeave,
          leaveCancelled: this.resetStyles
        }
      }, children);
    },

    mapBones(bones) {
      // Remove spaces and return array of structures
      return bones.replace(/\s/g, '').split(',').map(this.genStructure);
    },

    onBeforeEnter(el) {
      this.resetStyles(el);
      if (!this.isLoading) return;
      el._initialStyle = {
        display: el.style.display,
        transition: el.style.transition
      };
      el.style.setProperty('transition', 'none', 'important');
    },

    onBeforeLeave(el) {
      el.style.setProperty('display', 'none', 'important');
    },

    resetStyles(el) {
      if (!el._initialStyle) return;
      el.style.display = el._initialStyle.display || '';
      el.style.transition = el._initialStyle.transition;
      delete el._initialStyle;
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'v-skeleton-loader',
      attrs: this.attrs,
      on: this.$listeners,
      class: this.classes,
      style: this.isLoading ? this.measurableStyles : undefined
    }, [this.genSkeleton()]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSkeletonLoader/index.js


/* harmony default export */ var components_VSkeletonLoader = (VSkeletonLoader_VSkeletonLoader);
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSlideGroup/VSlideItem.js
// Extensions
 // Mixins



/* harmony default export */ var VSlideItem = (Object(mixins["a" /* default */])(BaseItem, Object(groupable["a" /* factory */])('slideGroup')
/* @vue/component */
).extend({
  name: 'v-slide-item'
}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSlideGroup/index.js



/* harmony default export */ var components_VSlideGroup = ({
  $_vuetify_subcomponents: {
    VSlideGroup: VSlideGroup["b" /* default */],
    VSlideItem: VSlideItem
  }
});
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VSnackbar/index.js
var VSnackbar = __webpack_require__(205);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSparkline/helpers/core.js
function genPoints(values, boundary) {
  const {
    minX,
    maxX,
    minY,
    maxY
  } = boundary;
  const totalValues = values.length;
  const maxValue = Math.max(...values);
  const minValue = Math.min(...values);
  const gridX = (maxX - minX) / (totalValues - 1);
  const gridY = (maxY - minY) / (maxValue - minValue || 1);
  return values.map((value, index) => {
    return {
      x: minX + index * gridX,
      y: maxY - (value - minValue) * gridY,
      value
    };
  });
}
function genBars(values, boundary) {
  const {
    minX,
    maxX,
    minY,
    maxY
  } = boundary;
  const totalValues = values.length;
  let maxValue = Math.max(...values);
  let minValue = Math.min(...values);
  if (minValue > 0) minValue = 0;
  if (maxValue < 0) maxValue = 0;
  const gridX = maxX / totalValues;
  const gridY = (maxY - minY) / (maxValue - minValue || 1);
  const horizonY = maxY - Math.abs(minValue * gridY);
  return values.map((value, index) => {
    const height = Math.abs(gridY * value);
    return {
      x: minX + index * gridX,
      y: horizonY - height + +(value < 0) * height,
      height,
      value
    };
  });
}
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSparkline/helpers/math.js
function math_int(value) {
  return parseInt(value, 10);
}
/**
 * https://en.wikipedia.org/wiki/Collinearity
 * x=(x1+x2)/2
 * y=(y1+y2)/2
 */


function checkCollinear(p0, p1, p2) {
  return math_int(p0.x + p2.x) === math_int(2 * p1.x) && math_int(p0.y + p2.y) === math_int(2 * p1.y);
}
function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}
function moveTo(to, from, radius) {
  const vector = {
    x: to.x - from.x,
    y: to.y - from.y
  };
  const length = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
  const unitVector = {
    x: vector.x / length,
    y: vector.y / length
  };
  return {
    x: from.x + unitVector.x * radius,
    y: from.y + unitVector.y * radius
  };
}
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSparkline/helpers/path.js

/**
 * From https://github.com/unsplash/react-trend/blob/master/src/helpers/DOM.helpers.js#L18
 */

function genPath(points, radius, fill = false, height = 75) {
  const start = points.shift();
  const end = points[points.length - 1];
  return (fill ? `M${start.x} ${height - start.x + 2} L${start.x} ${start.y}` : `M${start.x} ${start.y}`) + points.map((point, index) => {
    const next = points[index + 1];
    const prev = points[index - 1] || start;
    const isCollinear = next && checkCollinear(next, point, prev);

    if (!next || isCollinear) {
      return `L${point.x} ${point.y}`;
    }

    const threshold = Math.min(getDistance(prev, point), getDistance(next, point));
    const isTooCloseForRadius = threshold / 2 < radius;
    const radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius;
    const before = moveTo(prev, point, radiusForPoint);
    const after = moveTo(next, point, radiusForPoint);
    return `L${before.x} ${before.y}S${point.x} ${point.y} ${after.x} ${after.y}`;
  }).join('') + (fill ? `L${end.x} ${height - start.x + 2} Z` : '');
}
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSparkline/VSparkline.js
// Mixins
 // Utilities




/* harmony default export */ var VSparkline = (Object(mixins["a" /* default */])(colorable["a" /* default */]).extend({
  name: 'VSparkline',
  inheritAttrs: false,
  props: {
    autoDraw: Boolean,
    autoDrawDuration: {
      type: Number,
      default: 2000
    },
    autoDrawEasing: {
      type: String,
      default: 'ease'
    },
    autoLineWidth: {
      type: Boolean,
      default: false
    },
    color: {
      type: String,
      default: 'primary'
    },
    fill: {
      type: Boolean,
      default: false
    },
    gradient: {
      type: Array,
      default: () => []
    },
    gradientDirection: {
      type: String,
      validator: val => ['top', 'bottom', 'left', 'right'].includes(val),
      default: 'top'
    },
    height: {
      type: [String, Number],
      default: 75
    },
    labels: {
      type: Array,
      default: () => []
    },
    labelSize: {
      type: [Number, String],
      default: 7
    },
    lineWidth: {
      type: [String, Number],
      default: 4
    },
    padding: {
      type: [String, Number],
      default: 8
    },
    showLabels: Boolean,
    smooth: {
      type: [Boolean, Number, String],
      default: false
    },
    type: {
      type: String,
      default: 'trend',
      validator: val => ['trend', 'bar'].includes(val)
    },
    value: {
      type: Array,
      default: () => []
    },
    width: {
      type: [Number, String],
      default: 300
    }
  },
  data: () => ({
    lastLength: 0
  }),
  computed: {
    parsedPadding() {
      return Number(this.padding);
    },

    parsedWidth() {
      return Number(this.width);
    },

    parsedHeight() {
      return parseInt(this.height, 10);
    },

    parsedLabelSize() {
      return parseInt(this.labelSize, 10) || 7;
    },

    totalHeight() {
      let height = this.parsedHeight;
      if (this.hasLabels) height += parseInt(this.labelSize, 10) * 1.5;
      return height;
    },

    totalWidth() {
      let width = this.parsedWidth;
      if (this.type === 'bar') width = Math.max(this.value.length * this._lineWidth, width);
      return width;
    },

    totalValues() {
      return this.value.length;
    },

    _lineWidth() {
      if (this.autoLineWidth && this.type !== 'trend') {
        const totalPadding = this.parsedPadding * (this.totalValues + 1);
        return (this.parsedWidth - totalPadding) / this.totalValues;
      } else {
        return parseFloat(this.lineWidth) || 4;
      }
    },

    boundary() {
      if (this.type === 'bar') return {
        minX: 0,
        maxX: this.totalWidth,
        minY: 0,
        maxY: this.parsedHeight
      };
      const padding = this.parsedPadding;
      return {
        minX: padding,
        maxX: this.totalWidth - padding,
        minY: padding,
        maxY: this.parsedHeight - padding
      };
    },

    hasLabels() {
      return Boolean(this.showLabels || this.labels.length > 0 || this.$scopedSlots.label);
    },

    parsedLabels() {
      const labels = [];
      const points = this._values;
      const len = points.length;

      for (let i = 0; labels.length < len; i++) {
        const item = points[i];
        let value = this.labels[i];

        if (!value) {
          value = typeof item === 'object' ? item.value : item;
        }

        labels.push({
          x: item.x,
          value: String(value)
        });
      }

      return labels;
    },

    normalizedValues() {
      return this.value.map(item => typeof item === 'number' ? item : item.value);
    },

    _values() {
      return this.type === 'trend' ? genPoints(this.normalizedValues, this.boundary) : genBars(this.normalizedValues, this.boundary);
    },

    textY() {
      let y = this.parsedHeight;
      if (this.type === 'trend') y -= 4;
      return y;
    },

    _radius() {
      return this.smooth === true ? 8 : Number(this.smooth);
    }

  },
  watch: {
    value: {
      immediate: true,

      handler() {
        this.$nextTick(() => {
          if (!this.autoDraw || this.type === 'bar' || !this.$refs.path) return;
          const path = this.$refs.path;
          const length = path.getTotalLength();

          if (!this.fill) {
            path.style.transition = 'none';
            path.style.strokeDasharray = length + ' ' + length;
            path.style.strokeDashoffset = Math.abs(length - (this.lastLength || 0)).toString();
            path.getBoundingClientRect();
            path.style.transition = `stroke-dashoffset ${this.autoDrawDuration}ms ${this.autoDrawEasing}`;
            path.style.strokeDashoffset = '0';
          } else {
            path.style.transformOrigin = 'bottom center';
            path.style.transition = 'none';
            path.style.transform = `scaleY(0)`;
            path.getBoundingClientRect();
            path.style.transition = `transform ${this.autoDrawDuration}ms ${this.autoDrawEasing}`;
            path.style.transform = `scaleY(1)`;
          }

          this.lastLength = length;
        });
      }

    }
  },
  methods: {
    genGradient() {
      const gradientDirection = this.gradientDirection;
      const gradient = this.gradient.slice(); // Pushes empty string to force
      // a fallback to currentColor

      if (!gradient.length) gradient.push('');
      const len = Math.max(gradient.length - 1, 1);
      const stops = gradient.reverse().map((color, index) => this.$createElement('stop', {
        attrs: {
          offset: index / len,
          'stop-color': color || 'currentColor'
        }
      }));
      return this.$createElement('defs', [this.$createElement('linearGradient', {
        attrs: {
          id: this._uid,
          gradientUnits: 'userSpaceOnUse',
          x1: gradientDirection === 'left' ? '100%' : '0',
          y1: gradientDirection === 'top' ? '100%' : '0',
          x2: gradientDirection === 'right' ? '100%' : '0',
          y2: gradientDirection === 'bottom' ? '100%' : '0'
        }
      }, stops)]);
    },

    genG(children) {
      return this.$createElement('g', {
        style: {
          fontSize: '8',
          textAnchor: 'middle',
          dominantBaseline: 'mathematical',
          fill: 'currentColor'
        }
      }, children);
    },

    genPath() {
      const points = genPoints(this.normalizedValues, this.boundary);
      return this.$createElement('path', {
        attrs: {
          d: genPath(points, this._radius, this.fill, this.parsedHeight),
          fill: this.fill ? `url(#${this._uid})` : 'none',
          stroke: this.fill ? 'none' : `url(#${this._uid})`
        },
        ref: 'path'
      });
    },

    genLabels(offsetX) {
      const children = this.parsedLabels.map((item, i) => this.$createElement('text', {
        attrs: {
          x: item.x + offsetX + this._lineWidth / 2,
          y: this.textY + this.parsedLabelSize * 0.75,
          'font-size': Number(this.labelSize) || 7
        }
      }, [this.genLabel(item, i)]));
      return this.genG(children);
    },

    genLabel(item, index) {
      return this.$scopedSlots.label ? this.$scopedSlots.label({
        index,
        value: item.value
      }) : item.value;
    },

    genBars() {
      if (!this.value || this.totalValues < 2) return undefined;
      const bars = genBars(this.normalizedValues, this.boundary);
      const offsetX = (Math.abs(bars[0].x - bars[1].x) - this._lineWidth) / 2;
      return this.$createElement('svg', {
        attrs: {
          display: 'block',
          viewBox: `0 0 ${this.totalWidth} ${this.totalHeight}`
        }
      }, [this.genGradient(), this.genClipPath(bars, offsetX, this._lineWidth, 'sparkline-bar-' + this._uid), this.hasLabels ? this.genLabels(offsetX) : undefined, this.$createElement('g', {
        attrs: {
          'clip-path': `url(#sparkline-bar-${this._uid}-clip)`,
          fill: `url(#${this._uid})`
        }
      }, [this.$createElement('rect', {
        attrs: {
          x: 0,
          y: 0,
          width: this.totalWidth,
          height: this.height
        }
      })])]);
    },

    genClipPath(bars, offsetX, lineWidth, id) {
      const rounding = typeof this.smooth === 'number' ? this.smooth : this.smooth ? 2 : 0;
      return this.$createElement('clipPath', {
        attrs: {
          id: `${id}-clip`
        }
      }, bars.map(item => {
        return this.$createElement('rect', {
          attrs: {
            x: item.x + offsetX,
            y: item.y,
            width: lineWidth,
            height: item.height,
            rx: rounding,
            ry: rounding
          }
        }, [this.autoDraw ? this.$createElement('animate', {
          attrs: {
            attributeName: 'height',
            from: 0,
            to: item.height,
            dur: `${this.autoDrawDuration}ms`,
            fill: 'freeze'
          }
        }) : undefined]);
      }));
    },

    genTrend() {
      return this.$createElement('svg', this.setTextColor(this.color, {
        attrs: { ...this.$attrs,
          display: 'block',
          'stroke-width': this._lineWidth || 1,
          viewBox: `0 0 ${this.width} ${this.totalHeight}`
        }
      }), [this.genGradient(), this.hasLabels && this.genLabels(-(this._lineWidth / 2)), this.genPath()]);
    }

  },

  render(h) {
    if (this.totalValues < 2) return undefined;
    return this.type === 'trend' ? this.genTrend() : this.genBars();
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSparkline/index.js


/* harmony default export */ var components_VSparkline = (VSparkline);
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VSpeedDial/VSpeedDial.sass
var VSpeedDial = __webpack_require__(464);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSpeedDial/VSpeedDial.js
// Styles
 // Mixins



 // Directives

 // Types


/* @vue/component */

/* harmony default export */ var VSpeedDial_VSpeedDial = (Object(mixins["a" /* default */])(positionable["a" /* default */], toggleable["a" /* default */], transitionable).extend({
  name: 'v-speed-dial',
  directives: {
    ClickOutside: click_outside["b" /* default */]
  },
  props: {
    direction: {
      type: String,
      default: 'top',
      validator: val => {
        return ['top', 'right', 'bottom', 'left'].includes(val);
      }
    },
    openOnHover: Boolean,
    transition: {
      type: String,
      default: 'scale-transition'
    }
  },
  computed: {
    classes() {
      return {
        'v-speed-dial': true,
        'v-speed-dial--top': this.top,
        'v-speed-dial--right': this.right,
        'v-speed-dial--bottom': this.bottom,
        'v-speed-dial--left': this.left,
        'v-speed-dial--absolute': this.absolute,
        'v-speed-dial--fixed': this.fixed,
        [`v-speed-dial--direction-${this.direction}`]: true,
        'v-speed-dial--is-active': this.isActive
      };
    }

  },

  render(h) {
    let children = [];
    const data = {
      class: this.classes,
      directives: [{
        name: 'click-outside',
        value: () => this.isActive = false
      }],
      on: {
        click: () => this.isActive = !this.isActive
      }
    };

    if (this.openOnHover) {
      data.on.mouseenter = () => this.isActive = true;

      data.on.mouseleave = () => this.isActive = false;
    }

    if (this.isActive) {
      let btnCount = 0;
      children = (this.$slots.default || []).map((b, i) => {
        if (b.tag && typeof b.componentOptions !== 'undefined' && (b.componentOptions.Ctor.options.name === 'v-btn' || b.componentOptions.Ctor.options.name === 'v-tooltip')) {
          btnCount++;
          return h('div', {
            style: {
              transitionDelay: btnCount * 0.05 + 's'
            },
            key: i
          }, [b]);
        } else {
          b.key = i;
          return b;
        }
      });
    }

    const list = h('transition-group', {
      class: 'v-speed-dial__list',
      props: {
        name: this.transition,
        mode: this.mode,
        origin: this.origin,
        tag: 'div'
      }
    }, children);
    return h('div', data, [this.$slots.activator, list]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSpeedDial/index.js


/* harmony default export */ var components_VSpeedDial = (VSpeedDial_VSpeedDial);
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VStepper/VStepper.sass
var VStepper = __webpack_require__(465);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/registrable/index.js
var registrable = __webpack_require__(33);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/proxyable/index.js
var proxyable = __webpack_require__(38);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VStepper/VStepper.js
// Styles
 // Extensions

 // Mixins


 // Utilities



const VStepper_baseMixins = Object(mixins["a" /* default */])(VSheet["b" /* default */], Object(registrable["b" /* provide */])('stepper'), proxyable["a" /* default */]);
/* @vue/component */

/* harmony default export */ var VStepper_VStepper = (VStepper_baseMixins.extend({
  name: 'v-stepper',

  provide() {
    return {
      stepClick: this.stepClick,
      isVertical: this.vertical
    };
  },

  props: {
    altLabels: Boolean,
    nonLinear: Boolean,
    flat: Boolean,
    vertical: Boolean
  },

  data() {
    const data = {
      isBooted: false,
      steps: [],
      content: [],
      isReverse: false
    };
    data.internalLazyValue = this.value != null ? this.value : (data[0] || {}).step || 1;
    return data;
  },

  computed: {
    classes() {
      return {
        'v-stepper--flat': this.flat,
        'v-stepper--is-booted': this.isBooted,
        'v-stepper--vertical': this.vertical,
        'v-stepper--alt-labels': this.altLabels,
        'v-stepper--non-linear': this.nonLinear,
        ...VSheet["b" /* default */].options.computed.classes.call(this)
      };
    },

    styles() {
      return { ...VSheet["b" /* default */].options.computed.styles.call(this)
      };
    }

  },
  watch: {
    internalValue(val, oldVal) {
      this.isReverse = Number(val) < Number(oldVal);
      oldVal && (this.isBooted = true);
      this.updateView();
    }

  },

  created() {
    /* istanbul ignore next */
    if (this.$listeners.input) {
      Object(console["a" /* breaking */])('@input', '@change', this);
    }
  },

  mounted() {
    this.updateView();
  },

  methods: {
    register(item) {
      if (item.$options.name === 'v-stepper-step') {
        this.steps.push(item);
      } else if (item.$options.name === 'v-stepper-content') {
        item.isVertical = this.vertical;
        this.content.push(item);
      }
    },

    unregister(item) {
      if (item.$options.name === 'v-stepper-step') {
        this.steps = this.steps.filter(i => i !== item);
      } else if (item.$options.name === 'v-stepper-content') {
        item.isVertical = this.vertical;
        this.content = this.content.filter(i => i !== item);
      }
    },

    stepClick(step) {
      this.$nextTick(() => this.internalValue = step);
    },

    updateView() {
      for (let index = this.steps.length; --index >= 0;) {
        this.steps[index].toggle(this.internalValue);
      }

      for (let index = this.content.length; --index >= 0;) {
        this.content[index].toggle(this.internalValue, this.isReverse);
      }
    }

  },

  render(h) {
    return h(this.tag, {
      staticClass: 'v-stepper',
      class: this.classes,
      style: this.styles
    }, this.$slots.default);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VStepper/VStepperStep.js
// Components
 // Mixins


 // Directives

 // Utilities


const VStepperStep_baseMixins = Object(mixins["a" /* default */])(colorable["a" /* default */], Object(registrable["a" /* inject */])('stepper', 'v-stepper-step', 'v-stepper'));
/* @vue/component */

/* harmony default export */ var VStepperStep = (VStepperStep_baseMixins.extend().extend({
  name: 'v-stepper-step',
  directives: {
    ripple: ripple["b" /* default */]
  },
  inject: ['stepClick'],
  props: {
    color: {
      type: String,
      default: 'primary'
    },
    complete: Boolean,
    completeIcon: {
      type: String,
      default: '$complete'
    },
    editable: Boolean,
    editIcon: {
      type: String,
      default: '$edit'
    },
    errorIcon: {
      type: String,
      default: '$error'
    },
    rules: {
      type: Array,
      default: () => []
    },
    step: [Number, String]
  },

  data() {
    return {
      isActive: false,
      isInactive: true
    };
  },

  computed: {
    classes() {
      return {
        'v-stepper__step--active': this.isActive,
        'v-stepper__step--editable': this.editable,
        'v-stepper__step--inactive': this.isInactive,
        'v-stepper__step--error error--text': this.hasError,
        'v-stepper__step--complete': this.complete
      };
    },

    hasError() {
      return this.rules.some(validate => validate() !== true);
    }

  },

  mounted() {
    this.stepper && this.stepper.register(this);
  },

  beforeDestroy() {
    this.stepper && this.stepper.unregister(this);
  },

  methods: {
    click(e) {
      e.stopPropagation();
      this.$emit('click', e);

      if (this.editable) {
        this.stepClick(this.step);
      }
    },

    genIcon(icon) {
      return this.$createElement(VIcon["b" /* default */], icon);
    },

    genLabel() {
      return this.$createElement('div', {
        staticClass: 'v-stepper__label'
      }, this.$slots.default);
    },

    genStep() {
      const color = !this.hasError && (this.complete || this.isActive) ? this.color : false;
      return this.$createElement('span', this.setBackgroundColor(color, {
        staticClass: 'v-stepper__step__step'
      }), this.genStepContent());
    },

    genStepContent() {
      const children = [];

      if (this.hasError) {
        children.push(this.genIcon(this.errorIcon));
      } else if (this.complete) {
        if (this.editable) {
          children.push(this.genIcon(this.editIcon));
        } else {
          children.push(this.genIcon(this.completeIcon));
        }
      } else {
        children.push(String(this.step));
      }

      return children;
    },

    toggle(step) {
      this.isActive = step.toString() === this.step.toString();
      this.isInactive = Number(step) < Number(this.step);
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'v-stepper__step',
      class: this.classes,
      directives: [{
        name: 'ripple',
        value: this.editable
      }],
      on: {
        click: this.click
      }
    }, [this.genStep(), this.genLabel()]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VStepper/VStepperContent.js
// Components
 // Mixins

 // Helpers

 // Utilities


const VStepperContent_baseMixins = Object(mixins["a" /* default */])(Object(registrable["a" /* inject */])('stepper', 'v-stepper-content', 'v-stepper'));
/* @vue/component */

/* harmony default export */ var VStepperContent = (VStepperContent_baseMixins.extend().extend({
  name: 'v-stepper-content',
  inject: {
    isVerticalProvided: {
      from: 'isVertical'
    }
  },
  props: {
    step: {
      type: [Number, String],
      required: true
    }
  },

  data() {
    return {
      height: 0,
      // Must be null to allow
      // previous comparison
      isActive: null,
      isReverse: false,
      isVertical: this.isVerticalProvided
    };
  },

  computed: {
    computedTransition() {
      // Fix for #8978
      const reverse = this.$vuetify.rtl ? !this.isReverse : this.isReverse;
      return reverse ? transitions["t" /* VTabReverseTransition */] : transitions["u" /* VTabTransition */];
    },

    styles() {
      if (!this.isVertical) return {};
      return {
        height: Object(helpers["i" /* convertToUnit */])(this.height)
      };
    }

  },
  watch: {
    isActive(current, previous) {
      // If active and the previous state
      // was null, is just booting up
      if (current && previous == null) {
        this.height = 'auto';
        return;
      }

      if (!this.isVertical) return;
      if (this.isActive) this.enter();else this.leave();
    }

  },

  mounted() {
    this.$refs.wrapper.addEventListener('transitionend', this.onTransition, false);
    this.stepper && this.stepper.register(this);
  },

  beforeDestroy() {
    this.$refs.wrapper.removeEventListener('transitionend', this.onTransition, false);
    this.stepper && this.stepper.unregister(this);
  },

  methods: {
    onTransition(e) {
      if (!this.isActive || e.propertyName !== 'height') return;
      this.height = 'auto';
    },

    enter() {
      let scrollHeight = 0; // Render bug with height

      requestAnimationFrame(() => {
        scrollHeight = this.$refs.wrapper.scrollHeight;
      });
      this.height = 0; // Give the collapsing element time to collapse

      setTimeout(() => this.isActive && (this.height = scrollHeight || 'auto'), 450);
    },

    leave() {
      this.height = this.$refs.wrapper.clientHeight;
      setTimeout(() => this.height = 0, 10);
    },

    toggle(step, reverse) {
      this.isActive = step.toString() === this.step.toString();
      this.isReverse = reverse;
    }

  },

  render(h) {
    const contentData = {
      staticClass: 'v-stepper__content'
    };
    const wrapperData = {
      staticClass: 'v-stepper__wrapper',
      style: this.styles,
      ref: 'wrapper'
    };

    if (!this.isVertical) {
      contentData.directives = [{
        name: 'show',
        value: this.isActive
      }];
    }

    const wrapper = h('div', wrapperData, [this.$slots.default]);
    const content = h('div', contentData, [wrapper]);
    return h(this.computedTransition, {
      on: this.$listeners
    }, [content]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VStepper/index.js




const VStepperHeader = Object(helpers["k" /* createSimpleFunctional */])('v-stepper__header');
const VStepperItems = Object(helpers["k" /* createSimpleFunctional */])('v-stepper__items');

/* harmony default export */ var components_VStepper = ({
  $_vuetify_subcomponents: {
    VStepper: VStepper_VStepper,
    VStepperContent: VStepperContent,
    VStepperStep: VStepperStep,
    VStepperHeader,
    VStepperItems
  }
});
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VSubheader/index.js + 1 modules
var VSubheader = __webpack_require__(314);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VSwitch/VSwitch.sass
var VSwitch = __webpack_require__(466);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/directives/touch/index.js
var touch = __webpack_require__(35);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VProgressCircular/VProgressCircular.js
var VProgressCircular_VProgressCircular = __webpack_require__(71);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSwitch/VSwitch.js
// Styles

 // Mixins


 // Directives

 // Components


 // Helpers


/* @vue/component */

/* harmony default export */ var VSwitch_VSwitch = (selectable["a" /* default */].extend({
  name: 'v-switch',
  directives: {
    Touch: touch["b" /* default */]
  },
  props: {
    inset: Boolean,
    loading: {
      type: [Boolean, String],
      default: false
    },
    flat: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    classes() {
      return { ...VInput["b" /* default */].options.computed.classes.call(this),
        'v-input--selection-controls v-input--switch': true,
        'v-input--switch--flat': this.flat,
        'v-input--switch--inset': this.inset
      };
    },

    attrs() {
      return {
        'aria-checked': String(this.isActive),
        'aria-disabled': String(this.isDisabled),
        role: 'switch'
      };
    },

    // Do not return undefined if disabled,
    // according to spec, should still show
    // a color when disabled and active
    validationState() {
      if (this.hasError && this.shouldValidate) return 'error';
      if (this.hasSuccess) return 'success';
      if (this.hasColor !== null) return this.computedColor;
      return undefined;
    },

    switchData() {
      return this.setTextColor(this.loading ? undefined : this.validationState, {
        class: this.themeClasses
      });
    }

  },
  methods: {
    genDefaultSlot() {
      return [this.genSwitch(), this.genLabel()];
    },

    genSwitch() {
      const {
        title,
        ...switchAttrs
      } = this.attrs$;
      return this.$createElement('div', {
        staticClass: 'v-input--selection-controls__input'
      }, [this.genInput('checkbox', { ...this.attrs,
        ...switchAttrs
      }), this.genRipple(this.setTextColor(this.validationState, {
        directives: [{
          name: 'touch',
          value: {
            left: this.onSwipeLeft,
            right: this.onSwipeRight
          }
        }]
      })), this.$createElement('div', {
        staticClass: 'v-input--switch__track',
        ...this.switchData
      }), this.$createElement('div', {
        staticClass: 'v-input--switch__thumb',
        ...this.switchData
      }, [this.genProgress()])]);
    },

    genProgress() {
      return this.$createElement(transitions["h" /* VFabTransition */], {}, [this.loading === false ? null : this.$slots.progress || this.$createElement(VProgressCircular_VProgressCircular["a" /* default */], {
        props: {
          color: this.loading === true || this.loading === '' ? this.color || 'primary' : this.loading,
          size: 16,
          width: 2,
          indeterminate: true
        }
      })]);
    },

    onSwipeLeft() {
      if (this.isActive) this.onChange();
    },

    onSwipeRight() {
      if (!this.isActive) this.onChange();
    },

    onKeydown(e) {
      if (e.keyCode === helpers["B" /* keyCodes */].left && this.isActive || e.keyCode === helpers["B" /* keyCodes */].right && !this.isActive) this.onChange();
    }

  }
}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSwitch/index.js


/* harmony default export */ var components_VSwitch = (VSwitch_VSwitch);
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VSystemBar/VSystemBar.sass
var VSystemBar = __webpack_require__(467);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/applicationable/index.js
var applicationable = __webpack_require__(39);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSystemBar/VSystemBar.js
// Styles
 // Mixins



 // Utilities



/* harmony default export */ var VSystemBar_VSystemBar = (Object(mixins["a" /* default */])(Object(applicationable["a" /* default */])('bar', ['height', 'window']), colorable["a" /* default */], themeable["a" /* default */]
/* @vue/component */
).extend({
  name: 'v-system-bar',
  props: {
    height: [Number, String],
    lightsOut: Boolean,
    window: Boolean
  },
  computed: {
    classes() {
      return {
        'v-system-bar--lights-out': this.lightsOut,
        'v-system-bar--absolute': this.absolute,
        'v-system-bar--fixed': !this.absolute && (this.app || this.fixed),
        'v-system-bar--window': this.window,
        ...this.themeClasses
      };
    },

    computedHeight() {
      if (this.height) {
        return isNaN(parseInt(this.height)) ? this.height : parseInt(this.height);
      }

      return this.window ? 32 : 24;
    },

    styles() {
      return {
        height: Object(helpers["i" /* convertToUnit */])(this.computedHeight)
      };
    }

  },
  methods: {
    updateApplication() {
      return this.$el ? this.$el.clientHeight : this.computedHeight;
    }

  },

  render(h) {
    const data = {
      staticClass: 'v-system-bar',
      class: this.classes,
      style: this.styles,
      on: this.$listeners
    };
    return h('div', this.setBackgroundColor(this.color, data), Object(helpers["v" /* getSlot */])(this));
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VSystemBar/index.js


/* harmony default export */ var components_VSystemBar = (VSystemBar_VSystemBar);
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VTabs/index.js
var VTabs = __webpack_require__(67);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VTextarea/index.js
var VTextarea = __webpack_require__(367);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VThemeProvider/index.js
var VThemeProvider = __webpack_require__(203);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VTimeline/index.js
var VTimeline = __webpack_require__(383);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VTimePicker/VTimePickerTitle.sass
var VTimePickerTitle = __webpack_require__(469);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/picker-button/index.js
var picker_button = __webpack_require__(307);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VDatePicker/util/pad.js
var pad = __webpack_require__(282);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VTimePicker/SelectingTimes.js
var SelectingTimes;

(function (SelectingTimes) {
  SelectingTimes[SelectingTimes["Hour"] = 1] = "Hour";
  SelectingTimes[SelectingTimes["Minute"] = 2] = "Minute";
  SelectingTimes[SelectingTimes["Second"] = 3] = "Second";
})(SelectingTimes || (SelectingTimes = {}));


// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VTimePicker/VTimePickerTitle.js
 // Mixins

 // Utils




/* harmony default export */ var VTimePicker_VTimePickerTitle = (Object(mixins["a" /* default */])(picker_button["a" /* default */]
/* @vue/component */
).extend({
  name: 'v-time-picker-title',
  props: {
    ampm: Boolean,
    ampmReadonly: Boolean,
    disabled: Boolean,
    hour: Number,
    minute: Number,
    second: Number,
    period: {
      type: String,
      validator: period => period === 'am' || period === 'pm'
    },
    readonly: Boolean,
    useSeconds: Boolean,
    selecting: Number
  },
  methods: {
    genTime() {
      let hour = this.hour;

      if (this.ampm) {
        hour = hour ? (hour - 1) % 12 + 1 : 12;
      }

      const displayedHour = this.hour == null ? '--' : this.ampm ? String(hour) : Object(pad["a" /* default */])(hour);
      const displayedMinute = this.minute == null ? '--' : Object(pad["a" /* default */])(this.minute);
      const titleContent = [this.genPickerButton('selecting', SelectingTimes.Hour, displayedHour, this.disabled), this.$createElement('span', ':'), this.genPickerButton('selecting', SelectingTimes.Minute, displayedMinute, this.disabled)];

      if (this.useSeconds) {
        const displayedSecond = this.second == null ? '--' : Object(pad["a" /* default */])(this.second);
        titleContent.push(this.$createElement('span', ':'));
        titleContent.push(this.genPickerButton('selecting', SelectingTimes.Second, displayedSecond, this.disabled));
      }

      return this.$createElement('div', {
        class: 'v-time-picker-title__time'
      }, titleContent);
    },

    genAmPm() {
      return this.$createElement('div', {
        staticClass: 'v-time-picker-title__ampm',
        class: {
          'v-time-picker-title__ampm--readonly': this.ampmReadonly
        }
      }, [!this.ampmReadonly || this.period === 'am' ? this.genPickerButton('period', 'am', this.$vuetify.lang.t('$vuetify.timePicker.am'), this.disabled || this.readonly) : null, !this.ampmReadonly || this.period === 'pm' ? this.genPickerButton('period', 'pm', this.$vuetify.lang.t('$vuetify.timePicker.pm'), this.disabled || this.readonly) : null]);
    }

  },

  render(h) {
    const children = [this.genTime()];
    this.ampm && children.push(this.genAmPm());
    return h('div', {
      staticClass: 'v-time-picker-title'
    }, children);
  }

}));
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VTimePicker/VTimePickerClock.sass
var VTimePickerClock = __webpack_require__(468);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VTimePicker/VTimePickerClock.js
 // Mixins


 // Types


/* harmony default export */ var VTimePicker_VTimePickerClock = (Object(mixins["a" /* default */])(colorable["a" /* default */], themeable["a" /* default */]
/* @vue/component */
).extend({
  name: 'v-time-picker-clock',
  props: {
    allowedValues: Function,
    ampm: Boolean,
    disabled: Boolean,
    double: Boolean,
    format: {
      type: Function,
      default: val => val
    },
    max: {
      type: Number,
      required: true
    },
    min: {
      type: Number,
      required: true
    },
    scrollable: Boolean,
    readonly: Boolean,
    rotate: {
      type: Number,
      default: 0
    },
    step: {
      type: Number,
      default: 1
    },
    value: Number
  },

  data() {
    return {
      inputValue: this.value,
      isDragging: false,
      valueOnMouseDown: null,
      valueOnMouseUp: null
    };
  },

  computed: {
    count() {
      return this.max - this.min + 1;
    },

    degreesPerUnit() {
      return 360 / this.roundCount;
    },

    degrees() {
      return this.degreesPerUnit * Math.PI / 180;
    },

    displayedValue() {
      return this.value == null ? this.min : this.value;
    },

    innerRadiusScale() {
      return 0.62;
    },

    roundCount() {
      return this.double ? this.count / 2 : this.count;
    }

  },
  watch: {
    value(value) {
      this.inputValue = value;
    }

  },
  methods: {
    wheel(e) {
      e.preventDefault();
      const delta = Math.sign(-e.deltaY || 1);
      let value = this.displayedValue;

      do {
        value = value + delta;
        value = (value - this.min + this.count) % this.count + this.min;
      } while (!this.isAllowed(value) && value !== this.displayedValue);

      if (value !== this.displayedValue) {
        this.update(value);
      }
    },

    isInner(value) {
      return this.double && value - this.min >= this.roundCount;
    },

    handScale(value) {
      return this.isInner(value) ? this.innerRadiusScale : 1;
    },

    isAllowed(value) {
      return !this.allowedValues || this.allowedValues(value);
    },

    genValues() {
      const children = [];

      for (let value = this.min; value <= this.max; value = value + this.step) {
        const color = value === this.value && (this.color || 'accent');
        children.push(this.$createElement('span', this.setBackgroundColor(color, {
          staticClass: 'v-time-picker-clock__item',
          class: {
            'v-time-picker-clock__item--active': value === this.displayedValue,
            'v-time-picker-clock__item--disabled': this.disabled || !this.isAllowed(value)
          },
          style: this.getTransform(value),
          domProps: {
            innerHTML: `<span>${this.format(value)}</span>`
          }
        })));
      }

      return children;
    },

    genHand() {
      const scale = `scaleY(${this.handScale(this.displayedValue)})`;
      const angle = this.rotate + this.degreesPerUnit * (this.displayedValue - this.min);
      const color = this.value != null && (this.color || 'accent');
      return this.$createElement('div', this.setBackgroundColor(color, {
        staticClass: 'v-time-picker-clock__hand',
        class: {
          'v-time-picker-clock__hand--inner': this.isInner(this.value)
        },
        style: {
          transform: `rotate(${angle}deg) ${scale}`
        }
      }));
    },

    getTransform(i) {
      const {
        x,
        y
      } = this.getPosition(i);
      return {
        left: `${50 + x * 50}%`,
        top: `${50 + y * 50}%`
      };
    },

    getPosition(value) {
      const rotateRadians = this.rotate * Math.PI / 180;
      return {
        x: Math.sin((value - this.min) * this.degrees + rotateRadians) * this.handScale(value),
        y: -Math.cos((value - this.min) * this.degrees + rotateRadians) * this.handScale(value)
      };
    },

    onMouseDown(e) {
      e.preventDefault();
      this.valueOnMouseDown = null;
      this.valueOnMouseUp = null;
      this.isDragging = true;
      this.onDragMove(e);
    },

    onMouseUp(e) {
      e.stopPropagation();
      this.isDragging = false;

      if (this.valueOnMouseUp !== null && this.isAllowed(this.valueOnMouseUp)) {
        this.$emit('change', this.valueOnMouseUp);
      }
    },

    onDragMove(e) {
      e.preventDefault();
      if (!this.isDragging && e.type !== 'click' || !this.$refs.clock) return;
      const {
        width,
        top,
        left
      } = this.$refs.clock.getBoundingClientRect();
      const {
        width: innerWidth
      } = this.$refs.innerClock.getBoundingClientRect();
      const {
        clientX,
        clientY
      } = 'touches' in e ? e.touches[0] : e;
      const center = {
        x: width / 2,
        y: -width / 2
      };
      const coords = {
        x: clientX - left,
        y: top - clientY
      };
      const handAngle = Math.round(this.angle(center, coords) - this.rotate + 360) % 360;
      const insideClick = this.double && this.euclidean(center, coords) < (innerWidth + innerWidth * this.innerRadiusScale) / 4;
      const checksCount = Math.ceil(15 / this.degreesPerUnit);
      let value;

      for (let i = 0; i < checksCount; i++) {
        value = this.angleToValue(handAngle + i * this.degreesPerUnit, insideClick);
        if (this.isAllowed(value)) return this.setMouseDownValue(value);
        value = this.angleToValue(handAngle - i * this.degreesPerUnit, insideClick);
        if (this.isAllowed(value)) return this.setMouseDownValue(value);
      }
    },

    angleToValue(angle, insideClick) {
      const value = (Math.round(angle / this.degreesPerUnit) + (insideClick ? this.roundCount : 0)) % this.count + this.min; // Necessary to fix edge case when selecting left part of the value(s) at 12 o'clock

      if (angle < 360 - this.degreesPerUnit / 2) return value;
      return insideClick ? this.max - this.roundCount + 1 : this.min;
    },

    setMouseDownValue(value) {
      if (this.valueOnMouseDown === null) {
        this.valueOnMouseDown = value;
      }

      this.valueOnMouseUp = value;
      this.update(value);
    },

    update(value) {
      if (this.inputValue !== value) {
        this.inputValue = value;
        this.$emit('input', value);
      }
    },

    euclidean(p0, p1) {
      const dx = p1.x - p0.x;
      const dy = p1.y - p0.y;
      return Math.sqrt(dx * dx + dy * dy);
    },

    angle(center, p1) {
      const value = 2 * Math.atan2(p1.y - center.y - this.euclidean(center, p1), p1.x - center.x);
      return Math.abs(value * 180 / Math.PI);
    }

  },

  render(h) {
    const data = {
      staticClass: 'v-time-picker-clock',
      class: {
        'v-time-picker-clock--indeterminate': this.value == null,
        ...this.themeClasses
      },
      on: this.readonly || this.disabled ? undefined : {
        mousedown: this.onMouseDown,
        mouseup: this.onMouseUp,
        mouseleave: e => this.isDragging && this.onMouseUp(e),
        touchstart: this.onMouseDown,
        touchend: this.onMouseUp,
        mousemove: this.onDragMove,
        touchmove: this.onDragMove
      },
      ref: 'clock'
    };

    if (this.scrollable && data.on) {
      data.on.wheel = this.wheel;
    }

    return h('div', data, [h('div', {
      staticClass: 'v-time-picker-clock__inner',
      ref: 'innerClock'
    }, [this.genHand(), this.genValues()])]);
  }

}));
// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/picker/index.js
var picker = __webpack_require__(382);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VTimePicker/VTimePicker.js
// Components

 // Mixins


 // Utils





const rangeHours24 = Object(helpers["j" /* createRange */])(24);
const rangeHours12am = Object(helpers["j" /* createRange */])(12);
const rangeHours12pm = rangeHours12am.map(v => v + 12);
const range60 = Object(helpers["j" /* createRange */])(60);
const selectingNames = {
  1: 'hour',
  2: 'minute',
  3: 'second'
};

/* harmony default export */ var VTimePicker = (Object(mixins["a" /* default */])(picker["a" /* default */], picker_button["a" /* default */]
/* @vue/component */
).extend({
  name: 'v-time-picker',
  props: {
    allowedHours: [Function, Array],
    allowedMinutes: [Function, Array],
    allowedSeconds: [Function, Array],
    disabled: Boolean,
    format: {
      type: String,
      default: 'ampm',

      validator(val) {
        return ['ampm', '24hr'].includes(val);
      }

    },
    min: String,
    max: String,
    readonly: Boolean,
    scrollable: Boolean,
    useSeconds: Boolean,
    value: null,
    ampmInTitle: Boolean
  },

  data() {
    return {
      inputHour: null,
      inputMinute: null,
      inputSecond: null,
      lazyInputHour: null,
      lazyInputMinute: null,
      lazyInputSecond: null,
      period: 'am',
      selecting: SelectingTimes.Hour
    };
  },

  computed: {
    selectingHour: {
      get() {
        return this.selecting === SelectingTimes.Hour;
      },

      set(v) {
        this.selecting = SelectingTimes.Hour;
      }

    },
    selectingMinute: {
      get() {
        return this.selecting === SelectingTimes.Minute;
      },

      set(v) {
        this.selecting = SelectingTimes.Minute;
      }

    },
    selectingSecond: {
      get() {
        return this.selecting === SelectingTimes.Second;
      },

      set(v) {
        this.selecting = SelectingTimes.Second;
      }

    },

    isAllowedHourCb() {
      let cb;

      if (this.allowedHours instanceof Array) {
        cb = val => this.allowedHours.includes(val);
      } else {
        cb = this.allowedHours;
      }

      if (!this.min && !this.max) return cb;
      const minHour = this.min ? Number(this.min.split(':')[0]) : 0;
      const maxHour = this.max ? Number(this.max.split(':')[0]) : 23;
      return val => {
        return val >= minHour * 1 && val <= maxHour * 1 && (!cb || cb(val));
      };
    },

    isAllowedMinuteCb() {
      let cb;
      const isHourAllowed = !this.isAllowedHourCb || this.inputHour === null || this.isAllowedHourCb(this.inputHour);

      if (this.allowedMinutes instanceof Array) {
        cb = val => this.allowedMinutes.includes(val);
      } else {
        cb = this.allowedMinutes;
      }

      if (!this.min && !this.max) {
        return isHourAllowed ? cb : () => false;
      }

      const [minHour, minMinute] = this.min ? this.min.split(':').map(Number) : [0, 0];
      const [maxHour, maxMinute] = this.max ? this.max.split(':').map(Number) : [23, 59];
      const minTime = minHour * 60 + minMinute * 1;
      const maxTime = maxHour * 60 + maxMinute * 1;
      return val => {
        const time = 60 * this.inputHour + val;
        return time >= minTime && time <= maxTime && isHourAllowed && (!cb || cb(val));
      };
    },

    isAllowedSecondCb() {
      let cb;
      const isHourAllowed = !this.isAllowedHourCb || this.inputHour === null || this.isAllowedHourCb(this.inputHour);
      const isMinuteAllowed = isHourAllowed && (!this.isAllowedMinuteCb || this.inputMinute === null || this.isAllowedMinuteCb(this.inputMinute));

      if (this.allowedSeconds instanceof Array) {
        cb = val => this.allowedSeconds.includes(val);
      } else {
        cb = this.allowedSeconds;
      }

      if (!this.min && !this.max) {
        return isMinuteAllowed ? cb : () => false;
      }

      const [minHour, minMinute, minSecond] = this.min ? this.min.split(':').map(Number) : [0, 0, 0];
      const [maxHour, maxMinute, maxSecond] = this.max ? this.max.split(':').map(Number) : [23, 59, 59];
      const minTime = minHour * 3600 + minMinute * 60 + (minSecond || 0) * 1;
      const maxTime = maxHour * 3600 + maxMinute * 60 + (maxSecond || 0) * 1;
      return val => {
        const time = 3600 * this.inputHour + 60 * this.inputMinute + val;
        return time >= minTime && time <= maxTime && isMinuteAllowed && (!cb || cb(val));
      };
    },

    isAmPm() {
      return this.format === 'ampm';
    }

  },
  watch: {
    value: 'setInputData'
  },

  mounted() {
    this.setInputData(this.value);
    this.$on('update:period', this.setPeriod);
  },

  methods: {
    genValue() {
      if (this.inputHour != null && this.inputMinute != null && (!this.useSeconds || this.inputSecond != null)) {
        return `${Object(pad["a" /* default */])(this.inputHour)}:${Object(pad["a" /* default */])(this.inputMinute)}` + (this.useSeconds ? `:${Object(pad["a" /* default */])(this.inputSecond)}` : '');
      }

      return null;
    },

    emitValue() {
      const value = this.genValue();
      if (value !== null) this.$emit('input', value);
    },

    setPeriod(period) {
      this.period = period;

      if (this.inputHour != null) {
        const newHour = this.inputHour + (period === 'am' ? -12 : 12);
        this.inputHour = this.firstAllowed('hour', newHour);
        this.emitValue();
      }
    },

    setInputData(value) {
      if (value == null || value === '') {
        this.inputHour = null;
        this.inputMinute = null;
        this.inputSecond = null;
      } else if (value instanceof Date) {
        this.inputHour = value.getHours();
        this.inputMinute = value.getMinutes();
        this.inputSecond = value.getSeconds();
      } else {
        const [, hour, minute,, second, period] = value.trim().toLowerCase().match(/^(\d+):(\d+)(:(\d+))?([ap]m)?$/) || new Array(6);
        this.inputHour = period ? this.convert12to24(parseInt(hour, 10), period) : parseInt(hour, 10);
        this.inputMinute = parseInt(minute, 10);
        this.inputSecond = parseInt(second || 0, 10);
      }

      this.period = this.inputHour == null || this.inputHour < 12 ? 'am' : 'pm';
    },

    convert24to12(hour) {
      return hour ? (hour - 1) % 12 + 1 : 12;
    },

    convert12to24(hour, period) {
      return hour % 12 + (period === 'pm' ? 12 : 0);
    },

    onInput(value) {
      if (this.selecting === SelectingTimes.Hour) {
        this.inputHour = this.isAmPm ? this.convert12to24(value, this.period) : value;
      } else if (this.selecting === SelectingTimes.Minute) {
        this.inputMinute = value;
      } else {
        this.inputSecond = value;
      }

      this.emitValue();
    },

    onChange(value) {
      this.$emit(`click:${selectingNames[this.selecting]}`, value);
      const emitChange = this.selecting === (this.useSeconds ? SelectingTimes.Second : SelectingTimes.Minute);

      if (this.selecting === SelectingTimes.Hour) {
        this.selecting = SelectingTimes.Minute;
      } else if (this.useSeconds && this.selecting === SelectingTimes.Minute) {
        this.selecting = SelectingTimes.Second;
      }

      if (this.inputHour === this.lazyInputHour && this.inputMinute === this.lazyInputMinute && (!this.useSeconds || this.inputSecond === this.lazyInputSecond)) return;
      const time = this.genValue();
      if (time === null) return;
      this.lazyInputHour = this.inputHour;
      this.lazyInputMinute = this.inputMinute;
      this.useSeconds && (this.lazyInputSecond = this.inputSecond);
      emitChange && this.$emit('change', time);
    },

    firstAllowed(type, value) {
      const allowedFn = type === 'hour' ? this.isAllowedHourCb : type === 'minute' ? this.isAllowedMinuteCb : this.isAllowedSecondCb;
      if (!allowedFn) return value; // TODO: clean up

      const range = type === 'minute' ? range60 : type === 'second' ? range60 : this.isAmPm ? value < 12 ? rangeHours12am : rangeHours12pm : rangeHours24;
      const first = range.find(v => allowedFn((v + value) % range.length + range[0]));
      return ((first || 0) + value) % range.length + range[0];
    },

    genClock() {
      return this.$createElement(VTimePicker_VTimePickerClock, {
        props: {
          allowedValues: this.selecting === SelectingTimes.Hour ? this.isAllowedHourCb : this.selecting === SelectingTimes.Minute ? this.isAllowedMinuteCb : this.isAllowedSecondCb,
          color: this.color,
          dark: this.dark,
          disabled: this.disabled,
          double: this.selecting === SelectingTimes.Hour && !this.isAmPm,
          format: this.selecting === SelectingTimes.Hour ? this.isAmPm ? this.convert24to12 : val => val : val => Object(pad["a" /* default */])(val, 2),
          light: this.light,
          max: this.selecting === SelectingTimes.Hour ? this.isAmPm && this.period === 'am' ? 11 : 23 : 59,
          min: this.selecting === SelectingTimes.Hour && this.isAmPm && this.period === 'pm' ? 12 : 0,
          readonly: this.readonly,
          scrollable: this.scrollable,
          size: Number(this.width) - (!this.fullWidth && this.landscape ? 80 : 20),
          step: this.selecting === SelectingTimes.Hour ? 1 : 5,
          value: this.selecting === SelectingTimes.Hour ? this.inputHour : this.selecting === SelectingTimes.Minute ? this.inputMinute : this.inputSecond
        },
        on: {
          input: this.onInput,
          change: this.onChange
        },
        ref: 'clock'
      });
    },

    genClockAmPm() {
      return this.$createElement('div', this.setTextColor(this.color || 'primary', {
        staticClass: 'v-time-picker-clock__ampm'
      }), [this.genPickerButton('period', 'am', this.$vuetify.lang.t('$vuetify.timePicker.am'), this.disabled || this.readonly), this.genPickerButton('period', 'pm', this.$vuetify.lang.t('$vuetify.timePicker.pm'), this.disabled || this.readonly)]);
    },

    genPickerBody() {
      return this.$createElement('div', {
        staticClass: 'v-time-picker-clock__container',
        key: this.selecting
      }, [!this.ampmInTitle && this.isAmPm && this.genClockAmPm(), this.genClock()]);
    },

    genPickerTitle() {
      return this.$createElement(VTimePicker_VTimePickerTitle, {
        props: {
          ampm: this.isAmPm,
          ampmReadonly: this.isAmPm && !this.ampmInTitle,
          disabled: this.disabled,
          hour: this.inputHour,
          minute: this.inputMinute,
          second: this.inputSecond,
          period: this.period,
          readonly: this.readonly,
          useSeconds: this.useSeconds,
          selecting: this.selecting
        },
        on: {
          'update:selecting': value => this.selecting = value,
          'update:period': period => this.$emit('update:period', period)
        },
        ref: 'title',
        slot: 'title'
      });
    }

  },

  render() {
    return this.genPicker('v-picker--time');
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VTimePicker/index.js




/* harmony default export */ var components_VTimePicker = ({
  $_vuetify_subcomponents: {
    VTimePicker: VTimePicker,
    VTimePickerClock: VTimePicker_VTimePickerClock,
    VTimePickerTitle: VTimePicker_VTimePickerTitle
  }
});
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VToolbar/index.js
var VToolbar = __webpack_require__(93);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VTooltip/VTooltip.sass
var VTooltip = __webpack_require__(470);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/activatable/index.js
var activatable = __webpack_require__(46);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/dependent/index.js
var dependent = __webpack_require__(56);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/mixins/menuable/index.js
var menuable = __webpack_require__(74);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VTooltip/VTooltip.js
 // Mixins






 // Helpers




/* @vue/component */

/* harmony default export */ var VTooltip_VTooltip = (Object(mixins["a" /* default */])(colorable["a" /* default */], delayable["a" /* default */], dependent["a" /* default */], menuable["a" /* default */], toggleable["a" /* default */]).extend({
  name: 'v-tooltip',
  props: {
    closeDelay: {
      type: [Number, String],
      default: 0
    },
    disabled: Boolean,
    openDelay: {
      type: [Number, String],
      default: 0
    },
    openOnHover: {
      type: Boolean,
      default: true
    },
    tag: {
      type: String,
      default: 'span'
    },
    transition: String
  },
  data: () => ({
    calculatedMinWidth: 0,
    closeDependents: false
  }),
  computed: {
    calculatedLeft() {
      const {
        activator,
        content
      } = this.dimensions;
      const unknown = !this.bottom && !this.left && !this.top && !this.right;
      const activatorLeft = this.attach !== false ? activator.offsetLeft : activator.left;
      let left = 0;

      if (this.top || this.bottom || unknown) {
        left = activatorLeft + activator.width / 2 - content.width / 2;
      } else if (this.left || this.right) {
        left = activatorLeft + (this.right ? activator.width : -content.width) + (this.right ? 10 : -10);
      }

      if (this.nudgeLeft) left -= parseInt(this.nudgeLeft);
      if (this.nudgeRight) left += parseInt(this.nudgeRight);
      return `${this.calcXOverflow(left, this.dimensions.content.width)}px`;
    },

    calculatedTop() {
      const {
        activator,
        content
      } = this.dimensions;
      const activatorTop = this.attach !== false ? activator.offsetTop : activator.top;
      let top = 0;

      if (this.top || this.bottom) {
        top = activatorTop + (this.bottom ? activator.height : -content.height) + (this.bottom ? 10 : -10);
      } else if (this.left || this.right) {
        top = activatorTop + activator.height / 2 - content.height / 2;
      }

      if (this.nudgeTop) top -= parseInt(this.nudgeTop);
      if (this.nudgeBottom) top += parseInt(this.nudgeBottom);
      if (this.attach === false) top += this.pageYOffset;
      return `${this.calcYOverflow(top)}px`;
    },

    classes() {
      return {
        'v-tooltip--top': this.top,
        'v-tooltip--right': this.right,
        'v-tooltip--bottom': this.bottom,
        'v-tooltip--left': this.left,
        'v-tooltip--attached': this.attach === '' || this.attach === true || this.attach === 'attach'
      };
    },

    computedTransition() {
      if (this.transition) return this.transition;
      return this.isActive ? 'scale-transition' : 'fade-transition';
    },

    offsetY() {
      return this.top || this.bottom;
    },

    offsetX() {
      return this.left || this.right;
    },

    styles() {
      return {
        left: this.calculatedLeft,
        maxWidth: Object(helpers["i" /* convertToUnit */])(this.maxWidth),
        minWidth: Object(helpers["i" /* convertToUnit */])(this.minWidth),
        top: this.calculatedTop,
        zIndex: this.zIndex || this.activeZIndex
      };
    }

  },

  beforeMount() {
    this.$nextTick(() => {
      this.value && this.callActivate();
    });
  },

  mounted() {
    if (Object(helpers["w" /* getSlotType */])(this, 'activator', true) === 'v-slot') {
      Object(console["b" /* consoleError */])(`v-tooltip's activator slot must be bound, try '<template #activator="data"><v-btn v-on="data.on>'`, this);
    }
  },

  methods: {
    activate() {
      // Update coordinates and dimensions of menu
      // and its activator
      this.updateDimensions(); // Start the transition

      requestAnimationFrame(this.startTransition);
    },

    deactivate() {
      this.runDelay('close');
    },

    genActivatorListeners() {
      const listeners = activatable["a" /* default */].options.methods.genActivatorListeners.call(this);

      listeners.focus = e => {
        this.getActivator(e);
        this.runDelay('open');
      };

      listeners.blur = e => {
        this.getActivator(e);
        this.runDelay('close');
      };

      listeners.keydown = e => {
        if (e.keyCode === helpers["B" /* keyCodes */].esc) {
          this.getActivator(e);
          this.runDelay('close');
        }
      };

      return listeners;
    },

    genActivatorAttributes() {
      return {
        'aria-haspopup': true,
        'aria-expanded': String(this.isActive)
      };
    },

    genTransition() {
      const content = this.genContent();
      if (!this.computedTransition) return content;
      return this.$createElement('transition', {
        props: {
          name: this.computedTransition
        }
      }, [content]);
    },

    genContent() {
      return this.$createElement('div', this.setBackgroundColor(this.color, {
        staticClass: 'v-tooltip__content',
        class: {
          [this.contentClass]: true,
          menuable__content__active: this.isActive,
          'v-tooltip__content--fixed': this.activatorFixed
        },
        style: this.styles,
        attrs: this.getScopeIdAttrs(),
        directives: [{
          name: 'show',
          value: this.isContentActive
        }],
        ref: 'content'
      }), this.getContentSlot());
    }

  },

  render(h) {
    return h(this.tag, {
      staticClass: 'v-tooltip',
      class: this.classes
    }, [this.showLazyContent(() => [this.genTransition()]), this.genActivator()]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VTooltip/index.js


/* harmony default export */ var components_VTooltip = (VTooltip_VTooltip);
// EXTERNAL MODULE: external "core-js/modules/esnext.set.add-all.js"
var esnext_set_add_all_js_ = __webpack_require__(212);

// EXTERNAL MODULE: external "core-js/modules/esnext.set.delete-all.js"
var esnext_set_delete_all_js_ = __webpack_require__(213);

// EXTERNAL MODULE: external "core-js/modules/esnext.set.difference.js"
var esnext_set_difference_js_ = __webpack_require__(214);

// EXTERNAL MODULE: external "core-js/modules/esnext.set.every.js"
var esnext_set_every_js_ = __webpack_require__(215);

// EXTERNAL MODULE: external "core-js/modules/esnext.set.filter.js"
var esnext_set_filter_js_ = __webpack_require__(216);

// EXTERNAL MODULE: external "core-js/modules/esnext.set.find.js"
var esnext_set_find_js_ = __webpack_require__(217);

// EXTERNAL MODULE: external "core-js/modules/esnext.set.intersection.js"
var esnext_set_intersection_js_ = __webpack_require__(218);

// EXTERNAL MODULE: external "core-js/modules/esnext.set.is-disjoint-from.js"
var esnext_set_is_disjoint_from_js_ = __webpack_require__(219);

// EXTERNAL MODULE: external "core-js/modules/esnext.set.is-subset-of.js"
var esnext_set_is_subset_of_js_ = __webpack_require__(220);

// EXTERNAL MODULE: external "core-js/modules/esnext.set.is-superset-of.js"
var esnext_set_is_superset_of_js_ = __webpack_require__(221);

// EXTERNAL MODULE: external "core-js/modules/esnext.set.join.js"
var esnext_set_join_js_ = __webpack_require__(222);

// EXTERNAL MODULE: external "core-js/modules/esnext.set.map.js"
var esnext_set_map_js_ = __webpack_require__(223);

// EXTERNAL MODULE: external "core-js/modules/esnext.set.reduce.js"
var esnext_set_reduce_js_ = __webpack_require__(224);

// EXTERNAL MODULE: external "core-js/modules/esnext.set.some.js"
var esnext_set_some_js_ = __webpack_require__(225);

// EXTERNAL MODULE: external "core-js/modules/esnext.set.symmetric-difference.js"
var esnext_set_symmetric_difference_js_ = __webpack_require__(226);

// EXTERNAL MODULE: external "core-js/modules/esnext.set.union.js"
var esnext_set_union_js_ = __webpack_require__(227);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.delete-all.js"
var esnext_map_delete_all_js_ = __webpack_require__(187);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.every.js"
var esnext_map_every_js_ = __webpack_require__(188);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.filter.js"
var esnext_map_filter_js_ = __webpack_require__(189);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.find.js"
var esnext_map_find_js_ = __webpack_require__(190);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.find-key.js"
var esnext_map_find_key_js_ = __webpack_require__(191);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.includes.js"
var esnext_map_includes_js_ = __webpack_require__(192);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.key-of.js"
var esnext_map_key_of_js_ = __webpack_require__(193);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.map-keys.js"
var esnext_map_map_keys_js_ = __webpack_require__(194);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.map-values.js"
var esnext_map_map_values_js_ = __webpack_require__(195);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.merge.js"
var esnext_map_merge_js_ = __webpack_require__(196);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.reduce.js"
var esnext_map_reduce_js_ = __webpack_require__(197);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.some.js"
var esnext_map_some_js_ = __webpack_require__(198);

// EXTERNAL MODULE: external "core-js/modules/esnext.map.update.js"
var esnext_map_update_js_ = __webpack_require__(199);

// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VTreeview/VTreeview.sass
var VTreeview = __webpack_require__(471);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VTreeview/VTreeviewNode.js
// Components

 // Mixins


 // Utils



const VTreeviewNode_baseMixins = Object(mixins["a" /* default */])(colorable["a" /* default */], Object(registrable["a" /* inject */])('treeview'));
const VTreeviewNodeProps = {
  activatable: Boolean,
  activeClass: {
    type: String,
    default: 'v-treeview-node--active'
  },
  color: {
    type: String,
    default: 'primary'
  },
  disablePerNode: Boolean,
  expandIcon: {
    type: String,
    default: '$subgroup'
  },
  indeterminateIcon: {
    type: String,
    default: '$checkboxIndeterminate'
  },
  itemChildren: {
    type: String,
    default: 'children'
  },
  itemDisabled: {
    type: String,
    default: 'disabled'
  },
  itemKey: {
    type: String,
    default: 'id'
  },
  itemText: {
    type: String,
    default: 'name'
  },
  loadChildren: Function,
  loadingIcon: {
    type: String,
    default: '$loading'
  },
  offIcon: {
    type: String,
    default: '$checkboxOff'
  },
  onIcon: {
    type: String,
    default: '$checkboxOn'
  },
  openOnClick: Boolean,
  rounded: Boolean,
  selectable: Boolean,
  selectedColor: {
    type: String,
    default: 'accent'
  },
  shaped: Boolean,
  transition: Boolean,
  selectionType: {
    type: String,
    default: 'leaf',
    validator: v => ['leaf', 'independent'].includes(v)
  }
};
/* @vue/component */

const VTreeviewNode = VTreeviewNode_baseMixins.extend().extend({
  name: 'v-treeview-node',
  inject: {
    treeview: {
      default: null
    }
  },
  props: {
    level: Number,
    item: {
      type: Object,
      default: () => null
    },
    parentIsDisabled: Boolean,
    ...VTreeviewNodeProps
  },
  data: () => ({
    hasLoaded: false,
    isActive: false,
    isIndeterminate: false,
    isLoading: false,
    isOpen: false,
    isSelected: false
  }),
  computed: {
    disabled() {
      return Object(helpers["s" /* getObjectValueByPath */])(this.item, this.itemDisabled) || !this.disablePerNode && this.parentIsDisabled && this.selectionType === 'leaf';
    },

    key() {
      return Object(helpers["s" /* getObjectValueByPath */])(this.item, this.itemKey);
    },

    children() {
      const children = Object(helpers["s" /* getObjectValueByPath */])(this.item, this.itemChildren);
      return children && children.filter(child => !this.treeview.isExcluded(Object(helpers["s" /* getObjectValueByPath */])(child, this.itemKey)));
    },

    text() {
      return Object(helpers["s" /* getObjectValueByPath */])(this.item, this.itemText);
    },

    scopedProps() {
      return {
        item: this.item,
        leaf: !this.children,
        selected: this.isSelected,
        indeterminate: this.isIndeterminate,
        active: this.isActive,
        open: this.isOpen
      };
    },

    computedIcon() {
      if (this.isIndeterminate) return this.indeterminateIcon;else if (this.isSelected) return this.onIcon;else return this.offIcon;
    },

    hasChildren() {
      return !!this.children && (!!this.children.length || !!this.loadChildren);
    }

  },

  created() {
    this.treeview.register(this);
  },

  beforeDestroy() {
    this.treeview.unregister(this);
  },

  methods: {
    checkChildren() {
      return new Promise(resolve => {
        // TODO: Potential issue with always trying
        // to load children if response is empty?
        if (!this.children || this.children.length || !this.loadChildren || this.hasLoaded) return resolve();
        this.isLoading = true;
        resolve(this.loadChildren(this.item));
      }).then(() => {
        this.isLoading = false;
        this.hasLoaded = true;
      });
    },

    open() {
      this.isOpen = !this.isOpen;
      this.treeview.updateOpen(this.key, this.isOpen);
      this.treeview.emitOpen();
    },

    genLabel() {
      const children = [];
      if (this.$scopedSlots.label) children.push(this.$scopedSlots.label(this.scopedProps));else children.push(this.text);
      return this.$createElement('div', {
        slot: 'label',
        staticClass: 'v-treeview-node__label'
      }, children);
    },

    genPrependSlot() {
      if (!this.$scopedSlots.prepend) return null;
      return this.$createElement('div', {
        staticClass: 'v-treeview-node__prepend'
      }, this.$scopedSlots.prepend(this.scopedProps));
    },

    genAppendSlot() {
      if (!this.$scopedSlots.append) return null;
      return this.$createElement('div', {
        staticClass: 'v-treeview-node__append'
      }, this.$scopedSlots.append(this.scopedProps));
    },

    genContent() {
      const children = [this.genPrependSlot(), this.genLabel(), this.genAppendSlot()];
      return this.$createElement('div', {
        staticClass: 'v-treeview-node__content'
      }, children);
    },

    genToggle() {
      return this.$createElement(VIcon_VIcon["a" /* default */], {
        staticClass: 'v-treeview-node__toggle',
        class: {
          'v-treeview-node__toggle--open': this.isOpen,
          'v-treeview-node__toggle--loading': this.isLoading
        },
        slot: 'prepend',
        on: {
          click: e => {
            e.stopPropagation();
            if (this.isLoading) return;
            this.checkChildren().then(() => this.open());
          }
        }
      }, [this.isLoading ? this.loadingIcon : this.expandIcon]);
    },

    genCheckbox() {
      return this.$createElement(VIcon_VIcon["a" /* default */], {
        staticClass: 'v-treeview-node__checkbox',
        props: {
          color: this.isSelected || this.isIndeterminate ? this.selectedColor : undefined,
          disabled: this.disabled
        },
        on: {
          click: e => {
            e.stopPropagation();
            if (this.isLoading) return;
            this.checkChildren().then(() => {
              // We nextTick here so that items watch in VTreeview has a chance to run first
              this.$nextTick(() => {
                this.isSelected = !this.isSelected;
                this.isIndeterminate = false;
                this.treeview.updateSelected(this.key, this.isSelected);
                this.treeview.emitSelected();
              });
            });
          }
        }
      }, [this.computedIcon]);
    },

    genLevel(level) {
      return Object(helpers["j" /* createRange */])(level).map(() => this.$createElement('div', {
        staticClass: 'v-treeview-node__level'
      }));
    },

    genNode() {
      const children = [this.genContent()];
      if (this.selectable) children.unshift(this.genCheckbox());

      if (this.hasChildren) {
        children.unshift(this.genToggle());
      } else {
        children.unshift(...this.genLevel(1));
      }

      children.unshift(...this.genLevel(this.level));
      return this.$createElement('div', this.setTextColor(this.isActive && this.color, {
        staticClass: 'v-treeview-node__root',
        class: {
          [this.activeClass]: this.isActive
        },
        on: {
          click: () => {
            if (this.openOnClick && this.hasChildren) {
              this.checkChildren().then(this.open);
            } else if (this.activatable && !this.disabled) {
              this.isActive = !this.isActive;
              this.treeview.updateActive(this.key, this.isActive);
              this.treeview.emitActive();
            }
          }
        }
      }), children);
    },

    genChild(item, parentIsDisabled) {
      return this.$createElement(VTreeviewNode, {
        key: Object(helpers["s" /* getObjectValueByPath */])(item, this.itemKey),
        props: {
          activatable: this.activatable,
          activeClass: this.activeClass,
          item,
          selectable: this.selectable,
          selectedColor: this.selectedColor,
          color: this.color,
          disablePerNode: this.disablePerNode,
          expandIcon: this.expandIcon,
          indeterminateIcon: this.indeterminateIcon,
          offIcon: this.offIcon,
          onIcon: this.onIcon,
          loadingIcon: this.loadingIcon,
          itemKey: this.itemKey,
          itemText: this.itemText,
          itemDisabled: this.itemDisabled,
          itemChildren: this.itemChildren,
          loadChildren: this.loadChildren,
          transition: this.transition,
          openOnClick: this.openOnClick,
          rounded: this.rounded,
          shaped: this.shaped,
          level: this.level + 1,
          selectionType: this.selectionType,
          parentIsDisabled
        },
        scopedSlots: this.$scopedSlots
      });
    },

    genChildrenWrapper() {
      if (!this.isOpen || !this.children) return null;
      const children = [this.children.map(c => this.genChild(c, this.disabled))];
      return this.$createElement('div', {
        staticClass: 'v-treeview-node__children'
      }, children);
    },

    genTransition() {
      return this.$createElement(transitions["f" /* VExpandTransition */], [this.genChildrenWrapper()]);
    }

  },

  render(h) {
    const children = [this.genNode()];
    if (this.transition) children.push(this.genTransition());else children.push(this.genChildrenWrapper());
    return h('div', {
      staticClass: 'v-treeview-node',
      class: {
        'v-treeview-node--leaf': !this.hasChildren,
        'v-treeview-node--click': this.openOnClick,
        'v-treeview-node--disabled': this.disabled,
        'v-treeview-node--rounded': this.rounded,
        'v-treeview-node--shaped': this.shaped,
        'v-treeview-node--selected': this.isSelected
      },
      attrs: {
        'aria-expanded': String(this.isOpen)
      }
    }, children);
  }

});
/* harmony default export */ var VTreeview_VTreeviewNode = (VTreeviewNode);
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VTreeview/util/filterTreeItems.js

function filterTreeItem(item, search, textKey) {
  const text = Object(helpers["s" /* getObjectValueByPath */])(item, textKey);
  return text.toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) > -1;
}
function filterTreeItems(filter, item, search, idKey, textKey, childrenKey, excluded) {
  if (filter(item, search, textKey)) {
    return true;
  }

  const children = Object(helpers["s" /* getObjectValueByPath */])(item, childrenKey);

  if (children) {
    let match = false;

    for (let i = 0; i < children.length; i++) {
      if (filterTreeItems(filter, children[i], search, idKey, textKey, childrenKey, excluded)) {
        match = true;
      }
    }

    if (match) return true;
  }

  excluded.add(Object(helpers["s" /* getObjectValueByPath */])(item, idKey));
  return false;
}
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VTreeview/VTreeview.js





























// Styles
 // Components

 // Mixins


 // Utils





/* harmony default export */ var VTreeview_VTreeview = (Object(mixins["a" /* default */])(Object(registrable["b" /* provide */])('treeview'), themeable["a" /* default */]
/* @vue/component */
).extend({
  name: 'v-treeview',

  provide() {
    return {
      treeview: this
    };
  },

  props: {
    active: {
      type: Array,
      default: () => []
    },
    dense: Boolean,
    disabled: Boolean,
    filter: Function,
    hoverable: Boolean,
    items: {
      type: Array,
      default: () => []
    },
    multipleActive: Boolean,
    open: {
      type: Array,
      default: () => []
    },
    openAll: Boolean,
    returnObject: {
      type: Boolean,
      default: false
    },
    search: String,
    value: {
      type: Array,
      default: () => []
    },
    ...VTreeviewNodeProps
  },
  data: () => ({
    level: -1,
    activeCache: new Set(),
    nodes: {},
    openCache: new Set(),
    selectedCache: new Set()
  }),
  computed: {
    excludedItems() {
      const excluded = new Set();
      if (!this.search) return excluded;

      for (let i = 0; i < this.items.length; i++) {
        filterTreeItems(this.filter || filterTreeItem, this.items[i], this.search, this.itemKey, this.itemText, this.itemChildren, excluded);
      }

      return excluded;
    }

  },
  watch: {
    items: {
      handler() {
        const oldKeys = Object.keys(this.nodes).map(k => Object(helpers["s" /* getObjectValueByPath */])(this.nodes[k].item, this.itemKey));
        const newKeys = this.getKeys(this.items);
        const diff = Object(helpers["c" /* arrayDiff */])(newKeys, oldKeys); // We only want to do stuff if items have changed

        if (!diff.length && newKeys.length < oldKeys.length) return; // If nodes are removed we need to clear them from this.nodes

        diff.forEach(k => delete this.nodes[k]);
        const oldSelectedCache = [...this.selectedCache];
        this.selectedCache = new Set();
        this.activeCache = new Set();
        this.openCache = new Set();
        this.buildTree(this.items); // Only emit selected if selection has changed
        // as a result of items changing. This fixes a
        // potential double emit when selecting a node
        // with dynamic children

        if (!Object(helpers["m" /* deepEqual */])(oldSelectedCache, [...this.selectedCache])) this.emitSelected();
      },

      deep: true
    },

    active(value) {
      this.handleNodeCacheWatcher(value, this.activeCache, this.updateActive, this.emitActive);
    },

    value(value) {
      this.handleNodeCacheWatcher(value, this.selectedCache, this.updateSelected, this.emitSelected);
    },

    open(value) {
      this.handleNodeCacheWatcher(value, this.openCache, this.updateOpen, this.emitOpen);
    }

  },

  created() {
    const getValue = key => this.returnObject ? Object(helpers["s" /* getObjectValueByPath */])(key, this.itemKey) : key;

    this.buildTree(this.items);

    for (const value of this.value.map(getValue)) {
      this.updateSelected(value, true, true);
    }

    for (const active of this.active.map(getValue)) {
      this.updateActive(active, true);
    }
  },

  mounted() {
    // Save the developer from themselves
    if (this.$slots.prepend || this.$slots.append) {
      Object(console["c" /* consoleWarn */])('The prepend and append slots require a slot-scope attribute', this);
    }

    if (this.openAll) {
      this.updateAll(true);
    } else {
      this.open.forEach(key => this.updateOpen(this.returnObject ? Object(helpers["s" /* getObjectValueByPath */])(key, this.itemKey) : key, true));
      this.emitOpen();
    }
  },

  methods: {
    /** @public */
    updateAll(value) {
      Object.keys(this.nodes).forEach(key => this.updateOpen(Object(helpers["s" /* getObjectValueByPath */])(this.nodes[key].item, this.itemKey), value));
      this.emitOpen();
    },

    getKeys(items, keys = []) {
      for (let i = 0; i < items.length; i++) {
        const key = Object(helpers["s" /* getObjectValueByPath */])(items[i], this.itemKey);
        keys.push(key);
        const children = Object(helpers["s" /* getObjectValueByPath */])(items[i], this.itemChildren);

        if (children) {
          keys.push(...this.getKeys(children));
        }
      }

      return keys;
    },

    buildTree(items, parent = null) {
      for (let i = 0; i < items.length; i++) {
        var _getObjectValueByPath;

        const item = items[i];
        const key = Object(helpers["s" /* getObjectValueByPath */])(item, this.itemKey);
        const children = (_getObjectValueByPath = Object(helpers["s" /* getObjectValueByPath */])(item, this.itemChildren)) != null ? _getObjectValueByPath : [];
        const oldNode = this.nodes.hasOwnProperty(key) ? this.nodes[key] : {
          isSelected: false,
          isIndeterminate: false,
          isActive: false,
          isOpen: false,
          vnode: null
        };
        const node = {
          vnode: oldNode.vnode,
          parent,
          children: children.map(c => Object(helpers["s" /* getObjectValueByPath */])(c, this.itemKey)),
          item
        };
        this.buildTree(children, key); // This fixed bug with dynamic children resetting selected parent state

        if (!this.nodes.hasOwnProperty(key) && parent !== null && this.nodes.hasOwnProperty(parent)) {
          node.isSelected = this.nodes[parent].isSelected;
        } else {
          node.isSelected = oldNode.isSelected;
          node.isIndeterminate = oldNode.isIndeterminate;
        }

        node.isActive = oldNode.isActive;
        node.isOpen = oldNode.isOpen;
        this.nodes[key] = node;

        if (children.length && this.selectionType !== 'independent') {
          const {
            isSelected,
            isIndeterminate
          } = this.calculateState(key, this.nodes);
          node.isSelected = isSelected;
          node.isIndeterminate = isIndeterminate;
        } // Don't forget to rebuild cache


        if (this.nodes[key].isSelected && (this.selectionType === 'independent' || node.children.length === 0)) this.selectedCache.add(key);
        if (this.nodes[key].isActive) this.activeCache.add(key);
        if (this.nodes[key].isOpen) this.openCache.add(key);
        this.updateVnodeState(key);
      }
    },

    calculateState(node, state) {
      const children = state[node].children;
      const counts = children.reduce((counts, child) => {
        counts[0] += +Boolean(state[child].isSelected);
        counts[1] += +Boolean(state[child].isIndeterminate);
        return counts;
      }, [0, 0]);
      const isSelected = !!children.length && counts[0] === children.length;
      const isIndeterminate = !isSelected && (counts[0] > 0 || counts[1] > 0);
      return {
        isSelected,
        isIndeterminate
      };
    },

    emitOpen() {
      this.emitNodeCache('update:open', this.openCache);
    },

    emitSelected() {
      this.emitNodeCache('input', this.selectedCache);
    },

    emitActive() {
      this.emitNodeCache('update:active', this.activeCache);
    },

    emitNodeCache(event, cache) {
      this.$emit(event, this.returnObject ? [...cache].map(key => this.nodes[key].item) : [...cache]);
    },

    handleNodeCacheWatcher(value, cache, updateFn, emitFn) {
      value = this.returnObject ? value.map(v => Object(helpers["s" /* getObjectValueByPath */])(v, this.itemKey)) : value;
      const old = [...cache];
      if (Object(helpers["m" /* deepEqual */])(old, value)) return;
      old.forEach(key => updateFn(key, false));
      value.forEach(key => updateFn(key, true));
      emitFn();
    },

    getDescendants(key, descendants = []) {
      const children = this.nodes[key].children;
      descendants.push(...children);

      for (let i = 0; i < children.length; i++) {
        descendants = this.getDescendants(children[i], descendants);
      }

      return descendants;
    },

    getParents(key) {
      let parent = this.nodes[key].parent;
      const parents = [];

      while (parent !== null) {
        parents.push(parent);
        parent = this.nodes[parent].parent;
      }

      return parents;
    },

    register(node) {
      const key = Object(helpers["s" /* getObjectValueByPath */])(node.item, this.itemKey);
      this.nodes[key].vnode = node;
      this.updateVnodeState(key);
    },

    unregister(node) {
      const key = Object(helpers["s" /* getObjectValueByPath */])(node.item, this.itemKey);
      if (this.nodes[key]) this.nodes[key].vnode = null;
    },

    isParent(key) {
      return this.nodes[key].children && this.nodes[key].children.length;
    },

    updateActive(key, isActive) {
      if (!this.nodes.hasOwnProperty(key)) return;

      if (!this.multipleActive) {
        this.activeCache.forEach(active => {
          this.nodes[active].isActive = false;
          this.updateVnodeState(active);
          this.activeCache.delete(active);
        });
      }

      const node = this.nodes[key];
      if (!node) return;
      if (isActive) this.activeCache.add(key);else this.activeCache.delete(key);
      node.isActive = isActive;
      this.updateVnodeState(key);
    },

    updateSelected(key, isSelected, isForced = false) {
      if (!this.nodes.hasOwnProperty(key)) return;
      const changed = new Map();

      if (this.selectionType !== 'independent') {
        for (const descendant of this.getDescendants(key)) {
          if (!Object(helpers["s" /* getObjectValueByPath */])(this.nodes[descendant].item, this.itemDisabled) || isForced) {
            this.nodes[descendant].isSelected = isSelected;
            this.nodes[descendant].isIndeterminate = false;
            changed.set(descendant, isSelected);
          }
        }

        const calculated = this.calculateState(key, this.nodes);
        this.nodes[key].isSelected = isSelected;
        this.nodes[key].isIndeterminate = calculated.isIndeterminate;
        changed.set(key, isSelected);

        for (const parent of this.getParents(key)) {
          const calculated = this.calculateState(parent, this.nodes);
          this.nodes[parent].isSelected = calculated.isSelected;
          this.nodes[parent].isIndeterminate = calculated.isIndeterminate;
          changed.set(parent, calculated.isSelected);
        }
      } else {
        this.nodes[key].isSelected = isSelected;
        this.nodes[key].isIndeterminate = false;
        changed.set(key, isSelected);
      }

      for (const [key, value] of changed.entries()) {
        this.updateVnodeState(key);
        if (this.selectionType === 'leaf' && this.isParent(key)) continue;
        value === true ? this.selectedCache.add(key) : this.selectedCache.delete(key);
      }
    },

    updateOpen(key, isOpen) {
      if (!this.nodes.hasOwnProperty(key)) return;
      const node = this.nodes[key];
      const children = Object(helpers["s" /* getObjectValueByPath */])(node.item, this.itemChildren);

      if (children && !children.length && node.vnode && !node.vnode.hasLoaded) {
        node.vnode.checkChildren().then(() => this.updateOpen(key, isOpen));
      } else if (children && children.length) {
        node.isOpen = isOpen;
        node.isOpen ? this.openCache.add(key) : this.openCache.delete(key);
        this.updateVnodeState(key);
      }
    },

    updateVnodeState(key) {
      const node = this.nodes[key];

      if (node && node.vnode) {
        node.vnode.isSelected = node.isSelected;
        node.vnode.isIndeterminate = node.isIndeterminate;
        node.vnode.isActive = node.isActive;
        node.vnode.isOpen = node.isOpen;
      }
    },

    isExcluded(key) {
      return !!this.search && this.excludedItems.has(key);
    }

  },

  render(h) {
    const children = this.items.length ? this.items.filter(item => {
      return !this.isExcluded(Object(helpers["s" /* getObjectValueByPath */])(item, this.itemKey));
    }).map(item => {
      const genChild = VTreeview_VTreeviewNode.options.methods.genChild.bind(this);
      return genChild(item, this.disabled || Object(helpers["s" /* getObjectValueByPath */])(item, this.itemDisabled));
    })
    /* istanbul ignore next */
    : this.$slots.default; // TODO: remove type annotation with TS 3.2

    return h('div', {
      staticClass: 'v-treeview',
      class: {
        'v-treeview--hoverable': this.hoverable,
        'v-treeview--dense': this.dense,
        ...this.themeClasses
      }
    }, children);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VTreeview/index.js



/* harmony default export */ var components_VTreeview = ({
  $_vuetify_subcomponents: {
    VTreeview: VTreeview_VTreeview,
    VTreeviewNode: VTreeview_VTreeviewNode
  }
});
// EXTERNAL MODULE: ./node_modules/vuetify/src/components/VVirtualScroll/VVirtualScroll.sass
var VVirtualScroll = __webpack_require__(472);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/directives/scroll/index.js
var directives_scroll = __webpack_require__(70);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VVirtualScroll/VVirtualScroll.js
// Styles
 // Mixins

 // Directives

 // Utilities


/* harmony default export */ var VVirtualScroll_VVirtualScroll = (measurable["a" /* default */].extend({
  name: 'v-virtual-scroll',
  directives: {
    Scroll: directives_scroll["b" /* default */]
  },
  props: {
    bench: {
      type: [Number, String],
      default: 0
    },
    itemHeight: {
      type: [Number, String],
      required: true
    },
    items: {
      type: Array,
      default: () => []
    }
  },
  data: () => ({
    first: 0,
    last: 0,
    scrollTop: 0
  }),
  computed: {
    __bench() {
      return parseInt(this.bench, 10);
    },

    __itemHeight() {
      return parseInt(this.itemHeight, 10);
    },

    firstToRender() {
      return Math.max(0, this.first - this.__bench);
    },

    lastToRender() {
      return Math.min(this.items.length, this.last + this.__bench);
    }

  },
  watch: {
    height: 'onScroll',
    itemHeight: 'onScroll'
  },

  mounted() {
    this.last = this.getLast(0);
  },

  methods: {
    getChildren() {
      return this.items.slice(this.firstToRender, this.lastToRender).map(this.genChild);
    },

    genChild(item, index) {
      index += this.firstToRender;
      const top = Object(helpers["i" /* convertToUnit */])(index * this.__itemHeight);
      return this.$createElement('div', {
        staticClass: 'v-virtual-scroll__item',
        style: {
          top
        },
        key: index
      }, Object(helpers["v" /* getSlot */])(this, 'default', {
        index,
        item
      }));
    },

    getFirst() {
      return Math.floor(this.scrollTop / this.__itemHeight);
    },

    getLast(first) {
      const height = parseInt(this.height || 0, 10) || this.$el.clientHeight;
      return first + Math.ceil(height / this.__itemHeight);
    },

    onScroll() {
      this.scrollTop = this.$el.scrollTop;
      this.first = this.getFirst();
      this.last = this.getLast(this.first);
    }

  },

  render(h) {
    const content = h('div', {
      staticClass: 'v-virtual-scroll__container',
      style: {
        height: Object(helpers["i" /* convertToUnit */])(this.items.length * this.__itemHeight)
      }
    }, this.getChildren());
    return h('div', {
      staticClass: 'v-virtual-scroll',
      style: this.measurableStyles,
      directives: [{
        name: 'scroll',
        modifiers: {
          self: true
        },
        value: this.onScroll
      }],
      on: this.$listeners
    }, [content]);
  }

}));
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VVirtualScroll/index.js


/* harmony default export */ var components_VVirtualScroll = (VVirtualScroll_VVirtualScroll);
// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VWindow/VWindow.js
var VWindow = __webpack_require__(68);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VWindow/VWindowItem.js
var VWindowItem = __webpack_require__(268);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/VWindow/index.js



/* harmony default export */ var components_VWindow = ({
  $_vuetify_subcomponents: {
    VWindow: VWindow["a" /* default */],
    VWindowItem: VWindowItem["a" /* default */]
  }
});
// CONCATENATED MODULE: ./node_modules/vuetify/lib/components/index.js

















































































// EXTERNAL MODULE: ./node_modules/vuetify/lib/directives/index.js + 1 modules
var directives = __webpack_require__(208);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/framework.js + 18 modules
var framework = __webpack_require__(50);

// CONCATENATED MODULE: ./node_modules/vuetify/lib/index.js





/***/ }),
/* 396 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 397 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 398 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _src_components_VCheckbox_VCheckbox_sass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(441);
/* harmony import */ var _src_components_VCheckbox_VCheckbox_sass__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_components_VCheckbox_VCheckbox_sass__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _src_styles_components_selection_controls_sass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(362);
/* harmony import */ var _src_styles_components_selection_controls_sass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_src_styles_components_selection_controls_sass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
/* harmony import */ var _VInput__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23);
/* harmony import */ var _mixins_selectable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(363);
// Styles

 // Components


 // Mixins


/* @vue/component */

/* harmony default export */ __webpack_exports__["a"] = (_mixins_selectable__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].extend({
  name: 'v-checkbox',
  props: {
    indeterminate: Boolean,
    indeterminateIcon: {
      type: String,
      default: '$checkboxIndeterminate'
    },
    offIcon: {
      type: String,
      default: '$checkboxOff'
    },
    onIcon: {
      type: String,
      default: '$checkboxOn'
    }
  },

  data() {
    return {
      inputIndeterminate: this.indeterminate
    };
  },

  computed: {
    classes() {
      return { ..._VInput__WEBPACK_IMPORTED_MODULE_3__[/* default */ "b"].options.computed.classes.call(this),
        'v-input--selection-controls': true,
        'v-input--checkbox': true,
        'v-input--indeterminate': this.inputIndeterminate
      };
    },

    computedIcon() {
      if (this.inputIndeterminate) {
        return this.indeterminateIcon;
      } else if (this.isActive) {
        return this.onIcon;
      } else {
        return this.offIcon;
      }
    },

    // Do not return undefined if disabled,
    // according to spec, should still show
    // a color when disabled and active
    validationState() {
      if (this.isDisabled && !this.inputIndeterminate) return undefined;
      if (this.hasError && this.shouldValidate) return 'error';
      if (this.hasSuccess) return 'success';
      if (this.hasColor !== null) return this.computedColor;
      return undefined;
    }

  },
  watch: {
    indeterminate(val) {
      // https://github.com/vuetifyjs/vuetify/issues/8270
      this.$nextTick(() => this.inputIndeterminate = val);
    },

    inputIndeterminate(val) {
      this.$emit('update:indeterminate', val);
    },

    isActive() {
      if (!this.indeterminate) return;
      this.inputIndeterminate = false;
    }

  },
  methods: {
    genCheckbox() {
      const {
        title,
        ...checkboxAttrs
      } = this.attrs$;
      return this.$createElement('div', {
        staticClass: 'v-input--selection-controls__input'
      }, [this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_2__[/* default */ "b"], this.setTextColor(this.validationState, {
        props: {
          dense: this.dense,
          dark: this.dark,
          light: this.light
        }
      }), this.computedIcon), this.genInput('checkbox', { ...checkboxAttrs,
        'aria-checked': this.inputIndeterminate ? 'mixed' : this.isActive.toString()
      }), this.genRipple(this.setTextColor(this.rippleState))]);
    },

    genDefaultSlot() {
      return [this.genCheckbox(), this.genLabel()];
    }

  }
}));

/***/ }),
/* 399 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _VWindow_VWindowItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(268);
// Extensions

/* @vue/component */

/* harmony default export */ __webpack_exports__["a"] = (_VWindow_VWindowItem__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].extend({
  name: 'v-tab-item',
  props: {
    id: String
  },
  methods: {
    genWindowItem() {
      const item = _VWindow_VWindowItem__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].options.methods.genWindowItem.call(this);
      item.data.domProps = item.data.domProps || {};
      item.data.domProps.id = this.id || this.value;
      return item;
    }

  }
}));

/***/ }),
/* 400 */,
/* 401 */,
/* 402 */,
/* 403 */,
/* 404 */,
/* 405 */,
/* 406 */,
/* 407 */,
/* 408 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/Editor.vue?vue&type=template&id=48c7cf33&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('ClientOnly',{scopedSlots:_vm._u([{key:"placeholder",fn:function(){return [_vm._v("\n      Loading...\n    ")]},proxy:true}])},[_c('tiptap-vuetify',{attrs:{"extensions":_vm.extensions},model:{value:(_vm.computedContent),callback:function ($$v) {_vm.computedContent=$$v},expression:"computedContent"}})],1)],1)}
var staticRenderFns = []


// CONCATENATED MODULE: ./components/Editor.vue?vue&type=template&id=48c7cf33&

// EXTERNAL MODULE: ./node_modules/tiptap-vuetify/dist/bundle-umd.js
var bundle_umd = __webpack_require__(431);

// EXTERNAL MODULE: ./components/tiptap/vuetify/ImagenURL.vue + 4 modules
var ImagenURL = __webpack_require__(430);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/Editor.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
// import the component and the necessary extensions


/* harmony default export */ var Editorvue_type_script_lang_js_ = ({
  // specify TiptapVuetify component in "components"
  components: {
    TiptapVuetify: bundle_umd["TiptapVuetify"],
    ImagenURL: ImagenURL["default"]
  },

  data() {
    return {
      extensions: [bundle_umd["History"], bundle_umd["Blockquote"], bundle_umd["Underline"], bundle_umd["Strike"], bundle_umd["Italic"], bundle_umd["ListItem"], bundle_umd["BulletList"], bundle_umd["OrderedList"], [bundle_umd["Heading"], {
        options: {
          levels: [1, 2, 3]
        }
      }], bundle_umd["Bold"], bundle_umd["Link"], bundle_umd["Code"], bundle_umd["HorizontalRule"], bundle_umd["Paragraph"], bundle_umd["HardBreak"], // [Image, {
      //   options: {
      //     imageSources: [{ component: FileSelector, name: 'File Selector' }]
      //   }
      // }],
      [bundle_umd["Image"], {
        options: {
          imageSourcesOverride: true,
          imageSources: [{
            component: ImagenURL["default"],
            name: 'Ingresar URL'
          }]
        }
      }]]
    };
  },

  props: {
    value: String
  },
  watch: {},
  computed: {
    computedContent: {
      get: function () {
        return this.value;
      },
      set: function (v) {
        this.$emit('input', v);
      }
    }
  },

  mounted() {}

});
// CONCATENATED MODULE: ./components/Editor.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_Editorvue_type_script_lang_js_ = (Editorvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(6);

// CONCATENATED MODULE: ./components/Editor.vue





/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  components_Editorvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  "086a872e"
  
)

/* harmony default export */ var Editor = __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 409 */,
/* 410 */,
/* 411 */,
/* 412 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 413 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 414 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 415 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 416 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 417 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 418 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 419 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 420 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 421 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 422 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_1_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Visualizador_vue_vue_type_style_index_0_id_efe6acec_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(379);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_1_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Visualizador_vue_vue_type_style_index_0_id_efe6acec_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_1_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Visualizador_vue_vue_type_style_index_0_id_efe6acec_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_1_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Visualizador_vue_vue_type_style_index_0_id_efe6acec_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_1_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Visualizador_vue_vue_type_style_index_0_id_efe6acec_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


/***/ }),
/* 423 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 424 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 425 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_1_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_ImagenURL_vue_vue_type_style_index_0_id_9151d25c_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(381);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_1_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_ImagenURL_vue_vue_type_style_index_0_id_9151d25c_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_1_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_ImagenURL_vue_vue_type_style_index_0_id_9151d25c_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_1_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_ImagenURL_vue_vue_type_style_index_0_id_9151d25c_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_1_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_ImagenURL_vue_vue_type_style_index_0_id_9151d25c_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


/***/ }),
/* 426 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 427 */,
/* 428 */,
/* 429 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/blogs/Visualizador.vue?vue&type=template&id=efe6acec&scoped=true&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"contenedor_blog_padre"},[_vm._ssrNode("<div class=\"contenedor_blog mt-5 mb-5\" data-v-efe6acec>"+(_vm._s(_vm.contenidoBlog))+"</div>")])}
var staticRenderFns = []


// CONCATENATED MODULE: ./components/blogs/Visualizador.vue?vue&type=template&id=efe6acec&scoped=true&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/blogs/Visualizador.vue?vue&type=script&lang=js&
//
//
//
//
//
//
/* harmony default export */ var Visualizadorvue_type_script_lang_js_ = ({
  name: 'visualizador-blog',
  props: {
    contenidoBlog: String
  }
});
// CONCATENATED MODULE: ./components/blogs/Visualizador.vue?vue&type=script&lang=js&
 /* harmony default export */ var blogs_Visualizadorvue_type_script_lang_js_ = (Visualizadorvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(6);

// CONCATENATED MODULE: ./components/blogs/Visualizador.vue



function injectStyles (context) {
  
  var style0 = __webpack_require__(422)
if (style0.__inject__) style0.__inject__(context)

}

/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  blogs_Visualizadorvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  injectStyles,
  "efe6acec",
  "bc63883a"
  
)

/* harmony default export */ var Visualizador = __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 430 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/tiptap/vuetify/ImagenURL.vue?vue&type=template&id=9151d25c&scoped=true&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"mt-5 mb-5 container"},[_c('v-divider',{staticClass:"mb-5"}),_vm._ssrNode(" "),_c('v-text-field',{attrs:{"label":"Ingresa la URL de tu imagen","required":""},model:{value:(_vm.imageUrl),callback:function ($$v) {_vm.imageUrl=$$v},expression:"imageUrl"}}),_vm._ssrNode(" "),_c('v-text-field',{attrs:{"label":"Ingresa el ALT de tu imagen","required":""},model:{value:(_vm.imageAlt),callback:function ($$v) {_vm.imageAlt=$$v},expression:"imageAlt"}}),_vm._ssrNode(" "),_c('v-btn',{staticClass:"mt-5 btnImage",attrs:{"color":"#ff1d89","block":""},on:{"click":_vm.selectImage}},[_vm._v("\n          Seleccionar\n      ")]),_vm._ssrNode(" "),_c('v-divider',{staticClass:"mt-5"})],2)}
var staticRenderFns = []


// CONCATENATED MODULE: ./components/tiptap/vuetify/ImagenURL.vue?vue&type=template&id=9151d25c&scoped=true&

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VImg/VImg.js
var VImg = __webpack_require__(63);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/tiptap/vuetify/ImagenURL.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/**
 * Example of a custom Image selector
 * Key is to emit a select-file event when a file needs to be added
 */

/* harmony default export */ var ImagenURLvue_type_script_lang_js_ = ({
  name: "ImagenURL",
  components: {
    VImg: VImg["a" /* default */]
  },

  data() {
    // Some public domain images from wikimedia.
    return {
      imageUrl: '',
      imageAlt: ''
    };
  },

  methods: {
    selectImage() {
      this.$emit('select-file', {
        src: this.imageUrl,
        alt: this.imageAlt
      });
    }

  }
});
// CONCATENATED MODULE: ./components/tiptap/vuetify/ImagenURL.vue?vue&type=script&lang=js&
 /* harmony default export */ var vuetify_ImagenURLvue_type_script_lang_js_ = (ImagenURLvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/vuetify-loader/lib/runtime/installComponents.js
var installComponents = __webpack_require__(10);
var installComponents_default = /*#__PURE__*/__webpack_require__.n(installComponents);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VBtn/VBtn.js
var VBtn = __webpack_require__(51);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VDivider/VDivider.js
var VDivider = __webpack_require__(210);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VTextField/VTextField.js
var VTextField = __webpack_require__(201);

// CONCATENATED MODULE: ./components/tiptap/vuetify/ImagenURL.vue



function injectStyles (context) {
  
  var style0 = __webpack_require__(425)
if (style0.__inject__) style0.__inject__(context)

}

/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  vuetify_ImagenURLvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  injectStyles,
  "9151d25c",
  "6e72bd3b"
  
)

/* harmony default export */ var ImagenURL = __webpack_exports__["default"] = (component.exports);

/* vuetify-loader */




installComponents_default()(component, {VBtn: VBtn["a" /* default */],VDivider: VDivider["a" /* default */],VTextField: VTextField["a" /* default */]})


/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(249);

__webpack_require__(250);

__webpack_require__(251);

__webpack_require__(252);

__webpack_require__(253);

__webpack_require__(254);

__webpack_require__(255);

!function (t, e) {
   true ? e(exports, __webpack_require__(1), __webpack_require__(256), __webpack_require__(395), __webpack_require__(257)) : undefined;
}(this, function (t, e, n, o, r) {
  "use strict";

  e = e && e.hasOwnProperty("default") ? e.default : e;

  var i = function (t, e) {
    return (i = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (t, e) {
      t.__proto__ = e;
    } || function (t, e) {
      for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
    })(t, e);
  };

  function a(t, e) {
    function n() {
      this.constructor = t;
    }

    i(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n());
  }

  var s = function () {
    return (s = Object.assign || function (t) {
      for (var e, n = 1, o = arguments.length; n < o; n++) for (var r in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);

      return t;
    }).apply(this, arguments);
  };

  function l(t, e, n, o) {
    var r,
        i = arguments.length,
        a = i < 3 ? e : null === o ? o = Object.getOwnPropertyDescriptor(e, n) : o;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(t, e, n, o);else for (var s = t.length - 1; s >= 0; s--) (r = t[s]) && (a = (i < 3 ? r(a) : i > 3 ? r(e, n, a) : r(e, n)) || a);
    return i > 3 && a && Object.defineProperty(e, n, a), a;
  }

  function c(t, e) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(t, e);
  }

  function p(t, e, n, o) {
    return new (n || (n = Promise))(function (r, i) {
      function a(t) {
        try {
          l(o.next(t));
        } catch (t) {
          i(t);
        }
      }

      function s(t) {
        try {
          l(o.throw(t));
        } catch (t) {
          i(t);
        }
      }

      function l(t) {
        t.done ? r(t.value) : new n(function (e) {
          e(t.value);
        }).then(a, s);
      }

      l((o = o.apply(t, e || [])).next());
    });
  }

  function u(t, e) {
    var n,
        o,
        r,
        i,
        a = {
      label: 0,
      sent: function () {
        if (1 & r[0]) throw r[1];
        return r[1];
      },
      trys: [],
      ops: []
    };
    return i = {
      next: s(0),
      throw: s(1),
      return: s(2)
    }, "function" == typeof Symbol && (i[Symbol.iterator] = function () {
      return this;
    }), i;

    function s(i) {
      return function (s) {
        return function (i) {
          if (n) throw new TypeError("Generator is already executing.");

          for (; a;) try {
            if (n = 1, o && (r = 2 & i[0] ? o.return : i[0] ? o.throw || ((r = o.return) && r.call(o), 0) : o.next) && !(r = r.call(o, i[1])).done) return r;

            switch (o = 0, r && (i = [2 & i[0], r.value]), i[0]) {
              case 0:
              case 1:
                r = i;
                break;

              case 4:
                return a.label++, {
                  value: i[1],
                  done: !1
                };

              case 5:
                a.label++, o = i[1], i = [0];
                continue;

              case 7:
                i = a.ops.pop(), a.trys.pop();
                continue;

              default:
                if (!(r = (r = a.trys).length > 0 && r[r.length - 1]) && (6 === i[0] || 2 === i[0])) {
                  a = 0;
                  continue;
                }

                if (3 === i[0] && (!r || i[1] > r[0] && i[1] < r[3])) {
                  a.label = i[1];
                  break;
                }

                if (6 === i[0] && a.label < r[1]) {
                  a.label = r[1], r = i;
                  break;
                }

                if (r && a.label < r[2]) {
                  a.label = r[2], a.ops.push(i);
                  break;
                }

                r[2] && a.ops.pop(), a.trys.pop();
                continue;
            }

            i = e.call(t, a);
          } catch (t) {
            i = [6, t], o = 0;
          } finally {
            n = r = 0;
          }

          if (5 & i[0]) throw i[1];
          return {
            value: i[0] ? i[1] : void 0,
            done: !0
          };
        }([i, s]);
      };
    }
  }

  function f(t, e) {
    var n = "function" == typeof Symbol && t[Symbol.iterator];
    if (!n) return t;
    var o,
        r,
        i = n.call(t),
        a = [];

    try {
      for (; (void 0 === e || e-- > 0) && !(o = i.next()).done;) a.push(o.value);
    } catch (t) {
      r = {
        error: t
      };
    } finally {
      try {
        o && !o.done && (n = i.return) && n.call(i);
      } finally {
        if (r) throw r.error;
      }
    }

    return a;
  }

  function d() {
    for (var t = [], e = 0; e < arguments.length; e++) t = t.concat(f(arguments[e]));

    return t;
  }

  var h = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

  function v(t, e) {
    return t(e = {
      exports: {}
    }, e.exports), e.exports;
  }

  var m = function (t) {
    return t && t.Math == Math && t;
  },
      g = m("object" == typeof globalThis && globalThis) || m("object" == typeof window && window) || m("object" == typeof self && self) || m("object" == typeof h && h) || Function("return this")(),
      y = function (t) {
    try {
      return !!t();
    } catch (t) {
      return !0;
    }
  },
      b = !y(function () {
    return 7 != Object.defineProperty({}, 1, {
      get: function () {
        return 7;
      }
    })[1];
  }),
      w = {}.propertyIsEnumerable,
      S = Object.getOwnPropertyDescriptor,
      C = {
    f: S && !w.call({
      1: 2
    }, 1) ? function (t) {
      var e = S(this, t);
      return !!e && e.enumerable;
    } : w
  },
      x = function (t, e) {
    return {
      enumerable: !(1 & t),
      configurable: !(2 & t),
      writable: !(4 & t),
      value: e
    };
  },
      k = {}.toString,
      O = function (t) {
    return k.call(t).slice(8, -1);
  },
      A = "".split,
      T = y(function () {
    return !Object("z").propertyIsEnumerable(0);
  }) ? function (t) {
    return "String" == O(t) ? A.call(t, "") : Object(t);
  } : Object,
      E = function (t) {
    if (null == t) throw TypeError("Can't call method on " + t);
    return t;
  },
      M = function (t) {
    return T(E(t));
  },
      N = function (t) {
    return "object" == typeof t ? null !== t : "function" == typeof t;
  },
      R = function (t, e) {
    if (!N(t)) return t;
    var n, o;
    if (e && "function" == typeof (n = t.toString) && !N(o = n.call(t))) return o;
    if ("function" == typeof (n = t.valueOf) && !N(o = n.call(t))) return o;
    if (!e && "function" == typeof (n = t.toString) && !N(o = n.call(t))) return o;
    throw TypeError("Can't convert object to primitive value");
  },
      L = {}.hasOwnProperty,
      I = function (t, e) {
    return L.call(t, e);
  },
      P = g.document,
      D = N(P) && N(P.createElement),
      _ = function (t) {
    return D ? P.createElement(t) : {};
  },
      B = !b && !y(function () {
    return 7 != Object.defineProperty(_("div"), "a", {
      get: function () {
        return 7;
      }
    }).a;
  }),
      V = Object.getOwnPropertyDescriptor,
      z = {
    f: b ? V : function (t, e) {
      if (t = M(t), e = R(e, !0), B) try {
        return V(t, e);
      } catch (t) {}
      if (I(t, e)) return x(!C.f.call(t, e), t[e]);
    }
  },
      $ = function (t) {
    if (!N(t)) throw TypeError(String(t) + " is not an object");
    return t;
  },
      j = Object.defineProperty,
      H = {
    f: b ? j : function (t, e, n) {
      if ($(t), e = R(e, !0), $(n), B) try {
        return j(t, e, n);
      } catch (t) {}
      if ("get" in n || "set" in n) throw TypeError("Accessors not supported");
      return "value" in n && (t[e] = n.value), t;
    }
  },
      F = b ? function (t, e, n) {
    return H.f(t, e, x(1, n));
  } : function (t, e, n) {
    return t[e] = n, t;
  },
      q = function (t, e) {
    try {
      F(g, t, e);
    } catch (n) {
      g[t] = e;
    }

    return e;
  },
      U = g["__core-js_shared__"] || q("__core-js_shared__", {}),
      W = Function.toString;

  "function" != typeof U.inspectSource && (U.inspectSource = function (t) {
    return W.call(t);
  });

  var K,
      J,
      G,
      X = U.inspectSource,
      Y = g.WeakMap,
      Z = "function" == typeof Y && /native code/.test(X(Y)),
      Q = v(function (t) {
    (t.exports = function (t, e) {
      return U[t] || (U[t] = void 0 !== e ? e : {});
    })("versions", []).push({
      version: "3.6.4",
      mode: "global",
      copyright: "© 2020 Denis Pushkarev (zloirock.ru)"
    });
  }),
      tt = 0,
      et = Math.random(),
      nt = function (t) {
    return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++tt + et).toString(36);
  },
      ot = Q("keys"),
      rt = function (t) {
    return ot[t] || (ot[t] = nt(t));
  },
      it = {},
      at = g.WeakMap;

  if (Z) {
    var st = new at(),
        lt = st.get,
        ct = st.has,
        pt = st.set;
    K = function (t, e) {
      return pt.call(st, t, e), e;
    }, J = function (t) {
      return lt.call(st, t) || {};
    }, G = function (t) {
      return ct.call(st, t);
    };
  } else {
    var ut = rt("state");
    it[ut] = !0, K = function (t, e) {
      return F(t, ut, e), e;
    }, J = function (t) {
      return I(t, ut) ? t[ut] : {};
    }, G = function (t) {
      return I(t, ut);
    };
  }

  var ft = {
    set: K,
    get: J,
    has: G,
    enforce: function (t) {
      return G(t) ? J(t) : K(t, {});
    },
    getterFor: function (t) {
      return function (e) {
        var n;
        if (!N(e) || (n = J(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required");
        return n;
      };
    }
  },
      dt = v(function (t) {
    var e = ft.get,
        n = ft.enforce,
        o = String(String).split("String");
    (t.exports = function (t, e, r, i) {
      var a = !!i && !!i.unsafe,
          s = !!i && !!i.enumerable,
          l = !!i && !!i.noTargetGet;
      "function" == typeof r && ("string" != typeof e || I(r, "name") || F(r, "name", e), n(r).source = o.join("string" == typeof e ? e : "")), t !== g ? (a ? !l && t[e] && (s = !0) : delete t[e], s ? t[e] = r : F(t, e, r)) : s ? t[e] = r : q(e, r);
    })(Function.prototype, "toString", function () {
      return "function" == typeof this && e(this).source || X(this);
    });
  }),
      ht = g,
      vt = function (t) {
    return "function" == typeof t ? t : void 0;
  },
      mt = function (t, e) {
    return arguments.length < 2 ? vt(ht[t]) || vt(g[t]) : ht[t] && ht[t][e] || g[t] && g[t][e];
  },
      gt = Math.ceil,
      yt = Math.floor,
      bt = function (t) {
    return isNaN(t = +t) ? 0 : (t > 0 ? yt : gt)(t);
  },
      wt = Math.min,
      St = function (t) {
    return t > 0 ? wt(bt(t), 9007199254740991) : 0;
  },
      Ct = Math.max,
      xt = Math.min,
      kt = function (t, e) {
    var n = bt(t);
    return n < 0 ? Ct(n + e, 0) : xt(n, e);
  },
      Ot = function (t) {
    return function (e, n, o) {
      var r,
          i = M(e),
          a = St(i.length),
          s = kt(o, a);

      if (t && n != n) {
        for (; a > s;) if ((r = i[s++]) != r) return !0;
      } else for (; a > s; s++) if ((t || s in i) && i[s] === n) return t || s || 0;

      return !t && -1;
    };
  },
      At = {
    includes: Ot(!0),
    indexOf: Ot(!1)
  },
      Tt = At.indexOf,
      Et = function (t, e) {
    var n,
        o = M(t),
        r = 0,
        i = [];

    for (n in o) !I(it, n) && I(o, n) && i.push(n);

    for (; e.length > r;) I(o, n = e[r++]) && (~Tt(i, n) || i.push(n));

    return i;
  },
      Mt = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"],
      Nt = Mt.concat("length", "prototype"),
      Rt = {
    f: Object.getOwnPropertyNames || function (t) {
      return Et(t, Nt);
    }
  },
      Lt = {
    f: Object.getOwnPropertySymbols
  },
      It = mt("Reflect", "ownKeys") || function (t) {
    var e = Rt.f($(t)),
        n = Lt.f;
    return n ? e.concat(n(t)) : e;
  },
      Pt = function (t, e) {
    for (var n = It(e), o = H.f, r = z.f, i = 0; i < n.length; i++) {
      var a = n[i];
      I(t, a) || o(t, a, r(e, a));
    }
  },
      Dt = /#|\.prototype\./,
      _t = function (t, e) {
    var n = Vt[Bt(t)];
    return n == $t || n != zt && ("function" == typeof e ? y(e) : !!e);
  },
      Bt = _t.normalize = function (t) {
    return String(t).replace(Dt, ".").toLowerCase();
  },
      Vt = _t.data = {},
      zt = _t.NATIVE = "N",
      $t = _t.POLYFILL = "P",
      jt = _t,
      Ht = z.f,
      Ft = function (t, e) {
    var n,
        o,
        r,
        i,
        a,
        s = t.target,
        l = t.global,
        c = t.stat;
    if (n = l ? g : c ? g[s] || q(s, {}) : (g[s] || {}).prototype) for (o in e) {
      if (i = e[o], r = t.noTargetGet ? (a = Ht(n, o)) && a.value : n[o], !jt(l ? o : s + (c ? "." : "#") + o, t.forced) && void 0 !== r) {
        if (typeof i == typeof r) continue;
        Pt(i, r);
      }

      (t.sham || r && r.sham) && F(i, "sham", !0), dt(n, o, i, t);
    }
  },
      qt = function (t) {
    if ("function" != typeof t) throw TypeError(String(t) + " is not a function");
    return t;
  },
      Ut = function (t) {
    return Object(E(t));
  },
      Wt = Array.isArray || function (t) {
    return "Array" == O(t);
  },
      Kt = !!Object.getOwnPropertySymbols && !y(function () {
    return !String(Symbol());
  }),
      Jt = Kt && !Symbol.sham && "symbol" == typeof Symbol.iterator,
      Gt = Q("wks"),
      Xt = g.Symbol,
      Yt = Jt ? Xt : Xt && Xt.withoutSetter || nt,
      Zt = function (t) {
    return I(Gt, t) || (Kt && I(Xt, t) ? Gt[t] = Xt[t] : Gt[t] = Yt("Symbol." + t)), Gt[t];
  },
      Qt = Zt("species"),
      te = function (t, e) {
    var n;
    return Wt(t) && ("function" != typeof (n = t.constructor) || n !== Array && !Wt(n.prototype) ? N(n) && null === (n = n[Qt]) && (n = void 0) : n = void 0), new (void 0 === n ? Array : n)(0 === e ? 0 : e);
  },
      ee = [].push,
      ne = function (t) {
    var e = 1 == t,
        n = 2 == t,
        o = 3 == t,
        r = 4 == t,
        i = 6 == t,
        a = 5 == t || i;
    return function (s, l, c, p) {
      for (var u, f, d = Ut(s), h = T(d), v = function (t, e, n) {
        if (qt(t), void 0 === e) return t;

        switch (n) {
          case 0:
            return function () {
              return t.call(e);
            };

          case 1:
            return function (n) {
              return t.call(e, n);
            };

          case 2:
            return function (n, o) {
              return t.call(e, n, o);
            };

          case 3:
            return function (n, o, r) {
              return t.call(e, n, o, r);
            };
        }

        return function () {
          return t.apply(e, arguments);
        };
      }(l, c, 3), m = St(h.length), g = 0, y = p || te, b = e ? y(s, m) : n ? y(s, 0) : void 0; m > g; g++) if ((a || g in h) && (f = v(u = h[g], g, d), t)) if (e) b[g] = f;else if (f) switch (t) {
        case 3:
          return !0;

        case 5:
          return u;

        case 6:
          return g;

        case 2:
          ee.call(b, u);
      } else if (r) return !1;

      return i ? -1 : o || r ? r : b;
    };
  },
      oe = {
    forEach: ne(0),
    map: ne(1),
    filter: ne(2),
    some: ne(3),
    every: ne(4),
    find: ne(5),
    findIndex: ne(6)
  },
      re = function (t, e) {
    var n = [][t];
    return !!n && y(function () {
      n.call(null, e || function () {
        throw 1;
      }, 1);
    });
  },
      ie = Object.defineProperty,
      ae = {},
      se = function (t) {
    throw t;
  },
      le = function (t, e) {
    if (I(ae, t)) return ae[t];
    e || (e = {});
    var n = [][t],
        o = !!I(e, "ACCESSORS") && e.ACCESSORS,
        r = I(e, 0) ? e[0] : se,
        i = I(e, 1) ? e[1] : void 0;
    return ae[t] = !!n && !y(function () {
      if (o && !b) return !0;
      var t = {
        length: -1
      };
      o ? ie(t, 1, {
        enumerable: !0,
        get: se
      }) : t[1] = 1, n.call(t, r, i);
    });
  },
      ce = oe.forEach,
      pe = re("forEach"),
      ue = le("forEach"),
      fe = pe && ue ? [].forEach : function (t) {
    return ce(this, t, arguments.length > 1 ? arguments[1] : void 0);
  };

  Ft({
    target: "Array",
    proto: !0,
    forced: [].forEach != fe
  }, {
    forEach: fe
  });

  var de,
      he,
      ve = function (t, e, n) {
    var o = R(e);
    o in t ? H.f(t, o, x(0, n)) : t[o] = n;
  },
      me = mt("navigator", "userAgent") || "",
      ge = g.process,
      ye = ge && ge.versions,
      be = ye && ye.v8;

  be ? he = (de = be.split("."))[0] + de[1] : me && (!(de = me.match(/Edge\/(\d+)/)) || de[1] >= 74) && (de = me.match(/Chrome\/(\d+)/)) && (he = de[1]);

  var we = he && +he,
      Se = Zt("species"),
      Ce = function (t) {
    return we >= 51 || !y(function () {
      var e = [];
      return (e.constructor = {})[Se] = function () {
        return {
          foo: 1
        };
      }, 1 !== e[t](Boolean).foo;
    });
  },
      xe = Ce("slice"),
      ke = le("slice", {
    ACCESSORS: !0,
    0: 0,
    1: 2
  }),
      Oe = Zt("species"),
      Ae = [].slice,
      Te = Math.max;

  Ft({
    target: "Array",
    proto: !0,
    forced: !xe || !ke
  }, {
    slice: function (t, e) {
      var n,
          o,
          r,
          i = M(this),
          a = St(i.length),
          s = kt(t, a),
          l = kt(void 0 === e ? a : e, a);
      if (Wt(i) && ("function" != typeof (n = i.constructor) || n !== Array && !Wt(n.prototype) ? N(n) && null === (n = n[Oe]) && (n = void 0) : n = void 0, n === Array || void 0 === n)) return Ae.call(i, s, l);

      for (o = new (void 0 === n ? Array : n)(Te(l - s, 0)), r = 0; s < l; s++, r++) s in i && ve(o, r, i[s]);

      return o.length = r, o;
    }
  });

  var Ee,
      Me = Object.setPrototypeOf || ("__proto__" in {} ? function () {
    var t,
        e = !1,
        n = {};

    try {
      (t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n, []), e = n instanceof Array;
    } catch (t) {}

    return function (n, o) {
      return $(n), function (t) {
        if (!N(t) && null !== t) throw TypeError("Can't set " + String(t) + " as a prototype");
      }(o), e ? t.call(n, o) : n.__proto__ = o, n;
    };
  }() : void 0),
      Ne = Object.keys || function (t) {
    return Et(t, Mt);
  },
      Re = b ? Object.defineProperties : function (t, e) {
    $(t);

    for (var n, o = Ne(e), r = o.length, i = 0; r > i;) H.f(t, n = o[i++], e[n]);

    return t;
  },
      Le = mt("document", "documentElement"),
      Ie = rt("IE_PROTO"),
      Pe = function () {},
      De = function (t) {
    return "<script>" + t + "<\/script>";
  },
      _e = function () {
    try {
      Ee = document.domain && new ActiveXObject("htmlfile");
    } catch (t) {}

    var t, e;
    _e = Ee ? function (t) {
      t.write(De("")), t.close();
      var e = t.parentWindow.Object;
      return t = null, e;
    }(Ee) : ((e = _("iframe")).style.display = "none", Le.appendChild(e), e.src = String("javascript:"), (t = e.contentWindow.document).open(), t.write(De("document.F=Object")), t.close(), t.F);

    for (var n = Mt.length; n--;) delete _e.prototype[Mt[n]];

    return _e();
  };

  it[Ie] = !0;

  var Be = Object.create || function (t, e) {
    var n;
    return null !== t ? (Pe.prototype = $(t), n = new Pe(), Pe.prototype = null, n[Ie] = t) : n = _e(), void 0 === e ? n : Re(n, e);
  },
      Ve = "[\t\n\v\f\r                　\u2028\u2029\ufeff]",
      ze = RegExp("^" + Ve + Ve + "*"),
      $e = RegExp(Ve + Ve + "*$"),
      je = function (t) {
    return function (e) {
      var n = String(E(e));
      return 1 & t && (n = n.replace(ze, "")), 2 & t && (n = n.replace($e, "")), n;
    };
  },
      He = {
    start: je(1),
    end: je(2),
    trim: je(3)
  },
      Fe = Rt.f,
      qe = z.f,
      Ue = H.f,
      We = He.trim,
      Ke = g.Number,
      Je = Ke.prototype,
      Ge = "Number" == O(Be(Je)),
      Xe = function (t) {
    var e,
        n,
        o,
        r,
        i,
        a,
        s,
        l,
        c = R(t, !1);
    if ("string" == typeof c && c.length > 2) if (43 === (e = (c = We(c)).charCodeAt(0)) || 45 === e) {
      if (88 === (n = c.charCodeAt(2)) || 120 === n) return NaN;
    } else if (48 === e) {
      switch (c.charCodeAt(1)) {
        case 66:
        case 98:
          o = 2, r = 49;
          break;

        case 79:
        case 111:
          o = 8, r = 55;
          break;

        default:
          return +c;
      }

      for (a = (i = c.slice(2)).length, s = 0; s < a; s++) if ((l = i.charCodeAt(s)) < 48 || l > r) return NaN;

      return parseInt(i, o);
    }
    return +c;
  };

  if (jt("Number", !Ke(" 0o1") || !Ke("0b1") || Ke("+0x1"))) {
    for (var Ye, Ze = function (t) {
      var e = arguments.length < 1 ? 0 : t,
          n = this;
      return n instanceof Ze && (Ge ? y(function () {
        Je.valueOf.call(n);
      }) : "Number" != O(n)) ? function (t, e, n) {
        var o, r;
        return Me && "function" == typeof (o = e.constructor) && o !== n && N(r = o.prototype) && r !== n.prototype && Me(t, r), t;
      }(new Ke(Xe(e)), n, Ze) : Xe(e);
    }, Qe = b ? Fe(Ke) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), tn = 0; Qe.length > tn; tn++) I(Ke, Ye = Qe[tn]) && !I(Ze, Ye) && Ue(Ze, Ye, qe(Ke, Ye));

    Ze.prototype = Je, Je.constructor = Ze, dt(g, "Number", Ze);
  }

  var en = {};
  en[Zt("toStringTag")] = "z";
  var nn = "[object z]" === String(en),
      on = Zt("toStringTag"),
      rn = "Arguments" == O(function () {
    return arguments;
  }()),
      an = nn ? O : function (t) {
    var e, n, o;
    return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (n = function (t, e) {
      try {
        return t[e];
      } catch (t) {}
    }(e = Object(t), on)) ? n : rn ? O(e) : "Object" == (o = O(e)) && "function" == typeof e.callee ? "Arguments" : o;
  },
      sn = nn ? {}.toString : function () {
    return "[object " + an(this) + "]";
  };
  nn || dt(Object.prototype, "toString", sn, {
    unsafe: !0
  });

  var ln = function () {
    var t = $(this),
        e = "";
    return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.sticky && (e += "y"), e;
  },
      cn = RegExp.prototype,
      pn = cn.toString,
      un = y(function () {
    return "/a/b" != pn.call({
      source: "a",
      flags: "b"
    });
  }),
      fn = "toString" != pn.name;

  (un || fn) && dt(RegExp.prototype, "toString", function () {
    var t = $(this),
        e = String(t.source),
        n = t.flags;
    return "/" + e + "/" + String(void 0 === n && t instanceof RegExp && !("flags" in cn) ? ln.call(t) : n);
  }, {
    unsafe: !0
  });
  var dn = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };

  for (var hn in dn) {
    var vn = g[hn],
        mn = vn && vn.prototype;
    if (mn && mn.forEach !== fe) try {
      F(mn, "forEach", fe);
    } catch (t) {
      mn.forEach = fe;
    }
  }

  function gn(t) {
    return (gn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t;
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    })(t);
  }

  function yn(t) {
    return function (t) {
      if (Array.isArray(t)) {
        for (var e = 0, n = new Array(t.length); e < t.length; e++) n[e] = t[e];

        return n;
      }
    }(t) || function (t) {
      if (Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t)) return Array.from(t);
    }(t) || function () {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }();
  }

  function bn(t, e, n) {
    (n ? Reflect.getOwnMetadataKeys(e, n) : Reflect.getOwnMetadataKeys(e)).forEach(function (o) {
      var r = n ? Reflect.getOwnMetadata(o, e, n) : Reflect.getOwnMetadata(o, e);
      n ? Reflect.defineMetadata(o, r, t, n) : Reflect.defineMetadata(o, r, t);
    });
  }

  var wn = {
    __proto__: []
  } instanceof Array;

  function Sn(t) {
    return function (e, n, o) {
      var r = "function" == typeof e ? e : e.constructor;
      r.__decorators__ || (r.__decorators__ = []), "number" != typeof o && (o = void 0), r.__decorators__.push(function (e) {
        return t(e, n, o);
      });
    };
  }

  function Cn() {
    for (var t = arguments.length, n = new Array(t), o = 0; o < t; o++) n[o] = arguments[o];

    return e.extend({
      mixins: n
    });
  }

  var xn = ["data", "beforeCreate", "created", "beforeMount", "mounted", "beforeDestroy", "destroyed", "beforeUpdate", "updated", "activated", "deactivated", "render", "errorCaptured", "serverPrefetch"];

  function kn(t) {
    var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    n.name = n.name || t._componentTag || t.name;
    var o = t.prototype;
    Object.getOwnPropertyNames(o).forEach(function (t) {
      if ("constructor" !== t) if (xn.indexOf(t) > -1) n[t] = o[t];else {
        var e = Object.getOwnPropertyDescriptor(o, t);
        void 0 !== e.value ? "function" == typeof e.value ? (n.methods || (n.methods = {}))[t] = e.value : (n.mixins || (n.mixins = [])).push({
          data: function () {
            return function (t, e, n) {
              return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
              }) : t[e] = n, t;
            }({}, t, e.value);
          }
        }) : (e.get || e.set) && ((n.computed || (n.computed = {}))[t] = {
          get: e.get,
          set: e.set
        });
      }
    }), (n.mixins || (n.mixins = [])).push({
      data: function () {
        return function (t, e) {
          var n = e.prototype._init;

          e.prototype._init = function () {
            var e = this,
                n = Object.getOwnPropertyNames(t);
            if (t.$options.props) for (var o in t.$options.props) t.hasOwnProperty(o) || n.push(o);
            n.forEach(function (n) {
              "_" !== n.charAt(0) && Object.defineProperty(e, n, {
                get: function () {
                  return t[n];
                },
                set: function (e) {
                  t[n] = e;
                },
                configurable: !0
              });
            });
          };

          var o = new e();
          e.prototype._init = n;
          var r = {};
          return Object.keys(o).forEach(function (t) {
            void 0 !== o[t] && (r[t] = o[t]);
          }), r;
        }(this, t);
      }
    });
    var r = t.__decorators__;
    r && (r.forEach(function (t) {
      return t(n);
    }), delete t.__decorators__);
    var i,
        a,
        s = Object.getPrototypeOf(t.prototype),
        l = s instanceof e ? s.constructor : e,
        c = l.extend(n);
    return function (t, e, n) {
      Object.getOwnPropertyNames(e).forEach(function (o) {
        if (!On[o]) {
          var r = Object.getOwnPropertyDescriptor(t, o);

          if (!r || r.configurable) {
            var i,
                a,
                s = Object.getOwnPropertyDescriptor(e, o);

            if (!wn) {
              if ("cid" === o) return;
              var l = Object.getOwnPropertyDescriptor(n, o);
              if (i = s.value, a = gn(i), null != i && ("object" === a || "function" === a) && l && l.value === s.value) return;
            }

            Object.defineProperty(t, o, s);
          }
        }
      });
    }(c, t, l), "undefined" != typeof Reflect && Reflect.defineMetadata && Reflect.getOwnMetadataKeys && (bn(i = c, a = t), Object.getOwnPropertyNames(a.prototype).forEach(function (t) {
      bn(i.prototype, a.prototype, t);
    }), Object.getOwnPropertyNames(a).forEach(function (t) {
      bn(i, a, t);
    })), c;
  }

  var On = {
    prototype: !0,
    arguments: !0,
    callee: !0,
    caller: !0
  };

  function An(t) {
    return "function" == typeof t ? kn(t) : function (e) {
      return kn(e, t);
    };
  }

  An.registerHooks = function (t) {
    xn.push.apply(xn, yn(t));
  };

  var Tn = "undefined" != typeof Reflect && void 0 !== Reflect.getMetadata;

  function En(t) {
    return void 0 === t && (t = {}), function (e, n) {
      !function (t, e, n) {
        Tn && (Array.isArray(t) || "function" == typeof t || void 0 !== t.type || (t.type = Reflect.getMetadata("design:type", e, n)));
      }(t, e, n), Sn(function (e, n) {
        (e.props || (e.props = {}))[n] = t;
      })(e, n);
    };
  }

  function Mn(t, e) {
    void 0 === e && (e = {});
    var n = e.deep,
        o = void 0 !== n && n,
        r = e.immediate,
        i = void 0 !== r && r;
    return Sn(function (e, n) {
      "object" != typeof e.watch && (e.watch = Object.create(null));
      var r = e.watch;
      "object" != typeof r[t] || Array.isArray(r[t]) ? void 0 === r[t] && (r[t] = []) : r[t] = [r[t]], r[t].push({
        handler: n,
        deep: o,
        immediate: i
      });
    });
  }

  var Nn = {
    color: "grey lighten-4",
    flat: !0,
    dense: !0
  },
      Rn = function () {
    function t(t) {
      this.text = t;
    }

    return t.prototype.toString = function () {
      return this.text;
    }, t;
  }(),
      Ln = H.f,
      In = Function.prototype,
      Pn = In.toString,
      Dn = /^\s*function ([^ (]*)/;

  !b || "name" in In || Ln(In, "name", {
    configurable: !0,
    get: function () {
      try {
        return Pn.call(this).match(Dn)[1];
      } catch (t) {
        return "";
      }
    }
  });

  var _n,
      Bn = function () {
    function t(t) {
      this.name = t;
    }

    return t.prototype.toString = function () {
      return this.name;
    }, t;
  }(),
      Vn = "input",
      zn = "init",
      $n = "blur",
      jn = "focus",
      Hn = {
    VALUE: "value",
    EXTENSIONS: "extensions",
    TOOLBAR_ATTRIBUTES: "toolbarAttributes",
    EDITOR_PROPERTIES: "editorProperties",
    NATIVE_EXTENSIONS: "nativeExtensions",
    PLACEHOLDER: "placeholder",
    CARD_PROPS: "cardProps",
    OUTPUT_FORMAT: "outputFormat",
    TYPE: "type",
    MIN_HEIGHT: "minHeight",
    MAX_HEIGHT: "maxHeight",
    DISABLED: "disabled"
  };

  !function (t) {
    t.card = "card", t.inline = "inline";
  }(_n || (_n = {}));
  var Fn = new (function () {
    function t() {}

    return t.prototype.warn = function (t) {
      console.warn("tiptap-vuetify: " + t);
    }, t.prototype.error = function (t) {
      console.error("tiptap-vuetify: " + t);
    }, t;
  }())(),
      qn = {
    EDITOR: "editor",
    OPTIONS: "options",
    CONTEXT: "context",
    DARK: "dark",
    DISABLED: "disabled"
  };

  var Un = function (t, e, n, o, r, i, a, s, l, c) {
    "boolean" != typeof a && (l = s, s = a, a = !1);
    var p,
        u = "function" == typeof n ? n.options : n;
    if (t && t.render && (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), o && (u._scopeId = o), i ? (p = function (t) {
      (t = t || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) || "undefined" == typeof __VUE_SSR_CONTEXT__ || (t = __VUE_SSR_CONTEXT__), e && e.call(this, l(t)), t && t._registeredComponents && t._registeredComponents.add(i);
    }, u._ssrRegister = p) : e && (p = a ? function () {
      e.call(this, c(this.$root.$options.shadowRoot));
    } : function (t) {
      e.call(this, s(t));
    }), p) if (u.functional) {
      var f = u.render;

      u.render = function (t, e) {
        return p.call(e), f(t, e);
      };
    } else {
      var d = u.beforeCreate;
      u.beforeCreate = d ? [].concat(d, p) : [p];
    }
    return n;
  };

  var Wn = Un({
    render: function () {
      var t = this,
          e = t.$createElement,
          n = t._self._c || e;
      return n("v-tooltip", {
        attrs: {
          top: ""
        },
        scopedSlots: t._u([{
          key: "activator",
          fn: function (e) {
            var o = e.on;
            return [n("v-btn", t._g({
              class: {
                "tiptap-vuetify-editor__action-render-btn": !0,
                "v-btn--active": t.$props[t.PROPS.OPTIONS].isActive(t.$props[t.PROPS.CONTEXT])
              },
              attrs: {
                disabled: t.disabled,
                dark: t.$props[t.PROPS.DARK],
                small: "",
                icon: ""
              },
              on: {
                click: function (e) {
                  return t.options.onClick({
                    context: t.$props[t.PROPS.CONTEXT],
                    editor: t.$props[t.PROPS.EDITOR]
                  });
                }
              }
            }, o), [n(t.isTextIcon ? "b" : t.isVuetifyIcon ? "v-icon" : null, {
              tag: "component",
              staticClass: "tiptap-vuetify-editor__btn-icon"
            }, [t._v("\n        " + t._s(t.buttonIcon) + "\n      ")])], 1)];
          }
        }])
      }, [t._v(" "), [t._v(t._s(t.tooltipText))]], 2);
    },
    staticRenderFns: []
  }, void 0, function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.PROPS = qn, e;
    }

    var r, i, s, p, u;
    return a(e, t), Object.defineProperty(e.prototype, "buttonIcon", {
      get: function () {
        var t = this[qn.OPTIONS].icons[this.$tiptapVuetify.iconsGroup];
        return t || (Fn.warn("No icon was provided in extension options."), "No icon");
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "isTextIcon", {
      get: function () {
        return this.buttonIcon instanceof Rn;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "isVuetifyIcon", {
      get: function () {
        return this.buttonIcon instanceof Bn;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "tooltipText", {
      get: function () {
        var t = this.$props[qn.OPTIONS].tooltip;
        return "function" == typeof t ? t(this.$props[qn.CONTEXT], this.$props[qn.OPTIONS]) : t;
      },
      enumerable: !0,
      configurable: !0
    }), r = qn.DISABLED, i = qn.EDITOR, s = qn.OPTIONS, p = qn.CONTEXT, u = qn.DARK, l([En({
      type: Boolean,
      default: !1
    }), c("design:type", Boolean)], e.prototype, r, void 0), l([En({
      type: Object,
      required: !0
    }), c("design:type", n.Editor)], e.prototype, i, void 0), l([En({
      type: Object,
      required: !0
    }), c("design:type", Object)], e.prototype, s, void 0), l([En({
      type: Object,
      required: !0
    }), c("design:type", Object)], e.prototype, p, void 0), l([En({
      type: Boolean,
      default: !1
    }), c("design:type", Boolean)], e.prototype, u, void 0), e = l([An({
      components: {
        VTooltip: o.VTooltip,
        VBtn: o.VBtn,
        VIcon: o.VIcon
      }
    })], e);
  }(e), void 0, !1, void 0, void 0, void 0),
      Kn = function () {
    return function (t) {
      var e = t.nativeExtensionName;
      this.options = s({
        onClick: function (n) {
          n.context.commands[e](t.onClickOptions);
        },
        isActive: function (n) {
          var o = n.isActive;
          return !!o[e] && o[e](t.isActiveOptions);
        }
      }, t);
    };
  }(),
      Jn = {
    EDITOR: "editor",
    ACTIONS: "actions",
    CONTEXT: "context",
    DARK: "dark",
    DISABLED: "disabled"
  };

  var Gn = Un({
    render: function () {
      var t = this,
          e = t.$createElement,
          n = t._self._c || e;
      return n("div", [t._l(t.$props[t.PROPS.ACTIONS], function (e, o) {
        return [t.isBtn(e) ? n("action-btn", {
          key: "action-button-" + o,
          attrs: {
            options: e.render.options,
            context: t.$props[t.PROPS.CONTEXT],
            editor: t.$props[t.PROPS.EDITOR],
            dark: t.$props[t.PROPS.DARK],
            disabled: t.$props[t.PROPS.DISABLED]
          }
        }) : t._e()];
      })], 2);
    },
    staticRenderFns: []
  }, void 0, function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.PROPS = Jn, e;
    }

    var o, r, i, s, p;
    return a(e, t), e.prototype.isBtn = function (t) {
      return t.render instanceof Kn;
    }, o = Jn.EDITOR, r = Jn.DISABLED, i = Jn.ACTIONS, s = Jn.CONTEXT, p = Jn.DARK, l([En({
      type: Object,
      required: !0
    }), c("design:type", n.Editor)], e.prototype, o, void 0), l([En({
      type: Boolean,
      default: !1
    }), c("design:type", Boolean)], e.prototype, r, void 0), l([En({
      type: Array,
      default: function () {
        return [];
      }
    }), c("design:type", Array)], e.prototype, i, void 0), l([En({
      type: Object
    }), c("design:type", Object)], e.prototype, s, void 0), l([En({
      type: Boolean,
      default: !1
    }), c("design:type", Boolean)], e.prototype, p, void 0), e = l([An({
      components: {
        "action-btn": Wn
      }
    })], e);
  }(e), void 0, !1, void 0, void 0, void 0);

  var Xn = Un({
    render: function () {
      var t = this,
          e = t.$createElement,
          n = t._self._c || e;
      return n("div", {
        staticClass: "tiptap-vuetify-editor__toolbar"
      }, [n("editor-menu-bar", {
        attrs: {
          editor: t.editor
        },
        scopedSlots: t._u([{
          key: "default",
          fn: function (e) {
            return [t._t("default", [n("v-toolbar", t._b({}, "v-toolbar", Object.assign({}, t.toolbarConfig, t.toolbarAttributes), !1), [n("actions-render", {
              attrs: {
                actions: t.actions,
                context: e,
                editor: t.editor,
                disabled: t.disabled
              }
            })], 1)], {
              isActive: e.isActive,
              commands: e.commands
            })];
          }
        }], null, !0)
      })], 1);
    },
    staticRenderFns: []
  }, void 0, function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.toolbarConfig = Nn, e;
    }

    return a(e, t), l([En({
      type: Boolean,
      default: !1
    }), c("design:type", Boolean)], e.prototype, "disabled", void 0), l([En({
      type: Object,
      required: !0
    }), c("design:type", n.Editor)], e.prototype, "editor", void 0), l([En({
      type: Array,
      default: function () {
        return [];
      }
    }), c("design:type", Array)], e.prototype, "actions", void 0), l([En({
      type: [Array, Object],
      default: function () {
        return {};
      }
    }), c("design:type", Object)], e.prototype, "toolbarAttributes", void 0), e = l([An({
      components: {
        ActionsRender: Gn,
        EditorMenuBar: n.EditorMenuBar,
        VToolbar: o.VToolbar
      }
    })], e);
  }(e), void 0, !1, void 0, void 0, void 0),
      Yn = function (t) {
    return function (e, n, o, r) {
      qt(n);
      var i = Ut(e),
          a = T(i),
          s = St(i.length),
          l = t ? s - 1 : 0,
          c = t ? -1 : 1;
      if (o < 2) for (;;) {
        if (l in a) {
          r = a[l], l += c;
          break;
        }

        if (l += c, t ? l < 0 : s <= l) throw TypeError("Reduce of empty array with no initial value");
      }

      for (; t ? l >= 0 : s > l; l += c) l in a && (r = n(r, a[l], l, i));

      return r;
    };
  },
      Zn = {
    left: Yn(!1),
    right: Yn(!0)
  }.left,
      Qn = re("reduce"),
      to = le("reduce", {
    1: 0
  });

  function eo(t, e) {
    return RegExp(t, e);
  }

  Ft({
    target: "Array",
    proto: !0,
    forced: !Qn || !to
  }, {
    reduce: function (t) {
      return Zn(this, t, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  var no,
      oo,
      ro = {
    UNSUPPORTED_Y: y(function () {
      var t = eo("a", "y");
      return t.lastIndex = 2, null != t.exec("abcd");
    }),
    BROKEN_CARET: y(function () {
      var t = eo("^r", "gy");
      return t.lastIndex = 2, null != t.exec("str");
    })
  },
      io = RegExp.prototype.exec,
      ao = String.prototype.replace,
      so = io,
      lo = (no = /a/, oo = /b*/g, io.call(no, "a"), io.call(oo, "a"), 0 !== no.lastIndex || 0 !== oo.lastIndex),
      co = ro.UNSUPPORTED_Y || ro.BROKEN_CARET,
      po = void 0 !== /()??/.exec("")[1];
  (lo || po || co) && (so = function (t) {
    var e,
        n,
        o,
        r,
        i = this,
        a = co && i.sticky,
        s = ln.call(i),
        l = i.source,
        c = 0,
        p = t;
    return a && (-1 === (s = s.replace("y", "")).indexOf("g") && (s += "g"), p = String(t).slice(i.lastIndex), i.lastIndex > 0 && (!i.multiline || i.multiline && "\n" !== t[i.lastIndex - 1]) && (l = "(?: " + l + ")", p = " " + p, c++), n = new RegExp("^(?:" + l + ")", s)), po && (n = new RegExp("^" + l + "$(?!\\s)", s)), lo && (e = i.lastIndex), o = io.call(a ? n : i, p), a ? o ? (o.input = o.input.slice(c), o[0] = o[0].slice(c), o.index = i.lastIndex, i.lastIndex += o[0].length) : i.lastIndex = 0 : lo && o && (i.lastIndex = i.global ? o.index + o[0].length : e), po && o && o.length > 1 && ao.call(o[0], n, function () {
      for (r = 1; r < arguments.length - 2; r++) void 0 === arguments[r] && (o[r] = void 0);
    }), o;
  });
  var uo = so;
  Ft({
    target: "RegExp",
    proto: !0,
    forced: /./.exec !== uo
  }, {
    exec: uo
  });

  var fo = Zt("species"),
      ho = !y(function () {
    var t = /./;
    return t.exec = function () {
      var t = [];
      return t.groups = {
        a: "7"
      }, t;
    }, "7" !== "".replace(t, "$<a>");
  }),
      vo = "$0" === "a".replace(/./, "$0"),
      mo = Zt("replace"),
      go = !!/./[mo] && "" === /./[mo]("a", "$0"),
      yo = !y(function () {
    var t = /(?:)/,
        e = t.exec;

    t.exec = function () {
      return e.apply(this, arguments);
    };

    var n = "ab".split(t);
    return 2 !== n.length || "a" !== n[0] || "b" !== n[1];
  }),
      bo = Zt("match"),
      wo = function (t) {
    var e;
    return N(t) && (void 0 !== (e = t[bo]) ? !!e : "RegExp" == O(t));
  },
      So = Zt("species"),
      Co = function (t) {
    return function (e, n) {
      var o,
          r,
          i = String(E(e)),
          a = bt(n),
          s = i.length;
      return a < 0 || a >= s ? t ? "" : void 0 : (o = i.charCodeAt(a)) < 55296 || o > 56319 || a + 1 === s || (r = i.charCodeAt(a + 1)) < 56320 || r > 57343 ? t ? i.charAt(a) : o : t ? i.slice(a, a + 2) : r - 56320 + (o - 55296 << 10) + 65536;
    };
  },
      xo = {
    codeAt: Co(!1),
    charAt: Co(!0)
  }.charAt,
      ko = function (t, e, n) {
    return e + (n ? xo(t, e).length : 1);
  },
      Oo = function (t, e) {
    var n = t.exec;

    if ("function" == typeof n) {
      var o = n.call(t, e);
      if ("object" != typeof o) throw TypeError("RegExp exec method returned something other than an Object or null");
      return o;
    }

    if ("RegExp" !== O(t)) throw TypeError("RegExp#exec called on incompatible receiver");
    return uo.call(t, e);
  },
      Ao = [].push,
      To = Math.min,
      Eo = !y(function () {
    return !RegExp(4294967295, "y");
  });

  !function (t, e, n, o) {
    var r = Zt(t),
        i = !y(function () {
      var e = {};
      return e[r] = function () {
        return 7;
      }, 7 != ""[t](e);
    }),
        a = i && !y(function () {
      var e = !1,
          n = /a/;
      return "split" === t && ((n = {}).constructor = {}, n.constructor[fo] = function () {
        return n;
      }, n.flags = "", n[r] = /./[r]), n.exec = function () {
        return e = !0, null;
      }, n[r](""), !e;
    });

    if (!i || !a || "replace" === t && (!ho || !vo || go) || "split" === t && !yo) {
      var s = /./[r],
          l = n(r, ""[t], function (t, e, n, o, r) {
        return e.exec === uo ? i && !r ? {
          done: !0,
          value: s.call(e, n, o)
        } : {
          done: !0,
          value: t.call(n, e, o)
        } : {
          done: !1
        };
      }, {
        REPLACE_KEEPS_$0: vo,
        REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: go
      }),
          c = l[0],
          p = l[1];
      dt(String.prototype, t, c), dt(RegExp.prototype, r, 2 == e ? function (t, e) {
        return p.call(t, this, e);
      } : function (t) {
        return p.call(t, this);
      });
    }

    o && F(RegExp.prototype[r], "sham", !0);
  }("split", 2, function (t, e, n) {
    var o;
    return o = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function (t, n) {
      var o = String(E(this)),
          r = void 0 === n ? 4294967295 : n >>> 0;
      if (0 === r) return [];
      if (void 0 === t) return [o];
      if (!wo(t)) return e.call(o, t, r);

      for (var i, a, s, l = [], c = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""), p = 0, u = new RegExp(t.source, c + "g"); (i = uo.call(u, o)) && !((a = u.lastIndex) > p && (l.push(o.slice(p, i.index)), i.length > 1 && i.index < o.length && Ao.apply(l, i.slice(1)), s = i[0].length, p = a, l.length >= r));) u.lastIndex === i.index && u.lastIndex++;

      return p === o.length ? !s && u.test("") || l.push("") : l.push(o.slice(p)), l.length > r ? l.slice(0, r) : l;
    } : "0".split(void 0, 0).length ? function (t, n) {
      return void 0 === t && 0 === n ? [] : e.call(this, t, n);
    } : e, [function (e, n) {
      var r = E(this),
          i = null == e ? void 0 : e[t];
      return void 0 !== i ? i.call(e, r, n) : o.call(String(r), e, n);
    }, function (t, r) {
      var i = n(o, t, this, r, o !== e);
      if (i.done) return i.value;

      var a = $(t),
          s = String(this),
          l = function (t, e) {
        var n,
            o = $(t).constructor;
        return void 0 === o || null == (n = $(o)[So]) ? e : qt(n);
      }(a, RegExp),
          c = a.unicode,
          p = (a.ignoreCase ? "i" : "") + (a.multiline ? "m" : "") + (a.unicode ? "u" : "") + (Eo ? "y" : "g"),
          u = new l(Eo ? a : "^(?:" + a.source + ")", p),
          f = void 0 === r ? 4294967295 : r >>> 0;

      if (0 === f) return [];
      if (0 === s.length) return null === Oo(u, s) ? [s] : [];

      for (var d = 0, h = 0, v = []; h < s.length;) {
        u.lastIndex = Eo ? h : 0;
        var m,
            g = Oo(u, Eo ? s : s.slice(h));
        if (null === g || (m = To(St(u.lastIndex + (Eo ? 0 : h)), s.length)) === d) h = ko(s, h, c);else {
          if (v.push(s.slice(d, h)), v.length === f) return v;

          for (var y = 1; y <= g.length - 1; y++) if (v.push(g[y]), v.length === f) return v;

          h = d = m;
        }
      }

      return v.push(s.slice(d)), v;
    }];
  }, !Eo);
  var Mo = "en",
      No = {
    en: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "Block quote"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "Bold"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "Bulleted list"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "Code"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "Code block"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "Undo"
            },
            redo: {
              tooltip: "Redo"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "Horizontal line"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "Italic"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "Ordered list"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "Paragraph"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "Strike"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "Underline"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return t.level + " level header";
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "Change Link"
            },
            notActive: {
              tooltip: "Add Link"
            }
          },
          window: {
            title: "Link control",
            form: {
              hrefLabel: "URL"
            },
            buttons: {
              close: "Close",
              remove: "Remove",
              apply: "Apply"
            }
          }
        },
        Image: {
          buttons: {
            tooltip: "Image"
          },
          window: {
            title: "Add Image",
            form: {
              sourceLink: "Image URL",
              altText: "Alternative Text",
              addImage: "Add Image"
            },
            imageUpload: {
              instruction: "Choose a file(s) or drag it here."
            },
            buttons: {
              close: "Close",
              apply: "Apply"
            }
          }
        },
        TodoList: {
          buttons: {
            todoList: {
              tooltip: "To Do List"
            }
          }
        }
      }
    },
    ru: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "Блок цитаты"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "Жирный"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "Маркированный список"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "Код"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "Блок кода"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "Назад"
            },
            redo: {
              tooltip: "Вперед"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "Горизонтальная линия"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "Курсивный"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "Упорядоченный список"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "Параграф"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "Перечерктнутый"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "Подчерктнутый"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return "Заголовок " + t.level + " уровня";
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "Изменить ссылку"
            },
            notActive: {
              tooltip: "Добавить ссылку"
            }
          },
          window: {
            title: "Управление ссылкой",
            form: {
              hrefLabel: "Href"
            },
            buttons: {
              close: "Закрыть",
              remove: "Удалить",
              apply: "Применить"
            }
          }
        },
        Image: {
          buttons: {
            tooltip: "Картинка"
          },
          window: {
            title: "Добавить картинку",
            form: {
              sourceLink: "Ссылка на картинку"
            },
            buttons: {
              close: "Закрыть",
              apply: "Применить"
            }
          }
        }
      }
    },
    es: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "Cita en bloque"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "Texto en negrita"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "Lista no ordenada"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "Código"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "Bloque de código"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "Deshacer"
            },
            redo: {
              tooltip: "Rehacer"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "Línea horizontal"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "Texto en cursiva"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "Lista ordenada"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "Párrafo"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "Tachar texto"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "Subrayar texto"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return "Nivel de encabezado " + t.level;
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "Actualizar enlace"
            },
            notActive: {
              tooltip: "Añadir enlace"
            }
          },
          window: {
            title: "Control de enlace",
            form: {
              hrefLabel: "Href"
            },
            buttons: {
              close: "Cerrar",
              remove: "Eliminar",
              apply: "Aplicar"
            }
          }
        },
        Image: {
          buttons: {
            tooltip: "Imagen"
          },
          window: {
            title: "Agregar Imagen",
            form: {
              sourceLink: "URL de la Imagen"
            },
            buttons: {
              close: "Cerrar",
              apply: "Aplicar"
            }
          }
        }
      }
    },
    pl: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "Blok cytatu"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "Pogrubienie"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "Lista punktów"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "Kod"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "Blok kodu"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "Cofnij"
            },
            redo: {
              tooltip: "Ponów"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "Linia pozioma"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "Kursywa"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "Lista numerowana"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "Paragraf"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "Przekreślenie"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "Podkreślenie"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return "Nagłówek " + t.level;
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "Zaktualizuj odnośnik"
            },
            notActive: {
              tooltip: "Dodaj odnośnik"
            }
          },
          window: {
            title: "Odnośnik",
            form: {
              hrefLabel: "Adres URL"
            },
            buttons: {
              close: "Zamknij",
              remove: "Usuń",
              apply: "Zastosuj"
            }
          }
        },
        Image: {
          buttons: {
            tooltip: "Obrazek"
          },
          window: {
            title: "Dodaj obrazek",
            form: {
              sourceLink: "Adres URL obrazka"
            },
            buttons: {
              close: "Zamknij",
              apply: "Zastosuj"
            }
          }
        }
      }
    },
    fr: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "Bloc de citation"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "Gras"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "Liste à puce"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "Code"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "Bloc de code"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "Annuler"
            },
            redo: {
              tooltip: "Rétablir"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "Ligne horizontale"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "Italique"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "Liste ordonnée"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "Paragraphe"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "Barré"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "Souligné"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return "Titre de niveau " + t.level;
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "Mise à jour du lien"
            },
            notActive: {
              tooltip: "Ajouter un lien"
            }
          },
          window: {
            title: "Ajout ou mise à jour d'un lien",
            form: {
              hrefLabel: "URL"
            },
            buttons: {
              close: "Fermer",
              remove: "Retirer",
              apply: "Appliquer"
            }
          }
        },
        Image: {
          buttons: {
            tooltip: "Image"
          },
          window: {
            title: "Ajouter une Image",
            form: {
              sourceLink: "Image URL",
              altText: "Texte alternatif",
              addImage: "Ajouter une image"
            },
            imageUpload: {
              instruction: "Sélectionnez un fichier(s), ou glisser-déposser içi"
            },
            buttons: {
              close: "Fermer",
              apply: "Appliquer"
            }
          }
        },
        TodoList: {
          buttons: {
            todoList: {
              tooltip: "Liste de choses à faire"
            }
          }
        }
      }
    },
    uk: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "Блок цитати"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "Жирний"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "Маркований список"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "Код"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "Блок кода"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "Назад"
            },
            redo: {
              tooltip: "Вперед"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "Горизонтальна лінія"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "Курсивний"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "Упорядкований список"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "Параграф"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "Перекреслений"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "Підкреслений"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return "Заголовок " + t.level + " рівня";
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "Змінити посилання"
            },
            notActive: {
              tooltip: "Додати посилання"
            }
          },
          window: {
            title: "Управління посиланням",
            form: {
              hrefLabel: "Href"
            },
            buttons: {
              close: "Закрити",
              remove: "Вилучити",
              apply: "Застосувати"
            }
          }
        }
      }
    },
    ptbr: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "Bloco de citação"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "Negrito"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "Lista de pontos"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "Código"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "Bloco de código"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "Desfazer"
            },
            redo: {
              tooltip: "Refazer"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "Linha horizontal"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "Itálico"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "Lista ordenada"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "Parágrafo"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "Riscado"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "Sublinhado"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return "cabeçalho nível " + t.level;
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "Mudar Link"
            },
            notActive: {
              tooltip: "Adicionar Link"
            }
          },
          window: {
            title: "Configurar link",
            form: {
              hrefLabel: "link"
            },
            buttons: {
              close: "Fechar",
              remove: "Remover",
              apply: "Aplicar"
            }
          }
        }
      }
    },
    tr: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "Alıntı"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "Kalın"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "Liste"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "Kod"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "Kod Bloğu"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "Geri"
            },
            redo: {
              tooltip: "İleri"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "Yatay çizgi"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "İtalik"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "Numaralı Liste"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "Paragraf"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "Üstü Çizili"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "Altı Çizili"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return t.level + " Başlık";
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "Link'i Düzenle"
            },
            notActive: {
              tooltip: "Link Ekle"
            }
          },
          window: {
            title: "Link Kontrol",
            form: {
              hrefLabel: "Adres"
            },
            buttons: {
              close: "Kapat",
              remove: "Sil",
              apply: "Uygula"
            }
          }
        }
      }
    },
    he: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "ציטוט"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "מודגש"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "רשימה לא ממוספרת"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "קוד"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "בלוק קוד"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "ביטול"
            },
            redo: {
              tooltip: "בצע שוב"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "קו אופקי"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "מוטה"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "רשימה ממוספרת"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "פיסקה"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "קו אמצע"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "קו תחתון"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return t.level + " כותרת בגודל";
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "שנה קישור"
            },
            notActive: {
              tooltip: "הוסף קישור"
            }
          },
          window: {
            title: "ניהול קישור",
            form: {
              hrefLabel: "כתובת"
            },
            buttons: {
              close: "סגור",
              remove: "הסר",
              apply: "החל"
            }
          }
        }
      }
    },
    nl: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "Citaatblok"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "Vet"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "Opsomming tekens"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "Code"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "Code blok"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "Ongedaan maken"
            },
            redo: {
              tooltip: "Opnieuw uitvoeren"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "Horizontale lijn"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "Cursief"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "Genummerde lijst"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "Paragraaf"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "Doorhalen"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "Onderstrepen"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return "Kop " + t.level;
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "Link wijzigigen"
            },
            notActive: {
              tooltip: "Link invoegen"
            }
          },
          window: {
            title: "Link controle",
            form: {
              hrefLabel: "Href"
            },
            buttons: {
              close: "Sluiten",
              remove: "Verwijderen",
              apply: "Toepassen"
            }
          }
        },
        Image: {
          buttons: {
            tooltip: "Afbeelding"
          },
          window: {
            title: "Afbeelding toevoegen",
            form: {
              sourceLink: "Afbeelding URL",
              altText: "Alternatieve Tekst"
            },
            imageUpload: {
              instruction: "Kies een of meerdere bestanden of sleep ze hiernaartoe."
            },
            buttons: {
              close: "Sluiten",
              apply: "Toepassen"
            }
          }
        }
      }
    },
    ja: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "引用"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "太字"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "箇条書き"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "コード"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "コードブロック"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "元に戻す"
            },
            redo: {
              tooltip: "やり直し"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "平行線"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "斜体"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "番号付きリスト"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "段落"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "取り消し線"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "下線"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return "見出し " + t.level;
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "リンク変更"
            },
            notActive: {
              tooltip: "リンク追加"
            }
          },
          window: {
            title: "リンクの編集",
            form: {
              hrefLabel: "リンク"
            },
            buttons: {
              close: "閉じる",
              remove: "削除",
              apply: "適用"
            }
          }
        },
        Image: {
          buttons: {
            tooltip: "画像"
          },
          window: {
            title: "画像を追加する",
            form: {
              sourceLink: "画像URL"
            },
            buttons: {
              close: "閉じる",
              apply: "適用"
            }
          }
        }
      }
    },
    de: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "Block Zitat"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "Fett"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "Aufzählungsliste"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "Code"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "Code Abschnitt"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "Rückgängig"
            },
            redo: {
              tooltip: "Wiederherstellen"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "Horizontale Linie"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "Kursiv"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "Geordnete Liste"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "Paragraph"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "Durchgestrichen"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "Unterstreichen"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return t.level + " level Überschrift";
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "Link ändern"
            },
            notActive: {
              tooltip: "Link hinzufügen"
            }
          },
          window: {
            title: "Link Kontrolle",
            form: {
              hrefLabel: "Href"
            },
            buttons: {
              close: "Schließen",
              remove: "Entfernen",
              apply: "Übernehmen"
            }
          }
        },
        Image: {
          buttons: {
            tooltip: "Bild"
          },
          window: {
            title: "Bild hinzufügen",
            form: {
              sourceLink: "Bild URL"
            },
            buttons: {
              close: "Schließen",
              apply: "Übernehmen"
            }
          }
        }
      }
    },
    ko: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "인용"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "굵게"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "글머리 기호"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "코드"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "코드 블록"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "입력 취소"
            },
            redo: {
              tooltip: "입력 다시 실행"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "수평선"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "기울임꼴"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "번호 매기기"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "단락"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "취소선"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "밑줄"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return "헤딩 " + t.level;
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "링크 변경"
            },
            notActive: {
              tooltip: "링크 추가"
            }
          },
          window: {
            title: "링크 편집",
            form: {
              hrefLabel: "링크"
            },
            buttons: {
              close: "닫기",
              remove: "삭제",
              apply: "적용"
            }
          }
        },
        Image: {
          buttons: {
            tooltip: "이미지"
          },
          window: {
            title: "이미지 추가",
            form: {
              sourceLink: "이미지 URL"
            },
            buttons: {
              close: "닫기",
              apply: "적용"
            }
          }
        }
      }
    },
    zh: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "引用"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "粗体"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "项目符号"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "代码"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "代码块"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "撤销"
            },
            redo: {
              tooltip: "重做"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "水平线"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "斜体"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "数字编号"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "段落"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "删除线"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "下划线"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return t.level + " 级标题 ";
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "改变链接"
            },
            notActive: {
              tooltip: "增加链接"
            }
          },
          window: {
            title: "增加链接",
            form: {
              hrefLabel: "链接"
            },
            buttons: {
              close: "关闭",
              remove: "移除",
              apply: "使用"
            }
          }
        },
        Image: {
          buttons: {
            tooltip: "图片"
          },
          window: {
            title: "添加图片",
            form: {
              sourceLink: "图片链接"
            },
            buttons: {
              close: "关闭",
              apply: "使用"
            }
          }
        }
      }
    },
    fa: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "نقل قول"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "درشت"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "لیست بولت"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "کد"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "بلوک کد"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "بازگشت"
            },
            redo: {
              tooltip: "مجدد"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "خط افقی"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "ایتالیک"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "لیست مرتب شده"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "پاراگراف"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "خط زدن"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "خط زیرین"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return t.level + " سطح هدر";
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "عوض کردن لینک"
            },
            notActive: {
              tooltip: "اضافه لینک"
            }
          },
          window: {
            title: "کنترل لینک",
            form: {
              hrefLabel: "لینک"
            },
            buttons: {
              close: "بستن",
              remove: "حذف",
              apply: "اعمال"
            }
          }
        },
        Image: {
          buttons: {
            tooltip: "عکس"
          },
          window: {
            title: "اضافه عکس",
            or: "OR",
            form: {
              sourceLink: "لینک عکس"
            },
            buttons: {
              close: "بستن",
              apply: "اعمال"
            }
          }
        },
        TodoList: {
          buttons: {
            todoList: {
              tooltip: "لیست کارها"
            }
          }
        }
      }
    },
    sv: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "Blockcitat"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "Fet"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "Punktlista"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "Kod"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "Kodblock"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "Ångra"
            },
            redo: {
              tooltip: "Gör om"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "Horisontell linje"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "Kursiv"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "Nummerlista"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "Stycke"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "Genomstruken"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "Understruken"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return "Rubriknivå " + t.level;
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "Ändra länk"
            },
            notActive: {
              tooltip: "Lägg till länk"
            }
          },
          window: {
            title: "Länkinställningar",
            form: {
              hrefLabel: "Href"
            },
            buttons: {
              close: "Stäng",
              remove: "Ta bort",
              apply: "Applicera"
            }
          }
        },
        Image: {
          buttons: {
            tooltip: "Bild"
          },
          window: {
            title: "Lägg till bild",
            or: "ELLER",
            form: {
              sourceLink: "Bild-URL"
            },
            buttons: {
              close: "Stäng",
              apply: "Applicera"
            }
          }
        },
        TodoList: {
          buttons: {
            todoList: {
              tooltip: "Att göra-lista"
            }
          }
        }
      }
    },
    cs: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "Bloková citace"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "Tučně"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "Bodový seznam"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "Kód"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "Blok kódu"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "Zpět"
            },
            redo: {
              tooltip: "Vpřed"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "Horizontální oddělovač"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "Kurzíva"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "Číslovaný seznam"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "Odstavec"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "Přeškrtnutě"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "Podrženě"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return t.level + ". úroveň nadpisu";
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "Změnit odkaz"
            },
            notActive: {
              tooltip: "Přidat odkaz"
            }
          },
          window: {
            title: "Správa odkazu",
            form: {
              hrefLabel: "Odkaz"
            },
            buttons: {
              close: "Zavřít",
              remove: "Odebrat",
              apply: "Použít"
            }
          }
        },
        Image: {
          buttons: {
            tooltip: "Obrázek"
          },
          window: {
            title: "Přidat obrázek",
            form: {
              sourceLink: "Adresa obrázku",
              altText: "Alternativní text",
              addImage: "Přidat obrázek"
            },
            imageUpload: {
              instruction: "Vyberte soubor(y) nebo je(j) přetáhněte sem."
            },
            buttons: {
              close: "Zavřít",
              apply: "Použít"
            }
          }
        },
        TodoList: {
          buttons: {
            todoList: {
              tooltip: "Seznam TODO"
            }
          }
        }
      }
    },
    it: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "Citazione"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "Grassetto"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "Elenco puntato"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "Codice"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "Blocco codice"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "Annulla"
            },
            redo: {
              tooltip: "Ripristina"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "Linea orizzontale"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "Corsivo"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "Elenco numerato"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "Paragrafo"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "Barrato"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "Sottolineato"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return t.level + " livello intestazione";
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "Modifica collegamento"
            },
            notActive: {
              tooltip: "Aggiungi collegamento"
            }
          },
          window: {
            title: "Gestione collegamento",
            form: {
              hrefLabel: "Indirizzo"
            },
            buttons: {
              close: "Chiudi",
              remove: "Rimuovi",
              apply: "Applica"
            }
          }
        },
        Image: {
          buttons: {
            tooltip: "Immagine"
          },
          window: {
            title: "Aggiungi Immagine",
            form: {
              sourceLink: "Indirizzo Immagine",
              altText: "Testo Alternativo",
              addImage: "Aggiungi Immagine"
            },
            imageUpload: {
              instruction: "Seleziona file o trascinalo(i) qui."
            },
            buttons: {
              close: "Chiudi",
              apply: "Applica"
            }
          }
        },
        TodoList: {
          buttons: {
            todoList: {
              tooltip: "Cose da fare"
            }
          }
        }
      }
    },
    el: {
      extensions: {
        Blockquote: {
          buttons: {
            blockquote: {
              tooltip: "Παράθεση"
            }
          }
        },
        Bold: {
          buttons: {
            bold: {
              tooltip: "Έντονη γραφή"
            }
          }
        },
        BulletList: {
          buttons: {
            bulletList: {
              tooltip: "Λίστα με κουκκίδες"
            }
          }
        },
        Code: {
          buttons: {
            code: {
              tooltip: "Κώδικας"
            }
          }
        },
        CodeBlock: {
          buttons: {
            codeBlock: {
              tooltip: "Μπλοκ κώδικα"
            }
          }
        },
        History: {
          buttons: {
            undo: {
              tooltip: "Αναίρεση"
            },
            redo: {
              tooltip: "Ακύρωση αναίρεσης"
            }
          }
        },
        HorizontalRule: {
          buttons: {
            horizontalRule: {
              tooltip: "Οριζόντια γραμμή"
            }
          }
        },
        Italic: {
          buttons: {
            italic: {
              tooltip: "Πλάγια γραφή"
            }
          }
        },
        OrderedList: {
          buttons: {
            orderedList: {
              tooltip: "Λίστα με αρίθμηση"
            }
          }
        },
        Paragraph: {
          buttons: {
            paragraph: {
              tooltip: "Παράγραφος"
            }
          }
        },
        Strike: {
          buttons: {
            strike: {
              tooltip: "Επιγράμμιση"
            }
          }
        },
        Underline: {
          buttons: {
            underline: {
              tooltip: "Υπογράμμιση"
            }
          }
        },
        Heading: {
          buttons: {
            heading: {
              tooltip: function (t) {
                return t.level + " επίπεδο κεφαλίδας";
              }
            }
          }
        },
        Link: {
          buttons: {
            isActive: {
              tooltip: "Αλλαγή συνδέσμου"
            },
            notActive: {
              tooltip: "Προσθήκη συνδέσμου"
            }
          },
          window: {
            title: "Διαχείριση συνδέσμου",
            form: {
              hrefLabel: "Διεύθυνση"
            },
            buttons: {
              close: "Κλείσιμο",
              remove: "Αφαίρεση",
              apply: "Εφαρμογή"
            }
          }
        },
        Image: {
          buttons: {
            tooltip: "Εικόνα"
          },
          window: {
            title: "Προσθήκη εικόνας",
            form: {
              sourceLink: "Διεύθυνση εικόνας",
              altText: "Εναλλακτικό κείμενο",
              addImage: "Προσθήκη εικόνας"
            },
            imageUpload: {
              instruction: "Επιλέξτε ένα αρχείο ή σύρετε το εδώ."
            },
            buttons: {
              close: "Κλείσιμο",
              apply: "Εφαρμογή"
            }
          }
        },
        TodoList: {
          buttons: {
            todoList: {
              tooltip: "Λίστα εκκρεμοτήτων"
            }
          }
        }
      }
    }
  };

  function Ro(t, e, n) {
    void 0 === n && (n = null);
    var o = n || dd.vuetifyLang || Mo;
    No[o] || (Fn.warn('The current language "' + o + '" is not yet available. Using language "' + Mo + '" by default. Contribution to github is welcome.'), o = Mo);
    var r,
        i = No[o];

    try {
      if (void 0 === (r = t.split(".").reduce(function (t, e) {
        return t[e];
      }, i))) throw new Error(t + " is undefined.");
    } catch (n) {
      return Fn.warn('Cannot get translation "' + t + '" for language "' + o + '". Fallback "' + Mo + '" is used instead. Contribution to github is welcome.'), Ro(t, e, Mo);
    }

    return r instanceof Function ? r(e) : r;
  }

  var Lo = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "$i18n", {
      get: function () {
        return {
          getMsg: Ro
        };
      },
      enumerable: !0,
      configurable: !0
    }), e = l([An], e);
  }(e),
      Io = "undefined" != typeof window && "undefined" != typeof document && "undefined" != typeof navigator,
      Po = function () {
    for (var t = ["Edge", "Trident", "Firefox"], e = 0; e < t.length; e += 1) if (Io && navigator.userAgent.indexOf(t[e]) >= 0) return 1;

    return 0;
  }();

  var Do = Io && window.Promise ? function (t) {
    var e = !1;
    return function () {
      e || (e = !0, window.Promise.resolve().then(function () {
        e = !1, t();
      }));
    };
  } : function (t) {
    var e = !1;
    return function () {
      e || (e = !0, setTimeout(function () {
        e = !1, t();
      }, Po));
    };
  };

  function _o(t) {
    return t && "[object Function]" === {}.toString.call(t);
  }

  function Bo(t, e) {
    if (1 !== t.nodeType) return [];
    var n = t.ownerDocument.defaultView.getComputedStyle(t, null);
    return e ? n[e] : n;
  }

  function Vo(t) {
    return "HTML" === t.nodeName ? t : t.parentNode || t.host;
  }

  function zo(t) {
    if (!t) return document.body;

    switch (t.nodeName) {
      case "HTML":
      case "BODY":
        return t.ownerDocument.body;

      case "#document":
        return t.body;
    }

    var e = Bo(t),
        n = e.overflow,
        o = e.overflowX,
        r = e.overflowY;
    return /(auto|scroll|overlay)/.test(n + r + o) ? t : zo(Vo(t));
  }

  function $o(t) {
    return t && t.referenceNode ? t.referenceNode : t;
  }

  var jo = Io && !(!window.MSInputMethodContext || !document.documentMode),
      Ho = Io && /MSIE 10/.test(navigator.userAgent);

  function Fo(t) {
    return 11 === t ? jo : 10 === t ? Ho : jo || Ho;
  }

  function qo(t) {
    if (!t) return document.documentElement;

    for (var e = Fo(10) ? document.body : null, n = t.offsetParent || null; n === e && t.nextElementSibling;) n = (t = t.nextElementSibling).offsetParent;

    var o = n && n.nodeName;
    return o && "BODY" !== o && "HTML" !== o ? -1 !== ["TH", "TD", "TABLE"].indexOf(n.nodeName) && "static" === Bo(n, "position") ? qo(n) : n : t ? t.ownerDocument.documentElement : document.documentElement;
  }

  function Uo(t) {
    return null !== t.parentNode ? Uo(t.parentNode) : t;
  }

  function Wo(t, e) {
    if (!(t && t.nodeType && e && e.nodeType)) return document.documentElement;
    var n = t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_FOLLOWING,
        o = n ? t : e,
        r = n ? e : t,
        i = document.createRange();
    i.setStart(o, 0), i.setEnd(r, 0);
    var a,
        s,
        l = i.commonAncestorContainer;
    if (t !== l && e !== l || o.contains(r)) return "BODY" === (s = (a = l).nodeName) || "HTML" !== s && qo(a.firstElementChild) !== a ? qo(l) : l;
    var c = Uo(t);
    return c.host ? Wo(c.host, e) : Wo(t, Uo(e).host);
  }

  function Ko(t) {
    var e = "top" === (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "top") ? "scrollTop" : "scrollLeft",
        n = t.nodeName;

    if ("BODY" === n || "HTML" === n) {
      var o = t.ownerDocument.documentElement;
      return (t.ownerDocument.scrollingElement || o)[e];
    }

    return t[e];
  }

  function Jo(t, e) {
    var n = "x" === e ? "Left" : "Top",
        o = "Left" === n ? "Right" : "Bottom";
    return parseFloat(t["border" + n + "Width"]) + parseFloat(t["border" + o + "Width"]);
  }

  function Go(t, e, n, o) {
    return Math.max(e["offset" + t], e["scroll" + t], n["client" + t], n["offset" + t], n["scroll" + t], Fo(10) ? parseInt(n["offset" + t]) + parseInt(o["margin" + ("Height" === t ? "Top" : "Left")]) + parseInt(o["margin" + ("Height" === t ? "Bottom" : "Right")]) : 0);
  }

  function Xo(t) {
    var e = t.body,
        n = t.documentElement,
        o = Fo(10) && getComputedStyle(n);
    return {
      height: Go("Height", e, n, o),
      width: Go("Width", e, n, o)
    };
  }

  var Yo = function (t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  },
      Zo = function () {
    function t(t, e) {
      for (var n = 0; n < e.length; n++) {
        var o = e[n];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
      }
    }

    return function (e, n, o) {
      return n && t(e.prototype, n), o && t(e, o), e;
    };
  }(),
      Qo = function (t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : t[e] = n, t;
  },
      tr = Object.assign || function (t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];

      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }

    return t;
  };

  function er(t) {
    return tr({}, t, {
      right: t.left + t.width,
      bottom: t.top + t.height
    });
  }

  function nr(t) {
    var e = {};

    try {
      if (Fo(10)) {
        e = t.getBoundingClientRect();
        var n = Ko(t, "top"),
            o = Ko(t, "left");
        e.top += n, e.left += o, e.bottom += n, e.right += o;
      } else e = t.getBoundingClientRect();
    } catch (t) {}

    var r = {
      left: e.left,
      top: e.top,
      width: e.right - e.left,
      height: e.bottom - e.top
    },
        i = "HTML" === t.nodeName ? Xo(t.ownerDocument) : {},
        a = i.width || t.clientWidth || r.width,
        s = i.height || t.clientHeight || r.height,
        l = t.offsetWidth - a,
        c = t.offsetHeight - s;

    if (l || c) {
      var p = Bo(t);
      l -= Jo(p, "x"), c -= Jo(p, "y"), r.width -= l, r.height -= c;
    }

    return er(r);
  }

  function or(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
        o = Fo(10),
        r = "HTML" === e.nodeName,
        i = nr(t),
        a = nr(e),
        s = zo(t),
        l = Bo(e),
        c = parseFloat(l.borderTopWidth),
        p = parseFloat(l.borderLeftWidth);
    n && r && (a.top = Math.max(a.top, 0), a.left = Math.max(a.left, 0));
    var u = er({
      top: i.top - a.top - c,
      left: i.left - a.left - p,
      width: i.width,
      height: i.height
    });

    if (u.marginTop = 0, u.marginLeft = 0, !o && r) {
      var f = parseFloat(l.marginTop),
          d = parseFloat(l.marginLeft);
      u.top -= c - f, u.bottom -= c - f, u.left -= p - d, u.right -= p - d, u.marginTop = f, u.marginLeft = d;
    }

    return (o && !n ? e.contains(s) : e === s && "BODY" !== s.nodeName) && (u = function (t, e) {
      var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
          o = Ko(e, "top"),
          r = Ko(e, "left"),
          i = n ? -1 : 1;
      return t.top += o * i, t.bottom += o * i, t.left += r * i, t.right += r * i, t;
    }(u, e)), u;
  }

  function rr(t) {
    if (!t || !t.parentElement || Fo()) return document.documentElement;

    for (var e = t.parentElement; e && "none" === Bo(e, "transform");) e = e.parentElement;

    return e || document.documentElement;
  }

  function ir(t, e, n, o) {
    var r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
        i = {
      top: 0,
      left: 0
    },
        a = r ? rr(t) : Wo(t, $o(e));
    if ("viewport" === o) i = function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
          n = t.ownerDocument.documentElement,
          o = or(t, n),
          r = Math.max(n.clientWidth, window.innerWidth || 0),
          i = Math.max(n.clientHeight, window.innerHeight || 0),
          a = e ? 0 : Ko(n),
          s = e ? 0 : Ko(n, "left");
      return er({
        top: a - o.top + o.marginTop,
        left: s - o.left + o.marginLeft,
        width: r,
        height: i
      });
    }(a, r);else {
      var s = void 0;
      "scrollParent" === o ? "BODY" === (s = zo(Vo(e))).nodeName && (s = t.ownerDocument.documentElement) : s = "window" === o ? t.ownerDocument.documentElement : o;
      var l = or(s, a, r);
      if ("HTML" !== s.nodeName || function t(e) {
        var n = e.nodeName;
        if ("BODY" === n || "HTML" === n) return !1;
        if ("fixed" === Bo(e, "position")) return !0;
        var o = Vo(e);
        return !!o && t(o);
      }(a)) i = l;else {
        var c = Xo(t.ownerDocument),
            p = c.height,
            u = c.width;
        i.top += l.top - l.marginTop, i.bottom = p + l.top, i.left += l.left - l.marginLeft, i.right = u + l.left;
      }
    }
    var f = "number" == typeof (n = n || 0);
    return i.left += f ? n : n.left || 0, i.top += f ? n : n.top || 0, i.right -= f ? n : n.right || 0, i.bottom -= f ? n : n.bottom || 0, i;
  }

  function ar(t, e, n, o, r) {
    var i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
    if (-1 === t.indexOf("auto")) return t;
    var a = ir(n, o, i, r),
        s = {
      top: {
        width: a.width,
        height: e.top - a.top
      },
      right: {
        width: a.right - e.right,
        height: a.height
      },
      bottom: {
        width: a.width,
        height: a.bottom - e.bottom
      },
      left: {
        width: e.left - a.left,
        height: a.height
      }
    },
        l = Object.keys(s).map(function (t) {
      return tr({
        key: t
      }, s[t], {
        area: (e = s[t], e.width * e.height)
      });
      var e;
    }).sort(function (t, e) {
      return e.area - t.area;
    }),
        c = l.filter(function (t) {
      var e = t.width,
          o = t.height;
      return e >= n.clientWidth && o >= n.clientHeight;
    }),
        p = c.length > 0 ? c[0].key : l[0].key,
        u = t.split("-")[1];
    return p + (u ? "-" + u : "");
  }

  function sr(t, e, n) {
    var o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    return or(n, o ? rr(e) : Wo(e, $o(n)), o);
  }

  function lr(t) {
    var e = t.ownerDocument.defaultView.getComputedStyle(t),
        n = parseFloat(e.marginTop || 0) + parseFloat(e.marginBottom || 0),
        o = parseFloat(e.marginLeft || 0) + parseFloat(e.marginRight || 0);
    return {
      width: t.offsetWidth + o,
      height: t.offsetHeight + n
    };
  }

  function cr(t) {
    var e = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    return t.replace(/left|right|bottom|top/g, function (t) {
      return e[t];
    });
  }

  function pr(t, e, n) {
    n = n.split("-")[0];
    var o = lr(t),
        r = {
      width: o.width,
      height: o.height
    },
        i = -1 !== ["right", "left"].indexOf(n),
        a = i ? "top" : "left",
        s = i ? "left" : "top",
        l = i ? "height" : "width",
        c = i ? "width" : "height";
    return r[a] = e[a] + e[l] / 2 - o[l] / 2, r[s] = n === s ? e[s] - o[c] : e[cr(s)], r;
  }

  function ur(t, e) {
    return Array.prototype.find ? t.find(e) : t.filter(e)[0];
  }

  function fr(t, e, n) {
    return (void 0 === n ? t : t.slice(0, function (t, e, n) {
      if (Array.prototype.findIndex) return t.findIndex(function (t) {
        return t[e] === n;
      });
      var o = ur(t, function (t) {
        return t[e] === n;
      });
      return t.indexOf(o);
    }(t, "name", n))).forEach(function (t) {
      t.function && console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
      var n = t.function || t.fn;
      t.enabled && _o(n) && (e.offsets.popper = er(e.offsets.popper), e.offsets.reference = er(e.offsets.reference), e = n(e, t));
    }), e;
  }

  function dr(t, e) {
    return t.some(function (t) {
      var n = t.name;
      return t.enabled && n === e;
    });
  }

  function hr(t) {
    for (var e = [!1, "ms", "Webkit", "Moz", "O"], n = t.charAt(0).toUpperCase() + t.slice(1), o = 0; o < e.length; o++) {
      var r = e[o],
          i = r ? "" + r + n : t;
      if (void 0 !== document.body.style[i]) return i;
    }

    return null;
  }

  function vr(t) {
    var e = t.ownerDocument;
    return e ? e.defaultView : window;
  }

  function mr(t, e, n, o) {
    n.updateBound = o, vr(t).addEventListener("resize", n.updateBound, {
      passive: !0
    });
    var r = zo(t);
    return function t(e, n, o, r) {
      var i = "BODY" === e.nodeName,
          a = i ? e.ownerDocument.defaultView : e;
      a.addEventListener(n, o, {
        passive: !0
      }), i || t(zo(a.parentNode), n, o, r), r.push(a);
    }(r, "scroll", n.updateBound, n.scrollParents), n.scrollElement = r, n.eventsEnabled = !0, n;
  }

  function gr() {
    var t, e;
    this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = (t = this.reference, e = this.state, vr(t).removeEventListener("resize", e.updateBound), e.scrollParents.forEach(function (t) {
      t.removeEventListener("scroll", e.updateBound);
    }), e.updateBound = null, e.scrollParents = [], e.scrollElement = null, e.eventsEnabled = !1, e));
  }

  function yr(t) {
    return "" !== t && !isNaN(parseFloat(t)) && isFinite(t);
  }

  function br(t, e) {
    Object.keys(e).forEach(function (n) {
      var o = "";
      -1 !== ["width", "height", "top", "right", "bottom", "left"].indexOf(n) && yr(e[n]) && (o = "px"), t.style[n] = e[n] + o;
    });
  }

  var wr = Io && /Firefox/i.test(navigator.userAgent);

  function Sr(t, e, n) {
    var o = ur(t, function (t) {
      return t.name === e;
    }),
        r = !!o && t.some(function (t) {
      return t.name === n && t.enabled && t.order < o.order;
    });

    if (!r) {
      var i = "`" + e + "`",
          a = "`" + n + "`";
      console.warn(a + " modifier is required by " + i + " modifier in order to work, be sure to include it before " + i + "!");
    }

    return r;
  }

  var Cr = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"],
      xr = Cr.slice(3);

  function kr(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
        n = xr.indexOf(t),
        o = xr.slice(n + 1).concat(xr.slice(0, n));
    return e ? o.reverse() : o;
  }

  var Or = {
    FLIP: "flip",
    CLOCKWISE: "clockwise",
    COUNTERCLOCKWISE: "counterclockwise"
  };

  function Ar(t, e, n, o) {
    var r = [0, 0],
        i = -1 !== ["right", "left"].indexOf(o),
        a = t.split(/(\+|\-)/).map(function (t) {
      return t.trim();
    }),
        s = a.indexOf(ur(a, function (t) {
      return -1 !== t.search(/,|\s/);
    }));
    a[s] && -1 === a[s].indexOf(",") && console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
    var l = /\s*,\s*|\s+/,
        c = -1 !== s ? [a.slice(0, s).concat([a[s].split(l)[0]]), [a[s].split(l)[1]].concat(a.slice(s + 1))] : [a];
    return (c = c.map(function (t, o) {
      var r = (1 === o ? !i : i) ? "height" : "width",
          a = !1;
      return t.reduce(function (t, e) {
        return "" === t[t.length - 1] && -1 !== ["+", "-"].indexOf(e) ? (t[t.length - 1] = e, a = !0, t) : a ? (t[t.length - 1] += e, a = !1, t) : t.concat(e);
      }, []).map(function (t) {
        return function (t, e, n, o) {
          var r = t.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),
              i = +r[1],
              a = r[2];
          if (!i) return t;

          if (0 === a.indexOf("%")) {
            var s = void 0;

            switch (a) {
              case "%p":
                s = n;
                break;

              case "%":
              case "%r":
              default:
                s = o;
            }

            return er(s)[e] / 100 * i;
          }

          if ("vh" === a || "vw" === a) return ("vh" === a ? Math.max(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0)) / 100 * i;
          return i;
        }(t, r, e, n);
      });
    })).forEach(function (t, e) {
      t.forEach(function (n, o) {
        yr(n) && (r[e] += n * ("-" === t[o - 1] ? -1 : 1));
      });
    }), r;
  }

  var Tr = {
    placement: "bottom",
    positionFixed: !1,
    eventsEnabled: !0,
    removeOnDestroy: !1,
    onCreate: function () {},
    onUpdate: function () {},
    modifiers: {
      shift: {
        order: 100,
        enabled: !0,
        fn: function (t) {
          var e = t.placement,
              n = e.split("-")[0],
              o = e.split("-")[1];

          if (o) {
            var r = t.offsets,
                i = r.reference,
                a = r.popper,
                s = -1 !== ["bottom", "top"].indexOf(n),
                l = s ? "left" : "top",
                c = s ? "width" : "height",
                p = {
              start: Qo({}, l, i[l]),
              end: Qo({}, l, i[l] + i[c] - a[c])
            };
            t.offsets.popper = tr({}, a, p[o]);
          }

          return t;
        }
      },
      offset: {
        order: 200,
        enabled: !0,
        fn: function (t, e) {
          var n = e.offset,
              o = t.placement,
              r = t.offsets,
              i = r.popper,
              a = r.reference,
              s = o.split("-")[0],
              l = void 0;
          return l = yr(+n) ? [+n, 0] : Ar(n, i, a, s), "left" === s ? (i.top += l[0], i.left -= l[1]) : "right" === s ? (i.top += l[0], i.left += l[1]) : "top" === s ? (i.left += l[0], i.top -= l[1]) : "bottom" === s && (i.left += l[0], i.top += l[1]), t.popper = i, t;
        },
        offset: 0
      },
      preventOverflow: {
        order: 300,
        enabled: !0,
        fn: function (t, e) {
          var n = e.boundariesElement || qo(t.instance.popper);
          t.instance.reference === n && (n = qo(n));
          var o = hr("transform"),
              r = t.instance.popper.style,
              i = r.top,
              a = r.left,
              s = r[o];
          r.top = "", r.left = "", r[o] = "";
          var l = ir(t.instance.popper, t.instance.reference, e.padding, n, t.positionFixed);
          r.top = i, r.left = a, r[o] = s, e.boundaries = l;
          var c = e.priority,
              p = t.offsets.popper,
              u = {
            primary: function (t) {
              var n = p[t];
              return p[t] < l[t] && !e.escapeWithReference && (n = Math.max(p[t], l[t])), Qo({}, t, n);
            },
            secondary: function (t) {
              var n = "right" === t ? "left" : "top",
                  o = p[n];
              return p[t] > l[t] && !e.escapeWithReference && (o = Math.min(p[n], l[t] - ("right" === t ? p.width : p.height))), Qo({}, n, o);
            }
          };
          return c.forEach(function (t) {
            var e = -1 !== ["left", "top"].indexOf(t) ? "primary" : "secondary";
            p = tr({}, p, u[e](t));
          }), t.offsets.popper = p, t;
        },
        priority: ["left", "right", "top", "bottom"],
        padding: 5,
        boundariesElement: "scrollParent"
      },
      keepTogether: {
        order: 400,
        enabled: !0,
        fn: function (t) {
          var e = t.offsets,
              n = e.popper,
              o = e.reference,
              r = t.placement.split("-")[0],
              i = Math.floor,
              a = -1 !== ["top", "bottom"].indexOf(r),
              s = a ? "right" : "bottom",
              l = a ? "left" : "top",
              c = a ? "width" : "height";
          return n[s] < i(o[l]) && (t.offsets.popper[l] = i(o[l]) - n[c]), n[l] > i(o[s]) && (t.offsets.popper[l] = i(o[s])), t;
        }
      },
      arrow: {
        order: 500,
        enabled: !0,
        fn: function (t, e) {
          var n;
          if (!Sr(t.instance.modifiers, "arrow", "keepTogether")) return t;
          var o = e.element;

          if ("string" == typeof o) {
            if (!(o = t.instance.popper.querySelector(o))) return t;
          } else if (!t.instance.popper.contains(o)) return console.warn("WARNING: `arrow.element` must be child of its popper element!"), t;

          var r = t.placement.split("-")[0],
              i = t.offsets,
              a = i.popper,
              s = i.reference,
              l = -1 !== ["left", "right"].indexOf(r),
              c = l ? "height" : "width",
              p = l ? "Top" : "Left",
              u = p.toLowerCase(),
              f = l ? "left" : "top",
              d = l ? "bottom" : "right",
              h = lr(o)[c];
          s[d] - h < a[u] && (t.offsets.popper[u] -= a[u] - (s[d] - h)), s[u] + h > a[d] && (t.offsets.popper[u] += s[u] + h - a[d]), t.offsets.popper = er(t.offsets.popper);
          var v = s[u] + s[c] / 2 - h / 2,
              m = Bo(t.instance.popper),
              g = parseFloat(m["margin" + p]),
              y = parseFloat(m["border" + p + "Width"]),
              b = v - t.offsets.popper[u] - g - y;
          return b = Math.max(Math.min(a[c] - h, b), 0), t.arrowElement = o, t.offsets.arrow = (Qo(n = {}, u, Math.round(b)), Qo(n, f, ""), n), t;
        },
        element: "[x-arrow]"
      },
      flip: {
        order: 600,
        enabled: !0,
        fn: function (t, e) {
          if (dr(t.instance.modifiers, "inner")) return t;
          if (t.flipped && t.placement === t.originalPlacement) return t;
          var n = ir(t.instance.popper, t.instance.reference, e.padding, e.boundariesElement, t.positionFixed),
              o = t.placement.split("-")[0],
              r = cr(o),
              i = t.placement.split("-")[1] || "",
              a = [];

          switch (e.behavior) {
            case Or.FLIP:
              a = [o, r];
              break;

            case Or.CLOCKWISE:
              a = kr(o);
              break;

            case Or.COUNTERCLOCKWISE:
              a = kr(o, !0);
              break;

            default:
              a = e.behavior;
          }

          return a.forEach(function (s, l) {
            if (o !== s || a.length === l + 1) return t;
            o = t.placement.split("-")[0], r = cr(o);
            var c = t.offsets.popper,
                p = t.offsets.reference,
                u = Math.floor,
                f = "left" === o && u(c.right) > u(p.left) || "right" === o && u(c.left) < u(p.right) || "top" === o && u(c.bottom) > u(p.top) || "bottom" === o && u(c.top) < u(p.bottom),
                d = u(c.left) < u(n.left),
                h = u(c.right) > u(n.right),
                v = u(c.top) < u(n.top),
                m = u(c.bottom) > u(n.bottom),
                g = "left" === o && d || "right" === o && h || "top" === o && v || "bottom" === o && m,
                y = -1 !== ["top", "bottom"].indexOf(o),
                b = !!e.flipVariations && (y && "start" === i && d || y && "end" === i && h || !y && "start" === i && v || !y && "end" === i && m),
                w = !!e.flipVariationsByContent && (y && "start" === i && h || y && "end" === i && d || !y && "start" === i && m || !y && "end" === i && v),
                S = b || w;
            (f || g || S) && (t.flipped = !0, (f || g) && (o = a[l + 1]), S && (i = function (t) {
              return "end" === t ? "start" : "start" === t ? "end" : t;
            }(i)), t.placement = o + (i ? "-" + i : ""), t.offsets.popper = tr({}, t.offsets.popper, pr(t.instance.popper, t.offsets.reference, t.placement)), t = fr(t.instance.modifiers, t, "flip"));
          }), t;
        },
        behavior: "flip",
        padding: 5,
        boundariesElement: "viewport",
        flipVariations: !1,
        flipVariationsByContent: !1
      },
      inner: {
        order: 700,
        enabled: !1,
        fn: function (t) {
          var e = t.placement,
              n = e.split("-")[0],
              o = t.offsets,
              r = o.popper,
              i = o.reference,
              a = -1 !== ["left", "right"].indexOf(n),
              s = -1 === ["top", "left"].indexOf(n);
          return r[a ? "left" : "top"] = i[n] - (s ? r[a ? "width" : "height"] : 0), t.placement = cr(e), t.offsets.popper = er(r), t;
        }
      },
      hide: {
        order: 800,
        enabled: !0,
        fn: function (t) {
          if (!Sr(t.instance.modifiers, "hide", "preventOverflow")) return t;
          var e = t.offsets.reference,
              n = ur(t.instance.modifiers, function (t) {
            return "preventOverflow" === t.name;
          }).boundaries;

          if (e.bottom < n.top || e.left > n.right || e.top > n.bottom || e.right < n.left) {
            if (!0 === t.hide) return t;
            t.hide = !0, t.attributes["x-out-of-boundaries"] = "";
          } else {
            if (!1 === t.hide) return t;
            t.hide = !1, t.attributes["x-out-of-boundaries"] = !1;
          }

          return t;
        }
      },
      computeStyle: {
        order: 850,
        enabled: !0,
        fn: function (t, e) {
          var n = e.x,
              o = e.y,
              r = t.offsets.popper,
              i = ur(t.instance.modifiers, function (t) {
            return "applyStyle" === t.name;
          }).gpuAcceleration;
          void 0 !== i && console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");

          var a = void 0 !== i ? i : e.gpuAcceleration,
              s = qo(t.instance.popper),
              l = nr(s),
              c = {
            position: r.position
          },
              p = function (t, e) {
            var n = t.offsets,
                o = n.popper,
                r = n.reference,
                i = Math.round,
                a = Math.floor,
                s = function (t) {
              return t;
            },
                l = i(r.width),
                c = i(o.width),
                p = -1 !== ["left", "right"].indexOf(t.placement),
                u = -1 !== t.placement.indexOf("-"),
                f = e ? p || u || l % 2 == c % 2 ? i : a : s,
                d = e ? i : s;

            return {
              left: f(l % 2 == 1 && c % 2 == 1 && !u && e ? o.left - 1 : o.left),
              top: d(o.top),
              bottom: d(o.bottom),
              right: f(o.right)
            };
          }(t, window.devicePixelRatio < 2 || !wr),
              u = "bottom" === n ? "top" : "bottom",
              f = "right" === o ? "left" : "right",
              d = hr("transform"),
              h = void 0,
              v = void 0;

          if (v = "bottom" === u ? "HTML" === s.nodeName ? -s.clientHeight + p.bottom : -l.height + p.bottom : p.top, h = "right" === f ? "HTML" === s.nodeName ? -s.clientWidth + p.right : -l.width + p.right : p.left, a && d) c[d] = "translate3d(" + h + "px, " + v + "px, 0)", c[u] = 0, c[f] = 0, c.willChange = "transform";else {
            var m = "bottom" === u ? -1 : 1,
                g = "right" === f ? -1 : 1;
            c[u] = v * m, c[f] = h * g, c.willChange = u + ", " + f;
          }
          var y = {
            "x-placement": t.placement
          };
          return t.attributes = tr({}, y, t.attributes), t.styles = tr({}, c, t.styles), t.arrowStyles = tr({}, t.offsets.arrow, t.arrowStyles), t;
        },
        gpuAcceleration: !0,
        x: "bottom",
        y: "right"
      },
      applyStyle: {
        order: 900,
        enabled: !0,
        fn: function (t) {
          var e, n;
          return br(t.instance.popper, t.styles), e = t.instance.popper, n = t.attributes, Object.keys(n).forEach(function (t) {
            !1 !== n[t] ? e.setAttribute(t, n[t]) : e.removeAttribute(t);
          }), t.arrowElement && Object.keys(t.arrowStyles).length && br(t.arrowElement, t.arrowStyles), t;
        },
        onLoad: function (t, e, n, o, r) {
          var i = sr(r, e, t, n.positionFixed),
              a = ar(n.placement, i, e, t, n.modifiers.flip.boundariesElement, n.modifiers.flip.padding);
          return e.setAttribute("x-placement", a), br(e, {
            position: n.positionFixed ? "fixed" : "absolute"
          }), n;
        },
        gpuAcceleration: void 0
      }
    }
  },
      Er = function () {
    function t(e, n) {
      var o = this,
          r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      Yo(this, t), this.scheduleUpdate = function () {
        return requestAnimationFrame(o.update);
      }, this.update = Do(this.update.bind(this)), this.options = tr({}, t.Defaults, r), this.state = {
        isDestroyed: !1,
        isCreated: !1,
        scrollParents: []
      }, this.reference = e && e.jquery ? e[0] : e, this.popper = n && n.jquery ? n[0] : n, this.options.modifiers = {}, Object.keys(tr({}, t.Defaults.modifiers, r.modifiers)).forEach(function (e) {
        o.options.modifiers[e] = tr({}, t.Defaults.modifiers[e] || {}, r.modifiers ? r.modifiers[e] : {});
      }), this.modifiers = Object.keys(this.options.modifiers).map(function (t) {
        return tr({
          name: t
        }, o.options.modifiers[t]);
      }).sort(function (t, e) {
        return t.order - e.order;
      }), this.modifiers.forEach(function (t) {
        t.enabled && _o(t.onLoad) && t.onLoad(o.reference, o.popper, o.options, t, o.state);
      }), this.update();
      var i = this.options.eventsEnabled;
      i && this.enableEventListeners(), this.state.eventsEnabled = i;
    }

    return Zo(t, [{
      key: "update",
      value: function () {
        return function () {
          if (!this.state.isDestroyed) {
            var t = {
              instance: this,
              styles: {},
              arrowStyles: {},
              attributes: {},
              flipped: !1,
              offsets: {}
            };
            t.offsets.reference = sr(this.state, this.popper, this.reference, this.options.positionFixed), t.placement = ar(this.options.placement, t.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), t.originalPlacement = t.placement, t.positionFixed = this.options.positionFixed, t.offsets.popper = pr(this.popper, t.offsets.reference, t.placement), t.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute", t = fr(this.modifiers, t), this.state.isCreated ? this.options.onUpdate(t) : (this.state.isCreated = !0, this.options.onCreate(t));
          }
        }.call(this);
      }
    }, {
      key: "destroy",
      value: function () {
        return function () {
          return this.state.isDestroyed = !0, dr(this.modifiers, "applyStyle") && (this.popper.removeAttribute("x-placement"), this.popper.style.position = "", this.popper.style.top = "", this.popper.style.left = "", this.popper.style.right = "", this.popper.style.bottom = "", this.popper.style.willChange = "", this.popper.style[hr("transform")] = ""), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this;
        }.call(this);
      }
    }, {
      key: "enableEventListeners",
      value: function () {
        return function () {
          this.state.eventsEnabled || (this.state = mr(this.reference, this.options, this.state, this.scheduleUpdate));
        }.call(this);
      }
    }, {
      key: "disableEventListeners",
      value: function () {
        return gr.call(this);
      }
    }]), t;
  }();

  Er.Utils = ("undefined" != typeof window ? window : global).PopperUtils, Er.placements = Cr, Er.Defaults = Tr;
  var Mr,
      Nr = Un({
    render: function () {
      var t = this,
          e = t.$createElement,
          n = t._self._c || e;
      return n("editor-menu-bubble", {
        attrs: {
          editor: t.editor
        },
        scopedSlots: t._u([{
          key: "default",
          fn: function (e) {
            return [n("div", {
              staticClass: "tiptap-vuetify-editor-pop",
              attrs: {
                role: "tooltip"
              }
            }, [n("div", {
              staticClass: "tiptap-vuetify-editor-pop__popper"
            }, [n("actions-render", {
              attrs: {
                actions: t.actions,
                context: e,
                editor: t.editor,
                dark: !0
              }
            }), t._v(" "), n("div", {
              attrs: {
                "x-arrow": ""
              }
            })], 1)])];
          }
        }])
      });
    },
    staticRenderFns: []
  }, void 0, function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return a(e, t), e.prototype.mounted = function () {
      var t = function () {
        function t() {
          var t = this;
          this.range = null, this.rect = null, this.timeoutMousemove = null, this.updateRect();

          var e = function (e, n) {
            var o = document.getSelection();
            t.range = o && o.rangeCount && o.getRangeAt(0), t.updateRect(n);
          },
              n = document.querySelector(".tiptap-vuetify-editor .ProseMirror");

          n.addEventListener("mouseup", e), n.addEventListener("input", e), n.addEventListener("keydown", function (t) {
            return e(0, !0);
          });
          var o, r, i;
          n.addEventListener("mousemove", (o = function () {
            e();
          }, r = 100, i = !1, function () {
            i || (o.apply(this, arguments), i = !0, setTimeout(function () {
              return i = !1;
            }, r));
          })), window.addEventListener("scroll", e), document.scrollingElement.addEventListener("scroll", e);
        }

        return t.prototype.updateRect = function (t) {
          void 0 === t && (t = !1), !t && this.range ? this.rect = this.range.getBoundingClientRect() : this.rect = {
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            width: 0,
            height: 0
          }, this.rectChangedCallback(this.rect);
        }, t.prototype.rectChangedCallback = function (t) {}, t.prototype.getBoundingClientRect = function () {
          return this.rect;
        }, Object.defineProperty(t.prototype, "clientWidth", {
          get: function () {
            return this.rect.width;
          },
          enumerable: !0,
          configurable: !0
        }), Object.defineProperty(t.prototype, "clientHeight", {
          get: function () {
            return this.rect.height;
          },
          enumerable: !0,
          configurable: !0
        }), t;
      }();

      setTimeout(function () {
        var e = document.querySelector(".tiptap-vuetify-editor-pop"),
            n = new t(),
            o = new Er(n, e, {
          placement: "top",
          modifiers: {
            offset: {
              offset: "0,5"
            }
          },
          positionFixed: !0
        });

        n.rectChangedCallback = function (t) {
          t.width > 0 ? (o.scheduleUpdate(), e.firstElementChild.classList.add("tiptap-vuetify-editor-pop__popper--visible")) : e.firstElementChild.classList.remove("tiptap-vuetify-editor-pop__popper--visible");
        };
      }, 1e3);
    }, l([En({
      type: Object,
      required: !0
    }), c("design:type", n.Editor)], e.prototype, "editor", void 0), l([En({
      type: Array,
      default: function () {
        return [];
      }
    }), c("design:type", Array)], e.prototype, "actions", void 0), e = l([An({
      components: {
        ActionsRender: Gn,
        EditorMenuBubble: n.EditorMenuBubble,
        VCard: o.VCard
      }
    })], e);
  }(Cn(Lo)), void 0, !1, void 0, void 0, void 0);
  !function (t) {
    t.toolbar = "toolbar", t.bubbleMenu = "bubbleMenu";
  }(Mr || (Mr = {}));

  var Rr,
      Lr = Un({
    render: function () {
      var t = this,
          e = t.$createElement,
          n = t._self._c || e;
      return t.editor ? n("div", {
        staticClass: "tiptap-vuetify-editor",
        class: {
          "tiptap-vuetify-editor--disabled": t.$props[t.PROPS.DISABLED]
        }
      }, [t.availableActions.bubbleMenu.length && t.editor.options.editable ? n("bubble", {
        attrs: {
          editor: t.editor,
          actions: t.availableActions.bubbleMenu
        }
      }) : t._e(), t._v(" "), t.$props[t.PROPS.TYPE] === t.EDITOR_TYPES_ENUM.card ? n("VCard", t._b({}, "VCard", t.$props[t.PROPS.CARD_PROPS], !1), [t._t("toolbar-before"), t._v(" "), t.availableActions.toolbar.length ? n("toolbar", {
        attrs: {
          editor: t.editor,
          actions: t.availableActions.toolbar,
          "toolbar-attributes": t.$props[t.PROPS.TOOLBAR_ATTRIBUTES],
          disabled: t.$props[t.PROPS.DISABLED]
        },
        scopedSlots: t._u([t.$scopedSlots.toolbar ? {
          key: "default",
          fn: function (e) {
            return [t._t("toolbar", null, null, e)];
          }
        } : null], null, !0)
      }) : t._e(), t._v(" "), t._t("toolbar-after"), t._v(" "), n("editor-content", {
        staticClass: "tiptap-vuetify-editor__content",
        class: {
          "tiptap-vuetify-editor__content--disabled": t.$props[t.PROPS.DISABLED]
        },
        style: t.contentDynamicStyles,
        attrs: {
          editor: t.editor
        }
      }), t._v(" "), t._t("footer")], 2) : t._e()], 1) : t._e();
    },
    staticRenderFns: []
  }, void 0, function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.PROPS = Hn, e.EDITOR_TYPES_ENUM = _n, e.editor = null, e.availableActions = {
        toolbar: [],
        bubbleMenu: []
      }, e.emitAfterOnUpdate = !1, e;
    }

    var i, p, u, h, v, m, g, y, b, w, S, C;
    return a(e, t), Object.defineProperty(e.prototype, "contentDynamicStyles", {
      get: function () {
        var t = function (t) {
          if (!t) return t;
          var e = parseInt(t, 10),
              n = t.slice(e.toString().length);
          return e + (n || "px");
        };

        return {
          minHeight: t(this[Hn.MIN_HEIGHT]),
          maxHeight: t(this[Hn.MAX_HEIGHT])
        };
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.onDisabledChange = function (t) {
      this.editor && this.editor.setOptions({
        editable: !t
      });
    }, e.prototype.onValueChange = function (t) {
      this.emitAfterOnUpdate ? this.emitAfterOnUpdate = !1 : this.editor && this.editor.setContent(t);
    }, e.prototype.mounted = function () {
      var t = this,
          e = [],
          o = [],
          i = {
        renderIn: Mr.toolbar,
        options: {}
      };
      this[Hn.EXTENSIONS].forEach(function (n) {
        var r, a, l, c;
        if (Array.isArray(n)) l = (r = f(n, 2))[0], c = r[1];else {
          if (!n.prototype.availableActions) throw new Error('Incorrect extension declaration passed to "extensions" prop (array). It looks like the array\'s element is in the wrong format.');
          l = n;
        }
        var p = s(s({}, i), c),
            u = new l(p.options);
        (a = t.availableActions[p.renderIn]).push.apply(a, d(u.availableActions)), u.nativeExtensionInstance && e.push(u.nativeExtensionInstance), o.push(u);
      });
      var a = d(this[Hn.NATIVE_EXTENSIONS], e);
      this[Hn.PLACEHOLDER] && a.push(new r.Placeholder({
        emptyNodeClass: "tiptap-vuetify-editor__paragraph--is-empty",
        emptyNodeText: this[Hn.PLACEHOLDER],
        showOnlyWhenEditable: !0
      })), this.editor = new n.Editor(s(s({
        editable: !this[Hn.DISABLED],
        extensions: a
      }, this[Hn.EDITOR_PROPERTIES]), {
        editorProps: s(s({}, this[Hn.EDITOR_PROPERTIES].editorProps), {
          handleKeyDown: function (e, n) {
            t[Hn.EDITOR_PROPERTIES].editorProps && t[Hn.EDITOR_PROPERTIES].editorProps.handleKeyDown && t[Hn.EDITOR_PROPERTIES].editorProps.handleKeyDown(e, n), t.$emit("keydown", n, e);
          }
        }),
        content: this[Hn.VALUE],
        onUpdate: this.onUpdate.bind(this),
        onBlur: this.onBlur.bind(this),
        onFocus: this.onFocus.bind(this)
      })), this.$emit(zn, {
        editor: this.editor
      }), o.forEach(function (e) {
        return e.onEditorInit && e.onEditorInit(t.editor);
      });
    }, e.prototype.onUpdate = function (t) {
      var e;
      this.emitAfterOnUpdate = !0, e = "html" === this[Hn.OUTPUT_FORMAT] ? t.getHTML() : t.getJSON(), this.$emit(Vn, e, t);
    }, e.prototype.onBlur = function (t) {
      var e = t.event,
          n = t.view;
      this.$emit($n, e, n);
    }, e.prototype.onFocus = function (t) {
      var e = t.event,
          n = t.view;
      this.$emit(jn, e, n);
    }, e.prototype.beforeDestroy = function () {
      this.editor && this.editor.destroy();
    }, i = Hn.DISABLED, p = Hn.VALUE, u = Hn.EXTENSIONS, h = Hn.PLACEHOLDER, v = Hn.CARD_PROPS, m = Hn.OUTPUT_FORMAT, g = Hn.TOOLBAR_ATTRIBUTES, y = Hn.EDITOR_PROPERTIES, b = Hn.NATIVE_EXTENSIONS, w = Hn.TYPE, S = Hn.MIN_HEIGHT, C = Hn.MAX_HEIGHT, l([En({
      type: Boolean,
      default: !1
    }), c("design:type", Boolean)], e.prototype, i, void 0), l([En({
      type: [String, Object],
      default: ""
    }), c("design:type", String)], e.prototype, p, void 0), l([En({
      type: Array,
      default: function () {
        return [];
      }
    }), c("design:type", Array)], e.prototype, u, void 0), l([En({
      type: String
    }), c("design:type", String)], e.prototype, h, void 0), l([En({
      type: Object,
      default: function () {
        return {};
      }
    }), c("design:type", Object)], e.prototype, v, void 0), l([En({
      type: String,
      default: "html"
    }), c("design:type", String)], e.prototype, m, void 0), l([En({
      type: [Array, Object],
      default: function () {
        return {};
      }
    }), c("design:type", Object)], e.prototype, g, void 0), l([En({
      type: Object,
      default: function () {
        return {};
      }
    }), c("design:type", Object)], e.prototype, y, void 0), l([En({
      type: Array,
      default: function () {
        return [];
      }
    }), c("design:type", Array)], e.prototype, b, void 0), l([En({
      type: String,
      default: _n.card
    }), c("design:type", String)], e.prototype, w, void 0), l([En({
      type: [String, Number]
    }), c("design:type", Object)], e.prototype, S, void 0), l([En({
      type: [String, Number]
    }), c("design:type", Object)], e.prototype, C, void 0), l([Mn("disabled"), c("design:type", Function), c("design:paramtypes", [Object]), c("design:returntype", void 0)], e.prototype, "onDisabledChange", null), l([Mn("value"), c("design:type", Function), c("design:paramtypes", [Object]), c("design:returntype", void 0)], e.prototype, "onValueChange", null), e = l([An({
      components: {
        Bubble: Nr,
        EditorContent: n.EditorContent,
        Toolbar: Xn,
        VCard: o.VCard
      }
    })], e);
  }(e), void 0, !1, void 0, void 0, void 0),
      Ir = "md",
      Pr = {
    close: (Rr = {}, Rr.md = new Bn("close"), Rr.fa = new Bn("fas fa-times"), Rr.mdi = new Bn("mdi-close"), Rr.mdiSvg = new Bn("M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z"), Rr)
  },
      Dr = oe.map,
      _r = Ce("map"),
      Br = le("map");

  Ft({
    target: "Array",
    proto: !0,
    forced: !_r || !Br
  }, {
    map: function (t) {
      return Dr(this, t, arguments.length > 1 ? arguments[1] : void 0);
    }
  });

  var Vr = function () {
    function t(t, e) {
      this.text = Ro(t, e);
    }

    return t.prototype.toString = function () {
      return this.text;
    }, t;
  }(),
      zr = function () {
    return function (t, e) {
      this.options = t, this.extensionClass = e, this.nativeExtensionInstance = null, e && (this.nativeExtensionInstance = new e(t));
    };
  }(),
      $r = function (t) {
    function e(e) {
      return t.call(this, e, r.Heading) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        return this.options.levels.map(function (t) {
          var e;
          return {
            render: new Kn({
              tooltip: new Vr("extensions.Heading.buttons.heading.tooltip", {
                level: t
              }),
              icons: (e = {}, e.md = new Rn("H" + t), e.fa = new Rn("H" + t), e.mdi = new Rn("H" + t), e.mdiSvg = new Rn("H" + t), e),
              nativeExtensionName: "heading",
              onClickOptions: {
                level: t
              },
              isActiveOptions: {
                level: t
              }
            })
          };
        });
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      jr = function (t) {
    function e(e) {
      return t.call(this, e, r.Bold) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        var t;
        return [{
          render: new Kn({
            tooltip: new Vr("extensions.Bold.buttons.bold.tooltip"),
            icons: (t = {}, t.md = new Bn("format_bold"), t.fa = new Bn("fas fa-bold"), t.mdi = new Bn("mdi-format-bold"), t.mdiSvg = new Bn("M13.5,15.5H10V12.5H13.5A1.5,1.5 0 0,1 15,14A1.5,1.5 0 0,1 13.5,15.5M10,6.5H13A1.5,1.5 0 0,1 14.5,8A1.5,1.5 0 0,1 13,9.5H10M15.6,10.79C16.57,10.11 17.25,9 17.25,8C17.25,5.74 15.5,4 13.25,4H7V18H14.04C16.14,18 17.75,16.3 17.75,14.21C17.75,12.69 16.89,11.39 15.6,10.79Z"), t),
            nativeExtensionName: "bold"
          })
        }];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      Hr = function (t) {
    function e(e) {
      return t.call(this, e, r.Italic) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        var t;
        return [{
          render: new Kn({
            tooltip: new Vr("extensions.Italic.buttons.italic.tooltip"),
            icons: (t = {}, t.md = new Bn("format_italic"), t.fa = new Bn("fas fa-italic"), t.mdi = new Bn("mdi-format-italic"), t.mdiSvg = new Bn("M10,4V7H12.21L8.79,15H6V18H14V15H11.79L15.21,7H18V4H10Z"), t),
            nativeExtensionName: "italic"
          })
        }];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      Fr = function (t) {
    function e(e) {
      return t.call(this, e, r.Strike) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        var t;
        return [{
          render: new Kn({
            tooltip: new Vr("extensions.Strike.buttons.strike.tooltip"),
            icons: (t = {}, t.md = new Bn("format_strikethrough"), t.fa = new Bn("fas fa-strikethrough"), t.mdi = new Bn("mdi-format-strikethrough"), t.mdiSvg = new Bn("M3,14H21V12H3M5,4V7H10V10H14V7H19V4M10,19H14V16H10V19Z"), t),
            nativeExtensionName: "strike"
          })
        }];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      qr = function (t) {
    function e(e) {
      return t.call(this, e, r.Underline) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        var t;
        return [{
          render: new Kn({
            tooltip: new Vr("extensions.Underline.buttons.underline.tooltip"),
            icons: (t = {}, t.md = new Bn("format_underline"), t.fa = new Bn("fas fa-underline"), t.mdi = new Bn("mdi-format-underline"), t.mdiSvg = new Bn("M5,21H19V19H5V21M12,17A6,6 0 0,0 18,11V3H15.5V11A3.5,3.5 0 0,1 12,14.5A3.5,3.5 0 0,1 8.5,11V3H6V11A6,6 0 0,0 12,17Z"), t),
            nativeExtensionName: "underline"
          })
        }];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      Ur = function (t) {
    function e(e) {
      return t.call(this, e, r.Code) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        var t;
        return [{
          render: new Kn({
            tooltip: new Vr("extensions.Code.buttons.code.tooltip"),
            icons: (t = {}, t.md = new Bn("code"), t.fa = new Bn("fas fa-code"), t.mdi = new Bn("mdi-code-tags"), t.mdiSvg = new Bn("M14.6,16.6L19.2,12L14.6,7.4L16,6L22,12L16,18L14.6,16.6M9.4,16.6L4.8,12L9.4,7.4L8,6L2,12L8,18L9.4,16.6Z"), t),
            nativeExtensionName: "code"
          })
        }];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      Wr = function (t) {
    function e(e) {
      return t.call(this, e, r.CodeBlock) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        var t;
        return [{
          render: new Kn({
            tooltip: new Vr("extensions.CodeBlock.buttons.codeBlock.tooltip"),
            icons: (t = {}, t.md = new Bn("code"), t.fa = new Bn("fas fa-code"), t.mdi = new Bn("mdi-code-tags"), t.mdiSvg = new Bn("M14.6,16.6L19.2,12L14.6,7.4L16,6L22,12L16,18L14.6,16.6M9.4,16.6L4.8,12L9.4,7.4L8,6L2,12L8,18L9.4,16.6Z"), t),
            nativeExtensionName: "code_block"
          })
        }];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      Kr = function (t) {
    function e(e) {
      return t.call(this, e, null) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        var t;
        return [{
          render: new Kn({
            tooltip: new Vr("extensions.Paragraph.buttons.paragraph.tooltip"),
            icons: (t = {}, t.md = new Bn("format_textdirection_l_to_r"), t.fa = new Bn("fas fa-paragraph"), t.mdi = new Bn("mdi-format-paragraph"), t.mdiSvg = new Bn("M13,4A4,4 0 0,1 17,8A4,4 0 0,1 13,12H11V18H9V4H13M13,10A2,2 0 0,0 15,8A2,2 0 0,0 13,6H11V10H13Z"), t),
            nativeExtensionName: "paragraph"
          })
        }];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      Jr = function (t) {
    function e(e) {
      return t.call(this, e, r.BulletList) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        var t;
        return [{
          render: new Kn({
            tooltip: new Vr("extensions.BulletList.buttons.bulletList.tooltip"),
            icons: (t = {}, t.md = new Bn("format_list_bulleted"), t.fa = new Bn("fas fa-list-ul"), t.mdi = new Bn("mdi-format-list-bulleted"), t.mdiSvg = new Bn("M7,5H21V7H7V5M7,13V11H21V13H7M4,4.5A1.5,1.5 0 0,1 5.5,6A1.5,1.5 0 0,1 4,7.5A1.5,1.5 0 0,1 2.5,6A1.5,1.5 0 0,1 4,4.5M4,10.5A1.5,1.5 0 0,1 5.5,12A1.5,1.5 0 0,1 4,13.5A1.5,1.5 0 0,1 2.5,12A1.5,1.5 0 0,1 4,10.5M7,19V17H21V19H7M4,16.5A1.5,1.5 0 0,1 5.5,18A1.5,1.5 0 0,1 4,19.5A1.5,1.5 0 0,1 2.5,18A1.5,1.5 0 0,1 4,16.5Z"), t),
            nativeExtensionName: "bullet_list"
          })
        }];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      Gr = function (t) {
    function e(e) {
      return t.call(this, e, r.OrderedList) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        var t;
        return [{
          render: new Kn({
            tooltip: new Vr("extensions.OrderedList.buttons.orderedList.tooltip"),
            icons: (t = {}, t.md = new Bn("format_list_numbered"), t.fa = new Bn("fas fa-list-ol"), t.mdi = new Bn("mdi-format-list-numbered"), t.mdiSvg = new Bn("M7,13V11H21V13H7M7,19V17H21V19H7M7,7V5H21V7H7M3,8V5H2V4H4V8H3M2,17V16H5V20H2V19H4V18.5H3V17.5H4V17H2M4.25,10A0.75,0.75 0 0,1 5,10.75C5,10.95 4.92,11.14 4.79,11.27L3.12,13H5V14H2V13.08L4,11H2V10H4.25Z"), t),
            nativeExtensionName: "ordered_list"
          })
        }];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      Xr = function (t) {
    function e(e) {
      return t.call(this, e, r.ListItem) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        return [];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      Yr = function (t) {
    function e(e) {
      return t.call(this, e, r.Blockquote) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        var t;
        return [{
          render: new Kn({
            tooltip: new Vr("extensions.Blockquote.buttons.blockquote.tooltip"),
            icons: (t = {}, t.md = new Bn("format_quote"), t.fa = new Bn("fas fa-quote-right"), t.mdi = new Bn("mdi-format-quote-close"), t.mdiSvg = new Bn("M14,17H17L19,13V7H13V13H16M6,17H9L11,13V7H5V13H8L6,17Z"), t),
            nativeExtensionName: "blockquote"
          })
        }];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      Zr = function (t) {
    function e(e) {
      return t.call(this, e, r.HardBreak) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        return [];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      Qr = function (t) {
    function e(e) {
      return t.call(this, e, r.HorizontalRule) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        var t;
        return [{
          render: new Kn({
            tooltip: new Vr("extensions.HorizontalRule.buttons.horizontalRule.tooltip"),
            icons: (t = {}, t.md = new Rn("—"), t.fa = new Bn("fas fa-minus"), t.mdi = new Bn("mdi-minus"), t.mdiSvg = new Bn("M19,13H5V11H19V13Z"), t),
            nativeExtensionName: "horizontal_rule"
          })
        }];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      ti = function (t) {
    function e(e) {
      return t.call(this, e, r.History) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        var t, e;
        return this.options && this.options.noActions ? [] : [{
          render: new Kn({
            tooltip: new Vr("extensions.History.buttons.undo.tooltip"),
            icons: (t = {}, t.md = new Bn("undo"), t.fa = new Bn("fas fa-undo"), t.mdi = new Bn("mdi-undo"), t.mdiSvg = new Bn("M12.5,8C9.85,8 7.45,9 5.6,10.6L2,7V16H11L7.38,12.38C8.77,11.22 10.54,10.5 12.5,10.5C16.04,10.5 19.05,12.81 20.1,16L22.47,15.22C21.08,11.03 17.15,8 12.5,8Z"), t),
            nativeExtensionName: "undo"
          })
        }, {
          render: new Kn({
            tooltip: new Vr("extensions.History.buttons.redo.tooltip"),
            icons: (e = {}, e.md = new Bn("redo"), e.fa = new Bn("fas fa-redo"), e.mdi = new Bn("mdi-redo"), e.mdiSvg = new Bn("M18.4,10.6C16.55,9 14.15,8 11.5,8C6.85,8 2.92,11.03 1.54,15.22L3.9,16C4.95,12.81 7.95,10.5 11.5,10.5C13.45,10.5 15.23,11.22 16.62,12.38L13,16H22V7L18.4,10.6Z"), e),
            nativeExtensionName: "redo"
          })
        }];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      ei = {
    VALUE: "value",
    CONTEXT: "context",
    EDITOR: "editor",
    NATIVE_EXTENSION_NAME: "nativeExtensionName",
    HREF: "href"
  };

  var ni = Un({
    render: function () {
      var t = this,
          e = t.$createElement,
          n = t._self._c || e;
      return n("v-dialog", {
        attrs: {
          value: t.value,
          "max-width": "500px"
        }
      }, [n("v-card", [n("v-card-title", [n("span", {
        staticClass: "headline"
      }, [t._v("\n        " + t._s(t.$i18n.getMsg("extensions.Link.window.title")) + "\n      ")]), t._v(" "), n("v-spacer"), t._v(" "), n("v-btn", {
        attrs: {
          icon: ""
        },
        on: {
          click: t.close
        }
      }, [n("v-icon", [t._v(t._s(t.COMMON_ICONS.close[t.$tiptapVuetify.iconsGroup]))])], 1)], 1), t._v(" "), n("v-card-text", [n("v-text-field", {
        attrs: {
          label: t.$i18n.getMsg("extensions.Link.window.form.hrefLabel")
        },
        model: {
          value: t.form.href,
          callback: function (e) {
            t.$set(t.form, "href", e);
          },
          expression: "form.href"
        }
      })], 1), t._v(" "), n("v-card-actions", [n("v-btn", {
        attrs: {
          text: ""
        },
        on: {
          click: t.close
        }
      }, [t._v("\n        " + t._s(t.$i18n.getMsg("extensions.Link.window.buttons.close")) + "\n      ")]), t._v(" "), n("v-btn", {
        attrs: {
          disabled: t.isDisabled,
          color: t.isRemove ? "error" : "primary",
          text: ""
        },
        on: {
          click: t.apply
        }
      }, [t._v("\n        " + t._s(t.$i18n.getMsg("extensions.Link.window.buttons." + (t.isRemove ? "remove" : "apply"))) + "\n      ")])], 1)], 1)], 1);
    },
    staticRenderFns: []
  }, void 0, function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.COMMON_ICONS = Pr, e.form = {
        href: e[ei.HREF],
        blank: !1
      }, e;
    }

    var n, r, i, s, p;
    return a(e, t), Object.defineProperty(e.prototype, "isRemove", {
      get: function () {
        return this[ei.HREF] && !this.form.href;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "isDisabled", {
      get: function () {
        return this[ei.HREF] === this.form.href || !this[ei.HREF] && !this.form.href;
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.apply = function () {
      this[ei.CONTEXT].commands[this[ei.NATIVE_EXTENSION_NAME]]({
        href: this.form.href
      }), this.close(), this[ei.EDITOR].focus();
    }, e.prototype.close = function () {
      this.$destroy(), this.$el.parentNode.removeChild(this.$el);
    }, n = ei.VALUE, r = ei.NATIVE_EXTENSION_NAME, i = ei.CONTEXT, s = ei.EDITOR, p = ei.HREF, l([En({
      type: Boolean,
      default: !1
    }), c("design:type", Boolean)], e.prototype, n, void 0), l([En({
      type: String,
      required: !0
    }), c("design:type", String)], e.prototype, r, void 0), l([En({
      type: Object,
      required: !0
    }), c("design:type", Object)], e.prototype, i, void 0), l([En({
      type: Object,
      required: !0
    }), c("design:type", Object)], e.prototype, s, void 0), l([En({
      type: String
    }), c("design:type", Object)], e.prototype, p, void 0), e = l([An({
      components: {
        VDialog: o.VDialog,
        VCard: o.VCard,
        VCardTitle: o.VCardTitle,
        VCardText: o.VCardText,
        VCardActions: o.VCardActions,
        VBtn: o.VBtn,
        VSpacer: o.VSpacer,
        VIcon: o.VIcon,
        VTextField: o.VTextField
      }
    })], e);
  }(Cn(Lo)), void 0, !1, void 0, void 0, void 0),
      oi = function (t) {
    function n(e) {
      return t.call(this, e, r.Link) || this;
    }

    return a(n, t), Object.defineProperty(n.prototype, "availableActions", {
      get: function () {
        var t;
        return [{
          render: new Kn({
            tooltip: function (t, e) {
              return new Vr(e.isActive(t) ? "extensions.Link.buttons.isActive.tooltip" : "extensions.Link.buttons.notActive.tooltip");
            },
            icons: (t = {}, t.md = new Bn("link"), t.fa = new Bn("fas fa-link"), t.mdi = new Bn("mdi-link"), t.mdiSvg = new Bn("M3.9,12C3.9,10.29 5.29,8.9 7,8.9H11V7H7A5,5 0 0,0 2,12A5,5 0 0,0 7,17H11V15.1H7C5.29,15.1 3.9,13.71 3.9,12M8,13H16V11H8V13M17,7H13V8.9H17C18.71,8.9 20.1,10.29 20.1,12C20.1,13.71 18.71,15.1 17,15.1H13V17H17A5,5 0 0,0 22,12A5,5 0 0,0 17,7Z"), t),
            nativeExtensionName: "link",
            onClick: function (t) {
              var n = t.context,
                  o = t.editor,
                  r = n.getMarkAttrs("link").href,
                  i = new (e.extend(ni))({
                vuetify: e.prototype.tiptapVuetifyPlugin.vuetify,
                propsData: {
                  value: !0,
                  nativeExtensionName: "link",
                  context: n,
                  editor: o,
                  href: r
                }
              });
              i.$mount(), document.querySelector("body").appendChild(i.$el);
            }
          })
        }];
      },
      enumerable: !0,
      configurable: !0
    }), n;
  }(zr),
      ri = Zt("isConcatSpreadable"),
      ii = we >= 51 || !y(function () {
    var t = [];
    return t[ri] = !1, t.concat()[0] !== t;
  }),
      ai = Ce("concat"),
      si = function (t) {
    if (!N(t)) return !1;
    var e = t[ri];
    return void 0 !== e ? !!e : Wt(t);
  };

  Ft({
    target: "Array",
    proto: !0,
    forced: !ii || !ai
  }, {
    concat: function (t) {
      var e,
          n,
          o,
          r,
          i,
          a = Ut(this),
          s = te(a, 0),
          l = 0;

      for (e = -1, o = arguments.length; e < o; e++) if (i = -1 === e ? a : arguments[e], si(i)) {
        if (l + (r = St(i.length)) > 9007199254740991) throw TypeError("Maximum allowed index exceeded");

        for (n = 0; n < r; n++, l++) n in i && ve(s, l, i[n]);
      } else {
        if (l >= 9007199254740991) throw TypeError("Maximum allowed index exceeded");
        ve(s, l++, i);
      }

      return s.length = l, s;
    }
  });
  var li = oe.filter,
      ci = Ce("filter"),
      pi = le("filter");
  Ft({
    target: "Array",
    proto: !0,
    forced: !ci || !pi
  }, {
    filter: function (t) {
      return li(this, t, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  var ui = Zt("unscopables"),
      fi = Array.prototype;
  null == fi[ui] && H.f(fi, ui, {
    configurable: !0,
    value: Be(null)
  });

  var di = function (t) {
    fi[ui][t] = !0;
  },
      hi = At.includes,
      vi = le("indexOf", {
    ACCESSORS: !0,
    1: 0
  });

  Ft({
    target: "Array",
    proto: !0,
    forced: !vi
  }, {
    includes: function (t) {
      return hi(this, t, arguments.length > 1 ? arguments[1] : void 0);
    }
  }), di("includes");
  var mi = Zt("match");
  Ft({
    target: "String",
    proto: !0,
    forced: !function (t) {
      var e = /./;

      try {
        "/./"[t](e);
      } catch (n) {
        try {
          return e[mi] = !1, "/./"[t](e);
        } catch (t) {}
      }

      return !1;
    }("includes")
  }, {
    includes: function (t) {
      return !!~String(E(this)).indexOf(function (t) {
        if (wo(t)) throw TypeError("The method doesn't accept regular expressions");
        return t;
      }(t), arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  var gi = "select-file",
      yi = "tiptap-vuetify-image-upload-area-holder";
  var bi = Un({
    render: function () {
      var t = this.$createElement,
          e = this._self._c || t;
      return e("div", {
        staticClass: "tiptap-vuetify-image-upload-area"
      }, [e("input", {
        attrs: {
          id: "tiptap-vuetify-image-upload-area__input-file",
          type: "file",
          accept: "image/*",
          multiple: ""
        }
      }), this._v(" "), e("label", {
        staticClass: "tiptap-vuetify-image-upload-area-holder",
        attrs: {
          for: "tiptap-vuetify-image-upload-area__input-file"
        }
      }, [e("div", [e("svg", {
        staticClass: "tiptap-vuetify-image-upload-area-holder__icon",
        attrs: {
          xmlns: "http://www.w3.org/2000/svg",
          width: "50",
          height: "43",
          viewBox: "0 0 50 43"
        }
      }, [e("path", {
        attrs: {
          d: "M48.4 26.5c-.9 0-1.7.7-1.7 1.7v11.6h-43.3v-11.6c0-.9-.7-1.7-1.7-1.7s-1.7.7-1.7 1.7v13.2c0 .9.7 1.7 1.7 1.7h46.7c.9 0 1.7-.7 1.7-1.7v-13.2c0-1-.7-1.7-1.7-1.7zm-24.5 6.1c.3.3.8.5 1.2.5.4 0 .9-.2 1.2-.5l10-11.6c.7-.7.7-1.7 0-2.4s-1.7-.7-2.4 0l-7.1 8.3v-25.3c0-.9-.7-1.7-1.7-1.7s-1.7.7-1.7 1.7v25.3l-7.1-8.3c-.7-.7-1.7-.7-2.4 0s-.7 1.7 0 2.4l10 11.6z"
        }
      })]), this._v(" "), e("br"), e("br"), this._v(" "), e("h3", [this._v(this._s(this.$i18n.getMsg("extensions.Image.window.imageUpload.instruction")))])])])]);
    },
    staticRenderFns: []
  }, void 0, function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return a(e, t), e.prototype.mounted = function () {
      var t = this,
          e = this.$el.querySelector("." + yi);
      this.$el.querySelector("#tiptap-vuetify-image-upload-area__input-file").addEventListener("change", function (n) {
        n.target instanceof HTMLInputElement && (t.filesSelected(n.target.files), e.classList.remove(yi + "--dragover"), n.target.value = "");
      }), e.addEventListener("dragover", function () {
        return e.classList.add(yi + "--dragover"), !1;
      });

      var n = function () {
        return e.classList.remove(yi + "--dragover"), !1;
      };

      e.addEventListener("dragleave", n), e.addEventListener("dragend", n), e.addEventListener("drop", function (e) {
        e.preventDefault(), t.filesSelected(e.dataTransfer.files);
      });
    }, e.prototype.filesSelected = function (t) {
      var e = this;
      d(t).forEach(function (t) {
        var n = new FileReader();
        n.addEventListener("load", function (n) {
          e.$emit(gi, {
            src: n.target.result.toString(),
            alt: t.name
          });
        }), n.readAsDataURL(t);
      });
    }, e = l([An], e);
  }(Cn(Lo)), void 0, !1, void 0, void 0, void 0);
  var wi = Un({
    render: function () {
      var t = this,
          e = t.$createElement,
          n = t._self._c || e;
      return n("div", [n("v-text-field", {
        attrs: {
          label: t.$i18n.getMsg("extensions.Image.window.form.sourceLink")
        },
        model: {
          value: t.form.src,
          callback: function (e) {
            t.$set(t.form, "src", e);
          },
          expression: "form.src"
        }
      }), t._v(" "), n("v-text-field", {
        attrs: {
          label: t.$i18n.getMsg("extensions.Image.window.form.altText")
        },
        model: {
          value: t.form.alt,
          callback: function (e) {
            t.$set(t.form, "alt", e);
          },
          expression: "form.alt"
        }
      }), t._v(" "), n("v-btn", {
        on: {
          click: t.addImage
        }
      }, [t._v("\n    " + t._s(t.$i18n.getMsg("extensions.Image.window.form.addImage")) + "\n  ")])], 1);
    },
    staticRenderFns: []
  }, void 0, function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.form = {
        src: null,
        alt: null
      }, e;
    }

    return a(e, t), e.prototype.addImage = function () {
      this.$emit(gi, {
        src: this.form.src,
        alt: this.form.alt
      }), this.form.src = null, this.form.alt = null;
    }, e = l([An({
      components: {
        VTextField: o.VTextField
      }
    })], e);
  }(Cn(Lo)), "data-v-c4747a2a", !1, void 0, void 0, void 0);
  let Si = !1;

  try {
    if ("undefined" != typeof window) {
      const t = Object.defineProperty({}, "passive", {
        get: () => {
          Si = !0;
        }
      });
      window.addEventListener("testListener", t, t), window.removeEventListener("testListener", t, t);
    }
  } catch (t) {
    console.warn(t);
  }

  Object.freeze({
    enter: 13,
    tab: 9,
    delete: 46,
    esc: 27,
    space: 32,
    up: 38,
    down: 40,
    left: 37,
    right: 39,
    end: 35,
    home: 36,
    del: 46,
    backspace: 8,
    insert: 45,
    pageup: 33,
    pagedown: 34
  });

  const Ci = /-(\w)/g,
        xi = t => t.replace(Ci, (t, e) => e ? e.toUpperCase() : "");

  const ki = {
    styleList: /;(?![^(]*\))/g,
    styleProp: /:(.*)/
  };

  function Oi(t) {
    const e = {};

    for (const n of t.split(ki.styleList)) {
      let [t, o] = n.split(ki.styleProp);
      (t = t.trim()) && ("string" == typeof o && (o = o.trim()), e[xi(t)] = o);
    }

    return e;
  }

  function Ai(t, e, n = "in-out") {
    return {
      name: t,
      functional: !0,
      props: {
        mode: {
          type: String,
          default: n
        }
      },
      render: (n, o) => n("transition", function () {
        const t = {};
        let e,
            n,
            o = arguments.length;

        for (; o--;) for (e of Object.keys(arguments[o])) switch (e) {
          case "class":
          case "style":
          case "directives":
            if (Array.isArray(t[e]) || (t[e] = []), "style" === e) {
              let t;
              t = Array.isArray(arguments[o].style) ? arguments[o].style : [arguments[o].style];

              for (let e = 0; e < t.length; e++) {
                const n = t[e];
                "string" == typeof n && (t[e] = Oi(n));
              }

              arguments[o].style = t;
            }

            t[e] = t[e].concat(arguments[o][e]);
            break;

          case "staticClass":
            if (!arguments[o][e]) break;
            void 0 === t[e] && (t[e] = ""), t[e] && (t[e] += " "), t[e] += arguments[o][e].trim();
            break;

          case "on":
          case "nativeOn":
            t[e] || (t[e] = {});
            const r = t[e];

            for (n of Object.keys(arguments[o][e] || {})) r[n] ? r[n] = Array().concat(r[n], arguments[o][e][n]) : r[n] = arguments[o][e][n];

            break;

          case "attrs":
          case "props":
          case "domProps":
          case "scopedSlots":
          case "staticStyle":
          case "hook":
          case "transition":
            t[e] || (t[e] = {}), t[e] = { ...arguments[o][e],
              ...t[e]
            };
            break;

          case "slot":
          case "key":
          case "ref":
          case "tag":
          case "show":
          case "keepAlive":
          default:
            t[e] || (t[e] = arguments[o][e]);
        }

        return t;
      }(o.data, {
        props: {
          name: t
        },
        on: e
      }), o.children)
    };
  }

  function Ti(t = "", e = !1) {
    const n = e ? "width" : "height",
          o = `offset${(r = n, r.charAt(0).toUpperCase() + r.slice(1))}`;
    var r;
    return {
      beforeEnter(t) {
        t._parent = t.parentNode, t._initialStyle = {
          transition: t.style.transition,
          visibility: t.style.visibility,
          overflow: t.style.overflow,
          [n]: t.style[n]
        };
      },

      enter(e) {
        const r = e._initialStyle,
              i = `${e[o]}px`;
        e.style.setProperty("transition", "none", "important"), e.style.visibility = "hidden", e.style.visibility = r.visibility, e.style.overflow = "hidden", e.style[n] = "0", e.offsetHeight, e.style.transition = r.transition, t && e._parent && e._parent.classList.add(t), requestAnimationFrame(() => {
          e.style[n] = i;
        });
      },

      afterEnter: a,
      enterCancelled: a,

      leave(t) {
        t._initialStyle = {
          transition: "",
          visibility: "",
          overflow: t.style.overflow,
          [n]: t.style[n]
        }, t.style.overflow = "hidden", t.style[n] = `${t[o]}px`, t.offsetHeight, requestAnimationFrame(() => t.style[n] = "0");
      },

      afterLeave: i,
      leaveCancelled: i
    };

    function i(e) {
      t && e._parent && e._parent.classList.remove(t), a(e);
    }

    function a(t) {
      const e = t._initialStyle[n];
      t.style.overflow = t._initialStyle.overflow, null != e && (t.style[n] = e), delete t._initialStyle;
    }
  }

  const Ei = Ai("expand-transition", Ti());
  Ai("expand-x-transition", Ti("", !0));
  var Mi = "value",
      Ni = "context",
      Ri = "editor",
      Li = "imageSources",
      Ii = "imageSourcesOverride",
      Pi = "nativeExtensionName";

  var Di,
      _i,
      Bi,
      Vi = Un({
    render: function () {
      var t = this,
          e = t.$createElement,
          n = t._self._c || e;
      return n("v-dialog", {
        attrs: {
          value: t.value,
          "max-width": "500px"
        }
      }, [n("v-card", [n("v-card-title", [n("span", {
        staticClass: "headline"
      }, [t._v("\n        " + t._s(t.$i18n.getMsg("extensions.Image.window.title")) + "\n      ")]), t._v(" "), n("v-spacer"), t._v(" "), n("v-btn", {
        attrs: {
          icon: ""
        },
        on: {
          click: t.close
        }
      }, [n("v-icon", [t._v(t._s(t.COMMON_ICONS.close[t.$tiptapVuetify.iconsGroup]))])], 1)], 1), t._v(" "), n("v-card-text", [n("v-expand-transition", [n("div", {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: t.previewSources.length,
          expression: "previewSources.length"
        }]
      }, [n("v-row", {
        attrs: {
          "no-gutters": "",
          justify: "center",
          align: "center"
        }
      }, t._l(t.previewSources, function (e, o) {
        return n("v-col", {
          key: "preview" + o,
          attrs: {
            cols: "4"
          }
        }, [n("v-img", {
          staticClass: "text-right",
          attrs: {
            src: e.src,
            alt: e.alt
          }
        }, [n("v-btn", {
          attrs: {
            icon: "",
            small: "",
            dark: ""
          },
          on: {
            click: function (n) {
              return t.removeSource(e);
            }
          }
        }, [n("v-icon", {
          attrs: {
            small: ""
          }
        }, [t._v("\n                    close\n                  ")])], 1)], 1), t._v(" "), n("v-text-field", {
          attrs: {
            label: "Alt Text"
          },
          model: {
            value: e.alt,
            callback: function (n) {
              t.$set(e, "alt", n);
            },
            expression: "source.alt"
          }
        })], 1);
      }), 1)], 1)])], 1), t._v(" "), n("v-tabs", {
        attrs: {
          "fixed-tabs": ""
        }
      }, [t._l(t.imageTabs, function (e, o) {
        return [n("v-tab", {
          key: "tab-" + o,
          attrs: {
            href: "#tab-" + o
          }
        }, [t._v("\n          " + t._s(e.name) + "\n        ")]), t._v(" "), n("v-tab-item", {
          key: "tab-item-" + o,
          attrs: {
            value: "tab-" + o
          }
        }, [n(e.component, {
          tag: "component",
          staticClass: "pa-4",
          on: {
            "select-file": t.onFileSelect
          }
        })], 1)];
      })], 2), t._v(" "), n("v-card-actions", [n("v-btn", {
        attrs: {
          text: ""
        },
        on: {
          click: t.close
        }
      }, [t._v("\n        " + t._s(t.$i18n.getMsg("extensions.Image.window.buttons.close")) + "\n      ")]), t._v(" "), n("v-btn", {
        attrs: {
          disabled: t.isDisabled,
          text: ""
        },
        on: {
          click: t.apply
        }
      }, [t._v("\n        " + t._s(t.$i18n.getMsg("extensions.Image.window.buttons.apply")) + "\n      ")])], 1)], 1)], 1);
    },
    staticRenderFns: []
  }, void 0, function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.COMMON_ICONS = Pr, e.defaultImageTabs = [{
        name: "URL",
        component: wi
      }, {
        name: "Upload",
        component: bi
      }], e.inputPreviewSources = [], e;
    }

    var n, r, i, s, p, u;
    return a(e, t), Object.defineProperty(e.prototype, "imageTabs", {
      get: function () {
        return this[Li] ? this[Ii] ? this[Li] : this.defaultImageTabs.concat(this[Li]) : this.defaultImageTabs;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previewSources", {
      get: function () {
        return this.inputPreviewSources.filter(Boolean);
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "isDisabled", {
      get: function () {
        return !this.previewSources.length;
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.removeSource = function (t) {
      this.inputPreviewSources.includes(t) && (this.inputPreviewSources = this.inputPreviewSources.filter(function (e) {
        return e !== t;
      }));
    }, e.prototype.onFileSelect = function (t) {
      if (null !== t.src && "" !== t.src) {
        var e = this.findFile(t);
        null !== e ? e.alt = t.alt : this.inputPreviewSources.push(t);
      }
    }, e.prototype.findFile = function (t) {
      var e = this.inputPreviewSources.filter(function (e) {
        return e.src === t.src;
      });
      return e.length > 0 ? e[0] : null;
    }, e.prototype.apply = function () {
      var t = this;
      this.previewSources.forEach(function (e) {
        t[Ni].commands[t[Pi]](e);
      }), this.close(), this[Ri].focus();
    }, e.prototype.close = function () {
      this.$destroy(), this.$el.parentNode.removeChild(this.$el);
    }, n = Mi, r = Pi, i = Ni, s = Ri, p = Li, u = Ii, l([En({
      type: Boolean,
      default: !1
    }), c("design:type", Boolean)], e.prototype, n, void 0), l([En({
      type: String,
      required: !0
    }), c("design:type", String)], e.prototype, r, void 0), l([En({
      type: Object,
      required: !0
    }), c("design:type", Object)], e.prototype, i, void 0), l([En({
      type: Object,
      required: !0
    }), c("design:type", Object)], e.prototype, s, void 0), l([En({
      type: Array,
      required: !1
    }), c("design:type", Object)], e.prototype, p, void 0), l([En({
      type: Boolean,
      required: !1
    }), c("design:type", Object)], e.prototype, u, void 0), e = l([An({
      components: {
        VRow: o.VRow,
        VCol: o.VCol,
        VExpandTransition: Ei,
        ImageForm: wi,
        ImageUploadArea: bi,
        VImg: o.VImg,
        VDialog: o.VDialog,
        VCard: o.VCard,
        VCardTitle: o.VCardTitle,
        VCardText: o.VCardText,
        VCardActions: o.VCardActions,
        VBtn: o.VBtn,
        VSpacer: o.VSpacer,
        VIcon: o.VIcon,
        VTextField: o.VTextField,
        VTabs: o.VTabs,
        VTab: o.VTab,
        VTabsSlider: o.VTabsSlider,
        VTabItem: o.VTabItem,
        VTabsItems: o.VTabsItems
      }
    })], e);
  }(Cn(Lo)), void 0, !1, void 0, void 0, void 0),
      zi = function (t) {
    function n(e) {
      return t.call(this, e, r.Image) || this;
    }

    return a(n, t), Object.defineProperty(n.prototype, "availableActions", {
      get: function () {
        var t,
            n = this.options;
        return [{
          render: new Kn({
            tooltip: new Vr("extensions.Image.buttons.tooltip"),
            icons: (t = {}, t.md = new Bn("image"), t.fa = new Bn("fas fa-image"), t.mdi = new Bn("mdi-image"), t.mdiSvg = new Bn("M8.5,13.5L11,16.5L14.5,12L19,18H5M21,19V5C21,3.89 20.1,3 19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19Z"), t),
            nativeExtensionName: "image",
            onClick: function (t) {
              var o = t.context,
                  r = t.editor;
              return p(this, void 0, void 0, function () {
                var t, i;
                return u(this, function (a) {
                  return t = e.extend(Vi), (i = new t({
                    vuetify: e.prototype.tiptapVuetifyPlugin.vuetify,
                    propsData: {
                      value: !0,
                      nativeExtensionName: "image",
                      context: o,
                      editor: r,
                      imageSources: n.imageSources,
                      imageSourcesOverride: n.imageSourcesOverride
                    }
                  })).$mount(), document.querySelector("body").appendChild(i.$el), [2];
                });
              });
            }
          })
        }];
      },
      enumerable: !0,
      configurable: !0
    }), n;
  }(zr),
      $i = function (t) {
    function e(e) {
      return t.call(this, e, r.TodoList) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        var t;
        return [{
          render: new Kn({
            tooltip: new Vr("extensions.TodoList.buttons.todoList.tooltip"),
            icons: (t = {}, t.md = new Bn("check_box"), t.fa = new Bn("fas fa-tasks"), t.mdi = new Bn("mdi-format-list-checks"), t.mdiSvg = new Bn("M3,5H9V11H3V5M5,7V9H7V7H5M11,7H21V9H11V7M11,15H21V17H11V15M5,20L1.5,16.5L2.91,15.09L5,17.17L9.59,12.59L11,14L5,20Z"), t),
            nativeExtensionName: "todo_list"
          })
        }];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      ji = !y(function () {
    function t() {}

    return t.prototype.constructor = null, Object.getPrototypeOf(new t()) !== t.prototype;
  }),
      Hi = rt("IE_PROTO"),
      Fi = Object.prototype,
      qi = ji ? Object.getPrototypeOf : function (t) {
    return t = Ut(t), I(t, Hi) ? t[Hi] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? Fi : null;
  },
      Ui = Zt("iterator"),
      Wi = !1;

  [].keys && ("next" in (Bi = [].keys()) ? (_i = qi(qi(Bi))) !== Object.prototype && (Di = _i) : Wi = !0), null == Di && (Di = {}), I(Di, Ui) || F(Di, Ui, function () {
    return this;
  });

  var Ki = {
    IteratorPrototype: Di,
    BUGGY_SAFARI_ITERATORS: Wi
  },
      Ji = H.f,
      Gi = Zt("toStringTag"),
      Xi = function (t, e, n) {
    t && !I(t = n ? t : t.prototype, Gi) && Ji(t, Gi, {
      configurable: !0,
      value: e
    });
  },
      Yi = Ki.IteratorPrototype,
      Zi = Ki.IteratorPrototype,
      Qi = Ki.BUGGY_SAFARI_ITERATORS,
      ta = Zt("iterator"),
      ea = function () {
    return this;
  },
      na = ft.set,
      oa = ft.getterFor("Array Iterator"),
      ra = function (t, e, n, o, r, i, a) {
    !function (t, e, n) {
      var o = e + " Iterator";
      t.prototype = Be(Yi, {
        next: x(1, n)
      }), Xi(t, o, !1);
    }(n, e, o);

    var s,
        l,
        c,
        p = function (t) {
      if (t === r && v) return v;
      if (!Qi && t in d) return d[t];

      switch (t) {
        case "keys":
        case "values":
        case "entries":
          return function () {
            return new n(this, t);
          };
      }

      return function () {
        return new n(this);
      };
    },
        u = e + " Iterator",
        f = !1,
        d = t.prototype,
        h = d[ta] || d["@@iterator"] || r && d[r],
        v = !Qi && h || p(r),
        m = "Array" == e && d.entries || h;

    if (m && (s = qi(m.call(new t())), Zi !== Object.prototype && s.next && (qi(s) !== Zi && (Me ? Me(s, Zi) : "function" != typeof s[ta] && F(s, ta, ea)), Xi(s, u, !0))), "values" == r && h && "values" !== h.name && (f = !0, v = function () {
      return h.call(this);
    }), d[ta] !== v && F(d, ta, v), r) if (l = {
      values: p("values"),
      keys: i ? v : p("keys"),
      entries: p("entries")
    }, a) for (c in l) !Qi && !f && c in d || dt(d, c, l[c]);else Ft({
      target: e,
      proto: !0,
      forced: Qi || f
    }, l);
    return l;
  }(Array, "Array", function (t, e) {
    na(this, {
      type: "Array Iterator",
      target: M(t),
      index: 0,
      kind: e
    });
  }, function () {
    var t = oa(this),
        e = t.target,
        n = t.kind,
        o = t.index++;
    return !e || o >= e.length ? (t.target = void 0, {
      value: void 0,
      done: !0
    }) : "keys" == n ? {
      value: o,
      done: !1
    } : "values" == n ? {
      value: e[o],
      done: !1
    } : {
      value: [o, e[o]],
      done: !1
    };
  }, "values");

  di("keys"), di("values"), di("entries");
  var ia = Zt("iterator"),
      aa = Zt("toStringTag"),
      sa = ra.values;

  for (var la in dn) {
    var ca = g[la],
        pa = ca && ca.prototype;

    if (pa) {
      if (pa[ia] !== sa) try {
        F(pa, ia, sa);
      } catch (t) {
        pa[ia] = sa;
      }
      if (pa[aa] || F(pa, aa, la), dn[la]) for (var ua in ra) if (pa[ua] !== ra[ua]) try {
        F(pa, ua, ra[ua]);
      } catch (t) {
        pa[ua] = ra[ua];
      }
    }
  }

  function fa(t) {
    this.content = t;
  }

  fa.prototype = {
    constructor: fa,
    find: function (t) {
      for (var e = 0; e < this.content.length; e += 2) if (this.content[e] === t) return e;

      return -1;
    },
    get: function (t) {
      var e = this.find(t);
      return -1 == e ? void 0 : this.content[e + 1];
    },
    update: function (t, e, n) {
      var o = n && n != t ? this.remove(n) : this,
          r = o.find(t),
          i = o.content.slice();
      return -1 == r ? i.push(n || t, e) : (i[r + 1] = e, n && (i[r] = n)), new fa(i);
    },
    remove: function (t) {
      var e = this.find(t);
      if (-1 == e) return this;
      var n = this.content.slice();
      return n.splice(e, 2), new fa(n);
    },
    addToStart: function (t, e) {
      return new fa([t, e].concat(this.remove(t).content));
    },
    addToEnd: function (t, e) {
      var n = this.remove(t).content.slice();
      return n.push(t, e), new fa(n);
    },
    addBefore: function (t, e, n) {
      var o = this.remove(e),
          r = o.content.slice(),
          i = o.find(t);
      return r.splice(-1 == i ? r.length : i, 0, e, n), new fa(r);
    },
    forEach: function (t) {
      for (var e = 0; e < this.content.length; e += 2) t(this.content[e], this.content[e + 1]);
    },
    prepend: function (t) {
      return (t = fa.from(t)).size ? new fa(t.content.concat(this.subtract(t).content)) : this;
    },
    append: function (t) {
      return (t = fa.from(t)).size ? new fa(this.subtract(t).content.concat(t.content)) : this;
    },
    subtract: function (t) {
      var e = this;
      t = fa.from(t);

      for (var n = 0; n < t.content.length; n += 2) e = e.remove(t.content[n]);

      return e;
    },

    get size() {
      return this.content.length >> 1;
    }

  }, fa.from = function (t) {
    if (t instanceof fa) return t;
    var e = [];
    if (t) for (var n in t) e.push(n, t[n]);
    return new fa(e);
  };
  var da = fa;

  var ha = function (t, e) {
    if (this.content = t, this.size = e || 0, null == e) for (var n = 0; n < t.length; n++) this.size += t[n].nodeSize;
  },
      va = {
    firstChild: {
      configurable: !0
    },
    lastChild: {
      configurable: !0
    },
    childCount: {
      configurable: !0
    }
  };

  ha.prototype.nodesBetween = function (t, e, n, o, r) {
    void 0 === o && (o = 0);

    for (var i = 0, a = 0; a < e; i++) {
      var s = this.content[i],
          l = a + s.nodeSize;

      if (l > t && !1 !== n(s, o + a, r, i) && s.content.size) {
        var c = a + 1;
        s.nodesBetween(Math.max(0, t - c), Math.min(s.content.size, e - c), n, o + c);
      }

      a = l;
    }
  }, ha.prototype.descendants = function (t) {
    this.nodesBetween(0, this.size, t);
  }, ha.prototype.textBetween = function (t, e, n, o) {
    var r = "",
        i = !0;
    return this.nodesBetween(t, e, function (a, s) {
      a.isText ? (r += a.text.slice(Math.max(t, s) - s, e - s), i = !n) : a.isLeaf && o ? (r += o, i = !n) : !i && a.isBlock && (r += n, i = !0);
    }, 0), r;
  }, ha.prototype.append = function (t) {
    if (!t.size) return this;
    if (!this.size) return t;
    var e = this.lastChild,
        n = t.firstChild,
        o = this.content.slice(),
        r = 0;

    for (e.isText && e.sameMarkup(n) && (o[o.length - 1] = e.withText(e.text + n.text), r = 1); r < t.content.length; r++) o.push(t.content[r]);

    return new ha(o, this.size + t.size);
  }, ha.prototype.cut = function (t, e) {
    if (null == e && (e = this.size), 0 == t && e == this.size) return this;
    var n = [],
        o = 0;
    if (e > t) for (var r = 0, i = 0; i < e; r++) {
      var a = this.content[r],
          s = i + a.nodeSize;
      s > t && ((i < t || s > e) && (a = a.isText ? a.cut(Math.max(0, t - i), Math.min(a.text.length, e - i)) : a.cut(Math.max(0, t - i - 1), Math.min(a.content.size, e - i - 1))), n.push(a), o += a.nodeSize), i = s;
    }
    return new ha(n, o);
  }, ha.prototype.cutByIndex = function (t, e) {
    return t == e ? ha.empty : 0 == t && e == this.content.length ? this : new ha(this.content.slice(t, e));
  }, ha.prototype.replaceChild = function (t, e) {
    var n = this.content[t];
    if (n == e) return this;
    var o = this.content.slice(),
        r = this.size + e.nodeSize - n.nodeSize;
    return o[t] = e, new ha(o, r);
  }, ha.prototype.addToStart = function (t) {
    return new ha([t].concat(this.content), this.size + t.nodeSize);
  }, ha.prototype.addToEnd = function (t) {
    return new ha(this.content.concat(t), this.size + t.nodeSize);
  }, ha.prototype.eq = function (t) {
    if (this.content.length != t.content.length) return !1;

    for (var e = 0; e < this.content.length; e++) if (!this.content[e].eq(t.content[e])) return !1;

    return !0;
  }, va.firstChild.get = function () {
    return this.content.length ? this.content[0] : null;
  }, va.lastChild.get = function () {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }, va.childCount.get = function () {
    return this.content.length;
  }, ha.prototype.child = function (t) {
    var e = this.content[t];
    if (!e) throw new RangeError("Index " + t + " out of range for " + this);
    return e;
  }, ha.prototype.maybeChild = function (t) {
    return this.content[t];
  }, ha.prototype.forEach = function (t) {
    for (var e = 0, n = 0; e < this.content.length; e++) {
      var o = this.content[e];
      t(o, n, e), n += o.nodeSize;
    }
  }, ha.prototype.findDiffStart = function (t, e) {
    return void 0 === e && (e = 0), function t(e, n, o) {
      for (var r = 0;; r++) {
        if (r == e.childCount || r == n.childCount) return e.childCount == n.childCount ? null : o;
        var i = e.child(r),
            a = n.child(r);

        if (i != a) {
          if (!i.sameMarkup(a)) return o;

          if (i.isText && i.text != a.text) {
            for (var s = 0; i.text[s] == a.text[s]; s++) o++;

            return o;
          }

          if (i.content.size || a.content.size) {
            var l = t(i.content, a.content, o + 1);
            if (null != l) return l;
          }

          o += i.nodeSize;
        } else o += i.nodeSize;
      }
    }(this, t, e);
  }, ha.prototype.findDiffEnd = function (t, e, n) {
    return void 0 === e && (e = this.size), void 0 === n && (n = t.size), function t(e, n, o, r) {
      for (var i = e.childCount, a = n.childCount;;) {
        if (0 == i || 0 == a) return i == a ? null : {
          a: o,
          b: r
        };
        var s = e.child(--i),
            l = n.child(--a),
            c = s.nodeSize;

        if (s != l) {
          if (!s.sameMarkup(l)) return {
            a: o,
            b: r
          };

          if (s.isText && s.text != l.text) {
            for (var p = 0, u = Math.min(s.text.length, l.text.length); p < u && s.text[s.text.length - p - 1] == l.text[l.text.length - p - 1];) p++, o--, r--;

            return {
              a: o,
              b: r
            };
          }

          if (s.content.size || l.content.size) {
            var f = t(s.content, l.content, o - 1, r - 1);
            if (f) return f;
          }

          o -= c, r -= c;
        } else o -= c, r -= c;
      }
    }(this, t, e, n);
  }, ha.prototype.findIndex = function (t, e) {
    if (void 0 === e && (e = -1), 0 == t) return ga(0, t);
    if (t == this.size) return ga(this.content.length, t);
    if (t > this.size || t < 0) throw new RangeError("Position " + t + " outside of fragment (" + this + ")");

    for (var n = 0, o = 0;; n++) {
      var r = o + this.child(n).nodeSize;
      if (r >= t) return r == t || e > 0 ? ga(n + 1, r) : ga(n, o);
      o = r;
    }
  }, ha.prototype.toString = function () {
    return "<" + this.toStringInner() + ">";
  }, ha.prototype.toStringInner = function () {
    return this.content.join(", ");
  }, ha.prototype.toJSON = function () {
    return this.content.length ? this.content.map(function (t) {
      return t.toJSON();
    }) : null;
  }, ha.fromJSON = function (t, e) {
    if (!e) return ha.empty;
    if (!Array.isArray(e)) throw new RangeError("Invalid input for Fragment.fromJSON");
    return new ha(e.map(t.nodeFromJSON));
  }, ha.fromArray = function (t) {
    if (!t.length) return ha.empty;

    for (var e, n = 0, o = 0; o < t.length; o++) {
      var r = t[o];
      n += r.nodeSize, o && r.isText && t[o - 1].sameMarkup(r) ? (e || (e = t.slice(0, o)), e[e.length - 1] = r.withText(e[e.length - 1].text + r.text)) : e && e.push(r);
    }

    return new ha(e || t, n);
  }, ha.from = function (t) {
    if (!t) return ha.empty;
    if (t instanceof ha) return t;
    if (Array.isArray(t)) return this.fromArray(t);
    if (t.attrs) return new ha([t], t.nodeSize);
    throw new RangeError("Can not convert " + t + " to a Fragment" + (t.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }, Object.defineProperties(ha.prototype, va);
  var ma = {
    index: 0,
    offset: 0
  };

  function ga(t, e) {
    return ma.index = t, ma.offset = e, ma;
  }

  function ya(t, e) {
    if (t === e) return !0;
    if (!t || "object" != typeof t || !e || "object" != typeof e) return !1;
    var n = Array.isArray(t);
    if (Array.isArray(e) != n) return !1;

    if (n) {
      if (t.length != e.length) return !1;

      for (var o = 0; o < t.length; o++) if (!ya(t[o], e[o])) return !1;
    } else {
      for (var r in t) if (!(r in e && ya(t[r], e[r]))) return !1;

      for (var i in e) if (!(i in t)) return !1;
    }

    return !0;
  }

  ha.empty = new ha([], 0);

  var ba = function (t, e) {
    this.type = t, this.attrs = e;
  };

  function wa(t) {
    var e = Error.call(this, t);
    return e.__proto__ = wa.prototype, e;
  }

  ba.prototype.addToSet = function (t) {
    for (var e, n = !1, o = 0; o < t.length; o++) {
      var r = t[o];
      if (this.eq(r)) return t;
      if (this.type.excludes(r.type)) e || (e = t.slice(0, o));else {
        if (r.type.excludes(this.type)) return t;
        !n && r.type.rank > this.type.rank && (e || (e = t.slice(0, o)), e.push(this), n = !0), e && e.push(r);
      }
    }

    return e || (e = t.slice()), n || e.push(this), e;
  }, ba.prototype.removeFromSet = function (t) {
    for (var e = 0; e < t.length; e++) if (this.eq(t[e])) return t.slice(0, e).concat(t.slice(e + 1));

    return t;
  }, ba.prototype.isInSet = function (t) {
    for (var e = 0; e < t.length; e++) if (this.eq(t[e])) return !0;

    return !1;
  }, ba.prototype.eq = function (t) {
    return this == t || this.type == t.type && ya(this.attrs, t.attrs);
  }, ba.prototype.toJSON = function () {
    var t = {
      type: this.type.name
    };

    for (var e in this.attrs) {
      t.attrs = this.attrs;
      break;
    }

    return t;
  }, ba.fromJSON = function (t, e) {
    if (!e) throw new RangeError("Invalid input for Mark.fromJSON");
    var n = t.marks[e.type];
    if (!n) throw new RangeError("There is no mark type " + e.type + " in this schema");
    return n.create(e.attrs);
  }, ba.sameSet = function (t, e) {
    if (t == e) return !0;
    if (t.length != e.length) return !1;

    for (var n = 0; n < t.length; n++) if (!t[n].eq(e[n])) return !1;

    return !0;
  }, ba.setFrom = function (t) {
    if (!t || 0 == t.length) return ba.none;
    if (t instanceof ba) return [t];
    var e = t.slice();
    return e.sort(function (t, e) {
      return t.type.rank - e.type.rank;
    }), e;
  }, ba.none = [], wa.prototype = Object.create(Error.prototype), wa.prototype.constructor = wa, wa.prototype.name = "ReplaceError";

  var Sa = function (t, e, n) {
    this.content = t, this.openStart = e, this.openEnd = n;
  },
      Ca = {
    size: {
      configurable: !0
    }
  };

  function xa(t, e, n) {
    if (n.openStart > t.depth) throw new wa("Inserted content deeper than insertion position");
    if (t.depth - n.openStart != e.depth - n.openEnd) throw new wa("Inconsistent open depths");
    return function t(e, n, o, r) {
      var i = e.index(r),
          a = e.node(r);

      if (i == n.index(r) && r < e.depth - o.openStart) {
        var s = t(e, n, o, r + 1);
        return a.copy(a.content.replaceChild(i, s));
      }

      if (o.content.size) {
        if (o.openStart || o.openEnd || e.depth != r || n.depth != r) {
          var l = function (t, e) {
            for (var n = e.depth - t.openStart, o = e.node(n).copy(t.content), r = n - 1; r >= 0; r--) o = e.node(r).copy(ha.from(o));

            return {
              start: o.resolveNoCache(t.openStart + n),
              end: o.resolveNoCache(o.content.size - t.openEnd - n)
            };
          }(o, e),
              c = l.start,
              p = l.end;

          return Ea(a, function t(e, n, o, r, i) {
            var a = e.depth > i && Oa(e, n, i + 1);
            var s = r.depth > i && Oa(o, r, i + 1);
            var l = [];
            Ta(null, e, i, l);
            a && s && n.index(i) == o.index(i) ? (ka(a, s), Aa(Ea(a, t(e, n, o, r, i + 1)), l)) : (a && Aa(Ea(a, Ma(e, n, i + 1)), l), Ta(n, o, i, l), s && Aa(Ea(s, Ma(o, r, i + 1)), l));
            Ta(r, null, i, l);
            return new ha(l);
          }(e, c, p, n, r));
        }

        var u = e.parent,
            f = u.content;
        return Ea(u, f.cut(0, e.parentOffset).append(o.content).append(f.cut(n.parentOffset)));
      }

      return Ea(a, Ma(e, n, r));
    }(t, e, n, 0);
  }

  function ka(t, e) {
    if (!e.type.compatibleContent(t.type)) throw new wa("Cannot join " + e.type.name + " onto " + t.type.name);
  }

  function Oa(t, e, n) {
    var o = t.node(n);
    return ka(o, e.node(n)), o;
  }

  function Aa(t, e) {
    var n = e.length - 1;
    n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t);
  }

  function Ta(t, e, n, o) {
    var r = (e || t).node(n),
        i = 0,
        a = e ? e.index(n) : r.childCount;
    t && (i = t.index(n), t.depth > n ? i++ : t.textOffset && (Aa(t.nodeAfter, o), i++));

    for (var s = i; s < a; s++) Aa(r.child(s), o);

    e && e.depth == n && e.textOffset && Aa(e.nodeBefore, o);
  }

  function Ea(t, e) {
    if (!t.type.validContent(e)) throw new wa("Invalid content for node " + t.type.name);
    return t.copy(e);
  }

  function Ma(t, e, n) {
    var o = [];
    (Ta(null, t, n, o), t.depth > n) && Aa(Ea(Oa(t, e, n + 1), Ma(t, e, n + 1)), o);
    return Ta(e, null, n, o), new ha(o);
  }

  Ca.size.get = function () {
    return this.content.size - this.openStart - this.openEnd;
  }, Sa.prototype.insertAt = function (t, e) {
    var n = function t(e, n, o, r) {
      var i = e.findIndex(n);
      var a = i.index;
      var s = i.offset;
      var l = e.maybeChild(a);
      if (s == n || l.isText) return r && !r.canReplace(a, a, o) ? null : e.cut(0, n).append(o).append(e.cut(n));
      var c = t(l.content, n - s - 1, o);
      return c && e.replaceChild(a, l.copy(c));
    }(this.content, t + this.openStart, e, null);

    return n && new Sa(n, this.openStart, this.openEnd);
  }, Sa.prototype.removeBetween = function (t, e) {
    return new Sa(function t(e, n, o) {
      var r = e.findIndex(n);
      var i = r.index;
      var a = r.offset;
      var s = e.maybeChild(i);
      var l = e.findIndex(o);
      var c = l.index;
      var p = l.offset;

      if (a == n || s.isText) {
        if (p != o && !e.child(c).isText) throw new RangeError("Removing non-flat range");
        return e.cut(0, n).append(e.cut(o));
      }

      if (i != c) throw new RangeError("Removing non-flat range");
      return e.replaceChild(i, s.copy(t(s.content, n - a - 1, o - a - 1)));
    }(this.content, t + this.openStart, e + this.openStart), this.openStart, this.openEnd);
  }, Sa.prototype.eq = function (t) {
    return this.content.eq(t.content) && this.openStart == t.openStart && this.openEnd == t.openEnd;
  }, Sa.prototype.toString = function () {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }, Sa.prototype.toJSON = function () {
    if (!this.content.size) return null;
    var t = {
      content: this.content.toJSON()
    };
    return this.openStart > 0 && (t.openStart = this.openStart), this.openEnd > 0 && (t.openEnd = this.openEnd), t;
  }, Sa.fromJSON = function (t, e) {
    if (!e) return Sa.empty;
    var n = e.openStart || 0,
        o = e.openEnd || 0;
    if ("number" != typeof n || "number" != typeof o) throw new RangeError("Invalid input for Slice.fromJSON");
    return new Sa(ha.fromJSON(t, e.content), e.openStart || 0, e.openEnd || 0);
  }, Sa.maxOpen = function (t, e) {
    void 0 === e && (e = !0);

    for (var n = 0, o = 0, r = t.firstChild; r && !r.isLeaf && (e || !r.type.spec.isolating); r = r.firstChild) n++;

    for (var i = t.lastChild; i && !i.isLeaf && (e || !i.type.spec.isolating); i = i.lastChild) o++;

    return new Sa(t, n, o);
  }, Object.defineProperties(Sa.prototype, Ca), Sa.empty = new Sa(ha.empty, 0, 0);

  var Na = function (t, e, n) {
    this.pos = t, this.path = e, this.depth = e.length / 3 - 1, this.parentOffset = n;
  },
      Ra = {
    parent: {
      configurable: !0
    },
    doc: {
      configurable: !0
    },
    textOffset: {
      configurable: !0
    },
    nodeAfter: {
      configurable: !0
    },
    nodeBefore: {
      configurable: !0
    }
  };

  Na.prototype.resolveDepth = function (t) {
    return null == t ? this.depth : t < 0 ? this.depth + t : t;
  }, Ra.parent.get = function () {
    return this.node(this.depth);
  }, Ra.doc.get = function () {
    return this.node(0);
  }, Na.prototype.node = function (t) {
    return this.path[3 * this.resolveDepth(t)];
  }, Na.prototype.index = function (t) {
    return this.path[3 * this.resolveDepth(t) + 1];
  }, Na.prototype.indexAfter = function (t) {
    return t = this.resolveDepth(t), this.index(t) + (t != this.depth || this.textOffset ? 1 : 0);
  }, Na.prototype.start = function (t) {
    return 0 == (t = this.resolveDepth(t)) ? 0 : this.path[3 * t - 1] + 1;
  }, Na.prototype.end = function (t) {
    return t = this.resolveDepth(t), this.start(t) + this.node(t).content.size;
  }, Na.prototype.before = function (t) {
    if (!(t = this.resolveDepth(t))) throw new RangeError("There is no position before the top-level node");
    return t == this.depth + 1 ? this.pos : this.path[3 * t - 1];
  }, Na.prototype.after = function (t) {
    if (!(t = this.resolveDepth(t))) throw new RangeError("There is no position after the top-level node");
    return t == this.depth + 1 ? this.pos : this.path[3 * t - 1] + this.path[3 * t].nodeSize;
  }, Ra.textOffset.get = function () {
    return this.pos - this.path[this.path.length - 1];
  }, Ra.nodeAfter.get = function () {
    var t = this.parent,
        e = this.index(this.depth);
    if (e == t.childCount) return null;
    var n = this.pos - this.path[this.path.length - 1],
        o = t.child(e);
    return n ? t.child(e).cut(n) : o;
  }, Ra.nodeBefore.get = function () {
    var t = this.index(this.depth),
        e = this.pos - this.path[this.path.length - 1];
    return e ? this.parent.child(t).cut(0, e) : 0 == t ? null : this.parent.child(t - 1);
  }, Na.prototype.marks = function () {
    var t = this.parent,
        e = this.index();
    if (0 == t.content.size) return ba.none;
    if (this.textOffset) return t.child(e).marks;
    var n = t.maybeChild(e - 1),
        o = t.maybeChild(e);

    if (!n) {
      var r = n;
      n = o, o = r;
    }

    for (var i = n.marks, a = 0; a < i.length; a++) !1 !== i[a].type.spec.inclusive || o && i[a].isInSet(o.marks) || (i = i[a--].removeFromSet(i));

    return i;
  }, Na.prototype.marksAcross = function (t) {
    var e = this.parent.maybeChild(this.index());
    if (!e || !e.isInline) return null;

    for (var n = e.marks, o = t.parent.maybeChild(t.index()), r = 0; r < n.length; r++) !1 !== n[r].type.spec.inclusive || o && n[r].isInSet(o.marks) || (n = n[r--].removeFromSet(n));

    return n;
  }, Na.prototype.sharedDepth = function (t) {
    for (var e = this.depth; e > 0; e--) if (this.start(e) <= t && this.end(e) >= t) return e;

    return 0;
  }, Na.prototype.blockRange = function (t, e) {
    if (void 0 === t && (t = this), t.pos < this.pos) return t.blockRange(this);

    for (var n = this.depth - (this.parent.inlineContent || this.pos == t.pos ? 1 : 0); n >= 0; n--) if (t.pos <= this.end(n) && (!e || e(this.node(n)))) return new Da(this, t, n);
  }, Na.prototype.sameParent = function (t) {
    return this.pos - this.parentOffset == t.pos - t.parentOffset;
  }, Na.prototype.max = function (t) {
    return t.pos > this.pos ? t : this;
  }, Na.prototype.min = function (t) {
    return t.pos < this.pos ? t : this;
  }, Na.prototype.toString = function () {
    for (var t = "", e = 1; e <= this.depth; e++) t += (t ? "/" : "") + this.node(e).type.name + "_" + this.index(e - 1);

    return t + ":" + this.parentOffset;
  }, Na.resolve = function (t, e) {
    if (!(e >= 0 && e <= t.content.size)) throw new RangeError("Position " + e + " out of range");

    for (var n = [], o = 0, r = e, i = t;;) {
      var a = i.content.findIndex(r),
          s = a.index,
          l = a.offset,
          c = r - l;
      if (n.push(i, s, o + l), !c) break;
      if ((i = i.child(s)).isText) break;
      r = c - 1, o += l + 1;
    }

    return new Na(e, n, r);
  }, Na.resolveCached = function (t, e) {
    for (var n = 0; n < La.length; n++) {
      var o = La[n];
      if (o.pos == e && o.doc == t) return o;
    }

    var r = La[Ia] = Na.resolve(t, e);
    return Ia = (Ia + 1) % Pa, r;
  }, Object.defineProperties(Na.prototype, Ra);

  var La = [],
      Ia = 0,
      Pa = 12,
      Da = function (t, e, n) {
    this.$from = t, this.$to = e, this.depth = n;
  },
      _a = {
    start: {
      configurable: !0
    },
    end: {
      configurable: !0
    },
    parent: {
      configurable: !0
    },
    startIndex: {
      configurable: !0
    },
    endIndex: {
      configurable: !0
    }
  };

  _a.start.get = function () {
    return this.$from.before(this.depth + 1);
  }, _a.end.get = function () {
    return this.$to.after(this.depth + 1);
  }, _a.parent.get = function () {
    return this.$from.node(this.depth);
  }, _a.startIndex.get = function () {
    return this.$from.index(this.depth);
  }, _a.endIndex.get = function () {
    return this.$to.indexAfter(this.depth);
  }, Object.defineProperties(Da.prototype, _a);

  var Ba = Object.create(null),
      Va = function (t, e, n, o) {
    this.type = t, this.attrs = e, this.content = n || ha.empty, this.marks = o || ba.none;
  },
      za = {
    nodeSize: {
      configurable: !0
    },
    childCount: {
      configurable: !0
    },
    textContent: {
      configurable: !0
    },
    firstChild: {
      configurable: !0
    },
    lastChild: {
      configurable: !0
    },
    isBlock: {
      configurable: !0
    },
    isTextblock: {
      configurable: !0
    },
    inlineContent: {
      configurable: !0
    },
    isInline: {
      configurable: !0
    },
    isText: {
      configurable: !0
    },
    isLeaf: {
      configurable: !0
    },
    isAtom: {
      configurable: !0
    }
  };

  za.nodeSize.get = function () {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }, za.childCount.get = function () {
    return this.content.childCount;
  }, Va.prototype.child = function (t) {
    return this.content.child(t);
  }, Va.prototype.maybeChild = function (t) {
    return this.content.maybeChild(t);
  }, Va.prototype.forEach = function (t) {
    this.content.forEach(t);
  }, Va.prototype.nodesBetween = function (t, e, n, o) {
    void 0 === o && (o = 0), this.content.nodesBetween(t, e, n, o, this);
  }, Va.prototype.descendants = function (t) {
    this.nodesBetween(0, this.content.size, t);
  }, za.textContent.get = function () {
    return this.textBetween(0, this.content.size, "");
  }, Va.prototype.textBetween = function (t, e, n, o) {
    return this.content.textBetween(t, e, n, o);
  }, za.firstChild.get = function () {
    return this.content.firstChild;
  }, za.lastChild.get = function () {
    return this.content.lastChild;
  }, Va.prototype.eq = function (t) {
    return this == t || this.sameMarkup(t) && this.content.eq(t.content);
  }, Va.prototype.sameMarkup = function (t) {
    return this.hasMarkup(t.type, t.attrs, t.marks);
  }, Va.prototype.hasMarkup = function (t, e, n) {
    return this.type == t && ya(this.attrs, e || t.defaultAttrs || Ba) && ba.sameSet(this.marks, n || ba.none);
  }, Va.prototype.copy = function (t) {
    return void 0 === t && (t = null), t == this.content ? this : new this.constructor(this.type, this.attrs, t, this.marks);
  }, Va.prototype.mark = function (t) {
    return t == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, t);
  }, Va.prototype.cut = function (t, e) {
    return 0 == t && e == this.content.size ? this : this.copy(this.content.cut(t, e));
  }, Va.prototype.slice = function (t, e, n) {
    if (void 0 === e && (e = this.content.size), void 0 === n && (n = !1), t == e) return Sa.empty;
    var o = this.resolve(t),
        r = this.resolve(e),
        i = n ? 0 : o.sharedDepth(e),
        a = o.start(i),
        s = o.node(i).content.cut(o.pos - a, r.pos - a);
    return new Sa(s, o.depth - i, r.depth - i);
  }, Va.prototype.replace = function (t, e, n) {
    return xa(this.resolve(t), this.resolve(e), n);
  }, Va.prototype.nodeAt = function (t) {
    for (var e = this;;) {
      var n = e.content.findIndex(t),
          o = n.index,
          r = n.offset;
      if (!(e = e.maybeChild(o))) return null;
      if (r == t || e.isText) return e;
      t -= r + 1;
    }
  }, Va.prototype.childAfter = function (t) {
    var e = this.content.findIndex(t),
        n = e.index,
        o = e.offset;
    return {
      node: this.content.maybeChild(n),
      index: n,
      offset: o
    };
  }, Va.prototype.childBefore = function (t) {
    if (0 == t) return {
      node: null,
      index: 0,
      offset: 0
    };
    var e = this.content.findIndex(t),
        n = e.index,
        o = e.offset;
    if (o < t) return {
      node: this.content.child(n),
      index: n,
      offset: o
    };
    var r = this.content.child(n - 1);
    return {
      node: r,
      index: n - 1,
      offset: o - r.nodeSize
    };
  }, Va.prototype.resolve = function (t) {
    return Na.resolveCached(this, t);
  }, Va.prototype.resolveNoCache = function (t) {
    return Na.resolve(this, t);
  }, Va.prototype.rangeHasMark = function (t, e, n) {
    var o = !1;
    return e > t && this.nodesBetween(t, e, function (t) {
      return n.isInSet(t.marks) && (o = !0), !o;
    }), o;
  }, za.isBlock.get = function () {
    return this.type.isBlock;
  }, za.isTextblock.get = function () {
    return this.type.isTextblock;
  }, za.inlineContent.get = function () {
    return this.type.inlineContent;
  }, za.isInline.get = function () {
    return this.type.isInline;
  }, za.isText.get = function () {
    return this.type.isText;
  }, za.isLeaf.get = function () {
    return this.type.isLeaf;
  }, za.isAtom.get = function () {
    return this.type.isAtom;
  }, Va.prototype.toString = function () {
    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
    var t = this.type.name;
    return this.content.size && (t += "(" + this.content.toStringInner() + ")"), ja(this.marks, t);
  }, Va.prototype.contentMatchAt = function (t) {
    var e = this.type.contentMatch.matchFragment(this.content, 0, t);
    if (!e) throw new Error("Called contentMatchAt on a node with invalid content");
    return e;
  }, Va.prototype.canReplace = function (t, e, n, o, r) {
    void 0 === n && (n = ha.empty), void 0 === o && (o = 0), void 0 === r && (r = n.childCount);
    var i = this.contentMatchAt(t).matchFragment(n, o, r),
        a = i && i.matchFragment(this.content, e);
    if (!a || !a.validEnd) return !1;

    for (var s = o; s < r; s++) if (!this.type.allowsMarks(n.child(s).marks)) return !1;

    return !0;
  }, Va.prototype.canReplaceWith = function (t, e, n, o) {
    if (o && !this.type.allowsMarks(o)) return !1;
    var r = this.contentMatchAt(t).matchType(n),
        i = r && r.matchFragment(this.content, e);
    return !!i && i.validEnd;
  }, Va.prototype.canAppend = function (t) {
    return t.content.size ? this.canReplace(this.childCount, this.childCount, t.content) : this.type.compatibleContent(t.type);
  }, Va.prototype.defaultContentType = function (t) {
    return this.contentMatchAt(t).defaultType;
  }, Va.prototype.check = function () {
    if (!this.type.validContent(this.content)) throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
    this.content.forEach(function (t) {
      return t.check();
    });
  }, Va.prototype.toJSON = function () {
    var t = {
      type: this.type.name
    };

    for (var e in this.attrs) {
      t.attrs = this.attrs;
      break;
    }

    return this.content.size && (t.content = this.content.toJSON()), this.marks.length && (t.marks = this.marks.map(function (t) {
      return t.toJSON();
    })), t;
  }, Va.fromJSON = function (t, e) {
    if (!e) throw new RangeError("Invalid input for Node.fromJSON");
    var n = null;

    if (e.marks) {
      if (!Array.isArray(e.marks)) throw new RangeError("Invalid mark data for Node.fromJSON");
      n = e.marks.map(t.markFromJSON);
    }

    if ("text" == e.type) {
      if ("string" != typeof e.text) throw new RangeError("Invalid text node in JSON");
      return t.text(e.text, n);
    }

    var o = ha.fromJSON(t, e.content);
    return t.nodeType(e.type).create(e.attrs, o, n);
  }, Object.defineProperties(Va.prototype, za);

  var $a = function (t) {
    function e(e, n, o, r) {
      if (t.call(this, e, n, null, r), !o) throw new RangeError("Empty text nodes are not allowed");
      this.text = o;
    }

    t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
    var n = {
      textContent: {
        configurable: !0
      },
      nodeSize: {
        configurable: !0
      }
    };
    return e.prototype.toString = function () {
      return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : ja(this.marks, JSON.stringify(this.text));
    }, n.textContent.get = function () {
      return this.text;
    }, e.prototype.textBetween = function (t, e) {
      return this.text.slice(t, e);
    }, n.nodeSize.get = function () {
      return this.text.length;
    }, e.prototype.mark = function (t) {
      return t == this.marks ? this : new e(this.type, this.attrs, this.text, t);
    }, e.prototype.withText = function (t) {
      return t == this.text ? this : new e(this.type, this.attrs, t, this.marks);
    }, e.prototype.cut = function (t, e) {
      return void 0 === t && (t = 0), void 0 === e && (e = this.text.length), 0 == t && e == this.text.length ? this : this.withText(this.text.slice(t, e));
    }, e.prototype.eq = function (t) {
      return this.sameMarkup(t) && this.text == t.text;
    }, e.prototype.toJSON = function () {
      var e = t.prototype.toJSON.call(this);
      return e.text = this.text, e;
    }, Object.defineProperties(e.prototype, n), e;
  }(Va);

  function ja(t, e) {
    for (var n = t.length - 1; n >= 0; n--) e = t[n].type.name + "(" + e + ")";

    return e;
  }

  var Ha = function (t) {
    this.validEnd = t, this.next = [], this.wrapCache = [];
  },
      Fa = {
    inlineContent: {
      configurable: !0
    },
    defaultType: {
      configurable: !0
    },
    edgeCount: {
      configurable: !0
    }
  };

  Ha.parse = function (t, e) {
    var n = new qa(t, e);
    if (null == n.next) return Ha.empty;
    var o = Wa(n);
    n.next && n.err("Unexpected trailing text");

    var r = function (t) {
      var e = Object.create(null);
      return function n(o) {
        var r = [];
        o.forEach(function (e) {
          t[e].forEach(function (e) {
            var n = e.term,
                o = e.to;

            if (n) {
              var i = r.indexOf(n),
                  a = i > -1 && r[i + 1];
              Za(t, o).forEach(function (t) {
                a || r.push(n, a = []), -1 == a.indexOf(t) && a.push(t);
              });
            }
          });
        });
        var i = e[o.join(",")] = new Ha(o.indexOf(t.length - 1) > -1);

        for (var a = 0; a < r.length; a += 2) {
          var s = r[a + 1].sort(Ya);
          i.next.push(r[a], e[s.join(",")] || n(s));
        }

        return i;
      }(Za(t, 0));
    }(function (t) {
      var e = [[]];
      return r(function t(e, i) {
        if ("choice" == e.type) return e.exprs.reduce(function (e, n) {
          return e.concat(t(n, i));
        }, []);
        if ("seq" == e.type) for (var a = 0;; a++) {
          var s = t(e.exprs[a], i);
          if (a == e.exprs.length - 1) return s;
          r(s, i = n());
        } else {
          if ("star" == e.type) {
            var l = n();
            return o(i, l), r(t(e.expr, l), l), [o(l)];
          }

          if ("plus" == e.type) {
            var c = n();
            return r(t(e.expr, i), c), r(t(e.expr, c), c), [o(c)];
          }

          if ("opt" == e.type) return [o(i)].concat(t(e.expr, i));

          if ("range" == e.type) {
            for (var p = i, u = 0; u < e.min; u++) {
              var f = n();
              r(t(e.expr, p), f), p = f;
            }

            if (-1 == e.max) r(t(e.expr, p), p);else for (var d = e.min; d < e.max; d++) {
              var h = n();
              o(p, h), r(t(e.expr, p), h), p = h;
            }
            return [o(p)];
          }

          if ("name" == e.type) return [o(i, null, e.value)];
        }
      }(t, 0), n()), e;

      function n() {
        return e.push([]) - 1;
      }

      function o(t, n, o) {
        var r = {
          term: o,
          to: n
        };
        return e[t].push(r), r;
      }

      function r(t, e) {
        t.forEach(function (t) {
          return t.to = e;
        });
      }
    }(o));

    return function (t, e) {
      for (var n = 0, o = [t]; n < o.length; n++) {
        for (var r = o[n], i = !r.validEnd, a = [], s = 0; s < r.next.length; s += 2) {
          var l = r.next[s],
              c = r.next[s + 1];
          a.push(l.name), !i || l.isText || l.hasRequiredAttrs() || (i = !1), -1 == o.indexOf(c) && o.push(c);
        }

        i && e.err("Only non-generatable nodes (" + a.join(", ") + ") in a required position");
      }
    }(r, n), r;
  }, Ha.prototype.matchType = function (t) {
    for (var e = 0; e < this.next.length; e += 2) if (this.next[e] == t) return this.next[e + 1];

    return null;
  }, Ha.prototype.matchFragment = function (t, e, n) {
    void 0 === e && (e = 0), void 0 === n && (n = t.childCount);

    for (var o = this, r = e; o && r < n; r++) o = o.matchType(t.child(r).type);

    return o;
  }, Fa.inlineContent.get = function () {
    var t = this.next[0];
    return !!t && t.isInline;
  }, Fa.defaultType.get = function () {
    for (var t = 0; t < this.next.length; t += 2) {
      var e = this.next[t];
      if (!e.isText && !e.hasRequiredAttrs()) return e;
    }
  }, Ha.prototype.compatible = function (t) {
    for (var e = 0; e < this.next.length; e += 2) for (var n = 0; n < t.next.length; n += 2) if (this.next[e] == t.next[n]) return !0;

    return !1;
  }, Ha.prototype.fillBefore = function (t, e, n) {
    void 0 === e && (e = !1), void 0 === n && (n = 0);
    var o = [this];
    return function r(i, a) {
      var s = i.matchFragment(t, n);
      if (s && (!e || s.validEnd)) return ha.from(a.map(function (t) {
        return t.createAndFill();
      }));

      for (var l = 0; l < i.next.length; l += 2) {
        var c = i.next[l],
            p = i.next[l + 1];

        if (!c.isText && !c.hasRequiredAttrs() && -1 == o.indexOf(p)) {
          o.push(p);
          var u = r(p, a.concat(c));
          if (u) return u;
        }
      }
    }(this, []);
  }, Ha.prototype.findWrapping = function (t) {
    for (var e = 0; e < this.wrapCache.length; e += 2) if (this.wrapCache[e] == t) return this.wrapCache[e + 1];

    var n = this.computeWrapping(t);
    return this.wrapCache.push(t, n), n;
  }, Ha.prototype.computeWrapping = function (t) {
    for (var e = Object.create(null), n = [{
      match: this,
      type: null,
      via: null
    }]; n.length;) {
      var o = n.shift(),
          r = o.match;

      if (r.matchType(t)) {
        for (var i = [], a = o; a.type; a = a.via) i.push(a.type);

        return i.reverse();
      }

      for (var s = 0; s < r.next.length; s += 2) {
        var l = r.next[s];
        l.isLeaf || l.hasRequiredAttrs() || l.name in e || o.type && !r.next[s + 1].validEnd || (n.push({
          match: l.contentMatch,
          type: l,
          via: o
        }), e[l.name] = !0);
      }
    }
  }, Fa.edgeCount.get = function () {
    return this.next.length >> 1;
  }, Ha.prototype.edge = function (t) {
    var e = t << 1;
    if (e >= this.next.length) throw new RangeError("There's no " + t + "th edge in this content match");
    return {
      type: this.next[e],
      next: this.next[e + 1]
    };
  }, Ha.prototype.toString = function () {
    var t = [];
    return function e(n) {
      t.push(n);

      for (var o = 1; o < n.next.length; o += 2) -1 == t.indexOf(n.next[o]) && e(n.next[o]);
    }(this), t.map(function (e, n) {
      for (var o = n + (e.validEnd ? "*" : " ") + " ", r = 0; r < e.next.length; r += 2) o += (r ? ", " : "") + e.next[r].name + "->" + t.indexOf(e.next[r + 1]);

      return o;
    }).join("\n");
  }, Object.defineProperties(Ha.prototype, Fa), Ha.empty = new Ha(!0);

  var qa = function (t, e) {
    this.string = t, this.nodeTypes = e, this.inline = null, this.pos = 0, this.tokens = t.split(/\s*(?=\b|\W|$)/), "" == this.tokens[this.tokens.length - 1] && this.tokens.pop(), "" == this.tokens[0] && this.tokens.unshift();
  },
      Ua = {
    next: {
      configurable: !0
    }
  };

  function Wa(t) {
    var e = [];

    do {
      e.push(Ka(t));
    } while (t.eat("|"));

    return 1 == e.length ? e[0] : {
      type: "choice",
      exprs: e
    };
  }

  function Ka(t) {
    var e = [];

    do {
      e.push(Ja(t));
    } while (t.next && ")" != t.next && "|" != t.next);

    return 1 == e.length ? e[0] : {
      type: "seq",
      exprs: e
    };
  }

  function Ja(t) {
    for (var e = function (t) {
      if (t.eat("(")) {
        var e = Wa(t);
        return t.eat(")") || t.err("Missing closing paren"), e;
      }

      if (!/\W/.test(t.next)) {
        var n = function (t, e) {
          var n = t.nodeTypes,
              o = n[e];
          if (o) return [o];
          var r = [];

          for (var i in n) {
            var a = n[i];
            a.groups.indexOf(e) > -1 && r.push(a);
          }

          0 == r.length && t.err("No node type or group '" + e + "' found");
          return r;
        }(t, t.next).map(function (e) {
          return null == t.inline ? t.inline = e.isInline : t.inline != e.isInline && t.err("Mixing inline and block content"), {
            type: "name",
            value: e
          };
        });

        return t.pos++, 1 == n.length ? n[0] : {
          type: "choice",
          exprs: n
        };
      }

      t.err("Unexpected token '" + t.next + "'");
    }(t);;) if (t.eat("+")) e = {
      type: "plus",
      expr: e
    };else if (t.eat("*")) e = {
      type: "star",
      expr: e
    };else if (t.eat("?")) e = {
      type: "opt",
      expr: e
    };else {
      if (!t.eat("{")) break;
      e = Xa(t, e);
    }

    return e;
  }

  function Ga(t) {
    /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
    var e = Number(t.next);
    return t.pos++, e;
  }

  function Xa(t, e) {
    var n = Ga(t),
        o = n;
    return t.eat(",") && (o = "}" != t.next ? Ga(t) : -1), t.eat("}") || t.err("Unclosed braced range"), {
      type: "range",
      min: n,
      max: o,
      expr: e
    };
  }

  function Ya(t, e) {
    return e - t;
  }

  function Za(t, e) {
    var n = [];
    return function e(o) {
      var r = t[o];
      if (1 == r.length && !r[0].term) return e(r[0].to);
      n.push(o);

      for (var i = 0; i < r.length; i++) {
        var a = r[i],
            s = a.term,
            l = a.to;
        s || -1 != n.indexOf(l) || e(l);
      }
    }(e), n.sort(Ya);
  }

  function Qa(t) {
    var e = Object.create(null);

    for (var n in t) {
      var o = t[n];
      if (!o.hasDefault) return null;
      e[n] = o.default;
    }

    return e;
  }

  function ts(t, e) {
    var n = Object.create(null);

    for (var o in t) {
      var r = e && e[o];

      if (void 0 === r) {
        var i = t[o];
        if (!i.hasDefault) throw new RangeError("No value supplied for attribute " + o);
        r = i.default;
      }

      n[o] = r;
    }

    return n;
  }

  function es(t) {
    var e = Object.create(null);
    if (t) for (var n in t) e[n] = new is(t[n]);
    return e;
  }

  Ua.next.get = function () {
    return this.tokens[this.pos];
  }, qa.prototype.eat = function (t) {
    return this.next == t && (this.pos++ || !0);
  }, qa.prototype.err = function (t) {
    throw new SyntaxError(t + " (in content expression '" + this.string + "')");
  }, Object.defineProperties(qa.prototype, Ua);

  var ns = function (t, e, n) {
    this.name = t, this.schema = e, this.spec = n, this.groups = n.group ? n.group.split(" ") : [], this.attrs = es(n.attrs), this.defaultAttrs = Qa(this.attrs), this.contentMatch = null, this.markSet = null, this.inlineContent = null, this.isBlock = !(n.inline || "text" == t), this.isText = "text" == t;
  },
      rs = {
    isInline: {
      configurable: !0
    },
    isTextblock: {
      configurable: !0
    },
    isLeaf: {
      configurable: !0
    },
    isAtom: {
      configurable: !0
    }
  };

  rs.isInline.get = function () {
    return !this.isBlock;
  }, rs.isTextblock.get = function () {
    return this.isBlock && this.inlineContent;
  }, rs.isLeaf.get = function () {
    return this.contentMatch == Ha.empty;
  }, rs.isAtom.get = function () {
    return this.isLeaf || this.spec.atom;
  }, ns.prototype.hasRequiredAttrs = function (t) {
    for (var e in this.attrs) if (this.attrs[e].isRequired && (!t || !(e in t))) return !0;

    return !1;
  }, ns.prototype.compatibleContent = function (t) {
    return this == t || this.contentMatch.compatible(t.contentMatch);
  }, ns.prototype.computeAttrs = function (t) {
    return !t && this.defaultAttrs ? this.defaultAttrs : ts(this.attrs, t);
  }, ns.prototype.create = function (t, e, n) {
    if (this.isText) throw new Error("NodeType.create can't construct text nodes");
    return new Va(this, this.computeAttrs(t), ha.from(e), ba.setFrom(n));
  }, ns.prototype.createChecked = function (t, e, n) {
    if (e = ha.from(e), !this.validContent(e)) throw new RangeError("Invalid content for node " + this.name);
    return new Va(this, this.computeAttrs(t), e, ba.setFrom(n));
  }, ns.prototype.createAndFill = function (t, e, n) {
    if (t = this.computeAttrs(t), (e = ha.from(e)).size) {
      var o = this.contentMatch.fillBefore(e);
      if (!o) return null;
      e = o.append(e);
    }

    var r = this.contentMatch.matchFragment(e).fillBefore(ha.empty, !0);
    return r ? new Va(this, t, e.append(r), ba.setFrom(n)) : null;
  }, ns.prototype.validContent = function (t) {
    var e = this.contentMatch.matchFragment(t);
    if (!e || !e.validEnd) return !1;

    for (var n = 0; n < t.childCount; n++) if (!this.allowsMarks(t.child(n).marks)) return !1;

    return !0;
  }, ns.prototype.allowsMarkType = function (t) {
    return null == this.markSet || this.markSet.indexOf(t) > -1;
  }, ns.prototype.allowsMarks = function (t) {
    if (null == this.markSet) return !0;

    for (var e = 0; e < t.length; e++) if (!this.allowsMarkType(t[e].type)) return !1;

    return !0;
  }, ns.prototype.allowedMarks = function (t) {
    if (null == this.markSet) return t;

    for (var e, n = 0; n < t.length; n++) this.allowsMarkType(t[n].type) ? e && e.push(t[n]) : e || (e = t.slice(0, n));

    return e ? e.length ? e : ba.empty : t;
  }, ns.compile = function (t, e) {
    var n = Object.create(null);
    t.forEach(function (t, o) {
      return n[t] = new ns(t, e, o);
    });
    var o = e.spec.topNode || "doc";
    if (!n[o]) throw new RangeError("Schema is missing its top node type ('" + o + "')");
    if (!n.text) throw new RangeError("Every schema needs a 'text' type");

    for (var r in n.text.attrs) throw new RangeError("The text node type should not have attributes");

    return n;
  }, Object.defineProperties(ns.prototype, rs);

  var is = function (t) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(t, "default"), this.default = t.default;
  },
      as = {
    isRequired: {
      configurable: !0
    }
  };

  as.isRequired.get = function () {
    return !this.hasDefault;
  }, Object.defineProperties(is.prototype, as);

  var ss = function (t, e, n, o) {
    this.name = t, this.schema = n, this.spec = o, this.attrs = es(o.attrs), this.rank = e, this.excluded = null;
    var r = Qa(this.attrs);
    this.instance = r && new ba(this, r);
  };

  ss.prototype.create = function (t) {
    return !t && this.instance ? this.instance : new ba(this, ts(this.attrs, t));
  }, ss.compile = function (t, e) {
    var n = Object.create(null),
        o = 0;
    return t.forEach(function (t, r) {
      return n[t] = new ss(t, o++, e, r);
    }), n;
  }, ss.prototype.removeFromSet = function (t) {
    for (var e = 0; e < t.length; e++) if (t[e].type == this) return t.slice(0, e).concat(t.slice(e + 1));

    return t;
  }, ss.prototype.isInSet = function (t) {
    for (var e = 0; e < t.length; e++) if (t[e].type == this) return t[e];
  }, ss.prototype.excludes = function (t) {
    return this.excluded.indexOf(t) > -1;
  };

  var ls = function (t) {
    for (var e in this.spec = {}, t) this.spec[e] = t[e];

    this.spec.nodes = da.from(t.nodes), this.spec.marks = da.from(t.marks), this.nodes = ns.compile(this.spec.nodes, this), this.marks = ss.compile(this.spec.marks, this);
    var n = Object.create(null);

    for (var o in this.nodes) {
      if (o in this.marks) throw new RangeError(o + " can not be both a node and a mark");
      var r = this.nodes[o],
          i = r.spec.content || "",
          a = r.spec.marks;
      r.contentMatch = n[i] || (n[i] = Ha.parse(i, this.nodes)), r.inlineContent = r.contentMatch.inlineContent, r.markSet = "_" == a ? null : a ? cs(this, a.split(" ")) : "" != a && r.inlineContent ? null : [];
    }

    for (var s in this.marks) {
      var l = this.marks[s],
          c = l.spec.excludes;
      l.excluded = null == c ? [l] : "" == c ? [] : cs(this, c.split(" "));
    }

    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached = Object.create(null), this.cached.wrappings = Object.create(null);
  };

  function cs(t, e) {
    for (var n = [], o = 0; o < e.length; o++) {
      var r = e[o],
          i = t.marks[r],
          a = i;
      if (i) n.push(i);else for (var s in t.marks) {
        var l = t.marks[s];
        ("_" == r || l.spec.group && l.spec.group.split(" ").indexOf(r) > -1) && n.push(a = l);
      }
      if (!a) throw new SyntaxError("Unknown mark type: '" + e[o] + "'");
    }

    return n;
  }

  ls.prototype.node = function (t, e, n, o) {
    if ("string" == typeof t) t = this.nodeType(t);else {
      if (!(t instanceof ns)) throw new RangeError("Invalid node type: " + t);
      if (t.schema != this) throw new RangeError("Node type from different schema used (" + t.name + ")");
    }
    return t.createChecked(e, n, o);
  }, ls.prototype.text = function (t, e) {
    var n = this.nodes.text;
    return new $a(n, n.defaultAttrs, t, ba.setFrom(e));
  }, ls.prototype.mark = function (t, e) {
    return "string" == typeof t && (t = this.marks[t]), t.create(e);
  }, ls.prototype.nodeFromJSON = function (t) {
    return Va.fromJSON(this, t);
  }, ls.prototype.markFromJSON = function (t) {
    return ba.fromJSON(this, t);
  }, ls.prototype.nodeType = function (t) {
    var e = this.nodes[t];
    if (!e) throw new RangeError("Unknown node type: " + t);
    return e;
  };

  var ps = function (t, e) {
    var n = this;
    this.schema = t, this.rules = e, this.tags = [], this.styles = [], e.forEach(function (t) {
      t.tag ? n.tags.push(t) : t.style && n.styles.push(t);
    });
  };

  ps.prototype.parse = function (t, e) {
    void 0 === e && (e = {});
    var n = new ys(this, e, !1);
    return n.addAll(t, null, e.from, e.to), n.finish();
  }, ps.prototype.parseSlice = function (t, e) {
    void 0 === e && (e = {});
    var n = new ys(this, e, !0);
    return n.addAll(t, null, e.from, e.to), Sa.maxOpen(n.finish());
  }, ps.prototype.matchTag = function (t, e) {
    for (var n = 0; n < this.tags.length; n++) {
      var o = this.tags[n];

      if (ws(t, o.tag) && (void 0 === o.namespace || t.namespaceURI == o.namespace) && (!o.context || e.matchesContext(o.context))) {
        if (o.getAttrs) {
          var r = o.getAttrs(t);
          if (!1 === r) continue;
          o.attrs = r;
        }

        return o;
      }
    }
  }, ps.prototype.matchStyle = function (t, e, n) {
    for (var o = 0; o < this.styles.length; o++) {
      var r = this.styles[o];

      if (!(0 != r.style.indexOf(t) || r.context && !n.matchesContext(r.context) || r.style.length > t.length && (61 != r.style.charCodeAt(t.length) || r.style.slice(t.length + 1) != e))) {
        if (r.getAttrs) {
          var i = r.getAttrs(e);
          if (!1 === i) continue;
          r.attrs = i;
        }

        return r;
      }
    }
  }, ps.schemaRules = function (t) {
    var e = [];

    function n(t) {
      for (var n = null == t.priority ? 50 : t.priority, o = 0; o < e.length; o++) {
        var r = e[o];
        if ((null == r.priority ? 50 : r.priority) < n) break;
      }

      e.splice(o, 0, t);
    }

    var o = function (e) {
      var o = t.marks[e].spec.parseDOM;
      o && o.forEach(function (t) {
        n(t = Ss(t)), t.mark = e;
      });
    };

    for (var r in t.marks) o(r);

    var i;

    for (var a in t.nodes) i = void 0, (i = t.nodes[a].spec.parseDOM) && i.forEach(function (t) {
      n(t = Ss(t)), t.node = a;
    });

    return e;
  }, ps.fromSchema = function (t) {
    return t.cached.domParser || (t.cached.domParser = new ps(t, ps.schemaRules(t)));
  };
  var us = {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    canvas: !0,
    dd: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    figcaption: !0,
    figure: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    li: !0,
    noscript: !0,
    ol: !0,
    output: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    tfoot: !0,
    ul: !0
  },
      fs = {
    head: !0,
    noscript: !0,
    object: !0,
    script: !0,
    style: !0,
    title: !0
  },
      ds = {
    ol: !0,
    ul: !0
  },
      hs = 1,
      vs = 2;

  function ms(t) {
    return (t ? hs : 0) | ("full" === t ? vs : 0);
  }

  var gs = function (t, e, n, o, r, i) {
    this.type = t, this.attrs = e, this.solid = o, this.match = r || (4 & i ? null : t.contentMatch), this.options = i, this.content = [], this.marks = n, this.activeMarks = ba.none;
  };

  gs.prototype.findWrapping = function (t) {
    if (!this.match) {
      if (!this.type) return [];
      var e = this.type.contentMatch.fillBefore(ha.from(t));

      if (!e) {
        var n,
            o = this.type.contentMatch;
        return (n = o.findWrapping(t.type)) ? (this.match = o, n) : null;
      }

      this.match = this.type.contentMatch.matchFragment(e);
    }

    return this.match.findWrapping(t.type);
  }, gs.prototype.finish = function (t) {
    if (!(this.options & hs)) {
      var e,
          n = this.content[this.content.length - 1];
      n && n.isText && (e = /[ \t\r\n\u000c]+$/.exec(n.text)) && (n.text.length == e[0].length ? this.content.pop() : this.content[this.content.length - 1] = n.withText(n.text.slice(0, n.text.length - e[0].length)));
    }

    var o = ha.from(this.content);
    return !t && this.match && (o = o.append(this.match.fillBefore(ha.empty, !0))), this.type ? this.type.create(this.attrs, o, this.marks) : o;
  };

  var ys = function (t, e, n) {
    this.parser = t, this.options = e, this.isOpen = n, this.pendingMarks = [];
    var o,
        r = e.topNode,
        i = ms(e.preserveWhitespace) | (n ? 4 : 0);
    o = r ? new gs(r.type, r.attrs, ba.none, !0, e.topMatch || r.type.contentMatch, i) : new gs(n ? null : t.schema.topNodeType, null, ba.none, !0, null, i), this.nodes = [o], this.open = 0, this.find = e.findPositions, this.needsBlock = !1;
  },
      bs = {
    top: {
      configurable: !0
    },
    currentPos: {
      configurable: !0
    }
  };

  function ws(t, e) {
    return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e);
  }

  function Ss(t) {
    var e = {};

    for (var n in t) e[n] = t[n];

    return e;
  }

  bs.top.get = function () {
    return this.nodes[this.open];
  }, ys.prototype.addDOM = function (t) {
    if (3 == t.nodeType) this.addTextNode(t);else if (1 == t.nodeType) {
      var e = t.getAttribute("style"),
          n = e ? this.readStyles(function (t) {
        var e,
            n = /\s*([\w-]+)\s*:\s*([^;]+)/g,
            o = [];

        for (; e = n.exec(t);) o.push(e[1], e[2].trim());

        return o;
      }(e)) : null;
      if (null != n) for (var o = 0; o < n.length; o++) this.addPendingMark(n[o]);
      if (this.addElement(t), null != n) for (var r = 0; r < n.length; r++) this.removePendingMark(n[r]);
    }
  }, ys.prototype.addTextNode = function (t) {
    var e = t.nodeValue,
        n = this.top;

    if ((n.type ? n.type.inlineContent : n.content.length && n.content[0].isInline) || /[^ \t\r\n\u000c]/.test(e)) {
      if (n.options & hs) n.options & vs || (e = e.replace(/\r?\n|\r/g, " "));else if (e = e.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(e) && this.open == this.nodes.length - 1) {
        var o = n.content[n.content.length - 1],
            r = t.previousSibling;
        (!o || r && "BR" == r.nodeName || o.isText && /[ \t\r\n\u000c]$/.test(o.text)) && (e = e.slice(1));
      }
      e && this.insertNode(this.parser.schema.text(e)), this.findInText(t);
    } else this.findInside(t);
  }, ys.prototype.addElement = function (t) {
    var e = t.nodeName.toLowerCase();
    ds.hasOwnProperty(e) && function (t) {
      for (var e = t.firstChild, n = null; e; e = e.nextSibling) {
        var o = 1 == e.nodeType ? e.nodeName.toLowerCase() : null;
        o && ds.hasOwnProperty(o) && n ? (n.appendChild(e), e = n) : "li" == o ? n = e : o && (n = null);
      }
    }(t);
    var n = this.options.ruleFromNode && this.options.ruleFromNode(t) || this.parser.matchTag(t, this);
    if (n ? n.ignore : fs.hasOwnProperty(e)) this.findInside(t);else if (!n || n.skip) {
      n && n.skip.nodeType && (t = n.skip);
      var o,
          r = this.top,
          i = this.needsBlock;
      if (us.hasOwnProperty(e)) o = !0, r.type || (this.needsBlock = !0);else if (!t.firstChild) return void this.leafFallback(t);
      this.addAll(t), o && this.sync(r), this.needsBlock = i;
    } else this.addElementByRule(t, n);
  }, ys.prototype.leafFallback = function (t) {
    "BR" == t.nodeName && this.top.type && this.top.type.inlineContent && this.addTextNode(t.ownerDocument.createTextNode("\n"));
  }, ys.prototype.readStyles = function (t) {
    for (var e = ba.none, n = 0; n < t.length; n += 2) {
      var o = this.parser.matchStyle(t[n], t[n + 1], this);

      if (o) {
        if (o.ignore) return null;
        e = this.parser.schema.marks[o.mark].create(o.attrs).addToSet(e);
      }
    }

    return e;
  }, ys.prototype.addElementByRule = function (t, e) {
    var n,
        o,
        r,
        i = this;
    e.node ? (o = this.parser.schema.nodes[e.node]).isLeaf ? this.insertNode(o.create(e.attrs)) || this.leafFallback(t) : n = this.enter(o, e.attrs, e.preserveWhitespace) : (r = this.parser.schema.marks[e.mark].create(e.attrs), this.addPendingMark(r));
    var a = this.top;
    if (o && o.isLeaf) this.findInside(t);else if (e.getContent) this.findInside(t), e.getContent(t, this.parser.schema).forEach(function (t) {
      return i.insertNode(t);
    });else {
      var s = e.contentElement;
      "string" == typeof s ? s = t.querySelector(s) : "function" == typeof s && (s = s(t)), s || (s = t), this.findAround(t, s, !0), this.addAll(s, n);
    }
    n && (this.sync(a), this.open--), r && this.removePendingMark(r);
  }, ys.prototype.addAll = function (t, e, n, o) {
    for (var r = n || 0, i = n ? t.childNodes[n] : t.firstChild, a = null == o ? null : t.childNodes[o]; i != a; i = i.nextSibling, ++r) this.findAtPoint(t, r), this.addDOM(i), e && us.hasOwnProperty(i.nodeName.toLowerCase()) && this.sync(e);

    this.findAtPoint(t, r);
  }, ys.prototype.findPlace = function (t) {
    for (var e, n, o = this.open; o >= 0; o--) {
      var r = this.nodes[o],
          i = r.findWrapping(t);
      if (i && (!e || e.length > i.length) && (e = i, n = r, !i.length)) break;
      if (r.solid) break;
    }

    if (!e) return !1;
    this.sync(n);

    for (var a = 0; a < e.length; a++) this.enterInner(e[a], null, !1);

    return !0;
  }, ys.prototype.insertNode = function (t) {
    if (t.isInline && this.needsBlock && !this.top.type) {
      var e = this.textblockFromContext();
      e && this.enterInner(e);
    }

    if (this.findPlace(t)) {
      this.closeExtra();
      var n = this.top;
      this.applyPendingMarks(n), n.match && (n.match = n.match.matchType(t.type));

      for (var o = n.activeMarks, r = 0; r < t.marks.length; r++) n.type && !n.type.allowsMarkType(t.marks[r].type) || (o = t.marks[r].addToSet(o));

      return n.content.push(t.mark(o)), !0;
    }

    return !1;
  }, ys.prototype.applyPendingMarks = function (t) {
    for (var e = 0; e < this.pendingMarks.length; e++) {
      var n = this.pendingMarks[e];
      t.type && !t.type.allowsMarkType(n.type) || n.isInSet(t.activeMarks) || (t.activeMarks = n.addToSet(t.activeMarks), this.pendingMarks.splice(e--, 1));
    }
  }, ys.prototype.enter = function (t, e, n) {
    var o = this.findPlace(t.create(e));
    return o && (this.applyPendingMarks(this.top), this.enterInner(t, e, !0, n)), o;
  }, ys.prototype.enterInner = function (t, e, n, o) {
    this.closeExtra();
    var r = this.top;
    r.match = r.match && r.match.matchType(t, e);
    var i = null == o ? -5 & r.options : ms(o);
    4 & r.options && 0 == r.content.length && (i |= 4), this.nodes.push(new gs(t, e, r.activeMarks, n, null, i)), this.open++;
  }, ys.prototype.closeExtra = function (t) {
    var e = this.nodes.length - 1;

    if (e > this.open) {
      for (; e > this.open; e--) this.nodes[e - 1].content.push(this.nodes[e].finish(t));

      this.nodes.length = this.open + 1;
    }
  }, ys.prototype.finish = function () {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }, ys.prototype.sync = function (t) {
    for (var e = this.open; e >= 0; e--) if (this.nodes[e] == t) return void (this.open = e);
  }, ys.prototype.addPendingMark = function (t) {
    this.pendingMarks.push(t);
  }, ys.prototype.removePendingMark = function (t) {
    var e = this.pendingMarks.lastIndexOf(t);
    if (e > -1) this.pendingMarks.splice(e, 1);else {
      var n = this.top;
      n.activeMarks = t.removeFromSet(n.activeMarks);
    }
  }, bs.currentPos.get = function () {
    this.closeExtra();

    for (var t = 0, e = this.open; e >= 0; e--) {
      for (var n = this.nodes[e].content, o = n.length - 1; o >= 0; o--) t += n[o].nodeSize;

      e && t++;
    }

    return t;
  }, ys.prototype.findAtPoint = function (t, e) {
    if (this.find) for (var n = 0; n < this.find.length; n++) this.find[n].node == t && this.find[n].offset == e && (this.find[n].pos = this.currentPos);
  }, ys.prototype.findInside = function (t) {
    if (this.find) for (var e = 0; e < this.find.length; e++) null == this.find[e].pos && 1 == t.nodeType && t.contains(this.find[e].node) && (this.find[e].pos = this.currentPos);
  }, ys.prototype.findAround = function (t, e, n) {
    if (t != e && this.find) for (var o = 0; o < this.find.length; o++) {
      if (null == this.find[o].pos && 1 == t.nodeType && t.contains(this.find[o].node)) e.compareDocumentPosition(this.find[o].node) & (n ? 2 : 4) && (this.find[o].pos = this.currentPos);
    }
  }, ys.prototype.findInText = function (t) {
    if (this.find) for (var e = 0; e < this.find.length; e++) this.find[e].node == t && (this.find[e].pos = this.currentPos - (t.nodeValue.length - this.find[e].offset));
  }, ys.prototype.matchesContext = function (t) {
    var e = this;
    if (t.indexOf("|") > -1) return t.split(/\s*\|\s*/).some(this.matchesContext, this);

    var n = t.split("/"),
        o = this.options.context,
        r = !(this.isOpen || o && o.parent.type != this.nodes[0].type),
        i = -(o ? o.depth + 1 : 0) + (r ? 0 : 1),
        a = function (t, s) {
      for (; t >= 0; t--) {
        var l = n[t];

        if ("" == l) {
          if (t == n.length - 1 || 0 == t) continue;

          for (; s >= i; s--) if (a(t - 1, s)) return !0;

          return !1;
        }

        var c = s > 0 || 0 == s && r ? e.nodes[s].type : o && s >= i ? o.node(s - i).type : null;
        if (!c || c.name != l && -1 == c.groups.indexOf(l)) return !1;
        s--;
      }

      return !0;
    };

    return a(n.length - 1, this.open);
  }, ys.prototype.textblockFromContext = function () {
    var t = this.options.context;
    if (t) for (var e = t.depth; e >= 0; e--) {
      var n = t.node(e).contentMatchAt(t.indexAfter(e)).defaultType;
      if (n && n.isTextblock && n.defaultAttrs) return n;
    }

    for (var o in this.parser.schema.nodes) {
      var r = this.parser.schema.nodes[o];
      if (r.isTextblock && r.defaultAttrs) return r;
    }
  }, Object.defineProperties(ys.prototype, bs);

  var Cs = function (t, e) {
    this.nodes = t || {}, this.marks = e || {};
  };

  function xs(t) {
    var e = {};

    for (var n in t) {
      var o = t[n].spec.toDOM;
      o && (e[n] = o);
    }

    return e;
  }

  function ks(t) {
    return t.document || window.document;
  }

  Cs.prototype.serializeFragment = function (t, e, n) {
    var o = this;
    void 0 === e && (e = {}), n || (n = ks(e).createDocumentFragment());
    var r = n,
        i = null;
    return t.forEach(function (t) {
      if (i || t.marks.length) {
        i || (i = []);

        for (var n = 0, a = 0; n < i.length && a < t.marks.length;) {
          var s = t.marks[a];

          if (o.marks[s.type.name]) {
            if (!s.eq(i[n]) || !1 === s.type.spec.spanning) break;
            n += 2, a++;
          } else a++;
        }

        for (; n < i.length;) r = i.pop(), i.pop();

        for (; a < t.marks.length;) {
          var l = t.marks[a++],
              c = o.serializeMark(l, t.isInline, e);
          c && (i.push(l, r), r.appendChild(c.dom), r = c.contentDOM || c.dom);
        }
      }

      r.appendChild(o.serializeNode(t, e));
    }), n;
  }, Cs.prototype.serializeNode = function (t, e) {
    void 0 === e && (e = {});
    var n = Cs.renderSpec(ks(e), this.nodes[t.type.name](t)),
        o = n.dom,
        r = n.contentDOM;

    if (r) {
      if (t.isLeaf) throw new RangeError("Content hole not allowed in a leaf node spec");
      e.onContent ? e.onContent(t, r, e) : this.serializeFragment(t.content, e, r);
    }

    return o;
  }, Cs.prototype.serializeNodeAndMarks = function (t, e) {
    void 0 === e && (e = {});

    for (var n = this.serializeNode(t, e), o = t.marks.length - 1; o >= 0; o--) {
      var r = this.serializeMark(t.marks[o], t.isInline, e);
      r && ((r.contentDOM || r.dom).appendChild(n), n = r.dom);
    }

    return n;
  }, Cs.prototype.serializeMark = function (t, e, n) {
    void 0 === n && (n = {});
    var o = this.marks[t.type.name];
    return o && Cs.renderSpec(ks(n), o(t, e));
  }, Cs.renderSpec = function (t, e) {
    if ("string" == typeof e) return {
      dom: t.createTextNode(e)
    };
    if (null != e.nodeType) return {
      dom: e
    };
    var n = t.createElement(e[0]),
        o = null,
        r = e[1],
        i = 1;
    if (r && "object" == typeof r && null == r.nodeType && !Array.isArray(r)) for (var a in i = 2, r) null != r[a] && n.setAttribute(a, r[a]);

    for (var s = i; s < e.length; s++) {
      var l = e[s];

      if (0 === l) {
        if (s < e.length - 1 || s > i) throw new RangeError("Content hole must be the only child of its parent node");
        return {
          dom: n,
          contentDOM: n
        };
      }

      var c = Cs.renderSpec(t, l),
          p = c.dom,
          u = c.contentDOM;

      if (n.appendChild(p), u) {
        if (o) throw new RangeError("Multiple content holes");
        o = u;
      }
    }

    return {
      dom: n,
      contentDOM: o
    };
  }, Cs.fromSchema = function (t) {
    return t.cached.domSerializer || (t.cached.domSerializer = new Cs(this.nodesFromSchema(t), this.marksFromSchema(t)));
  }, Cs.nodesFromSchema = function (t) {
    var e = xs(t.nodes);
    return e.text || (e.text = function (t) {
      return t.text;
    }), e;
  }, Cs.marksFromSchema = function (t) {
    return xs(t.marks);
  };
  var Os = Object.freeze({
    __proto__: null,
    ContentMatch: Ha,
    DOMParser: ps,
    DOMSerializer: Cs,
    Fragment: ha,
    Mark: ba,
    MarkType: ss,
    Node: Va,
    NodeRange: Da,
    NodeType: ns,
    ReplaceError: wa,
    ResolvedPos: Na,
    Schema: ls,
    Slice: Sa
  }),
      As = 65535,
      Ts = Math.pow(2, 16);

  function Es(t) {
    return t & As;
  }

  var Ms = function (t, e, n) {
    void 0 === e && (e = !1), void 0 === n && (n = null), this.pos = t, this.deleted = e, this.recover = n;
  },
      Ns = function (t, e) {
    void 0 === e && (e = !1), this.ranges = t, this.inverted = e;
  };

  Ns.prototype.recover = function (t) {
    var e = 0,
        n = Es(t);
    if (!this.inverted) for (var o = 0; o < n; o++) e += this.ranges[3 * o + 2] - this.ranges[3 * o + 1];
    return this.ranges[3 * n] + e + function (t) {
      return (t - (t & As)) / Ts;
    }(t);
  }, Ns.prototype.mapResult = function (t, e) {
    return void 0 === e && (e = 1), this._map(t, e, !1);
  }, Ns.prototype.map = function (t, e) {
    return void 0 === e && (e = 1), this._map(t, e, !0);
  }, Ns.prototype._map = function (t, e, n) {
    for (var o = 0, r = this.inverted ? 2 : 1, i = this.inverted ? 1 : 2, a = 0; a < this.ranges.length; a += 3) {
      var s = this.ranges[a] - (this.inverted ? o : 0);
      if (s > t) break;
      var l = this.ranges[a + r],
          c = this.ranges[a + i],
          p = s + l;

      if (t <= p) {
        var u = s + o + ((l ? t == s ? -1 : t == p ? 1 : e : e) < 0 ? 0 : c);
        if (n) return u;
        var f = a / 3 + (t - s) * Ts;
        return new Ms(u, e < 0 ? t != s : t != p, f);
      }

      o += c - l;
    }

    return n ? t + o : new Ms(t + o);
  }, Ns.prototype.touches = function (t, e) {
    for (var n = 0, o = Es(e), r = this.inverted ? 2 : 1, i = this.inverted ? 1 : 2, a = 0; a < this.ranges.length; a += 3) {
      var s = this.ranges[a] - (this.inverted ? n : 0);
      if (s > t) break;
      var l = this.ranges[a + r];
      if (t <= s + l && a == 3 * o) return !0;
      n += this.ranges[a + i] - l;
    }

    return !1;
  }, Ns.prototype.forEach = function (t) {
    for (var e = this.inverted ? 2 : 1, n = this.inverted ? 1 : 2, o = 0, r = 0; o < this.ranges.length; o += 3) {
      var i = this.ranges[o],
          a = i - (this.inverted ? r : 0),
          s = i + (this.inverted ? 0 : r),
          l = this.ranges[o + e],
          c = this.ranges[o + n];
      t(a, a + l, s, s + c), r += c - l;
    }
  }, Ns.prototype.invert = function () {
    return new Ns(this.ranges, !this.inverted);
  }, Ns.prototype.toString = function () {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }, Ns.offset = function (t) {
    return 0 == t ? Ns.empty : new Ns(t < 0 ? [0, -t, 0] : [0, 0, t]);
  }, Ns.empty = new Ns([]);

  var Rs = function (t, e, n, o) {
    this.maps = t || [], this.from = n || 0, this.to = null == o ? this.maps.length : o, this.mirror = e;
  };

  function Ls(t) {
    var e = Error.call(this, t);
    return e.__proto__ = Ls.prototype, e;
  }

  Rs.prototype.slice = function (t, e) {
    return void 0 === t && (t = 0), void 0 === e && (e = this.maps.length), new Rs(this.maps, this.mirror, t, e);
  }, Rs.prototype.copy = function () {
    return new Rs(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }, Rs.prototype.appendMap = function (t, e) {
    this.to = this.maps.push(t), null != e && this.setMirror(this.maps.length - 1, e);
  }, Rs.prototype.appendMapping = function (t) {
    for (var e = 0, n = this.maps.length; e < t.maps.length; e++) {
      var o = t.getMirror(e);
      this.appendMap(t.maps[e], null != o && o < e ? n + o : null);
    }
  }, Rs.prototype.getMirror = function (t) {
    if (this.mirror) for (var e = 0; e < this.mirror.length; e++) if (this.mirror[e] == t) return this.mirror[e + (e % 2 ? -1 : 1)];
  }, Rs.prototype.setMirror = function (t, e) {
    this.mirror || (this.mirror = []), this.mirror.push(t, e);
  }, Rs.prototype.appendMappingInverted = function (t) {
    for (var e = t.maps.length - 1, n = this.maps.length + t.maps.length; e >= 0; e--) {
      var o = t.getMirror(e);
      this.appendMap(t.maps[e].invert(), null != o && o > e ? n - o - 1 : null);
    }
  }, Rs.prototype.invert = function () {
    var t = new Rs();
    return t.appendMappingInverted(this), t;
  }, Rs.prototype.map = function (t, e) {
    if (void 0 === e && (e = 1), this.mirror) return this._map(t, e, !0);

    for (var n = this.from; n < this.to; n++) t = this.maps[n].map(t, e);

    return t;
  }, Rs.prototype.mapResult = function (t, e) {
    return void 0 === e && (e = 1), this._map(t, e, !1);
  }, Rs.prototype._map = function (t, e, n) {
    for (var o = !1, r = null, i = this.from; i < this.to; i++) {
      var a = this.maps[i],
          s = r && r[i];
      if (null != s && a.touches(t, s)) t = a.recover(s);else {
        var l = a.mapResult(t, e);

        if (null != l.recover) {
          var c = this.getMirror(i);

          if (null != c && c > i && c < this.to) {
            if (l.deleted) {
              i = c, t = this.maps[c].recover(l.recover);
              continue;
            }

            (r || (r = Object.create(null)))[c] = l.recover;
          }
        }

        l.deleted && (o = !0), t = l.pos;
      }
    }

    return n ? t : new Ms(t, o);
  }, Ls.prototype = Object.create(Error.prototype), Ls.prototype.constructor = Ls, Ls.prototype.name = "TransformError";

  var Is = function (t) {
    this.doc = t, this.steps = [], this.docs = [], this.mapping = new Rs();
  },
      Ps = {
    before: {
      configurable: !0
    },
    docChanged: {
      configurable: !0
    }
  };

  function Ds() {
    throw new Error("Override me");
  }

  Ps.before.get = function () {
    return this.docs.length ? this.docs[0] : this.doc;
  }, Is.prototype.step = function (t) {
    var e = this.maybeStep(t);
    if (e.failed) throw new Ls(e.failed);
    return this;
  }, Is.prototype.maybeStep = function (t) {
    var e = t.apply(this.doc);
    return e.failed || this.addStep(t, e.doc), e;
  }, Ps.docChanged.get = function () {
    return this.steps.length > 0;
  }, Is.prototype.addStep = function (t, e) {
    this.docs.push(this.doc), this.steps.push(t), this.mapping.appendMap(t.getMap()), this.doc = e;
  }, Object.defineProperties(Is.prototype, Ps);

  var _s = Object.create(null),
      Bs = function () {};

  Bs.prototype.apply = function (t) {
    return Ds();
  }, Bs.prototype.getMap = function () {
    return Ns.empty;
  }, Bs.prototype.invert = function (t) {
    return Ds();
  }, Bs.prototype.map = function (t) {
    return Ds();
  }, Bs.prototype.merge = function (t) {
    return null;
  }, Bs.prototype.toJSON = function () {
    return Ds();
  }, Bs.fromJSON = function (t, e) {
    if (!e || !e.stepType) throw new RangeError("Invalid input for Step.fromJSON");
    var n = _s[e.stepType];
    if (!n) throw new RangeError("No step type " + e.stepType + " defined");
    return n.fromJSON(t, e);
  }, Bs.jsonID = function (t, e) {
    if (t in _s) throw new RangeError("Duplicate use of step JSON ID " + t);
    return _s[t] = e, e.prototype.jsonID = t, e;
  };

  var Vs = function (t, e) {
    this.doc = t, this.failed = e;
  };

  Vs.ok = function (t) {
    return new Vs(t, null);
  }, Vs.fail = function (t) {
    return new Vs(null, t);
  }, Vs.fromReplace = function (t, e, n, o) {
    try {
      return Vs.ok(t.replace(e, n, o));
    } catch (t) {
      if (t instanceof wa) return Vs.fail(t.message);
      throw t;
    }
  };

  var zs = function (t) {
    function e(e, n, o, r) {
      t.call(this), this.from = e, this.to = n, this.slice = o, this.structure = !!r;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.apply = function (t) {
      return this.structure && js(t, this.from, this.to) ? Vs.fail("Structure replace would overwrite content") : Vs.fromReplace(t, this.from, this.to, this.slice);
    }, e.prototype.getMap = function () {
      return new Ns([this.from, this.to - this.from, this.slice.size]);
    }, e.prototype.invert = function (t) {
      return new e(this.from, this.from + this.slice.size, t.slice(this.from, this.to));
    }, e.prototype.map = function (t) {
      var n = t.mapResult(this.from, 1),
          o = t.mapResult(this.to, -1);
      return n.deleted && o.deleted ? null : new e(n.pos, Math.max(n.pos, o.pos), this.slice);
    }, e.prototype.merge = function (t) {
      if (!(t instanceof e) || t.structure != this.structure) return null;

      if (this.from + this.slice.size != t.from || this.slice.openEnd || t.slice.openStart) {
        if (t.to != this.from || this.slice.openStart || t.slice.openEnd) return null;
        var n = this.slice.size + t.slice.size == 0 ? Sa.empty : new Sa(t.slice.content.append(this.slice.content), t.slice.openStart, this.slice.openEnd);
        return new e(t.from, this.to, n, this.structure);
      }

      var o = this.slice.size + t.slice.size == 0 ? Sa.empty : new Sa(this.slice.content.append(t.slice.content), this.slice.openStart, t.slice.openEnd);
      return new e(this.from, this.to + (t.to - t.from), o, this.structure);
    }, e.prototype.toJSON = function () {
      var t = {
        stepType: "replace",
        from: this.from,
        to: this.to
      };
      return this.slice.size && (t.slice = this.slice.toJSON()), this.structure && (t.structure = !0), t;
    }, e.fromJSON = function (t, n) {
      if ("number" != typeof n.from || "number" != typeof n.to) throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      return new e(n.from, n.to, Sa.fromJSON(t, n.slice), !!n.structure);
    }, e;
  }(Bs);

  Bs.jsonID("replace", zs);

  var $s = function (t) {
    function e(e, n, o, r, i, a, s) {
      t.call(this), this.from = e, this.to = n, this.gapFrom = o, this.gapTo = r, this.slice = i, this.insert = a, this.structure = !!s;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.apply = function (t) {
      if (this.structure && (js(t, this.from, this.gapFrom) || js(t, this.gapTo, this.to))) return Vs.fail("Structure gap-replace would overwrite content");
      var e = t.slice(this.gapFrom, this.gapTo);
      if (e.openStart || e.openEnd) return Vs.fail("Gap is not a flat range");
      var n = this.slice.insertAt(this.insert, e.content);
      return n ? Vs.fromReplace(t, this.from, this.to, n) : Vs.fail("Content does not fit in gap");
    }, e.prototype.getMap = function () {
      return new Ns([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);
    }, e.prototype.invert = function (t) {
      var n = this.gapTo - this.gapFrom;
      return new e(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, t.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
    }, e.prototype.map = function (t) {
      var n = t.mapResult(this.from, 1),
          o = t.mapResult(this.to, -1),
          r = t.map(this.gapFrom, -1),
          i = t.map(this.gapTo, 1);
      return n.deleted && o.deleted || r < n.pos || i > o.pos ? null : new e(n.pos, o.pos, r, i, this.slice, this.insert, this.structure);
    }, e.prototype.toJSON = function () {
      var t = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert
      };
      return this.slice.size && (t.slice = this.slice.toJSON()), this.structure && (t.structure = !0), t;
    }, e.fromJSON = function (t, n) {
      if ("number" != typeof n.from || "number" != typeof n.to || "number" != typeof n.gapFrom || "number" != typeof n.gapTo || "number" != typeof n.insert) throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      return new e(n.from, n.to, n.gapFrom, n.gapTo, Sa.fromJSON(t, n.slice), n.insert, !!n.structure);
    }, e;
  }(Bs);

  function js(t, e, n) {
    for (var o = t.resolve(e), r = n - e, i = o.depth; r > 0 && i > 0 && o.indexAfter(i) == o.node(i).childCount;) i--, r--;

    if (r > 0) for (var a = o.node(i).maybeChild(o.indexAfter(i)); r > 0;) {
      if (!a || a.isLeaf) return !0;
      a = a.firstChild, r--;
    }
    return !1;
  }

  function Hs(t, e, n) {
    return (0 == e || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n));
  }

  function Fs(t) {
    for (var e = t.parent.content.cutByIndex(t.startIndex, t.endIndex), n = t.depth;; --n) {
      var o = t.$from.node(n),
          r = t.$from.index(n),
          i = t.$to.indexAfter(n);
      if (n < t.depth && o.canReplace(r, i, e)) return n;
      if (0 == n || o.type.spec.isolating || !Hs(o, r, i)) break;
    }
  }

  function qs(t, e, n, o) {
    void 0 === n && (n = 1);
    var r = t.resolve(e),
        i = r.depth - n,
        a = o && o[o.length - 1] || r.parent;
    if (i < 0 || r.parent.type.spec.isolating || !r.parent.canReplace(r.index(), r.parent.childCount) || !a.type.validContent(r.parent.content.cutByIndex(r.index(), r.parent.childCount))) return !1;

    for (var s = r.depth - 1, l = n - 2; s > i; s--, l--) {
      var c = r.node(s),
          p = r.index(s);
      if (c.type.spec.isolating) return !1;
      var u = c.content.cutByIndex(p, c.childCount),
          f = o && o[l] || c;
      if (f != c && (u = u.replaceChild(0, f.type.create(f.attrs))), !c.canReplace(p + 1, c.childCount) || !f.type.validContent(u)) return !1;
    }

    var d = r.indexAfter(i),
        h = o && o[0];
    return r.node(i).canReplaceWith(d, d, h ? h.type : r.node(i + 1).type);
  }

  function Us(t, e) {
    var n,
        o,
        r = t.resolve(e),
        i = r.index();
    return n = r.nodeBefore, o = r.nodeAfter, n && o && !n.isLeaf && n.canAppend(o) && r.parent.canReplace(i, i + 1);
  }

  function Ws(t, e, n) {
    for (var o = [], r = 0; r < t.childCount; r++) {
      var i = t.child(r);
      i.content.size && (i = i.copy(Ws(i.content, e, i))), i.isInline && (i = e(i, n, r)), o.push(i);
    }

    return ha.fromArray(o);
  }

  Bs.jsonID("replaceAround", $s), Is.prototype.lift = function (t, e) {
    for (var n = t.$from, o = t.$to, r = t.depth, i = n.before(r + 1), a = o.after(r + 1), s = i, l = a, c = ha.empty, p = 0, u = r, f = !1; u > e; u--) f || n.index(u) > 0 ? (f = !0, c = ha.from(n.node(u).copy(c)), p++) : s--;

    for (var d = ha.empty, h = 0, v = r, m = !1; v > e; v--) m || o.after(v + 1) < o.end(v) ? (m = !0, d = ha.from(o.node(v).copy(d)), h++) : l++;

    return this.step(new $s(s, l, i, a, new Sa(c.append(d), p, h), c.size - p, !0));
  }, Is.prototype.wrap = function (t, e) {
    for (var n = ha.empty, o = e.length - 1; o >= 0; o--) n = ha.from(e[o].type.create(e[o].attrs, n));

    var r = t.start,
        i = t.end;
    return this.step(new $s(r, i, r, i, new Sa(n, 0, 0), e.length, !0));
  }, Is.prototype.setBlockType = function (t, e, n, o) {
    var r = this;
    if (void 0 === e && (e = t), !n.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock");
    var i = this.steps.length;
    return this.doc.nodesBetween(t, e, function (t, e) {
      if (t.isTextblock && !t.hasMarkup(n, o) && function (t, e, n) {
        var o = t.resolve(e),
            r = o.index();
        return o.parent.canReplaceWith(r, r + 1, n);
      }(r.doc, r.mapping.slice(i).map(e), n)) {
        r.clearIncompatible(r.mapping.slice(i).map(e, 1), n);
        var a = r.mapping.slice(i),
            s = a.map(e, 1),
            l = a.map(e + t.nodeSize, 1);
        return r.step(new $s(s, l, s + 1, l - 1, new Sa(ha.from(n.create(o, null, t.marks)), 0, 0), 1, !0)), !1;
      }
    }), this;
  }, Is.prototype.setNodeMarkup = function (t, e, n, o) {
    var r = this.doc.nodeAt(t);
    if (!r) throw new RangeError("No node at given position");
    e || (e = r.type);
    var i = e.create(n, null, o || r.marks);
    if (r.isLeaf) return this.replaceWith(t, t + r.nodeSize, i);
    if (!e.validContent(r.content)) throw new RangeError("Invalid content for node type " + e.name);
    return this.step(new $s(t, t + r.nodeSize, t + 1, t + r.nodeSize - 1, new Sa(ha.from(i), 0, 0), 1, !0));
  }, Is.prototype.split = function (t, e, n) {
    void 0 === e && (e = 1);

    for (var o = this.doc.resolve(t), r = ha.empty, i = ha.empty, a = o.depth, s = o.depth - e, l = e - 1; a > s; a--, l--) {
      r = ha.from(o.node(a).copy(r));
      var c = n && n[l];
      i = ha.from(c ? c.type.create(c.attrs, i) : o.node(a).copy(i));
    }

    return this.step(new zs(t, t, new Sa(r.append(i), e, e), !0));
  }, Is.prototype.join = function (t, e) {
    void 0 === e && (e = 1);
    var n = new zs(t - e, t + e, Sa.empty, !0);
    return this.step(n);
  };

  var Ks = function (t) {
    function e(e, n, o) {
      t.call(this), this.from = e, this.to = n, this.mark = o;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.apply = function (t) {
      var e = this,
          n = t.slice(this.from, this.to),
          o = t.resolve(this.from),
          r = o.node(o.sharedDepth(this.to)),
          i = new Sa(Ws(n.content, function (t, n) {
        return n.type.allowsMarkType(e.mark.type) ? t.mark(e.mark.addToSet(t.marks)) : t;
      }, r), n.openStart, n.openEnd);
      return Vs.fromReplace(t, this.from, this.to, i);
    }, e.prototype.invert = function () {
      return new Js(this.from, this.to, this.mark);
    }, e.prototype.map = function (t) {
      var n = t.mapResult(this.from, 1),
          o = t.mapResult(this.to, -1);
      return n.deleted && o.deleted || n.pos >= o.pos ? null : new e(n.pos, o.pos, this.mark);
    }, e.prototype.merge = function (t) {
      if (t instanceof e && t.mark.eq(this.mark) && this.from <= t.to && this.to >= t.from) return new e(Math.min(this.from, t.from), Math.max(this.to, t.to), this.mark);
    }, e.prototype.toJSON = function () {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }, e.fromJSON = function (t, n) {
      if ("number" != typeof n.from || "number" != typeof n.to) throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      return new e(n.from, n.to, t.markFromJSON(n.mark));
    }, e;
  }(Bs);

  Bs.jsonID("addMark", Ks);

  var Js = function (t) {
    function e(e, n, o) {
      t.call(this), this.from = e, this.to = n, this.mark = o;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.apply = function (t) {
      var e = this,
          n = t.slice(this.from, this.to),
          o = new Sa(Ws(n.content, function (t) {
        return t.mark(e.mark.removeFromSet(t.marks));
      }), n.openStart, n.openEnd);
      return Vs.fromReplace(t, this.from, this.to, o);
    }, e.prototype.invert = function () {
      return new Ks(this.from, this.to, this.mark);
    }, e.prototype.map = function (t) {
      var n = t.mapResult(this.from, 1),
          o = t.mapResult(this.to, -1);
      return n.deleted && o.deleted || n.pos >= o.pos ? null : new e(n.pos, o.pos, this.mark);
    }, e.prototype.merge = function (t) {
      if (t instanceof e && t.mark.eq(this.mark) && this.from <= t.to && this.to >= t.from) return new e(Math.min(this.from, t.from), Math.max(this.to, t.to), this.mark);
    }, e.prototype.toJSON = function () {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }, e.fromJSON = function (t, n) {
      if ("number" != typeof n.from || "number" != typeof n.to) throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      return new e(n.from, n.to, t.markFromJSON(n.mark));
    }, e;
  }(Bs);

  function Gs(t, e, n, o) {
    if (void 0 === n && (n = e), void 0 === o && (o = Sa.empty), e == n && !o.size) return null;
    var r = t.resolve(e),
        i = t.resolve(n);
    if (Zs(r, i, o)) return new zs(e, n, o);

    var a = function (t, e) {
      var n = function t(e, n, o, r) {
        var i = ha.empty,
            a = 0,
            s = o[n];

        if (e.depth > n) {
          var l = t(e, n + 1, o, r || s);
          a = l.openEnd + 1, i = ha.from(e.node(n + 1).copy(l.content));
        }

        s && (i = i.append(s.content), a = s.openEnd);
        r && (i = i.append(e.node(n).contentMatchAt(e.indexAfter(n)).fillBefore(ha.empty, !0)), a = 0);
        return {
          content: i,
          openEnd: a
        };
      }(t, 0, e, !1),
          o = n.content,
          r = n.openEnd;

      return new Sa(o, t.depth, r || 0);
    }(r, function (t, e) {
      for (var n = new Qs(t), o = 1; e.size && o <= 3; o++) {
        var r = n.placeSlice(e.content, e.openStart, e.openEnd, o);
        3 == o && r != e && r.size && (o = 0), e = r;
      }

      for (; n.open.length;) n.closeNode();

      return n.placed;
    }(r, o)),
        s = Ys(r, i, a);

    if (!s) return null;

    if (a.size != s.size && function (t, e, n) {
      if (!e.parent.isTextblock) return !1;
      var o,
          r = n.openEnd ? function (t, e) {
        for (var n = 1; n < e; n++) t = t.lastChild.content;

        return t.lastChild;
      }(n.content, n.openEnd) : t.node(t.depth - (n.openStart - n.openEnd));
      if (!r.isTextblock) return !1;

      for (var i = e.index(); i < e.parent.childCount; i++) if (!r.type.allowsMarks(e.parent.child(i).marks)) return !1;

      n.openEnd ? o = r.contentMatchAt(r.childCount) : (o = r.contentMatchAt(r.childCount), n.size && (o = o.matchFragment(n.content, n.openStart ? 1 : 0)));
      return (o = o.matchFragment(e.parent.content, e.index())) && o.validEnd;
    }(r, i, a)) {
      for (var l = i.depth, c = i.after(l); l > 1 && c == i.end(--l);) ++c;

      var p = Ys(r, t.resolve(c), a);
      if (p) return new $s(e, c, n, i.end(), p, a.size);
    }

    return s.size || e != n ? new zs(e, n, s) : null;
  }

  function Xs(t, e, n, o, r, i, a) {
    var s,
        l = t.childCount,
        c = l - (a > 0 ? 1 : 0),
        p = i < 0 ? e : n.node(r);
    s = i < 0 ? p.contentMatchAt(c) : 1 == l && a > 0 ? p.contentMatchAt(i ? n.index(r) : n.indexAfter(r)) : p.contentMatchAt(n.indexAfter(r)).matchFragment(t, l > 0 && i ? 1 : 0, c);
    var u = o.node(r);

    if (a > 0 && r < o.depth) {
      var f = u.content.cutByIndex(o.indexAfter(r)).addToStart(t.lastChild),
          d = s.fillBefore(f, !0);

      if (d && d.size && i > 0 && 1 == l && (d = null), d) {
        var h = Xs(t.lastChild.content, t.lastChild, n, o, r + 1, 1 == l ? i - 1 : -1, a - 1);

        if (h) {
          var v = t.lastChild.copy(h);
          return d.size ? t.cutByIndex(0, l - 1).append(d).addToEnd(v) : t.replaceChild(l - 1, v);
        }
      }
    }

    a > 0 && (s = s.matchType((1 == l && i > 0 ? n.node(r + 1) : t.lastChild).type));
    var m = o.index(r);
    if (m == u.childCount && !u.type.compatibleContent(e.type)) return null;

    for (var g = s.fillBefore(u.content, !0, m), y = m; g && y < u.content.childCount; y++) p.type.allowsMarks(u.content.child(y).marks) || (g = null);

    if (!g) return null;

    if (a > 0) {
      var b = function t(e, n, o, r, i) {
        var a,
            s = e.content,
            l = s.childCount;
        a = i >= 0 ? o.node(r).contentMatchAt(o.indexAfter(r)).matchFragment(s, i > 0 ? 1 : 0, l) : e.contentMatchAt(l);

        if (n > 0) {
          var c = t(s.lastChild, n - 1, o, r + 1, 1 == l ? i - 1 : -1);
          s = s.replaceChild(l - 1, c);
        }

        return e.copy(s.append(a.fillBefore(ha.empty, !0)));
      }(t.lastChild, a - 1, n, r + 1, 1 == l ? i - 1 : -1);

      t = t.replaceChild(l - 1, b);
    }

    return t = t.append(g), o.depth > r && (t = t.addToEnd(function t(e, n) {
      var o = e.node(n);
      var r = o.contentMatchAt(0).fillBefore(o.content, !0, e.index(n));
      e.depth > n && (r = r.addToEnd(t(e, n + 1)));
      return o.copy(r);
    }(o, r + 1))), t;
  }

  function Ys(t, e, n) {
    var o = Xs(n.content, t.node(0), t, e, 0, n.openStart, n.openEnd);
    return o ? function (t, e, n) {
      for (; e > 0 && n > 0 && 1 == t.childCount;) t = t.firstChild.content, e--, n--;

      return new Sa(t, e, n);
    }(o, n.openStart, e.depth) : null;
  }

  function Zs(t, e, n) {
    return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content);
  }

  Bs.jsonID("removeMark", Js), Is.prototype.addMark = function (t, e, n) {
    var o = this,
        r = [],
        i = [],
        a = null,
        s = null;
    return this.doc.nodesBetween(t, e, function (o, l, c) {
      if (o.isInline) {
        var p = o.marks;

        if (!n.isInSet(p) && c.type.allowsMarkType(n.type)) {
          for (var u = Math.max(l, t), f = Math.min(l + o.nodeSize, e), d = n.addToSet(p), h = 0; h < p.length; h++) p[h].isInSet(d) || (a && a.to == u && a.mark.eq(p[h]) ? a.to = f : r.push(a = new Js(u, f, p[h])));

          s && s.to == u ? s.to = f : i.push(s = new Ks(u, f, n));
        }
      }
    }), r.forEach(function (t) {
      return o.step(t);
    }), i.forEach(function (t) {
      return o.step(t);
    }), this;
  }, Is.prototype.removeMark = function (t, e, n) {
    var o = this;
    void 0 === n && (n = null);
    var r = [],
        i = 0;
    return this.doc.nodesBetween(t, e, function (o, a) {
      if (o.isInline) {
        i++;
        var s = null;

        if (n instanceof ss) {
          var l = n.isInSet(o.marks);
          l && (s = [l]);
        } else n ? n.isInSet(o.marks) && (s = [n]) : s = o.marks;

        if (s && s.length) for (var c = Math.min(a + o.nodeSize, e), p = 0; p < s.length; p++) {
          for (var u = s[p], f = void 0, d = 0; d < r.length; d++) {
            var h = r[d];
            h.step == i - 1 && u.eq(r[d].style) && (f = h);
          }

          f ? (f.to = c, f.step = i) : r.push({
            style: u,
            from: Math.max(a, t),
            to: c,
            step: i
          });
        }
      }
    }), r.forEach(function (t) {
      return o.step(new Js(t.from, t.to, t.style));
    }), this;
  }, Is.prototype.clearIncompatible = function (t, e, n) {
    void 0 === n && (n = e.contentMatch);

    for (var o = this.doc.nodeAt(t), r = [], i = t + 1, a = 0; a < o.childCount; a++) {
      var s = o.child(a),
          l = i + s.nodeSize,
          c = n.matchType(s.type, s.attrs);

      if (c) {
        n = c;

        for (var p = 0; p < s.marks.length; p++) e.allowsMarkType(s.marks[p].type) || this.step(new Js(i, l, s.marks[p]));
      } else r.push(new zs(i, l, Sa.empty));

      i = l;
    }

    if (!n.validEnd) {
      var u = n.fillBefore(ha.empty, !0);
      this.replace(i, i, new Sa(u, 0, 0));
    }

    for (var f = r.length - 1; f >= 0; f--) this.step(r[f]);

    return this;
  }, Is.prototype.replace = function (t, e, n) {
    void 0 === e && (e = t), void 0 === n && (n = Sa.empty);
    var o = Gs(this.doc, t, e, n);
    return o && this.step(o), this;
  }, Is.prototype.replaceWith = function (t, e, n) {
    return this.replace(t, e, new Sa(ha.from(n), 0, 0));
  }, Is.prototype.delete = function (t, e) {
    return this.replace(t, e, Sa.empty);
  }, Is.prototype.insert = function (t, e) {
    return this.replaceWith(t, t, e);
  };

  var Qs = function (t) {
    this.open = [];

    for (var e = 0; e <= t.depth; e++) {
      var n = t.node(e),
          o = n.contentMatchAt(t.indexAfter(e));
      this.open.push({
        parent: n,
        match: o,
        content: ha.empty,
        wrapper: !1,
        openEnd: 0,
        depth: e
      });
    }

    this.placed = [];
  };

  function tl(t, e, n) {
    var o = t.content;

    if (e > 1) {
      var r = tl(t.firstChild, e - 1, 1 == t.childCount ? n - 1 : 0);
      o = t.content.replaceChild(0, r);
    }

    var i = t.type.contentMatch.fillBefore(o, 0 == n);
    return t.copy(i.append(o));
  }

  function el(t, e, n, o, r) {
    if (e < n) {
      var i = t.firstChild;
      t = t.replaceChild(0, i.copy(el(i.content, e + 1, n, o, i)));
    }

    if (e > o) {
      var a = r.contentMatchAt(0),
          s = a.fillBefore(t).append(t);
      t = s.append(a.matchFragment(s).fillBefore(ha.empty, !0));
    }

    return t;
  }

  function nl(t, e) {
    for (var n = [], o = Math.min(t.depth, e.depth); o >= 0; o--) {
      var r = t.start(o);
      if (r < t.pos - (t.depth - o) || e.end(o) > e.pos + (e.depth - o) || t.node(o).type.spec.isolating || e.node(o).type.spec.isolating) break;
      r == e.start(o) && n.push(o);
    }

    return n;
  }

  Qs.prototype.placeSlice = function (t, e, n, o, r) {
    if (e > 0) {
      var i = t.firstChild,
          a = this.placeSlice(i.content, Math.max(0, e - 1), n && 1 == t.childCount ? n - 1 : 0, o, i);
      a.content != i.content && (a.content.size ? (t = t.replaceChild(0, i.copy(a.content)), e = a.openStart + 1) : (1 == t.childCount && (n = 0), t = t.cutByIndex(1), e = 0));
    }

    var s = this.placeContent(t, e, n, o, r);

    if (o > 2 && s.size && 0 == e) {
      var l = s.content.firstChild,
          c = 1 == s.content.childCount;
      this.placeContent(l.content, 0, n && c ? n - 1 : 0, o, l), s = c ? ha.empty : new Sa(s.content.cutByIndex(1), 0, n);
    }

    return s;
  }, Qs.prototype.placeContent = function (t, e, n, o, r) {
    for (var i = 0; i < t.childCount; i++) {
      for (var a = t.child(i), s = !1, l = i == t.childCount - 1, c = this.open.length - 1; c >= 0; c--) {
        var p = this.open[c],
            u = void 0;

        if (o > 1 && (u = p.match.findWrapping(a.type)) && (!r || !u.length || u[u.length - 1] != r.type)) {
          for (; this.open.length - 1 > c;) this.closeNode();

          for (var f = 0; f < u.length; f++) p.match = p.match.matchType(u[f]), c++, p = {
            parent: u[f].create(),
            match: u[f].contentMatch,
            content: ha.empty,
            wrapper: !0,
            openEnd: 0,
            depth: c + f
          }, this.open.push(p);
        }

        var d = p.match.matchType(a.type);

        if (!d) {
          var h = p.match.fillBefore(ha.from(a));

          if (!h) {
            if (r && p.match.matchType(r.type)) break;
            continue;
          }

          for (var v = 0; v < h.childCount; v++) {
            var m = h.child(v);
            this.addNode(p, m, 0), d = p.match.matchFragment(m);
          }
        }

        for (; this.open.length - 1 > c;) this.closeNode();

        a = a.mark(p.parent.type.allowedMarks(a.marks)), e && (a = tl(a, e, l ? n : 0), e = 0), this.addNode(p, a, l ? n : 0), p.match = d, l && (n = 0), s = !0;
        break;
      }

      if (!s) break;
    }

    return this.open.length > 1 && (i > 0 && i == t.childCount || r && this.open[this.open.length - 1].parent.type == r.type) && this.closeNode(), new Sa(t.cutByIndex(i), e, n);
  }, Qs.prototype.addNode = function (t, e, n) {
    var o, r;
    t.content = (o = t.content, r = t.openEnd, r ? o.replaceChild(o.childCount - 1, function t(e, n) {
      var o = e.content;

      if (n > 1) {
        var r = t(e.lastChild, n - 1);
        o = e.content.replaceChild(e.childCount - 1, r);
      }

      var i = e.contentMatchAt(e.childCount).fillBefore(ha.empty, !0);
      return e.copy(o.append(i));
    }(o.lastChild, r)) : o).addToEnd(e), t.openEnd = n;
  }, Qs.prototype.closeNode = function () {
    var t = this.open.pop();
    0 == t.content.size || (t.wrapper ? this.addNode(this.open[this.open.length - 1], t.parent.copy(t.content), t.openEnd + 1) : this.placed[t.depth] = {
      depth: t.depth,
      content: t.content,
      openEnd: t.openEnd
    });
  }, Is.prototype.replaceRange = function (t, e, n) {
    if (!n.size) return this.deleteRange(t, e);
    var o = this.doc.resolve(t),
        r = this.doc.resolve(e);
    if (Zs(o, r, n)) return this.step(new zs(t, e, n));
    var i = nl(o, this.doc.resolve(e));
    0 == i[i.length - 1] && i.pop();
    var a = -(o.depth + 1);
    i.unshift(a);

    for (var s = o.depth, l = o.pos - 1; s > 0; s--, l--) {
      var c = o.node(s).type.spec;
      if (c.defining || c.isolating) break;
      i.indexOf(s) > -1 ? a = s : o.before(s) == l && i.splice(1, 0, -s);
    }

    for (var p = i.indexOf(a), u = [], f = n.openStart, d = n.content, h = 0;; h++) {
      var v = d.firstChild;
      if (u.push(v), h == n.openStart) break;
      d = v.content;
    }

    f > 0 && u[f - 1].type.spec.defining && o.node(p).type != u[f - 1].type ? f -= 1 : f >= 2 && u[f - 1].isTextblock && u[f - 2].type.spec.defining && o.node(p).type != u[f - 2].type && (f -= 2);

    for (var m = n.openStart; m >= 0; m--) {
      var g = (m + f + 1) % (n.openStart + 1),
          y = u[g];
      if (y) for (var b = 0; b < i.length; b++) {
        var w = i[(b + p) % i.length],
            S = !0;
        w < 0 && (S = !1, w = -w);
        var C = o.node(w - 1),
            x = o.index(w - 1);
        if (C.canReplaceWith(x, x, y.type, y.marks)) return this.replace(o.before(w), S ? r.after(w) : e, new Sa(el(n.content, 0, n.openStart, g), g, n.openEnd));
      }
    }

    for (var k = this.steps.length, O = i.length - 1; O >= 0 && (this.replace(t, e, n), !(this.steps.length > k)); O--) {
      var A = i[O];
      O < 0 || (t = o.before(A), e = r.after(A));
    }

    return this;
  }, Is.prototype.replaceRangeWith = function (t, e, n) {
    if (!n.isInline && t == e && this.doc.resolve(t).parent.content.size) {
      var o = function (t, e, n) {
        var o = t.resolve(e);
        if (o.parent.canReplaceWith(o.index(), o.index(), n)) return e;
        if (0 == o.parentOffset) for (var r = o.depth - 1; r >= 0; r--) {
          var i = o.index(r);
          if (o.node(r).canReplaceWith(i, i, n)) return o.before(r + 1);
          if (i > 0) return null;
        }
        if (o.parentOffset == o.parent.content.size) for (var a = o.depth - 1; a >= 0; a--) {
          var s = o.indexAfter(a);
          if (o.node(a).canReplaceWith(s, s, n)) return o.after(a + 1);
          if (s < o.node(a).childCount) return null;
        }
      }(this.doc, t, n.type);

      null != o && (t = e = o);
    }

    return this.replaceRange(t, e, new Sa(ha.from(n), 0, 0));
  }, Is.prototype.deleteRange = function (t, e) {
    for (var n = this.doc.resolve(t), o = this.doc.resolve(e), r = nl(n, o), i = 0; i < r.length; i++) {
      var a = r[i],
          s = i == r.length - 1;
      if (s && 0 == a || n.node(a).type.contentMatch.validEnd) return this.delete(n.start(a), o.end(a));
      if (a > 0 && (s || n.node(a - 1).canReplace(n.index(a - 1), o.indexAfter(a - 1)))) return this.delete(n.before(a), o.after(a));
    }

    for (var l = 1; l <= n.depth && l <= o.depth; l++) if (t - n.start(l) == n.depth - l && e > n.end(l) && o.end(l) - e != o.depth - l) return this.delete(n.before(l), e);

    return this.delete(t, e);
  };

  var ol = Object.create(null),
      rl = function (t, e, n) {
    this.ranges = n || [new al(t.min(e), t.max(e))], this.$anchor = t, this.$head = e;
  },
      il = {
    anchor: {
      configurable: !0
    },
    head: {
      configurable: !0
    },
    from: {
      configurable: !0
    },
    to: {
      configurable: !0
    },
    $from: {
      configurable: !0
    },
    $to: {
      configurable: !0
    },
    empty: {
      configurable: !0
    }
  };

  il.anchor.get = function () {
    return this.$anchor.pos;
  }, il.head.get = function () {
    return this.$head.pos;
  }, il.from.get = function () {
    return this.$from.pos;
  }, il.to.get = function () {
    return this.$to.pos;
  }, il.$from.get = function () {
    return this.ranges[0].$from;
  }, il.$to.get = function () {
    return this.ranges[0].$to;
  }, il.empty.get = function () {
    for (var t = this.ranges, e = 0; e < t.length; e++) if (t[e].$from.pos != t[e].$to.pos) return !1;

    return !0;
  }, rl.prototype.content = function () {
    return this.$from.node(0).slice(this.from, this.to, !0);
  }, rl.prototype.replace = function (t, e) {
    void 0 === e && (e = Sa.empty);

    for (var n = e.content.lastChild, o = null, r = 0; r < e.openEnd; r++) o = n, n = n.lastChild;

    for (var i = t.steps.length, a = this.ranges, s = 0; s < a.length; s++) {
      var l = a[s],
          c = l.$from,
          p = l.$to,
          u = t.mapping.slice(i);
      t.replaceRange(u.map(c.pos), u.map(p.pos), s ? Sa.empty : e), 0 == s && hl(t, i, (n ? n.isInline : o && o.isTextblock) ? -1 : 1);
    }
  }, rl.prototype.replaceWith = function (t, e) {
    for (var n = t.steps.length, o = this.ranges, r = 0; r < o.length; r++) {
      var i = o[r],
          a = i.$from,
          s = i.$to,
          l = t.mapping.slice(n),
          c = l.map(a.pos),
          p = l.map(s.pos);
      r ? t.deleteRange(c, p) : (t.replaceRangeWith(c, p, e), hl(t, n, e.isInline ? -1 : 1));
    }
  }, rl.findFrom = function (t, e, n) {
    var o = t.parent.inlineContent ? new sl(t) : dl(t.node(0), t.parent, t.pos, t.index(), e, n);
    if (o) return o;

    for (var r = t.depth - 1; r >= 0; r--) {
      var i = e < 0 ? dl(t.node(0), t.node(r), t.before(r + 1), t.index(r), e, n) : dl(t.node(0), t.node(r), t.after(r + 1), t.index(r) + 1, e, n);
      if (i) return i;
    }
  }, rl.near = function (t, e) {
    return void 0 === e && (e = 1), this.findFrom(t, e) || this.findFrom(t, -e) || new ul(t.node(0));
  }, rl.atStart = function (t) {
    return dl(t, t, 0, 0, 1) || new ul(t);
  }, rl.atEnd = function (t) {
    return dl(t, t, t.content.size, t.childCount, -1) || new ul(t);
  }, rl.fromJSON = function (t, e) {
    if (!e || !e.type) throw new RangeError("Invalid input for Selection.fromJSON");
    var n = ol[e.type];
    if (!n) throw new RangeError("No selection type " + e.type + " defined");
    return n.fromJSON(t, e);
  }, rl.jsonID = function (t, e) {
    if (t in ol) throw new RangeError("Duplicate use of selection JSON ID " + t);
    return ol[t] = e, e.prototype.jsonID = t, e;
  }, rl.prototype.getBookmark = function () {
    return sl.between(this.$anchor, this.$head).getBookmark();
  }, Object.defineProperties(rl.prototype, il), rl.prototype.visible = !0;

  var al = function (t, e) {
    this.$from = t, this.$to = e;
  },
      sl = function (t) {
    function e(e, n) {
      void 0 === n && (n = e), t.call(this, e, n);
    }

    t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
    var n = {
      $cursor: {
        configurable: !0
      }
    };
    return n.$cursor.get = function () {
      return this.$anchor.pos == this.$head.pos ? this.$head : null;
    }, e.prototype.map = function (n, o) {
      var r = n.resolve(o.map(this.head));
      if (!r.parent.inlineContent) return t.near(r);
      var i = n.resolve(o.map(this.anchor));
      return new e(i.parent.inlineContent ? i : r, r);
    }, e.prototype.replace = function (e, n) {
      if (void 0 === n && (n = Sa.empty), t.prototype.replace.call(this, e, n), n == Sa.empty) {
        var o = this.$from.marksAcross(this.$to);
        o && e.ensureMarks(o);
      }
    }, e.prototype.eq = function (t) {
      return t instanceof e && t.anchor == this.anchor && t.head == this.head;
    }, e.prototype.getBookmark = function () {
      return new ll(this.anchor, this.head);
    }, e.prototype.toJSON = function () {
      return {
        type: "text",
        anchor: this.anchor,
        head: this.head
      };
    }, e.fromJSON = function (t, n) {
      if ("number" != typeof n.anchor || "number" != typeof n.head) throw new RangeError("Invalid input for TextSelection.fromJSON");
      return new e(t.resolve(n.anchor), t.resolve(n.head));
    }, e.create = function (t, e, n) {
      void 0 === n && (n = e);
      var o = t.resolve(e);
      return new this(o, n == e ? o : t.resolve(n));
    }, e.between = function (n, o, r) {
      var i = n.pos - o.pos;

      if (r && !i || (r = i >= 0 ? 1 : -1), !o.parent.inlineContent) {
        var a = t.findFrom(o, r, !0) || t.findFrom(o, -r, !0);
        if (!a) return t.near(o, r);
        o = a.$head;
      }

      return n.parent.inlineContent || (0 == i ? n = o : (n = (t.findFrom(n, -r, !0) || t.findFrom(n, r, !0)).$anchor).pos < o.pos != i < 0 && (n = o)), new e(n, o);
    }, Object.defineProperties(e.prototype, n), e;
  }(rl);

  rl.jsonID("text", sl);

  var ll = function (t, e) {
    this.anchor = t, this.head = e;
  };

  ll.prototype.map = function (t) {
    return new ll(t.map(this.anchor), t.map(this.head));
  }, ll.prototype.resolve = function (t) {
    return sl.between(t.resolve(this.anchor), t.resolve(this.head));
  };

  var cl = function (t) {
    function e(e) {
      var n = e.nodeAfter,
          o = e.node(0).resolve(e.pos + n.nodeSize);
      t.call(this, e, o), this.node = n;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.map = function (n, o) {
      var r = o.mapResult(this.anchor),
          i = r.deleted,
          a = r.pos,
          s = n.resolve(a);
      return i ? t.near(s) : new e(s);
    }, e.prototype.content = function () {
      return new Sa(ha.from(this.node), 0, 0);
    }, e.prototype.eq = function (t) {
      return t instanceof e && t.anchor == this.anchor;
    }, e.prototype.toJSON = function () {
      return {
        type: "node",
        anchor: this.anchor
      };
    }, e.prototype.getBookmark = function () {
      return new pl(this.anchor);
    }, e.fromJSON = function (t, n) {
      if ("number" != typeof n.anchor) throw new RangeError("Invalid input for NodeSelection.fromJSON");
      return new e(t.resolve(n.anchor));
    }, e.create = function (t, e) {
      return new this(t.resolve(e));
    }, e.isSelectable = function (t) {
      return !t.isText && !1 !== t.type.spec.selectable;
    }, e;
  }(rl);

  cl.prototype.visible = !1, rl.jsonID("node", cl);

  var pl = function (t) {
    this.anchor = t;
  };

  pl.prototype.map = function (t) {
    var e = t.mapResult(this.anchor),
        n = e.deleted,
        o = e.pos;
    return n ? new ll(o, o) : new pl(o);
  }, pl.prototype.resolve = function (t) {
    var e = t.resolve(this.anchor),
        n = e.nodeAfter;
    return n && cl.isSelectable(n) ? new cl(e) : rl.near(e);
  };

  var ul = function (t) {
    function e(e) {
      t.call(this, e.resolve(0), e.resolve(e.content.size));
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.toJSON = function () {
      return {
        type: "all"
      };
    }, e.fromJSON = function (t) {
      return new e(t);
    }, e.prototype.map = function (t) {
      return new e(t);
    }, e.prototype.eq = function (t) {
      return t instanceof e;
    }, e.prototype.getBookmark = function () {
      return fl;
    }, e;
  }(rl);

  rl.jsonID("all", ul);
  var fl = {
    map: function () {
      return this;
    },
    resolve: function (t) {
      return new ul(t);
    }
  };

  function dl(t, e, n, o, r, i) {
    if (e.inlineContent) return sl.create(t, n);

    for (var a = o - (r > 0 ? 0 : 1); r > 0 ? a < e.childCount : a >= 0; a += r) {
      var s = e.child(a);

      if (s.isAtom) {
        if (!i && cl.isSelectable(s)) return cl.create(t, n - (r < 0 ? s.nodeSize : 0));
      } else {
        var l = dl(t, s, n + r, r < 0 ? s.childCount : 0, r, i);
        if (l) return l;
      }

      n += s.nodeSize * r;
    }
  }

  function hl(t, e, n) {
    var o = t.steps.length - 1;

    if (!(o < e)) {
      var r,
          i = t.steps[o];
      if (i instanceof zs || i instanceof $s) t.mapping.maps[o].forEach(function (t, e, n, o) {
        null == r && (r = o);
      }), t.setSelection(rl.near(t.doc.resolve(r), n));
    }
  }

  var vl = function (t) {
    function e(e) {
      t.call(this, e.doc), this.time = Date.now(), this.curSelection = e.selection, this.curSelectionFor = 0, this.storedMarks = e.storedMarks, this.updated = 0, this.meta = Object.create(null);
    }

    t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
    var n = {
      selection: {
        configurable: !0
      },
      selectionSet: {
        configurable: !0
      },
      storedMarksSet: {
        configurable: !0
      },
      isGeneric: {
        configurable: !0
      },
      scrolledIntoView: {
        configurable: !0
      }
    };
    return n.selection.get = function () {
      return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
    }, e.prototype.setSelection = function (t) {
      if (t.$from.doc != this.doc) throw new RangeError("Selection passed to setSelection must point at the current document");
      return this.curSelection = t, this.curSelectionFor = this.steps.length, this.updated = -3 & (1 | this.updated), this.storedMarks = null, this;
    }, n.selectionSet.get = function () {
      return (1 & this.updated) > 0;
    }, e.prototype.setStoredMarks = function (t) {
      return this.storedMarks = t, this.updated |= 2, this;
    }, e.prototype.ensureMarks = function (t) {
      return ba.sameSet(this.storedMarks || this.selection.$from.marks(), t) || this.setStoredMarks(t), this;
    }, e.prototype.addStoredMark = function (t) {
      return this.ensureMarks(t.addToSet(this.storedMarks || this.selection.$head.marks()));
    }, e.prototype.removeStoredMark = function (t) {
      return this.ensureMarks(t.removeFromSet(this.storedMarks || this.selection.$head.marks()));
    }, n.storedMarksSet.get = function () {
      return (2 & this.updated) > 0;
    }, e.prototype.addStep = function (e, n) {
      t.prototype.addStep.call(this, e, n), this.updated = -3 & this.updated, this.storedMarks = null;
    }, e.prototype.setTime = function (t) {
      return this.time = t, this;
    }, e.prototype.replaceSelection = function (t) {
      return this.selection.replace(this, t), this;
    }, e.prototype.replaceSelectionWith = function (t, e) {
      var n = this.selection;
      return !1 !== e && (t = t.mark(this.storedMarks || (n.empty ? n.$from.marks() : n.$from.marksAcross(n.$to) || ba.none))), n.replaceWith(this, t), this;
    }, e.prototype.deleteSelection = function () {
      return this.selection.replace(this), this;
    }, e.prototype.insertText = function (t, e, n) {
      void 0 === n && (n = e);
      var o = this.doc.type.schema;
      if (null == e) return t ? this.replaceSelectionWith(o.text(t), !0) : this.deleteSelection();
      if (!t) return this.deleteRange(e, n);
      var r = this.storedMarks;

      if (!r) {
        var i = this.doc.resolve(e);
        r = n == e ? i.marks() : i.marksAcross(this.doc.resolve(n));
      }

      return this.replaceRangeWith(e, n, o.text(t, r)), this.selection.empty || this.setSelection(rl.near(this.selection.$to)), this;
    }, e.prototype.setMeta = function (t, e) {
      return this.meta["string" == typeof t ? t : t.key] = e, this;
    }, e.prototype.getMeta = function (t) {
      return this.meta["string" == typeof t ? t : t.key];
    }, n.isGeneric.get = function () {
      for (var t in this.meta) return !1;

      return !0;
    }, e.prototype.scrollIntoView = function () {
      return this.updated |= 4, this;
    }, n.scrolledIntoView.get = function () {
      return (4 & this.updated) > 0;
    }, Object.defineProperties(e.prototype, n), e;
  }(Is);

  function ml(t, e) {
    return e && t ? t.bind(e) : t;
  }

  var gl = function (t, e, n) {
    this.name = t, this.init = ml(e.init, n), this.apply = ml(e.apply, n);
  },
      yl = [new gl("doc", {
    init: function (t) {
      return t.doc || t.schema.topNodeType.createAndFill();
    },
    apply: function (t) {
      return t.doc;
    }
  }), new gl("selection", {
    init: function (t, e) {
      return t.selection || rl.atStart(e.doc);
    },
    apply: function (t) {
      return t.selection;
    }
  }), new gl("storedMarks", {
    init: function (t) {
      return t.storedMarks || null;
    },
    apply: function (t, e, n, o) {
      return o.selection.$cursor ? t.storedMarks : null;
    }
  }), new gl("scrollToSelection", {
    init: function () {
      return 0;
    },
    apply: function (t, e) {
      return t.scrolledIntoView ? e + 1 : e;
    }
  })],
      bl = function (t, e) {
    var n = this;
    this.schema = t, this.fields = yl.concat(), this.plugins = [], this.pluginsByKey = Object.create(null), e && e.forEach(function (t) {
      if (n.pluginsByKey[t.key]) throw new RangeError("Adding different instances of a keyed plugin (" + t.key + ")");
      n.plugins.push(t), n.pluginsByKey[t.key] = t, t.spec.state && n.fields.push(new gl(t.key, t.spec.state, t));
    });
  },
      wl = function (t) {
    this.config = t;
  },
      Sl = {
    schema: {
      configurable: !0
    },
    plugins: {
      configurable: !0
    },
    tr: {
      configurable: !0
    }
  };

  Sl.schema.get = function () {
    return this.config.schema;
  }, Sl.plugins.get = function () {
    return this.config.plugins;
  }, wl.prototype.apply = function (t) {
    return this.applyTransaction(t).state;
  }, wl.prototype.filterTransaction = function (t, e) {
    void 0 === e && (e = -1);

    for (var n = 0; n < this.config.plugins.length; n++) if (n != e) {
      var o = this.config.plugins[n];
      if (o.spec.filterTransaction && !o.spec.filterTransaction.call(o, t, this)) return !1;
    }

    return !0;
  }, wl.prototype.applyTransaction = function (t) {
    if (!this.filterTransaction(t)) return {
      state: this,
      transactions: []
    };

    for (var e = [t], n = this.applyInner(t), o = null;;) {
      for (var r = !1, i = 0; i < this.config.plugins.length; i++) {
        var a = this.config.plugins[i];

        if (a.spec.appendTransaction) {
          var s = o ? o[i].n : 0,
              l = o ? o[i].state : this,
              c = s < e.length && a.spec.appendTransaction.call(a, s ? e.slice(s) : e, l, n);

          if (c && n.filterTransaction(c, i)) {
            if (c.setMeta("appendedTransaction", t), !o) {
              o = [];

              for (var p = 0; p < this.config.plugins.length; p++) o.push(p < i ? {
                state: n,
                n: e.length
              } : {
                state: this,
                n: 0
              });
            }

            e.push(c), n = n.applyInner(c), r = !0;
          }

          o && (o[i] = {
            state: n,
            n: e.length
          });
        }
      }

      if (!r) return {
        state: n,
        transactions: e
      };
    }
  }, wl.prototype.applyInner = function (t) {
    if (!t.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction");

    for (var e = new wl(this.config), n = this.config.fields, o = 0; o < n.length; o++) {
      var r = n[o];
      e[r.name] = r.apply(t, this[r.name], this, e);
    }

    for (var i = 0; i < Cl.length; i++) Cl[i](this, t, e);

    return e;
  }, Sl.tr.get = function () {
    return new vl(this);
  }, wl.create = function (t) {
    for (var e = new bl(t.schema || t.doc.type.schema, t.plugins), n = new wl(e), o = 0; o < e.fields.length; o++) n[e.fields[o].name] = e.fields[o].init(t, n);

    return n;
  }, wl.prototype.reconfigure = function (t) {
    for (var e = new bl(t.schema || this.schema, t.plugins), n = e.fields, o = new wl(e), r = 0; r < n.length; r++) {
      var i = n[r].name;
      o[i] = this.hasOwnProperty(i) ? this[i] : n[r].init(t, o);
    }

    return o;
  }, wl.prototype.toJSON = function (t) {
    var e = {
      doc: this.doc.toJSON(),
      selection: this.selection.toJSON()
    };
    if (this.storedMarks && (e.storedMarks = this.storedMarks.map(function (t) {
      return t.toJSON();
    })), t && "object" == typeof t) for (var n in t) {
      if ("doc" == n || "selection" == n) throw new RangeError("The JSON fields `doc` and `selection` are reserved");
      var o = t[n],
          r = o.spec.state;
      r && r.toJSON && (e[n] = r.toJSON.call(o, this[o.key]));
    }
    return e;
  }, wl.fromJSON = function (t, e, n) {
    if (!e) throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!t.schema) throw new RangeError("Required config field 'schema' missing");
    var o = new bl(t.schema, t.plugins),
        r = new wl(o);
    return o.fields.forEach(function (o) {
      if ("doc" == o.name) r.doc = Va.fromJSON(t.schema, e.doc);else if ("selection" == o.name) r.selection = rl.fromJSON(r.doc, e.selection);else if ("storedMarks" == o.name) e.storedMarks && (r.storedMarks = e.storedMarks.map(t.schema.markFromJSON));else {
        if (n) for (var i in n) {
          var a = n[i],
              s = a.spec.state;
          if (a.key == o.name && s && s.fromJSON && Object.prototype.hasOwnProperty.call(e, i)) return void (r[o.name] = s.fromJSON.call(a, t, e[i], r));
        }
        r[o.name] = o.init(t, r);
      }
    }), r;
  }, wl.addApplyListener = function (t) {
    Cl.push(t);
  }, wl.removeApplyListener = function (t) {
    var e = Cl.indexOf(t);
    e > -1 && Cl.splice(e, 1);
  }, Object.defineProperties(wl.prototype, Sl);
  var Cl = [];

  var xl = function (t) {
    this.props = {}, t.props && function t(e, n, o) {
      for (var r in e) {
        var i = e[r];
        i instanceof Function ? i = i.bind(n) : "handleDOMEvents" == r && (i = t(i, n, {})), o[r] = i;
      }

      return o;
    }(t.props, this, this.props), this.spec = t, this.key = t.key ? t.key.key : Ol("plugin");
  };

  xl.prototype.getState = function (t) {
    return t[this.key];
  };

  var kl = Object.create(null);

  function Ol(t) {
    return t in kl ? t + "$" + ++kl[t] : (kl[t] = 0, t + "$");
  }

  var Al = function (t) {
    void 0 === t && (t = "key"), this.key = Ol(t);
  };

  Al.prototype.get = function (t) {
    return t.config.pluginsByKey[this.key];
  }, Al.prototype.getState = function (t) {
    return t[this.key];
  };
  var Tl = Object.freeze({
    __proto__: null,
    AllSelection: ul,
    EditorState: wl,
    NodeSelection: cl,
    Plugin: xl,
    PluginKey: Al,
    Selection: rl,
    SelectionRange: al,
    TextSelection: sl,
    Transaction: vl
  });

  function El(t, e) {
    return !t.selection.empty && (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
  }

  function Ml(t, e) {
    for (; t; t = "start" == e ? t.firstChild : t.lastChild) if (t.isTextblock) return !0;

    return !1;
  }

  function Nl(t) {
    if (!t.parent.type.spec.isolating) for (var e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0) return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating) break;
    }
    return null;
  }

  function Rl(t) {
    if (!t.parent.type.spec.isolating) for (var e = t.depth - 1; e >= 0; e--) {
      var n = t.node(e);
      if (t.index(e) + 1 < n.childCount) return t.doc.resolve(t.after(e + 1));
      if (n.type.spec.isolating) break;
    }
    return null;
  }

  function Ll(t, e, n) {
    var o,
        r,
        i = e.nodeBefore,
        a = e.nodeAfter;
    if (i.type.spec.isolating || a.type.spec.isolating) return !1;
    if (function (t, e, n) {
      var o = e.nodeBefore,
          r = e.nodeAfter,
          i = e.index();
      return !(!(o && r && o.type.compatibleContent(r.type)) || (!o.content.size && e.parent.canReplace(i - 1, i) ? (n && n(t.tr.delete(e.pos - o.nodeSize, e.pos).scrollIntoView()), 0) : !e.parent.canReplace(i, i + 1) || !r.isTextblock && !Us(t.doc, e.pos) || (n && n(t.tr.clearIncompatible(e.pos, o.type, o.contentMatchAt(o.childCount)).join(e.pos).scrollIntoView()), 0)));
    }(t, e, n)) return !0;

    if (e.parent.canReplace(e.index(), e.index() + 1) && (o = (r = i.contentMatchAt(i.childCount)).findWrapping(a.type)) && r.matchType(o[0] || a.type).validEnd) {
      if (n) {
        for (var s = e.pos + a.nodeSize, l = ha.empty, c = o.length - 1; c >= 0; c--) l = ha.from(o[c].create(null, l));

        l = ha.from(i.copy(l));
        var p = t.tr.step(new $s(e.pos - 1, s, e.pos, s, new Sa(l, 1, 0), o.length, !0)),
            u = s + 2 * o.length;
        Us(p.doc, u) && p.join(u), n(p.scrollIntoView());
      }

      return !0;
    }

    var f = rl.findFrom(e, 1),
        d = f && f.$from.blockRange(f.$to),
        h = d && Fs(d);
    return null != h && h >= e.depth && (n && n(t.tr.lift(d, h).scrollIntoView()), !0);
  }

  function Il() {
    for (var t = [], e = arguments.length; e--;) t[e] = arguments[e];

    return function (e, n, o) {
      for (var r = 0; r < t.length; r++) if (t[r](e, n, o)) return !0;

      return !1;
    };
  }

  var Pl = Il(El, function (t, e, n) {
    var o = t.selection.$cursor;
    if (!o || (n ? !n.endOfTextblock("backward", t) : o.parentOffset > 0)) return !1;
    var r = Nl(o);

    if (!r) {
      var i = o.blockRange(),
          a = i && Fs(i);
      return null != a && (e && e(t.tr.lift(i, a).scrollIntoView()), !0);
    }

    var s = r.nodeBefore;
    if (!s.type.spec.isolating && Ll(t, r, e)) return !0;

    if (0 == o.parent.content.size && (Ml(s, "end") || cl.isSelectable(s))) {
      if (e) {
        var l = t.tr.deleteRange(o.before(), o.after());
        l.setSelection(Ml(s, "end") ? rl.findFrom(l.doc.resolve(l.mapping.map(r.pos, -1)), -1) : cl.create(l.doc, r.pos - s.nodeSize)), e(l.scrollIntoView());
      }

      return !0;
    }

    return !(!s.isAtom || r.depth != o.depth - 1 || (e && e(t.tr.delete(r.pos - s.nodeSize, r.pos).scrollIntoView()), 0));
  }, function (t, e, n) {
    var o = t.selection.$cursor;
    if (!o || (n ? !n.endOfTextblock("backward", t) : o.parentOffset > 0)) return !1;
    var r = Nl(o),
        i = r && r.nodeBefore;
    return !(!i || !cl.isSelectable(i) || (e && e(t.tr.setSelection(cl.create(t.doc, r.pos - i.nodeSize)).scrollIntoView()), 0));
  }),
      Dl = Il(El, function (t, e, n) {
    var o = t.selection.$cursor;
    if (!o || (n ? !n.endOfTextblock("forward", t) : o.parentOffset < o.parent.content.size)) return !1;
    var r = Rl(o);
    if (!r) return !1;
    var i = r.nodeAfter;
    if (Ll(t, r, e)) return !0;

    if (0 == o.parent.content.size && (Ml(i, "start") || cl.isSelectable(i))) {
      if (e) {
        var a = t.tr.deleteRange(o.before(), o.after());
        a.setSelection(Ml(i, "start") ? rl.findFrom(a.doc.resolve(a.mapping.map(r.pos)), 1) : cl.create(a.doc, a.mapping.map(r.pos))), e(a.scrollIntoView());
      }

      return !0;
    }

    return !(!i.isAtom || r.depth != o.depth - 1 || (e && e(t.tr.delete(r.pos, r.pos + i.nodeSize).scrollIntoView()), 0));
  }, function (t, e, n) {
    var o = t.selection.$cursor;
    if (!o || (n ? !n.endOfTextblock("forward", t) : o.parentOffset < o.parent.content.size)) return !1;
    var r = Rl(o),
        i = r && r.nodeAfter;
    return !(!i || !cl.isSelectable(i) || (e && e(t.tr.setSelection(cl.create(t.doc, r.pos)).scrollIntoView()), 0));
  }),
      _l = {
    Enter: Il(function (t, e) {
      var n = t.selection,
          o = n.$head,
          r = n.$anchor;
      return !(!o.parent.type.spec.code || !o.sameParent(r) || (e && e(t.tr.insertText("\n").scrollIntoView()), 0));
    }, function (t, e) {
      var n = t.selection,
          o = n.$from,
          r = n.$to;
      if (o.parent.inlineContent || r.parent.inlineContent) return !1;
      var i = o.parent.contentMatchAt(r.indexAfter()).defaultType;
      if (!i || !i.isTextblock) return !1;

      if (e) {
        var a = (!o.parentOffset && r.index() < r.parent.childCount ? o : r).pos,
            s = t.tr.insert(a, i.createAndFill());
        s.setSelection(sl.create(s.doc, a + 1)), e(s.scrollIntoView());
      }

      return !0;
    }, function (t, e) {
      var n = t.selection.$cursor;
      if (!n || n.parent.content.size) return !1;

      if (n.depth > 1 && n.after() != n.end(-1)) {
        var o = n.before();
        if (qs(t.doc, o)) return e && e(t.tr.split(o).scrollIntoView()), !0;
      }

      var r = n.blockRange(),
          i = r && Fs(r);
      return null != i && (e && e(t.tr.lift(r, i).scrollIntoView()), !0);
    }, function (t, e) {
      var n = t.selection,
          o = n.$from,
          r = n.$to;
      if (t.selection instanceof cl && t.selection.node.isBlock) return !(!o.parentOffset || !qs(t.doc, o.pos) || (e && e(t.tr.split(o.pos).scrollIntoView()), 0));
      if (!o.parent.isBlock) return !1;

      if (e) {
        var i = r.parentOffset == r.parent.content.size,
            a = t.tr;
        t.selection instanceof sl && a.deleteSelection();
        var s = 0 == o.depth ? null : o.node(-1).contentMatchAt(o.indexAfter(-1)).defaultType,
            l = i && s ? [{
          type: s
        }] : null,
            c = qs(a.doc, a.mapping.map(o.pos), 1, l);
        l || c || !qs(a.doc, a.mapping.map(o.pos), 1, s && [{
          type: s
        }]) || (l = [{
          type: s
        }], c = !0), c && (a.split(a.mapping.map(o.pos), 1, l), i || o.parentOffset || o.parent.type == s || !o.node(-1).canReplace(o.index(-1), o.indexAfter(-1), ha.from(s.create(), o.parent)) || a.setNodeMarkup(a.mapping.map(o.before()), s)), e(a.scrollIntoView());
      }

      return !0;
    }),
    "Mod-Enter": function (t, e) {
      var n = t.selection,
          o = n.$head,
          r = n.$anchor;
      if (!o.parent.type.spec.code || !o.sameParent(r)) return !1;
      var i = o.node(-1),
          a = o.indexAfter(-1),
          s = i.contentMatchAt(a).defaultType;
      if (!i.canReplaceWith(a, a, s)) return !1;

      if (e) {
        var l = o.after(),
            c = t.tr.replaceWith(l, l, s.createAndFill());
        c.setSelection(rl.near(c.doc.resolve(l), 1)), e(c.scrollIntoView());
      }

      return !0;
    },
    Backspace: Pl,
    "Mod-Backspace": Pl,
    Delete: Dl,
    "Mod-Delete": Dl,
    "Mod-a": function (t, e) {
      return e && e(t.tr.setSelection(new ul(t.doc))), !0;
    }
  },
      Bl = {
    "Ctrl-h": _l.Backspace,
    "Alt-Backspace": _l["Mod-Backspace"],
    "Ctrl-d": _l.Delete,
    "Ctrl-Alt-Backspace": _l["Mod-Delete"],
    "Alt-Delete": _l["Mod-Delete"],
    "Alt-d": _l["Mod-Delete"]
  };

  for (var Vl in _l) Bl[Vl] = _l[Vl];

  "undefined" != typeof navigator ? /Mac/.test(navigator.platform) : "undefined" != typeof os && os.platform();

  function zl(t) {
    return function (e, n) {
      var o = e.selection,
          r = o.$from,
          i = o.$to,
          a = r.blockRange(i, function (e) {
        return e.childCount && e.firstChild.type == t;
      });
      return !!a && (!n || (r.node(a.depth - 1).type == t ? function (t, e, n, o) {
        var r = t.tr,
            i = o.end,
            a = o.$to.end(o.depth);
        i < a && (r.step(new $s(i - 1, a, i, a, new Sa(ha.from(n.create(null, o.parent.copy())), 1, 0), 1, !0)), o = new Da(r.doc.resolve(o.$from.pos), r.doc.resolve(a), o.depth));
        return e(r.lift(o, Fs(o)).scrollIntoView()), !0;
      }(e, n, t, a) : function (t, e, n) {
        for (var o = t.tr, r = n.parent, i = n.end, a = n.endIndex - 1, s = n.startIndex; a > s; a--) i -= r.child(a).nodeSize, o.delete(i - 1, i + 1);

        var l = o.doc.resolve(n.start),
            c = l.nodeAfter,
            p = 0 == n.startIndex,
            u = n.endIndex == r.childCount,
            f = l.node(-1),
            d = l.index(-1);
        if (!f.canReplace(d + (p ? 0 : 1), d + 1, c.content.append(u ? ha.empty : ha.from(r)))) return !1;
        var h = l.pos,
            v = h + c.nodeSize;
        return o.step(new $s(h - (p ? 1 : 0), v + (u ? 1 : 0), h + 1, v - 1, new Sa((p ? ha.empty : ha.from(r.copy(ha.empty))).append(u ? ha.empty : ha.from(r.copy(ha.empty))), p ? 0 : 1, u ? 0 : 1), p ? 0 : 1)), e(o.scrollIntoView()), !0;
      }(e, n, a)));
    };
  }

  function $l(t) {
    return function (e, n) {
      var o = e.selection,
          r = o.$from,
          i = o.$to,
          a = r.blockRange(i, function (e) {
        return e.childCount && e.firstChild.type == t;
      });
      if (!a) return !1;
      var s = a.startIndex;
      if (0 == s) return !1;
      var l = a.parent,
          c = l.child(s - 1);
      if (c.type != t) return !1;

      if (n) {
        var p = c.lastChild && c.lastChild.type == l.type,
            u = ha.from(p ? t.create() : null),
            f = new Sa(ha.from(t.create(null, ha.from(l.type.create(null, u)))), p ? 3 : 1, 0),
            d = a.start,
            h = a.end;
        n(e.tr.step(new $s(d - (p ? 3 : 1), h, d, h, f, 1, !0)).scrollIntoView());
      }

      return !0;
    };
  }

  for (var jl = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'",
    229: "q"
  }, Hl = jl, Fl = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ";",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"',
    229: "Q"
  }, ql = "undefined" != typeof navigator && /Chrome\/(\d+)/.exec(navigator.userAgent), Ul = "undefined" != typeof navigator && /Apple Computer/.test(navigator.vendor), Wl = "undefined" != typeof navigator && /Gecko\/\d+/.test(navigator.userAgent), Kl = "undefined" != typeof navigator && /Mac/.test(navigator.platform), Jl = "undefined" != typeof navigator && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), Gl = ql && (Kl || +ql[1] < 57) || Wl && Kl, Xl = 0; Xl < 10; Xl++) jl[48 + Xl] = jl[96 + Xl] = String(Xl);

  for (Xl = 1; Xl <= 24; Xl++) jl[Xl + 111] = "F" + Xl;

  for (Xl = 65; Xl <= 90; Xl++) jl[Xl] = String.fromCharCode(Xl + 32), Fl[Xl] = String.fromCharCode(Xl);

  for (var Yl in jl) Fl.hasOwnProperty(Yl) || (Fl[Yl] = jl[Yl]);

  var Zl = function (t) {
    var e = !(Gl && (t.ctrlKey || t.altKey || t.metaKey) || (Ul || Jl) && t.shiftKey && t.key && 1 == t.key.length) && t.key || (t.shiftKey ? Fl : jl)[t.keyCode] || t.key || "Unidentified";
    return "Esc" == e && (e = "Escape"), "Del" == e && (e = "Delete"), "Left" == e && (e = "ArrowLeft"), "Up" == e && (e = "ArrowUp"), "Right" == e && (e = "ArrowRight"), "Down" == e && (e = "ArrowDown"), e;
  },
      Ql = "undefined" != typeof navigator && /Mac/.test(navigator.platform);

  function tc(t) {
    var e,
        n,
        o,
        r,
        i = t.split(/-(?!$)/),
        a = i[i.length - 1];
    "Space" == a && (a = " ");

    for (var s = 0; s < i.length - 1; s++) {
      var l = i[s];
      if (/^(cmd|meta|m)$/i.test(l)) r = !0;else if (/^a(lt)?$/i.test(l)) e = !0;else if (/^(c|ctrl|control)$/i.test(l)) n = !0;else if (/^s(hift)?$/i.test(l)) o = !0;else {
        if (!/^mod$/i.test(l)) throw new Error("Unrecognized modifier name: " + l);
        Ql ? r = !0 : n = !0;
      }
    }

    return e && (a = "Alt-" + a), n && (a = "Ctrl-" + a), r && (a = "Meta-" + a), o && (a = "Shift-" + a), a;
  }

  function ec(t, e, n) {
    return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), !1 !== n && e.shiftKey && (t = "Shift-" + t), t;
  }

  var nc = {};

  if ("undefined" != typeof navigator && "undefined" != typeof document) {
    var oc = /Edge\/(\d+)/.exec(navigator.userAgent),
        rc = /MSIE \d/.test(navigator.userAgent),
        ic = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    nc.mac = /Mac/.test(navigator.platform);
    var ac = nc.ie = !!(rc || ic || oc);
    nc.ie_version = rc ? document.documentMode || 6 : ic ? +ic[1] : oc ? +oc[1] : null, nc.gecko = !ac && /gecko\/(\d+)/i.test(navigator.userAgent), nc.gecko_version = nc.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
    var sc = !ac && /Chrome\/(\d+)/.exec(navigator.userAgent);
    nc.chrome = !!sc, nc.chrome_version = sc && +sc[1], nc.ios = !ac && /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent), nc.android = /Android \d/.test(navigator.userAgent), nc.webkit = !ac && "WebkitAppearance" in document.documentElement.style, nc.safari = /Apple Computer/.test(navigator.vendor), nc.webkit_version = nc.webkit && +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
  }

  var lc = function (t) {
    for (var e = 0;; e++) if (!(t = t.previousSibling)) return e;
  },
      cc = function (t) {
    var e = t.parentNode;
    return e && 11 == e.nodeType ? e.host : e;
  },
      pc = function (t, e, n) {
    var o = document.createRange();
    return o.setEnd(t, null == n ? t.nodeValue.length : n), o.setStart(t, e || 0), o;
  },
      uc = function (t, e, n, o) {
    return n && (dc(t, e, n, o, -1) || dc(t, e, n, o, 1));
  },
      fc = /^(img|br|input|textarea|hr)$/i;

  function dc(t, e, n, o, r) {
    for (;;) {
      if (t == n && e == o) return !0;

      if (e == (r < 0 ? 0 : hc(t))) {
        var i = t.parentNode;
        if (1 != i.nodeType || vc(t) || fc.test(t.nodeName) || "false" == t.contentEditable) return !1;
        e = lc(t) + (r < 0 ? 0 : 1), t = i;
      } else {
        if (1 != t.nodeType) return !1;
        if ("false" == (t = t.childNodes[e + (r < 0 ? -1 : 0)]).contentEditable) return !1;
        e = r < 0 ? hc(t) : 0;
      }
    }
  }

  function hc(t) {
    return 3 == t.nodeType ? t.nodeValue.length : t.childNodes.length;
  }

  function vc(t) {
    for (var e, n = t; n && !(e = n.pmViewDesc); n = n.parentNode);

    return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
  }

  var mc = function (t) {
    var e = t.isCollapsed;
    return e && nc.chrome && t.rangeCount && !t.getRangeAt(0).collapsed && (e = !1), e;
  };

  function gc(t, e) {
    var n = document.createEvent("Event");
    return n.initEvent("keydown", !0, !0), n.keyCode = t, n.key = n.code = e, n;
  }

  function yc(t) {
    return {
      left: 0,
      right: t.innerWidth,
      top: 0,
      bottom: t.innerHeight
    };
  }

  function bc(t, e) {
    return "number" == typeof t ? t : t[e];
  }

  function wc(t, e, n) {
    for (var o = t.someProp("scrollThreshold") || 0, r = t.someProp("scrollMargin") || 5, i = t.dom.ownerDocument, a = i.defaultView, s = n || t.dom; s; s = cc(s)) if (1 == s.nodeType) {
      var l = s == i.body || 1 != s.nodeType,
          c = l ? yc(a) : s.getBoundingClientRect(),
          p = 0,
          u = 0;
      if (e.top < c.top + bc(o, "top") ? u = -(c.top - e.top + bc(r, "top")) : e.bottom > c.bottom - bc(o, "bottom") && (u = e.bottom - c.bottom + bc(r, "bottom")), e.left < c.left + bc(o, "left") ? p = -(c.left - e.left + bc(r, "left")) : e.right > c.right - bc(o, "right") && (p = e.right - c.right + bc(r, "right")), (p || u) && (l ? a.scrollBy(p, u) : (u && (s.scrollTop += u), p && (s.scrollLeft += p))), l) break;
    }
  }

  function Sc(t) {
    for (var e = [], n = t.ownerDocument; t && (e.push({
      dom: t,
      top: t.scrollTop,
      left: t.scrollLeft
    }), t != n); t = cc(t));

    return e;
  }

  function Cc(t, e) {
    for (var n = 0; n < t.length; n++) {
      var o = t[n],
          r = o.dom,
          i = o.top,
          a = o.left;
      r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != a && (r.scrollLeft = a);
    }
  }

  var xc = null;

  function kc(t, e) {
    for (var n, o, r = 2e8, i = 0, a = e.top, s = e.top, l = t.firstChild, c = 0; l; l = l.nextSibling, c++) {
      var p = void 0;
      if (1 == l.nodeType) p = l.getClientRects();else {
        if (3 != l.nodeType) continue;
        p = pc(l).getClientRects();
      }

      for (var u = 0; u < p.length; u++) {
        var f = p[u];

        if (f.top <= a && f.bottom >= s) {
          a = Math.max(f.bottom, a), s = Math.min(f.top, s);
          var d = f.left > e.left ? f.left - e.left : f.right < e.left ? e.left - f.right : 0;

          if (d < r) {
            n = l, r = d, o = d && 3 == n.nodeType ? {
              left: f.right < e.left ? f.right : f.left,
              top: e.top
            } : e, 1 == l.nodeType && d && (i = c + (e.left >= (f.left + f.right) / 2 ? 1 : 0));
            continue;
          }
        }

        !n && (e.left >= f.right && e.top >= f.top || e.left >= f.left && e.top >= f.bottom) && (i = c + 1);
      }
    }

    return n && 3 == n.nodeType ? function (t, e) {
      for (var n = t.nodeValue.length, o = document.createRange(), r = 0; r < n; r++) {
        o.setEnd(t, r + 1), o.setStart(t, r);
        var i = Tc(o, 1);
        if (i.top != i.bottom && Oc(e, i)) return {
          node: t,
          offset: r + (e.left >= (i.left + i.right) / 2 ? 1 : 0)
        };
      }

      return {
        node: t,
        offset: 0
      };
    }(n, o) : !n || r && 1 == n.nodeType ? {
      node: t,
      offset: i
    } : kc(n, o);
  }

  function Oc(t, e) {
    return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1;
  }

  function Ac(t, e) {
    var n,
        o,
        r,
        i,
        a = t.root;
    if (a.caretPositionFromPoint) try {
      var s = a.caretPositionFromPoint(e.left, e.top);
      s && (r = (n = s).offsetNode, i = n.offset);
    } catch (t) {}

    if (!r && a.caretRangeFromPoint) {
      var l = a.caretRangeFromPoint(e.left, e.top);
      l && (r = (o = l).startContainer, i = o.startOffset);
    }

    var c,
        p = a.elementFromPoint(e.left, e.top + 1);

    if (!p || !t.dom.contains(1 != p.nodeType ? p.parentNode : p)) {
      var u = t.dom.getBoundingClientRect();
      if (!Oc(e, u)) return null;
      if (!(p = function t(e, n, o) {
        var r = e.childNodes.length;
        if (r && o.top < o.bottom) for (var i = Math.max(0, Math.min(r - 1, Math.floor(r * (n.top - o.top) / (o.bottom - o.top)) - 2)), a = i;;) {
          var s = e.childNodes[a];
          if (1 == s.nodeType) for (var l = s.getClientRects(), c = 0; c < l.length; c++) {
            var p = l[c];
            if (Oc(n, p)) return t(s, n, p);
          }
          if ((a = (a + 1) % r) == i) break;
        }
        return e;
      }(t.dom, e, u))) return null;
    }

    if (p = function (t, e) {
      var n = t.parentNode;
      return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t;
    }(p, e), r) {
      if (nc.gecko && 1 == r.nodeType && (i = Math.min(i, r.childNodes.length)) < r.childNodes.length) {
        var f,
            d = r.childNodes[i];
        "IMG" == d.nodeName && (f = d.getBoundingClientRect()).right <= e.left && f.bottom > e.top && i++;
      }

      r == t.dom && i == r.childNodes.length - 1 && 1 == r.lastChild.nodeType && e.top > r.lastChild.getBoundingClientRect().bottom ? c = t.state.doc.content.size : 0 != i && 1 == r.nodeType && "BR" == r.childNodes[i - 1].nodeName || (c = function (t, e, n, o) {
        for (var r = -1, i = e; i != t.dom;) {
          var a = t.docView.nearestDesc(i, !0);
          if (!a) return null;

          if (a.node.isBlock && a.parent) {
            var s = a.dom.getBoundingClientRect();
            if (s.left > o.left || s.top > o.top) r = a.posBefore;else {
              if (!(s.right < o.left || s.bottom < o.top)) break;
              r = a.posAfter;
            }
          }

          i = a.dom.parentNode;
        }

        return r > -1 ? r : t.docView.posFromDOM(e, n);
      }(t, r, i, e));
    }

    null == c && (c = function (t, e, n) {
      var o = kc(e, n),
          r = o.node,
          i = o.offset,
          a = -1;

      if (1 == r.nodeType && !r.firstChild) {
        var s = r.getBoundingClientRect();
        a = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
      }

      return t.docView.posFromDOM(r, i, a);
    }(t, p, e));
    var h = t.docView.nearestDesc(p, !0);
    return {
      pos: c,
      inside: h ? h.posAtStart - h.border : -1
    };
  }

  function Tc(t, e) {
    var n = t.getClientRects();
    return n.length ? n[e < 0 ? 0 : n.length - 1] : t.getBoundingClientRect();
  }

  function Ec(t, e) {
    var n = t.docView.domFromPos(e),
        o = n.node,
        r = n.offset;

    if (3 == o.nodeType && (nc.chrome || nc.gecko)) {
      var i = Tc(pc(o, r, r), 0);

      if (nc.gecko && r && /\s/.test(o.nodeValue[r - 1]) && r < o.nodeValue.length) {
        var a = Tc(pc(o, r - 1, r - 1), -1);

        if (Math.abs(a.left - i.left) < 1 && a.top == i.top) {
          var s = Tc(pc(o, r, r + 1), -1);
          return Mc(s, s.left < a.left);
        }
      }

      return i;
    }

    if (1 == o.nodeType && !t.state.doc.resolve(e).parent.inlineContent) {
      var l,
          c = !0;

      if (r < o.childNodes.length) {
        var p = o.childNodes[r];
        1 == p.nodeType && (l = p.getBoundingClientRect());
      }

      if (!l && r) {
        var u = o.childNodes[r - 1];
        1 == u.nodeType && (l = u.getBoundingClientRect(), c = !1);
      }

      return function (t, e) {
        if (0 == t.height) return t;
        var n = e ? t.top : t.bottom;
        return {
          top: n,
          bottom: n,
          left: t.left,
          right: t.right
        };
      }(l || o.getBoundingClientRect(), c);
    }

    for (var f = -1; f < 2; f += 2) if (f < 0 && r) {
      var d = void 0,
          h = 3 == o.nodeType ? pc(o, r - 1, r) : 3 == (d = o.childNodes[r - 1]).nodeType ? pc(d) : 1 == d.nodeType && "BR" != d.nodeName ? d : null;

      if (h) {
        var v = Tc(h, 1);
        if (v.top < v.bottom) return Mc(v, !1);
      }
    } else if (f > 0 && r < hc(o)) {
      var m = void 0,
          g = 3 == o.nodeType ? pc(o, r, r + 1) : 3 == (m = o.childNodes[r]).nodeType ? pc(m) : 1 == m.nodeType ? m : null;

      if (g) {
        var y = Tc(g, -1);
        if (y.top < y.bottom) return Mc(y, !0);
      }
    }

    return Mc(Tc(3 == o.nodeType ? pc(o) : o, 0), !1);
  }

  function Mc(t, e) {
    if (0 == t.width) return t;
    var n = e ? t.left : t.right;
    return {
      top: t.top,
      bottom: t.bottom,
      left: n,
      right: n
    };
  }

  function Nc(t, e, n) {
    var o = t.state,
        r = t.root.activeElement;
    o != e && t.updateState(e), r != t.dom && t.focus();

    try {
      return n();
    } finally {
      o != e && t.updateState(o), r != t.dom && r.focus();
    }
  }

  var Rc = /[\u0590-\u08ac]/;
  var Lc = null,
      Ic = null,
      Pc = !1;

  function Dc(t, e, n) {
    return Lc == e && Ic == n ? Pc : (Lc = e, Ic = n, Pc = "up" == n || "down" == n ? function (t, e, n) {
      var o = e.selection,
          r = "up" == n ? o.$anchor.min(o.$head) : o.$anchor.max(o.$head);
      return Nc(t, e, function () {
        for (var e = t.docView.domFromPos(r.pos).node;;) {
          var o = t.docView.nearestDesc(e, !0);
          if (!o) break;

          if (o.node.isBlock) {
            e = o.dom;
            break;
          }

          e = o.dom.parentNode;
        }

        for (var i = Ec(t, r.pos), a = e.firstChild; a; a = a.nextSibling) {
          var s = void 0;
          if (1 == a.nodeType) s = a.getClientRects();else {
            if (3 != a.nodeType) continue;
            s = pc(a, 0, a.nodeValue.length).getClientRects();
          }

          for (var l = 0; l < s.length; l++) {
            var c = s[l];
            if (c.bottom > c.top && ("up" == n ? c.bottom < i.top + 1 : c.top > i.bottom - 1)) return !1;
          }
        }

        return !0;
      });
    }(t, e, n) : function (t, e, n) {
      var o = e.selection.$head;
      if (!o.parent.isTextblock) return !1;
      var r = o.parentOffset,
          i = !r,
          a = r == o.parent.content.size,
          s = getSelection();
      return Rc.test(o.parent.textContent) && s.modify ? Nc(t, e, function () {
        var e = s.getRangeAt(0),
            r = s.focusNode,
            i = s.focusOffset,
            a = s.caretBidiLevel;
        s.modify("move", n, "character");
        var l = !(o.depth ? t.docView.domAfterPos(o.before()) : t.dom).contains(1 == s.focusNode.nodeType ? s.focusNode : s.focusNode.parentNode) || r == s.focusNode && i == s.focusOffset;
        return s.removeAllRanges(), s.addRange(e), null != a && (s.caretBidiLevel = a), l;
      }) : "left" == n || "backward" == n ? i : a;
    }(t, e, n));
  }

  var _c = function (t, e, n, o) {
    this.parent = t, this.children = e, this.dom = n, n.pmViewDesc = this, this.contentDOM = o, this.dirty = 0;
  },
      Bc = {
    beforePosition: {
      configurable: !0
    },
    size: {
      configurable: !0
    },
    border: {
      configurable: !0
    },
    posBefore: {
      configurable: !0
    },
    posAtStart: {
      configurable: !0
    },
    posAfter: {
      configurable: !0
    },
    posAtEnd: {
      configurable: !0
    },
    contentLost: {
      configurable: !0
    }
  };

  _c.prototype.matchesWidget = function () {
    return !1;
  }, _c.prototype.matchesMark = function () {
    return !1;
  }, _c.prototype.matchesNode = function () {
    return !1;
  }, _c.prototype.matchesHack = function () {
    return !1;
  }, Bc.beforePosition.get = function () {
    return !1;
  }, _c.prototype.parseRule = function () {
    return null;
  }, _c.prototype.stopEvent = function () {
    return !1;
  }, Bc.size.get = function () {
    for (var t = 0, e = 0; e < this.children.length; e++) t += this.children[e].size;

    return t;
  }, Bc.border.get = function () {
    return 0;
  }, _c.prototype.destroy = function () {
    this.parent = null, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = null);

    for (var t = 0; t < this.children.length; t++) this.children[t].destroy();
  }, _c.prototype.posBeforeChild = function (t) {
    for (var e = 0, n = this.posAtStart; e < this.children.length; e++) {
      var o = this.children[e];
      if (o == t) return n;
      n += o.size;
    }
  }, Bc.posBefore.get = function () {
    return this.parent.posBeforeChild(this);
  }, Bc.posAtStart.get = function () {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }, Bc.posAfter.get = function () {
    return this.posBefore + this.size;
  }, Bc.posAtEnd.get = function () {
    return this.posAtStart + this.size - 2 * this.border;
  }, _c.prototype.localPosFromDOM = function (t, e, n) {
    if (this.contentDOM && this.contentDOM.contains(1 == t.nodeType ? t : t.parentNode)) {
      if (n < 0) {
        var o, r;
        if (t == this.contentDOM) o = t.childNodes[e - 1];else {
          for (; t.parentNode != this.contentDOM;) t = t.parentNode;

          o = t.previousSibling;
        }

        for (; o && (!(r = o.pmViewDesc) || r.parent != this);) o = o.previousSibling;

        return o ? this.posBeforeChild(r) + r.size : this.posAtStart;
      }

      var i, a;
      if (t == this.contentDOM) i = t.childNodes[e];else {
        for (; t.parentNode != this.contentDOM;) t = t.parentNode;

        i = t.nextSibling;
      }

      for (; i && (!(a = i.pmViewDesc) || a.parent != this);) i = i.nextSibling;

      return i ? this.posBeforeChild(a) : this.posAtEnd;
    }

    var s;
    if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) s = 2 & t.compareDocumentPosition(this.contentDOM);else if (this.dom.firstChild) {
      if (0 == e) for (var l = t;; l = l.parentNode) {
        if (l == this.dom) {
          s = !1;
          break;
        }

        if (l.parentNode.firstChild != l) break;
      }
      if (null == s && e == t.childNodes.length) for (var c = t;; c = c.parentNode) {
        if (c == this.dom) {
          s = !0;
          break;
        }

        if (c.parentNode.lastChild != c) break;
      }
    }
    return (null == s ? n > 0 : s) ? this.posAtEnd : this.posAtStart;
  }, _c.prototype.nearestDesc = function (t, e) {
    for (var n = !0, o = t; o; o = o.parentNode) {
      var r = this.getDesc(o);

      if (r && (!e || r.node)) {
        if (!n || !r.nodeDOM || (1 == r.nodeDOM.nodeType ? r.nodeDOM.contains(t) : r.nodeDOM == t)) return r;
        n = !1;
      }
    }
  }, _c.prototype.getDesc = function (t) {
    for (var e = t.pmViewDesc, n = e; n; n = n.parent) if (n == this) return e;
  }, _c.prototype.posFromDOM = function (t, e, n) {
    for (var o = t;; o = o.parentNode) {
      var r = this.getDesc(o);
      if (r) return r.localPosFromDOM(t, e, n);
    }
  }, _c.prototype.descAt = function (t) {
    for (var e = 0, n = 0; e < this.children.length; e++) {
      var o = this.children[e],
          r = n + o.size;

      if (n == t && r != n) {
        for (; !o.border && o.children.length;) o = o.children[0];

        return o;
      }

      if (t < r) return o.descAt(t - n - o.border);
      n = r;
    }
  }, _c.prototype.domFromPos = function (t) {
    if (!this.contentDOM) return {
      node: this.dom,
      offset: 0
    };

    for (var e = 0, n = 0;; n++) {
      if (e == t) {
        for (; n < this.children.length && (this.children[n].beforePosition || this.children[n].dom.parentNode != this.contentDOM);) n++;

        return {
          node: this.contentDOM,
          offset: n == this.children.length ? this.contentDOM.childNodes.length : lc(this.children[n].dom)
        };
      }

      if (n == this.children.length) throw new Error("Invalid position " + t);
      var o = this.children[n],
          r = e + o.size;
      if (t < r) return o.domFromPos(t - e - o.border);
      e = r;
    }
  }, _c.prototype.parseRange = function (t, e, n) {
    if (void 0 === n && (n = 0), 0 == this.children.length) return {
      node: this.contentDOM,
      from: t,
      to: e,
      fromOffset: 0,
      toOffset: this.contentDOM.childNodes.length
    };

    for (var o = -1, r = -1, i = n, a = 0;; a++) {
      var s = this.children[a],
          l = i + s.size;

      if (-1 == o && t <= l) {
        var c = i + s.border;
        if (t >= c && e <= l - s.border && s.node && s.contentDOM && this.contentDOM.contains(s.contentDOM)) return s.parseRange(t, e, c);
        t = i;

        for (var p = a; p > 0; p--) {
          var u = this.children[p - 1];

          if (u.size && u.dom.parentNode == this.contentDOM && !u.emptyChildAt(1)) {
            o = lc(u.dom) + 1;
            break;
          }

          t -= u.size;
        }

        -1 == o && (o = 0);
      }

      if (o > -1 && e <= l) {
        e = l;

        for (var f = a + 1; f < this.children.length; f++) {
          var d = this.children[f];

          if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) {
            r = lc(d.dom);
            break;
          }

          e += d.size;
        }

        -1 == r && (r = this.contentDOM.childNodes.length);
        break;
      }

      i = l;
    }

    return {
      node: this.contentDOM,
      from: t,
      to: e,
      fromOffset: o,
      toOffset: r
    };
  }, _c.prototype.emptyChildAt = function (t) {
    if (this.border || !this.contentDOM || !this.children.length) return !1;
    var e = this.children[t < 0 ? 0 : this.children.length - 1];
    return 0 == e.size || e.emptyChildAt(t);
  }, _c.prototype.domAfterPos = function (t) {
    var e = this.domFromPos(t),
        n = e.node,
        o = e.offset;
    if (1 != n.nodeType || o == n.childNodes.length) throw new RangeError("No node after pos " + t);
    return n.childNodes[o];
  }, _c.prototype.setSelection = function (t, e, n, o) {
    for (var r = Math.min(t, e), i = Math.max(t, e), a = 0, s = 0; a < this.children.length; a++) {
      var l = this.children[a],
          c = s + l.size;
      if (r > s && i < c) return l.setSelection(t - s - l.border, e - s - l.border, n, o);
      s = c;
    }

    var p = this.domFromPos(t),
        u = this.domFromPos(e),
        f = n.getSelection(),
        d = document.createRange();

    if (o || !uc(p.node, p.offset, f.anchorNode, f.anchorOffset) || !uc(u.node, u.offset, f.focusNode, f.focusOffset)) {
      if (f.extend) d.setEnd(p.node, p.offset), d.collapse(!1);else {
        if (t > e) {
          var h = p;
          p = u, u = h;
        }

        d.setEnd(u.node, u.offset), d.setStart(p.node, p.offset);
      }
      f.removeAllRanges(), f.addRange(d), f.extend && f.extend(u.node, u.offset);
    }
  }, _c.prototype.ignoreMutation = function (t) {
    return !this.contentDOM && "selection" != t.type;
  }, Bc.contentLost.get = function () {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }, _c.prototype.markDirty = function (t, e) {
    for (var n = 0, o = 0; o < this.children.length; o++) {
      var r = this.children[o],
          i = n + r.size;

      if (n == i ? t <= i && e >= n : t < i && e > n) {
        var a = n + r.border,
            s = i - r.border;
        if (t >= a && e <= s) return this.dirty = t == n || e == i ? 2 : 1, void (t != a || e != s || !r.contentLost && r.dom.parentNode == this.contentDOM ? r.markDirty(t - a, e - a) : r.dirty = 3);
        r.dirty = 3;
      }

      n = i;
    }

    this.dirty = 2;
  }, _c.prototype.markParentsDirty = function () {
    for (var t = this.parent; t; t = t.parent) {
      t.dirty < 2 && (t.dirty = 2);
    }
  }, Object.defineProperties(_c.prototype, Bc);

  var Vc = [],
      zc = function (t) {
    function e(e, n, o, r) {
      var i,
          a = n.type.toDOM;

      if ("function" == typeof a && (a = a(o, function () {
        return i ? i.parent ? i.parent.posBeforeChild(i) : void 0 : r;
      })), !n.type.spec.raw) {
        if (1 != a.nodeType) {
          var s = document.createElement("span");
          s.appendChild(a), a = s;
        }

        a.contentEditable = !1, a.classList.add("ProseMirror-widget");
      }

      t.call(this, e, Vc, a, null), this.widget = n, i = this;
    }

    t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
    var n = {
      beforePosition: {
        configurable: !0
      }
    };
    return n.beforePosition.get = function () {
      return this.widget.type.side < 0;
    }, e.prototype.matchesWidget = function (t) {
      return 0 == this.dirty && t.type.eq(this.widget.type);
    }, e.prototype.parseRule = function () {
      return {
        ignore: !0
      };
    }, e.prototype.stopEvent = function (t) {
      var e = this.widget.spec.stopEvent;
      return !!e && e(t);
    }, Object.defineProperties(e.prototype, n), e;
  }(_c),
      $c = function (t) {
    function e(e, n, o, r) {
      t.call(this, e, Vc, n, null), this.textDOM = o, this.text = r;
    }

    t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
    var n = {
      size: {
        configurable: !0
      }
    };
    return n.size.get = function () {
      return this.text.length;
    }, e.prototype.localPosFromDOM = function (t, e) {
      return t != this.textDOM ? this.posAtStart + (e ? this.size : 0) : this.posAtStart + e;
    }, e.prototype.domFromPos = function (t) {
      return {
        node: this.textDOM,
        offset: t
      };
    }, e.prototype.ignoreMutation = function (t) {
      return "characterData" === t.type && t.target.nodeValue == t.oldValue;
    }, Object.defineProperties(e.prototype, n), e;
  }(_c),
      jc = function (t) {
    function e(e, n, o, r) {
      t.call(this, e, [], o, r), this.mark = n;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.create = function (t, n, o, r) {
      var i = r.nodeViews[n.type.name],
          a = i && i(n, r, o);
      return a && a.dom || (a = Cs.renderSpec(document, n.type.spec.toDOM(n, o))), new e(t, n, a.dom, a.contentDOM || a.dom);
    }, e.prototype.parseRule = function () {
      return {
        mark: this.mark.type.name,
        attrs: this.mark.attrs,
        contentElement: this.contentDOM
      };
    }, e.prototype.matchesMark = function (t) {
      return 3 != this.dirty && this.mark.eq(t);
    }, e.prototype.markDirty = function (e, n) {
      if (t.prototype.markDirty.call(this, e, n), 0 != this.dirty) {
        for (var o = this.parent; !o.node;) o = o.parent;

        o.dirty < this.dirty && (o.dirty = this.dirty), this.dirty = 0;
      }
    }, e.prototype.slice = function (t, n, o) {
      var r = e.create(this.parent, this.mark, !0, o),
          i = this.children,
          a = this.size;
      n < a && (i = op(i, n, a, o)), t > 0 && (i = op(i, 0, t, o));

      for (var s = 0; s < i.length; s++) i[s].parent = r;

      return r.children = i, r;
    }, e;
  }(_c),
      Hc = function (t) {
    function e(e, n, o, r, i, a, s, l, c) {
      t.call(this, e, n.isLeaf ? Vc : [], i, a), this.nodeDOM = s, this.node = n, this.outerDeco = o, this.innerDeco = r, a && this.updateChildren(l, c);
    }

    t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
    var n = {
      size: {
        configurable: !0
      },
      border: {
        configurable: !0
      }
    };
    return e.create = function (t, n, o, r, i, a) {
      var s,
          l,
          c = i.nodeViews[n.type.name],
          p = c && c(n, i, function () {
        return l ? l.parent ? l.parent.posBeforeChild(l) : void 0 : a;
      }, o),
          u = p && p.dom,
          f = p && p.contentDOM;
      if (n.isText) {
        if (u) {
          if (3 != u.nodeType) throw new RangeError("Text must be rendered as a DOM text node");
        } else u = document.createTextNode(n.text);
      } else u || (u = (s = Cs.renderSpec(document, n.type.spec.toDOM(n))).dom, f = s.contentDOM);
      f || n.isText || "BR" == u.nodeName || (u.hasAttribute("contenteditable") || (u.contentEditable = !1), n.type.spec.draggable && (u.draggable = !0));
      var d = u;
      return u = Zc(u, o, n), p ? l = new Wc(t, n, o, r, u, f, d, p, i, a + 1) : n.isText ? new qc(t, n, o, r, u, d, i) : new e(t, n, o, r, u, f, d, i, a + 1);
    }, e.prototype.parseRule = function () {
      var t = this;
      if (this.node.type.spec.reparseInView) return null;
      var e = {
        node: this.node.type.name,
        attrs: this.node.attrs
      };
      return this.node.type.spec.code && (e.preserveWhitespace = "full"), this.contentDOM && !this.contentLost ? e.contentElement = this.contentDOM : e.getContent = function () {
        return t.contentDOM ? ha.empty : t.node.content;
      }, e;
    }, e.prototype.matchesNode = function (t, e, n) {
      return 0 == this.dirty && t.eq(this.node) && Qc(e, this.outerDeco) && n.eq(this.innerDeco);
    }, n.size.get = function () {
      return this.node.nodeSize;
    }, n.border.get = function () {
      return this.node.isLeaf ? 0 : 1;
    }, e.prototype.updateChildren = function (t, e) {
      var n = this,
          o = this.node.inlineContent,
          r = e,
          i = o && t.composing && this.localCompositionNode(t, e),
          a = new ep(this, i && i.node);
      !function (t, e, n, o) {
        var r = e.locals(t),
            i = 0;

        if (0 == r.length) {
          for (var a = 0; a < t.childCount; a++) {
            var s = t.child(a);
            o(s, r, e.forChild(i, s), a), i += s.nodeSize;
          }

          return;
        }

        for (var l = 0, c = [], p = null, u = 0;;) {
          if (l < r.length && r[l].to == i) {
            for (var f = r[l++], d = void 0; l < r.length && r[l].to == i;) (d || (d = [f])).push(r[l++]);

            if (d) {
              d.sort(np);

              for (var h = 0; h < d.length; h++) n(d[h], u, !!p);
            } else n(f, u, !!p);
          }

          var v = void 0,
              m = void 0;
          if (p) m = -1, v = p, p = null;else {
            if (!(u < t.childCount)) break;
            m = u, v = t.child(u++);
          }

          for (var g = 0; g < c.length; g++) c[g].to <= i && c.splice(g--, 1);

          for (; l < r.length && r[l].from == i;) c.push(r[l++]);

          var y = i + v.nodeSize;

          if (v.isText) {
            var b = y;
            l < r.length && r[l].from < b && (b = r[l].from);

            for (var w = 0; w < c.length; w++) c[w].to < b && (b = c[w].to);

            b < y && (p = v.cut(b - i), v = v.cut(0, b - i), y = b, m = -1);
          }

          o(v, c.length ? c.slice() : Vc, e.forChild(i, v), m), i = y;
        }
      }(this.node, this.innerDeco, function (e, i, s) {
        e.spec.marks ? a.syncToMarks(e.spec.marks, o, t) : e.type.side >= 0 && !s && a.syncToMarks(i == n.node.childCount ? ba.none : n.node.child(i).marks, o, t), a.placeWidget(e, t, r);
      }, function (e, n, i, s) {
        a.syncToMarks(e.marks, o, t), a.findNodeMatch(e, n, i, s) || a.updateNextNode(e, n, i, t, s) || a.addNode(e, n, i, t, r), r += e.nodeSize;
      }), a.syncToMarks(Vc, o, t), this.node.isTextblock && a.addTextblockHacks(), a.destroyRest(), (a.changed || 2 == this.dirty) && (i && this.protectLocalComposition(t, i), this.renderChildren());
    }, e.prototype.renderChildren = function () {
      !function t(e, n) {
        var o = e.firstChild;

        for (var r = 0; r < n.length; r++) {
          var i = n[r],
              a = i.dom;

          if (a.parentNode == e) {
            for (; a != o;) o = tp(o);

            o = o.nextSibling;
          } else e.insertBefore(a, o);

          if (i instanceof jc) {
            var s = o ? o.previousSibling : e.lastChild;
            t(i.contentDOM, i.children), o = s ? s.nextSibling : e.firstChild;
          }
        }

        for (; o;) o = tp(o);
      }(this.contentDOM, this.children), nc.ios && function (t) {
        if ("UL" == t.nodeName || "OL" == t.nodeName) {
          var e = t.style.cssText;
          t.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t).listStyle, t.style.cssText = e;
        }
      }(this.dom);
    }, e.prototype.localCompositionNode = function (t, e) {
      var n = t.state.selection,
          o = n.from,
          r = n.to;

      if (!(!(t.state.selection instanceof sl) || o < e || r > e + this.node.content.size)) {
        var i = t.root.getSelection(),
            a = function (t, e) {
          for (;;) {
            if (3 == t.nodeType) return t;

            if (1 == t.nodeType && e > 0) {
              if (t.childNodes.length > e && 3 == t.childNodes[e].nodeType) return t.childNodes[e];
              t = t.childNodes[e - 1], e = hc(t);
            } else {
              if (!(1 == t.nodeType && e < t.childNodes.length)) return null;
              t = t.childNodes[e], e = 0;
            }
          }
        }(i.focusNode, i.focusOffset);

        if (a && this.dom.contains(a.parentNode)) {
          var s = a.nodeValue,
              l = function (t, e, n, o) {
            for (var r = "", i = 0, a = 0; i < t.childCount; i++) {
              var s = t.child(i),
                  l = a + s.nodeSize;

              if (s.isText) {
                if (r += s.text, l >= o) {
                  for (var c = l - r.length, p = r.lastIndexOf(e); p > -1 && c + p > n;) p = r.lastIndexOf(e, p - 1);

                  if (p > -1 && c + p + e.length >= o) return c + p;
                  if (l > o) break;
                }
              } else r = "";

              a = l;
            }

            return -1;
          }(this.node.content, s, o - e, r - e);

          return l < 0 ? null : {
            node: a,
            pos: l,
            text: s
          };
        }
      }
    }, e.prototype.protectLocalComposition = function (t, e) {
      var n = e.node,
          o = e.pos,
          r = e.text;

      if (!this.getDesc(n)) {
        for (var i = n; i.parentNode != this.contentDOM; i = i.parentNode) {
          for (; i.previousSibling;) i.parentNode.removeChild(i.previousSibling);

          for (; i.nextSibling;) i.parentNode.removeChild(i.nextSibling);

          i.pmViewDesc && (i.pmViewDesc = null);
        }

        var a = new $c(this, i, n, r);
        t.compositionNodes.push(a), this.children = op(this.children, o, o + r.length, t, a);
      }
    }, e.prototype.update = function (t, e, n, o) {
      return !(3 == this.dirty || !t.sameMarkup(this.node)) && (this.updateInner(t, e, n, o), !0);
    }, e.prototype.updateInner = function (t, e, n, o) {
      this.updateOuterDeco(e), this.node = t, this.innerDeco = n, this.contentDOM && this.updateChildren(o, this.posAtStart), this.dirty = 0;
    }, e.prototype.updateOuterDeco = function (t) {
      if (!Qc(t, this.outerDeco)) {
        var e = 1 != this.nodeDOM.nodeType,
            n = this.dom;
        this.dom = Xc(this.dom, this.nodeDOM, Gc(this.outerDeco, this.node, e), Gc(t, this.node, e)), this.dom != n && (n.pmViewDesc = null, this.dom.pmViewDesc = this), this.outerDeco = t;
      }
    }, e.prototype.selectNode = function () {
      this.nodeDOM.classList.add("ProseMirror-selectednode"), !this.contentDOM && this.node.type.spec.draggable || (this.dom.draggable = !0);
    }, e.prototype.deselectNode = function () {
      this.nodeDOM.classList.remove("ProseMirror-selectednode"), !this.contentDOM && this.node.type.spec.draggable || (this.dom.draggable = !1);
    }, Object.defineProperties(e.prototype, n), e;
  }(_c);

  function Fc(t, e, n, o, r) {
    return Zc(o, e, t), new Hc(null, t, e, n, o, o, o, r, 0);
  }

  var qc = function (t) {
    function e(e, n, o, r, i, a, s) {
      t.call(this, e, n, o, r, i, null, a, s);
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.parseRule = function () {
      return {
        skip: this.nodeDOM.parentNode || !0
      };
    }, e.prototype.update = function (t, e) {
      return !(3 == this.dirty || 0 != this.dirty && !this.inParent() || !t.sameMarkup(this.node)) && (this.updateOuterDeco(e), 0 == this.dirty && t.text == this.node.text || t.text == this.nodeDOM.nodeValue || (this.nodeDOM.nodeValue = t.text), this.node = t, this.dirty = 0, !0);
    }, e.prototype.inParent = function () {
      for (var t = this.parent.contentDOM, e = this.nodeDOM; e; e = e.parentNode) if (e == t) return !0;

      return !1;
    }, e.prototype.domFromPos = function (t) {
      return {
        node: this.nodeDOM,
        offset: t
      };
    }, e.prototype.localPosFromDOM = function (e, n, o) {
      return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : t.prototype.localPosFromDOM.call(this, e, n, o);
    }, e.prototype.ignoreMutation = function (t) {
      return "characterData" != t.type && "selection" != t.type;
    }, e.prototype.slice = function (t, n, o) {
      var r = this.node.cut(t, n),
          i = document.createTextNode(r.text);
      return new e(this.parent, r, this.outerDeco, this.innerDeco, i, i, o);
    }, e;
  }(Hc),
      Uc = function (t) {
    function e() {
      t.apply(this, arguments);
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.parseRule = function () {
      return {
        ignore: !0
      };
    }, e.prototype.matchesHack = function () {
      return 0 == this.dirty;
    }, e;
  }(_c),
      Wc = function (t) {
    function e(e, n, o, r, i, a, s, l, c, p) {
      t.call(this, e, n, o, r, i, a, s, c, p), this.spec = l;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.update = function (e, n, o, r) {
      if (3 == this.dirty) return !1;

      if (this.spec.update) {
        var i = this.spec.update(e, n);
        return i && this.updateInner(e, n, o, r), i;
      }

      return !(!this.contentDOM && !e.isLeaf) && t.prototype.update.call(this, e, n, o, r);
    }, e.prototype.selectNode = function () {
      this.spec.selectNode ? this.spec.selectNode() : t.prototype.selectNode.call(this);
    }, e.prototype.deselectNode = function () {
      this.spec.deselectNode ? this.spec.deselectNode() : t.prototype.deselectNode.call(this);
    }, e.prototype.setSelection = function (e, n, o, r) {
      this.spec.setSelection ? this.spec.setSelection(e, n, o) : t.prototype.setSelection.call(this, e, n, o, r);
    }, e.prototype.destroy = function () {
      this.spec.destroy && this.spec.destroy(), t.prototype.destroy.call(this);
    }, e.prototype.stopEvent = function (t) {
      return !!this.spec.stopEvent && this.spec.stopEvent(t);
    }, e.prototype.ignoreMutation = function (e) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : t.prototype.ignoreMutation.call(this, e);
    }, e;
  }(Hc);

  function Kc(t) {
    t && (this.nodeName = t);
  }

  Kc.prototype = Object.create(null);
  var Jc = [new Kc()];

  function Gc(t, e, n) {
    if (0 == t.length) return Jc;

    for (var o = n ? Jc[0] : new Kc(), r = [o], i = 0; i < t.length; i++) {
      var a = t[i].type.attrs,
          s = o;
      if (a) for (var l in a.nodeName && r.push(s = new Kc(a.nodeName)), a) {
        var c = a[l];
        null != c && (n && 1 == r.length && r.push(s = o = new Kc(e.isInline ? "span" : "div")), "class" == l ? s.class = (s.class ? s.class + " " : "") + c : "style" == l ? s.style = (s.style ? s.style + ";" : "") + c : "nodeName" != l && (s[l] = c));
      }
    }

    return r;
  }

  function Xc(t, e, n, o) {
    if (n == Jc && o == Jc) return e;

    for (var r = e, i = 0; i < o.length; i++) {
      var a = o[i],
          s = n[i];

      if (i) {
        var l = void 0;
        s && s.nodeName == a.nodeName && r != t && (l = r.parentNode) && l.tagName.toLowerCase() == a.nodeName ? r = l : ((l = document.createElement(a.nodeName)).appendChild(r), s = Jc[0], r = l);
      }

      Yc(r, s || Jc[0], a);
    }

    return r;
  }

  function Yc(t, e, n) {
    for (var o in e) "class" == o || "style" == o || "nodeName" == o || o in n || t.removeAttribute(o);

    for (var r in n) "class" != r && "style" != r && "nodeName" != r && n[r] != e[r] && t.setAttribute(r, n[r]);

    if (e.class != n.class) {
      for (var i = e.class ? e.class.split(" ") : Vc, a = n.class ? n.class.split(" ") : Vc, s = 0; s < i.length; s++) -1 == a.indexOf(i[s]) && t.classList.remove(i[s]);

      for (var l = 0; l < a.length; l++) -1 == i.indexOf(a[l]) && t.classList.add(a[l]);
    }

    if (e.style != n.style) {
      if (e.style) for (var c, p = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g; c = p.exec(e.style);) t.style.removeProperty(c[1]);
      n.style && (t.style.cssText += n.style);
    }
  }

  function Zc(t, e, n) {
    return Xc(t, t, Jc, Gc(e, n, 1 != t.nodeType));
  }

  function Qc(t, e) {
    if (t.length != e.length) return !1;

    for (var n = 0; n < t.length; n++) if (!t[n].type.eq(e[n].type)) return !1;

    return !0;
  }

  function tp(t) {
    var e = t.nextSibling;
    return t.parentNode.removeChild(t), e;
  }

  var ep = function (t, e) {
    this.top = t, this.lock = e, this.index = 0, this.stack = [], this.changed = !1;

    var n = function (t, e) {
      for (var n = [], o = t.childCount, r = e.length - 1; o > 0 && r >= 0; r--) {
        var i = e[r],
            a = i.node;

        if (a) {
          if (a != t.child(o - 1)) break;
          n.push(i), --o;
        }
      }

      return {
        nodes: n.reverse(),
        offset: o
      };
    }(t.node.content, t.children);

    this.preMatched = n.nodes, this.preMatchOffset = n.offset;
  };

  function np(t, e) {
    return t.type.side - e.type.side;
  }

  function op(t, e, n, o, r) {
    for (var i = [], a = 0, s = 0; a < t.length; a++) {
      var l = t[a],
          c = s,
          p = s += l.size;
      c >= n || p <= e ? i.push(l) : (c < e && i.push(l.slice(0, e - c, o)), r && (i.push(r), r = null), p > n && i.push(l.slice(n - c, l.size, o)));
    }

    return i;
  }

  function rp(t, e) {
    var n = t.selection,
        o = n.$anchor,
        r = n.$head,
        i = e > 0 ? o.max(r) : o.min(r),
        a = i.parent.inlineContent ? i.depth ? t.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
    return a && rl.findFrom(a, e);
  }

  function ip(t, e) {
    return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
  }

  function ap(t, e, n) {
    var o = t.state.selection;

    if (o instanceof sl) {
      if (!o.empty || n.indexOf("s") > -1) return !1;

      if (t.endOfTextblock(e > 0 ? "right" : "left")) {
        var r = rp(t.state, e);
        return !!(r && r instanceof cl) && ip(t, r);
      }

      var i,
          a = o.$head,
          s = a.textOffset ? null : e < 0 ? a.nodeBefore : a.nodeAfter;
      if (!s || s.isText) return !1;
      var l = e < 0 ? a.pos - s.nodeSize : a.pos;
      return !!(s.isAtom || (i = t.docView.descAt(l)) && !i.contentDOM) && (cl.isSelectable(s) ? ip(t, new cl(e < 0 ? t.state.doc.resolve(a.pos - s.nodeSize) : a)) : !!nc.webkit && ip(t, new sl(t.state.doc.resolve(e < 0 ? l : l + s.nodeSize))));
    }

    if (o instanceof cl && o.node.isInline) return ip(t, new sl(e > 0 ? o.$to : o.$from));
    var c = rp(t.state, e);
    return !!c && ip(t, c);
  }

  function sp(t) {
    return 3 == t.nodeType ? t.nodeValue.length : t.childNodes.length;
  }

  function lp(t) {
    var e = t.pmViewDesc;
    return e && 0 == e.size && (t.nextSibling || "BR" != t.nodeName);
  }

  function cp(t) {
    var e = t.root.getSelection(),
        n = e.focusNode,
        o = e.focusOffset;

    if (n) {
      var r,
          i,
          a = !1;

      for (nc.gecko && 1 == n.nodeType && o < sp(n) && lp(n.childNodes[o]) && (a = !0);;) if (o > 0) {
        if (1 != n.nodeType) break;
        var s = n.childNodes[o - 1];
        if (lp(s)) r = n, i = --o;else {
          if (3 != s.nodeType) break;
          o = (n = s).nodeValue.length;
        }
      } else {
        if (up(n)) break;

        for (var l = n.previousSibling; l && lp(l);) r = n.parentNode, i = lc(l), l = l.previousSibling;

        if (l) o = sp(n = l);else {
          if ((n = n.parentNode) == t.dom) break;
          o = 0;
        }
      }

      a ? fp(t, e, n, o) : r && fp(t, e, r, i);
    }
  }

  function pp(t) {
    var e = t.root.getSelection(),
        n = e.focusNode,
        o = e.focusOffset;

    if (n) {
      for (var r, i, a = sp(n);;) if (o < a) {
        if (1 != n.nodeType) break;
        if (!lp(n.childNodes[o])) break;
        r = n, i = ++o;
      } else {
        if (up(n)) break;

        for (var s = n.nextSibling; s && lp(s);) r = s.parentNode, i = lc(s) + 1, s = s.nextSibling;

        if (s) o = 0, a = sp(n = s);else {
          if ((n = n.parentNode) == t.dom) break;
          o = a = 0;
        }
      }

      r && fp(t, e, r, i);
    }
  }

  function up(t) {
    var e = t.pmViewDesc;
    return e && e.node && e.node.isBlock;
  }

  function fp(t, e, n, o) {
    if (mc(e)) {
      var r = document.createRange();
      r.setEnd(n, o), r.setStart(n, o), e.removeAllRanges(), e.addRange(r);
    } else e.extend && e.extend(n, o);

    t.domObserver.setCurSelection();
  }

  function dp(t, e, n) {
    var o = t.state.selection;
    if (o instanceof sl && !o.empty || n.indexOf("s") > -1) return !1;
    var r = o.$from,
        i = o.$to;

    if (!r.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
      var a = rp(t.state, e);
      if (a && a instanceof cl) return ip(t, a);
    }

    if (!r.parent.inlineContent) {
      var s = rl.findFrom(e < 0 ? r : i, e);
      return !s || ip(t, s);
    }

    return !1;
  }

  function hp(t, e) {
    if (!(t.state.selection instanceof sl)) return !0;
    var n = t.state.selection,
        o = n.$head,
        r = n.$anchor,
        i = n.empty;
    if (!o.sameParent(r)) return !0;
    if (!i) return !1;
    if (t.endOfTextblock(e > 0 ? "forward" : "backward")) return !0;
    var a = !o.textOffset && (e < 0 ? o.nodeBefore : o.nodeAfter);

    if (a && !a.isText) {
      var s = t.state.tr;
      return e < 0 ? s.delete(o.pos - a.nodeSize, o.pos) : s.delete(o.pos, o.pos + a.nodeSize), t.dispatch(s), !0;
    }

    return !1;
  }

  function vp(t, e, n) {
    t.domObserver.stop(), e.contentEditable = n, t.domObserver.start();
  }

  function mp(t, e) {
    var n = e.keyCode,
        o = function (t) {
      var e = "";
      return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e;
    }(e);

    return 8 == n || nc.mac && 72 == n && "c" == o ? hp(t, -1) || cp(t) : 46 == n || nc.mac && 68 == n && "c" == o ? hp(t, 1) || pp(t) : 13 == n && !nc.ios || 27 == n || (37 == n ? ap(t, -1, o) || cp(t) : 39 == n ? ap(t, 1, o) || pp(t) : 38 == n ? dp(t, -1, o) || cp(t) : 40 == n ? function (t) {
      if (nc.chrome && !(t.state.selection.$head.parentOffset > 0)) {
        var e = t.root.getSelection(),
            n = e.focusNode,
            o = e.focusOffset;

        if (n && 1 == n.nodeType && 0 == o && n.firstChild && "false" == n.firstChild.contentEditable) {
          var r = n.firstChild;
          vp(t, r, !0), setTimeout(function () {
            return vp(t, r, !1);
          }, 20);
        }
      }
    }(t) || dp(t, 1, o) || pp(t) : o == (nc.mac ? "m" : "c") && (66 == n || 73 == n || 89 == n || 90 == n));
  }

  function gp(t, e) {
    var n,
        o,
        r = t.root.getSelection(),
        i = t.state.doc,
        a = t.docView.nearestDesc(r.focusNode),
        s = a && 0 == a.size,
        l = t.docView.posFromDOM(r.focusNode, r.focusOffset),
        c = i.resolve(l);

    if (mc(r)) {
      for (n = c; a && !a.node;) a = a.parent;

      if (a && a.node.isAtom && cl.isSelectable(a.node) && a.parent && (!a.node.isInline || !function (t, e) {
        for (var n = t.focusNode, o = t.focusOffset, r = o; n;) {
          if (n == e) return 0 == o || r == hc(e);
          o = lc(n), r = o + 1, n = n.parentNode;
        }
      }(r, a.dom))) {
        var p = a.posBefore;
        o = new cl(l == p ? c : i.resolve(p));
      }
    } else n = i.resolve(t.docView.posFromDOM(r.anchorNode, r.anchorOffset));

    o || (o = Op(t, n, c, "pointer" == e || t.state.selection.head < c.pos && !s ? 1 : -1));
    return o;
  }

  function yp(t, e) {
    var n = t.state.selection;

    if (xp(t, n), t.editable ? t.hasFocus() : Ap(t) && document.activeElement.contains(t.dom)) {
      if (t.domObserver.disconnectSelection(), t.cursorWrapper) !function (t) {
        var e = t.root.getSelection(),
            n = document.createRange(),
            o = t.cursorWrapper.dom,
            r = "IMG" == o.nodeName;
        r ? n.setEnd(o.parentNode, lc(o) + 1) : n.setEnd(o, 0);
        n.collapse(!1), e.removeAllRanges(), e.addRange(n), !r && !t.state.selection.visible && nc.ie && nc.ie_version <= 11 && (o.disabled = !0, o.disabled = !1);
      }(t);else {
        var o,
            r,
            i = n.anchor,
            a = n.head;
        !bp || n instanceof sl || (n.$from.parent.inlineContent || (o = wp(t, n.from)), n.empty || n.$from.parent.inlineContent || (r = wp(t, n.to))), t.docView.setSelection(i, a, t.root, e), bp && (o && Cp(o), r && Cp(r)), n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : i != a && (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && function (t) {
          var e = t.dom.ownerDocument;
          e.removeEventListener("selectionchange", t.hideSelectionGuard);
          var n = t.root.getSelection(),
              o = n.anchorNode,
              r = n.anchorOffset;
          e.addEventListener("selectionchange", t.hideSelectionGuard = function () {
            n.anchorNode == o && n.anchorOffset == r || (e.removeEventListener("selectionchange", t.hideSelectionGuard), t.dom.classList.remove("ProseMirror-hideselection"));
          });
        }(t));
      }
      t.domObserver.setCurSelection(), t.domObserver.connectSelection();
    }
  }

  ep.prototype.getPreMatch = function (t) {
    return t >= this.preMatchOffset ? this.preMatched[t - this.preMatchOffset] : null;
  }, ep.prototype.destroyBetween = function (t, e) {
    if (t != e) {
      for (var n = t; n < e; n++) this.top.children[n].destroy();

      this.top.children.splice(t, e - t), this.changed = !0;
    }
  }, ep.prototype.destroyRest = function () {
    this.destroyBetween(this.index, this.top.children.length);
  }, ep.prototype.syncToMarks = function (t, e, n) {
    for (var o = 0, r = this.stack.length >> 1, i = Math.min(r, t.length); o < i && (o == r - 1 ? this.top : this.stack[o + 1 << 1]).matchesMark(t[o]) && !1 !== t[o].type.spec.spanning;) o++;

    for (; o < r;) this.destroyRest(), this.top.dirty = 0, this.index = this.stack.pop(), this.top = this.stack.pop(), r--;

    for (; r < t.length;) {
      this.stack.push(this.top, this.index + 1);

      for (var a = -1, s = this.index; s < Math.min(this.index + 3, this.top.children.length); s++) if (this.top.children[s].matchesMark(t[r])) {
        a = s;
        break;
      }

      if (a > -1) a > this.index && (this.changed = !0, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];else {
        var l = jc.create(this.top, t[r], e, n);
        this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0;
      }
      this.index = 0, r++;
    }
  }, ep.prototype.findNodeMatch = function (t, e, n, o) {
    var r = -1,
        i = o < 0 ? void 0 : this.getPreMatch(o),
        a = this.top.children;
    if (i && i.matchesNode(t, e, n)) r = a.indexOf(i);else for (var s = this.index, l = Math.min(a.length, s + 5); s < l; s++) {
      var c = a[s];

      if (c.matchesNode(t, e, n) && this.preMatched.indexOf(c) < 0) {
        r = s;
        break;
      }
    }
    return !(r < 0) && (this.destroyBetween(this.index, r), this.index++, !0);
  }, ep.prototype.updateNextNode = function (t, e, n, o, r) {
    if (this.index == this.top.children.length) return !1;
    var i = this.top.children[this.index];

    if (i instanceof Hc) {
      var a = this.preMatched.indexOf(i);
      if (a > -1 && a + this.preMatchOffset != r) return !1;
      var s = i.dom;
      if (!(this.lock && (s == this.lock || 1 == s.nodeType && s.contains(this.lock.parentNode)) && !(t.isText && i.node && i.node.isText && i.nodeDOM.nodeValue == t.text && 3 != i.dirty && Qc(e, i.outerDeco))) && i.update(t, e, n, o)) return i.dom != s && (this.changed = !0), this.index++, !0;
    }

    return !1;
  }, ep.prototype.addNode = function (t, e, n, o, r) {
    this.top.children.splice(this.index++, 0, Hc.create(this.top, t, e, n, o, r)), this.changed = !0;
  }, ep.prototype.placeWidget = function (t, e, n) {
    if (this.index < this.top.children.length && this.top.children[this.index].matchesWidget(t)) this.index++;else {
      var o = new zc(this.top, t, e, n);
      this.top.children.splice(this.index++, 0, o), this.changed = !0;
    }
  }, ep.prototype.addTextblockHacks = function () {
    for (var t = this.top.children[this.index - 1]; t instanceof jc;) t = t.children[t.children.length - 1];

    if (!t || !(t instanceof qc) || /\n$/.test(t.node.text)) if (this.index < this.top.children.length && this.top.children[this.index].matchesHack()) this.index++;else {
      var e = document.createElement("br");
      this.top.children.splice(this.index++, 0, new Uc(this.top, Vc, e, null)), this.changed = !0;
    }
  };
  var bp = nc.safari || nc.chrome && nc.chrome_version < 63;

  function wp(t, e) {
    var n = t.docView.domFromPos(e),
        o = n.node,
        r = n.offset,
        i = r < o.childNodes.length ? o.childNodes[r] : null,
        a = r ? o.childNodes[r - 1] : null;

    if ((!i || "false" == i.contentEditable) && (nc.safari || !a || "false" == a.contentEditable)) {
      if (i) return Sp(i);
      if (a) return Sp(a);
    }
  }

  function Sp(t) {
    return t.contentEditable = "true", nc.safari && t.draggable && (t.draggable = !1, t.wasDraggable = !0), t;
  }

  function Cp(t) {
    t.contentEditable = "false", t.wasDraggable && (t.draggable = !0, t.wasDraggable = null);
  }

  function xp(t, e) {
    if (e instanceof cl) {
      var n = t.docView.descAt(e.from);
      n != t.lastSelectedViewDesc && (kp(t), n && n.selectNode(), t.lastSelectedViewDesc = n);
    } else kp(t);
  }

  function kp(t) {
    t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = null);
  }

  function Op(t, e, n, o) {
    return t.someProp("createSelectionBetween", function (o) {
      return o(t, e, n);
    }) || sl.between(e, n, o);
  }

  function Ap(t) {
    var e = t.root.getSelection();
    if (!e.anchorNode) return !1;

    try {
      return t.dom.contains(3 == e.anchorNode.nodeType ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(3 == e.focusNode.nodeType ? e.focusNode.parentNode : e.focusNode));
    } catch (t) {
      return !1;
    }
  }

  function Tp(t) {
    var e = t.pmViewDesc;
    if (e) return e.parseRule();

    if ("BR" == t.nodeName && t.parentNode) {
      if (nc.safari && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
        var n = document.createElement("div");
        return n.appendChild(document.createElement("li")), {
          skip: n
        };
      }

      if (t.parentNode.lastChild == t || nc.safari && /^(tr|table)$/i.test(t.parentNode.nodeName)) return {
        ignore: !0
      };
    } else if ("IMG" == t.nodeName && t.getAttribute("mark-placeholder")) return {
      ignore: !0
    };
  }

  function Ep(t, e, n, o, r) {
    if (e < 0) {
      var i = t.lastSelectionTime > Date.now() - 50 ? t.lastSelectionOrigin : null,
          a = gp(t, i);

      if (!t.state.selection.eq(a)) {
        var s = t.state.tr.setSelection(a);
        "pointer" == i ? s.setMeta("pointer", !0) : "key" == i && s.scrollIntoView(), t.dispatch(s);
      }
    } else {
      var l = t.state.doc.resolve(e),
          c = l.sharedDepth(n);
      e = l.before(c + 1), n = t.state.doc.resolve(n).after(c + 1);

      var p,
          u,
          f = t.state.selection,
          d = function (t, e, n) {
        var o = t.docView.parseRange(e, n),
            r = o.node,
            i = o.fromOffset,
            a = o.toOffset,
            s = o.from,
            l = o.to,
            c = t.root.getSelection(),
            p = null,
            u = c.anchorNode;
        if (u && t.dom.contains(1 == u.nodeType ? u : u.parentNode) && (p = [{
          node: u,
          offset: c.anchorOffset
        }], mc(c) || p.push({
          node: c.focusNode,
          offset: c.focusOffset
        })), nc.chrome && 8 === t.lastKeyCode) for (var f = a; f > i; f--) {
          var d = r.childNodes[f - 1],
              h = d.pmViewDesc;

          if ("BR" == d.nodeType && !h) {
            a = f;
            break;
          }

          if (!h || h.size) break;
        }
        var v = t.state.doc,
            m = t.someProp("domParser") || ps.fromSchema(t.state.schema),
            g = v.resolve(s),
            y = null,
            b = m.parse(r, {
          topNode: g.parent,
          topMatch: g.parent.contentMatchAt(g.index()),
          topOpen: !0,
          from: i,
          to: a,
          preserveWhitespace: !g.parent.type.spec.code || "full",
          editableContent: !0,
          findPositions: p,
          ruleFromNode: Tp,
          context: g
        });

        if (p && null != p[0].pos) {
          var w = p[0].pos,
              S = p[1] && p[1].pos;
          null == S && (S = w), y = {
            anchor: w + s,
            head: S + s
          };
        }

        return {
          doc: b,
          sel: y,
          from: s,
          to: l
        };
      }(t, e, n),
          h = t.state.doc,
          v = h.slice(d.from, d.to);

      8 === t.lastKeyCode && Date.now() - 100 < t.lastKeyCodeTime ? (p = t.state.selection.to, u = "end") : (p = t.state.selection.from, u = "start"), t.lastKeyCode = null;

      var m = function (t, e, n, o, r) {
        var i = t.findDiffStart(e, n);
        if (null == i) return null;
        var a = t.findDiffEnd(e, n + t.size, n + e.size),
            s = a.a,
            l = a.b;

        if ("end" == r) {
          var c = Math.max(0, i - Math.min(s, l));
          o -= s + c - i;
        }

        if (s < i && t.size < e.size) {
          var p = o <= i && o >= s ? i - o : 0;
          l = (i -= p) + (l - s), s = i;
        } else if (l < i) {
          var u = o <= i && o >= l ? i - o : 0;
          s = (i -= u) + (s - l), l = i;
        }

        return {
          start: i,
          endA: s,
          endB: l
        };
      }(v.content, d.doc.content, d.from, p, u);

      if (!m) {
        if (!(o && f instanceof sl && !f.empty && f.$head.sameParent(f.$anchor)) || t.composing || d.sel && d.sel.anchor != d.sel.head) {
          if (d.sel) {
            var g = Mp(t, t.state.doc, d.sel);
            g && !g.eq(t.state.selection) && t.dispatch(t.state.tr.setSelection(g));
          }

          return;
        }

        m = {
          start: f.from,
          endA: f.to,
          endB: f.to
        };
      }

      t.domChangeCount++, t.state.selection.from < t.state.selection.to && m.start == m.endB && t.state.selection instanceof sl && (m.start > t.state.selection.from && m.start <= t.state.selection.from + 2 ? m.start = t.state.selection.from : m.endA < t.state.selection.to && m.endA >= t.state.selection.to - 2 && (m.endB += t.state.selection.to - m.endA, m.endA = t.state.selection.to)), nc.ie && nc.ie_version <= 11 && m.endB == m.start + 1 && m.endA == m.start && m.start > d.from && "  " == d.doc.textBetween(m.start - d.from - 1, m.start - d.from + 1) && (m.start--, m.endA--, m.endB--);
      var y,
          b = d.doc.resolveNoCache(m.start - d.from),
          w = d.doc.resolveNoCache(m.endB - d.from);
      if ((nc.ios && t.lastIOSEnter > Date.now() - 100 && (!b.sameParent(w) || r.some(function (t) {
        return "DIV" == t.nodeName;
      })) || !b.sameParent(w) && b.pos < d.doc.content.size && (y = rl.findFrom(d.doc.resolve(b.pos + 1), 1, !0)) && y.head == w.pos) && t.someProp("handleKeyDown", function (e) {
        return e(t, gc(13, "Enter"));
      })) t.lastIOSEnter = 0;else if (t.state.selection.anchor > m.start && function (t, e, n, o, r) {
        if (!o.parent.isTextblock || n - e <= r.pos - o.pos || Np(o, !0, !1) < r.pos) return !1;
        var i = t.resolve(e);
        if (i.parentOffset < i.parent.content.size || !i.parent.isTextblock) return !1;
        var a = t.resolve(Np(i, !0, !0));
        if (!a.parent.isTextblock || a.pos > n || Np(a, !0, !1) < n) return !1;
        return o.parent.content.cut(o.parentOffset).eq(a.parent.content);
      }(h, m.start, m.endA, b, w) && t.someProp("handleKeyDown", function (e) {
        return e(t, gc(8, "Backspace"));
      })) nc.android && nc.chrome && t.domObserver.suppressSelectionUpdates();else {
        var S,
            C,
            x,
            k,
            O = m.start,
            A = m.endA;
        if (b.sameParent(w) && b.parent.inlineContent) if (b.pos == w.pos) nc.ie && nc.ie_version <= 11 && 0 == b.parentOffset && (t.domObserver.suppressSelectionUpdates(), setTimeout(function () {
          return yp(t);
        }, 20)), S = t.state.tr.delete(O, A), C = h.resolve(m.start).marksAcross(h.resolve(m.endA));else if (m.endA == m.endB && (k = h.resolve(m.start)) && (x = function (t, e) {
          for (var n, o, r, i = t.firstChild.marks, a = e.firstChild.marks, s = i, l = a, c = 0; c < a.length; c++) s = a[c].removeFromSet(s);

          for (var p = 0; p < i.length; p++) l = i[p].removeFromSet(l);

          if (1 == s.length && 0 == l.length) o = s[0], n = "add", r = function (t) {
            return t.mark(o.addToSet(t.marks));
          };else {
            if (0 != s.length || 1 != l.length) return null;
            o = l[0], n = "remove", r = function (t) {
              return t.mark(o.removeFromSet(t.marks));
            };
          }

          for (var u = [], f = 0; f < e.childCount; f++) u.push(r(e.child(f)));

          if (ha.from(u).eq(t)) return {
            mark: o,
            type: n
          };
        }(b.parent.content.cut(b.parentOffset, w.parentOffset), k.parent.content.cut(k.parentOffset, m.endA - k.start())))) S = t.state.tr, "add" == x.type ? S.addMark(O, A, x.mark) : S.removeMark(O, A, x.mark);else if (b.parent.child(b.index()).isText && b.index() == w.index() - (w.textOffset ? 0 : 1)) {
          var T = b.parent.textBetween(b.parentOffset, w.parentOffset);
          if (t.someProp("handleTextInput", function (e) {
            return e(t, O, A, T);
          })) return;
          S = t.state.tr.insertText(T, O, A);
        }

        if (S || (S = t.state.tr.replace(O, A, d.doc.slice(m.start - d.from, m.endB - d.from))), d.sel) {
          var E = Mp(t, S.doc, d.sel);
          E && !(nc.chrome && nc.android && t.composing && E.empty && E.head == O || nc.ie && E.empty && E.head == O) && S.setSelection(E);
        }

        C && S.ensureMarks(C), t.dispatch(S.scrollIntoView());
      }
    }
  }

  function Mp(t, e, n) {
    return Math.max(n.anchor, n.head) > e.content.size ? null : Op(t, e.resolve(n.anchor), e.resolve(n.head));
  }

  function Np(t, e, n) {
    for (var o = t.depth, r = e ? t.end() : t.pos; o > 0 && (e || t.indexAfter(o) == t.node(o).childCount);) o--, r++, e = !1;

    if (n) for (var i = t.node(o).maybeChild(t.indexAfter(o)); i && !i.isLeaf;) i = i.firstChild, r++;
    return r;
  }

  function Rp(t, e) {
    for (var n = [], o = e.content, r = e.openStart, i = e.openEnd; r > 1 && i > 1 && 1 == o.childCount && 1 == o.firstChild.childCount;) {
      r--, i--;
      var a = o.firstChild;
      n.push(a.type.name, a.type.hasRequiredAttrs() ? a.attrs : null), o = a.content;
    }

    var s = t.someProp("clipboardSerializer") || Cs.fromSchema(t.state.schema),
        l = Bp(),
        c = l.createElement("div");
    c.appendChild(s.serializeFragment(o, {
      document: l
    }));

    for (var p, u = c.firstChild; u && 1 == u.nodeType && (p = Dp[u.nodeName.toLowerCase()]);) {
      for (var f = p.length - 1; f >= 0; f--) {
        for (var d = l.createElement(p[f]); c.firstChild;) d.appendChild(c.firstChild);

        c.appendChild(d);
      }

      u = c.firstChild;
    }

    return u && 1 == u.nodeType && u.setAttribute("data-pm-slice", r + " " + i + " " + JSON.stringify(n)), {
      dom: c,
      text: t.someProp("clipboardTextSerializer", function (t) {
        return t(e);
      }) || e.content.textBetween(0, e.content.size, "\n\n")
    };
  }

  function Lp(t, e, n, o, r) {
    var i,
        a,
        s = r.parent.type.spec.code;
    if (!n && !e) return null;
    var l = e && (o || s || !n);

    if (l) {
      if (t.someProp("transformPastedText", function (t) {
        e = t(e);
      }), s) return new Sa(ha.from(t.state.schema.text(e)), 0, 0);
      var c = t.someProp("clipboardTextParser", function (t) {
        return t(e, r);
      });
      c ? a = c : (i = document.createElement("div"), e.trim().split(/(?:\r\n?|\n)+/).forEach(function (t) {
        i.appendChild(document.createElement("p")).textContent = t;
      }));
    } else t.someProp("transformPastedHTML", function (t) {
      n = t(n);
    }), i = function (t) {
      var e = /(\s*<meta [^>]*>)*/.exec(t);
      e && (t = t.slice(e[0].length));
      var n,
          o = Bp().createElement("div"),
          r = /(?:<meta [^>]*>)*<([a-z][^>\s]+)/i.exec(t),
          i = 0;
      (n = r && Dp[r[1].toLowerCase()]) && (t = n.map(function (t) {
        return "<" + t + ">";
      }).join("") + t + n.map(function (t) {
        return "</" + t + ">";
      }).reverse().join(""), i = n.length);
      o.innerHTML = t;

      for (var a = 0; a < i; a++) o = o.firstChild;

      return o;
    }(n);

    var p = i && i.querySelector("[data-pm-slice]"),
        u = p && /^(\d+) (\d+) (.*)/.exec(p.getAttribute("data-pm-slice"));

    if (!a) {
      var f = t.someProp("clipboardParser") || t.someProp("domParser") || ps.fromSchema(t.state.schema);
      a = f.parseSlice(i, {
        preserveWhitespace: !(!l && !u),
        context: r
      });
    }

    return a = u ? function (t, e) {
      if (!t.size) return t;
      var n,
          o = t.content.firstChild.type.schema;

      try {
        n = JSON.parse(e);
      } catch (e) {
        return t;
      }

      for (var r = t.content, i = t.openStart, a = t.openEnd, s = n.length - 2; s >= 0; s -= 2) {
        var l = o.nodes[n[s]];
        if (!l || l.hasRequiredAttrs()) break;
        r = ha.from(l.create(n[s + 1], r)), i++, a++;
      }

      return new Sa(r, i, a);
    }(function (t, e, n) {
      e < t.openStart && (t = new Sa(Pp(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd));
      n < t.openEnd && (t = new Sa(Pp(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n));
      return t;
    }(a, +u[1], +u[2]), u[3]) : Sa.maxOpen(function (t, e) {
      if (t.childCount < 2) return t;

      for (var n = function (n) {
        var o = e.node(n),
            r = o.contentMatchAt(e.index(n)),
            i = void 0,
            a = [];
        if (t.forEach(function (t) {
          if (a) {
            var e,
                n = r.findWrapping(t.type);
            if (!n) return a = null;
            if (e = a.length && i.length && function t(e, n, o, r, i) {
              if (i < e.length && i < n.length && e[i] == n[i]) {
                var a = t(e, n, o, r.lastChild, i + 1);
                if (a) return r.copy(r.content.replaceChild(r.childCount - 1, a));
                var s = r.contentMatchAt(r.childCount);
                if (s.matchType(i == e.length - 1 ? o.type : e[i + 1])) return r.copy(r.content.append(ha.from(Ip(o, e, i + 1))));
              }
            }(n, i, t, a[a.length - 1], 0)) a[a.length - 1] = e;else {
              a.length && (a[a.length - 1] = function t(e, n) {
                if (0 == n) return e;
                var o = e.content.replaceChild(e.childCount - 1, t(e.lastChild, n - 1));
                var r = e.contentMatchAt(e.childCount).fillBefore(ha.empty, !0);
                return e.copy(o.append(r));
              }(a[a.length - 1], i.length));
              var o = Ip(t, n);
              a.push(o), r = r.matchType(o.type, o.attrs), i = n;
            }
          }
        }), a) return {
          v: ha.from(a)
        };
      }, o = e.depth; o >= 0; o--) {
        var r = n(o);
        if (r) return r.v;
      }

      return t;
    }(a.content, r), !1), t.someProp("transformPasted", function (t) {
      a = t(a);
    }), a;
  }

  function Ip(t, e, n) {
    void 0 === n && (n = 0);

    for (var o = e.length - 1; o >= n; o--) t = e[o].create(null, ha.from(t));

    return t;
  }

  function Pp(t, e, n, o, r, i) {
    var a = e < 0 ? t.firstChild : t.lastChild,
        s = a.content;
    return r < o - 1 && (s = Pp(s, e, n, o, r + 1, i)), r >= n && (s = e < 0 ? a.contentMatchAt(0).fillBefore(s, t.childCount > 1 || i <= r).append(s) : s.append(a.contentMatchAt(a.childCount).fillBefore(ha.empty, !0))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, a.copy(s));
  }

  var Dp = {
    thead: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
  },
      _p = null;

  function Bp() {
    return _p || (_p = document.implementation.createHTMLDocument("title"));
  }

  var Vp = {
    childList: !0,
    characterData: !0,
    characterDataOldValue: !0,
    attributes: !0,
    attributeOldValue: !0,
    subtree: !0
  },
      zp = nc.ie && nc.ie_version <= 11,
      $p = function () {
    this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null;
  };

  $p.prototype.set = function (t) {
    this.anchorNode = t.anchorNode, this.anchorOffset = t.anchorOffset, this.focusNode = t.focusNode, this.focusOffset = t.focusOffset;
  }, $p.prototype.eq = function (t) {
    return t.anchorNode == this.anchorNode && t.anchorOffset == this.anchorOffset && t.focusNode == this.focusNode && t.focusOffset == this.focusOffset;
  };

  var jp = function (t, e) {
    var n = this;
    this.view = t, this.handleDOMChange = e, this.queue = [], this.flushingSoon = !1, this.observer = window.MutationObserver && new window.MutationObserver(function (t) {
      for (var e = 0; e < t.length; e++) n.queue.push(t[e]);

      nc.ie && nc.ie_version <= 11 && t.some(function (t) {
        return "childList" == t.type && t.removedNodes.length || "characterData" == t.type && t.oldValue.length > t.target.nodeValue.length;
      }) ? n.flushSoon() : n.flush();
    }), this.currentSelection = new $p(), zp && (this.onCharData = function (t) {
      n.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), n.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.suppressingSelectionUpdates = !1;
  };

  jp.prototype.flushSoon = function () {
    var t = this;
    this.flushingSoon || (this.flushingSoon = !0, window.setTimeout(function () {
      t.flushingSoon = !1, t.flush();
    }, 20));
  }, jp.prototype.start = function () {
    this.observer && this.observer.observe(this.view.dom, Vp), zp && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }, jp.prototype.stop = function () {
    var t = this;

    if (this.observer) {
      var e = this.observer.takeRecords();

      if (e.length) {
        for (var n = 0; n < e.length; n++) this.queue.push(e[n]);

        window.setTimeout(function () {
          return t.flush();
        }, 20);
      }

      this.observer.disconnect();
    }

    zp && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }, jp.prototype.connectSelection = function () {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }, jp.prototype.disconnectSelection = function () {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }, jp.prototype.suppressSelectionUpdates = function () {
    var t = this;
    this.suppressingSelectionUpdates = !0, setTimeout(function () {
      return t.suppressingSelectionUpdates = !1;
    }, 50);
  }, jp.prototype.onSelectionChange = function () {
    if ((!(t = this.view).editable || t.root.activeElement == t.dom) && Ap(t)) {
      var t;
      if (this.suppressingSelectionUpdates) return yp(this.view);

      if (nc.ie && nc.ie_version <= 11 && !this.view.state.selection.empty) {
        var e = this.view.root.getSelection();
        if (e.focusNode && uc(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)) return this.flushSoon();
      }

      this.flush();
    }
  }, jp.prototype.setCurSelection = function () {
    this.currentSelection.set(this.view.root.getSelection());
  }, jp.prototype.ignoreSelectionChange = function (t) {
    if (0 == t.rangeCount) return !0;
    var e = t.getRangeAt(0).commonAncestorContainer,
        n = this.view.docView.nearestDesc(e);
    return n && n.ignoreMutation({
      type: "selection",
      target: 3 == e.nodeType ? e.parentNode : e
    });
  }, jp.prototype.flush = function () {
    if (this.view.docView && !this.flushingSoon) {
      var t = this.observer ? this.observer.takeRecords() : [];
      this.queue.length && (t = this.queue.concat(t), this.queue.length = 0);
      var e = this.view.root.getSelection(),
          n = !this.suppressingSelectionUpdates && !this.currentSelection.eq(e) && Ap(this.view) && !this.ignoreSelectionChange(e),
          o = -1,
          r = -1,
          i = !1,
          a = [];
      if (this.view.editable) for (var s = 0; s < t.length; s++) {
        var l = this.registerMutation(t[s], a);
        l && (o = o < 0 ? l.from : Math.min(l.from, o), r = r < 0 ? l.to : Math.max(l.to, r), l.typeOver && !this.view.composing && (i = !0));
      }

      if (nc.gecko && a.length > 1) {
        var c = a.filter(function (t) {
          return "BR" == t.nodeName;
        });

        if (2 == c.length) {
          var p = c[0],
              u = c[1];
          p.parentNode && p.parentNode.parentNode == u.parentNode ? u.remove() : p.remove();
        }
      }

      (o > -1 || n) && (o > -1 && (this.view.docView.markDirty(o, r), function (t) {
        if (Hp) return;
        Hp = !0, "normal" == getComputedStyle(t.dom).whiteSpace && console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
      }(this.view)), this.handleDOMChange(o, r, i, a), this.view.docView.dirty ? this.view.updateState(this.view.state) : this.currentSelection.eq(e) || yp(this.view));
    }
  }, jp.prototype.registerMutation = function (t, e) {
    if (e.indexOf(t.target) > -1) return null;
    var n = this.view.docView.nearestDesc(t.target);
    if ("attributes" == t.type && (n == this.view.docView || "contenteditable" == t.attributeName || "style" == t.attributeName && !t.oldValue && !t.target.getAttribute("style"))) return null;
    if (!n || n.ignoreMutation(t)) return null;

    if ("childList" == t.type) {
      var o = t.previousSibling,
          r = t.nextSibling;
      if (nc.ie && nc.ie_version <= 11 && t.addedNodes.length) for (var i = 0; i < t.addedNodes.length; i++) {
        var a = t.addedNodes[i],
            s = a.previousSibling,
            l = a.nextSibling;
        (!s || Array.prototype.indexOf.call(t.addedNodes, s) < 0) && (o = s), (!l || Array.prototype.indexOf.call(t.addedNodes, l) < 0) && (r = l);
      }

      for (var c = o && o.parentNode == t.target ? lc(o) + 1 : 0, p = n.localPosFromDOM(t.target, c, -1), u = r && r.parentNode == t.target ? lc(r) : t.target.childNodes.length, f = 0; f < t.addedNodes.length; f++) e.push(t.addedNodes[f]);

      return {
        from: p,
        to: n.localPosFromDOM(t.target, u, 1)
      };
    }

    return "attributes" == t.type ? {
      from: n.posAtStart - n.border,
      to: n.posAtEnd + n.border
    } : {
      from: n.posAtStart,
      to: n.posAtEnd,
      typeOver: t.target.nodeValue == t.oldValue
    };
  };
  var Hp = !1;
  var Fp = {},
      qp = {};

  function Up(t, e) {
    t.lastSelectionOrigin = e, t.lastSelectionTime = Date.now();
  }

  function Wp(t) {
    t.someProp("handleDOMEvents", function (e) {
      for (var n in e) t.eventHandlers[n] || t.dom.addEventListener(n, t.eventHandlers[n] = function (e) {
        return Kp(t, e);
      });
    });
  }

  function Kp(t, e) {
    return t.someProp("handleDOMEvents", function (n) {
      var o = n[e.type];
      return !!o && (o(t, e) || e.defaultPrevented);
    });
  }

  function Jp(t) {
    return {
      left: t.clientX,
      top: t.clientY
    };
  }

  function Gp(t, e, n, o, r) {
    if (-1 == o) return !1;

    for (var i = t.state.doc.resolve(o), a = function (o) {
      if (t.someProp(e, function (e) {
        return o > i.depth ? e(t, n, i.nodeAfter, i.before(o), r, !0) : e(t, n, i.node(o), i.before(o), r, !1);
      })) return {
        v: !0
      };
    }, s = i.depth + 1; s > 0; s--) {
      var l = a(s);
      if (l) return l.v;
    }

    return !1;
  }

  function Xp(t, e, n) {
    t.focused || t.focus();
    var o = t.state.tr.setSelection(e);
    "pointer" == n && o.setMeta("pointer", !0), t.dispatch(o);
  }

  function Yp(t, e, n, o, r) {
    return Gp(t, "handleClickOn", e, n, o) || t.someProp("handleClick", function (n) {
      return n(t, e, o);
    }) || (r ? function (t, e) {
      if (-1 == e) return !1;
      var n,
          o,
          r = t.state.selection;
      r instanceof cl && (n = r.node);

      for (var i = t.state.doc.resolve(e), a = i.depth + 1; a > 0; a--) {
        var s = a > i.depth ? i.nodeAfter : i.node(a);

        if (cl.isSelectable(s)) {
          o = n && r.$from.depth > 0 && a >= r.$from.depth && i.before(r.$from.depth + 1) == r.$from.pos ? i.before(r.$from.depth) : i.before(a);
          break;
        }
      }

      return null != o && (Xp(t, cl.create(t.state.doc, o), "pointer"), !0);
    }(t, n) : function (t, e) {
      if (-1 == e) return !1;
      var n = t.state.doc.resolve(e),
          o = n.nodeAfter;
      return !!(o && o.isAtom && cl.isSelectable(o)) && (Xp(t, new cl(n), "pointer"), !0);
    }(t, n));
  }

  function Zp(t, e, n, o) {
    return Gp(t, "handleTripleClickOn", e, n, o) || t.someProp("handleTripleClick", function (n) {
      return n(t, e, o);
    }) || function (t, e) {
      var n = t.state.doc;
      if (-1 == e) return !!n.inlineContent && (Xp(t, sl.create(n, 0, n.content.size), "pointer"), !0);

      for (var o = n.resolve(e), r = o.depth + 1; r > 0; r--) {
        var i = r > o.depth ? o.nodeAfter : o.node(r),
            a = o.before(r);
        if (i.inlineContent) Xp(t, sl.create(n, a + 1, a + 1 + i.content.size), "pointer");else {
          if (!cl.isSelectable(i)) continue;
          Xp(t, cl.create(n, a), "pointer");
        }
        return !0;
      }
    }(t, n);
  }

  function Qp(t) {
    return iu(t);
  }

  qp.keydown = function (t, e) {
    t.shiftKey = 16 == e.keyCode || e.shiftKey, nu(t, e) || (t.lastKeyCode = e.keyCode, t.lastKeyCodeTime = Date.now(), !nc.ios || 13 != e.keyCode || e.ctrlKey || e.altKey || e.metaKey ? t.someProp("handleKeyDown", function (n) {
      return n(t, e);
    }) || mp(t, e) ? e.preventDefault() : Up(t, "key") : t.lastIOSEnter = Date.now());
  }, qp.keyup = function (t, e) {
    16 == e.keyCode && (t.shiftKey = !1);
  }, qp.keypress = function (t, e) {
    if (!(nu(t, e) || !e.charCode || e.ctrlKey && !e.altKey || nc.mac && e.metaKey)) if (t.someProp("handleKeyPress", function (n) {
      return n(t, e);
    })) e.preventDefault();else {
      var n = t.state.selection;

      if (!(n instanceof sl && n.$from.sameParent(n.$to))) {
        var o = String.fromCharCode(e.charCode);
        t.someProp("handleTextInput", function (e) {
          return e(t, n.$from.pos, n.$to.pos, o);
        }) || t.dispatch(t.state.tr.insertText(o).scrollIntoView()), e.preventDefault();
      }
    }
  };
  var tu = nc.mac ? "metaKey" : "ctrlKey";

  Fp.mousedown = function (t, e) {
    t.shiftKey = e.shiftKey;
    var n = Qp(t),
        o = Date.now(),
        r = "singleClick";
    o - t.lastClick.time < 500 && function (t, e) {
      var n = e.x - t.clientX,
          o = e.y - t.clientY;
      return n * n + o * o < 100;
    }(e, t.lastClick) && !e[tu] && ("singleClick" == t.lastClick.type ? r = "doubleClick" : "doubleClick" == t.lastClick.type && (r = "tripleClick")), t.lastClick = {
      time: o,
      x: e.clientX,
      y: e.clientY,
      type: r
    };
    var i = t.posAtCoords(Jp(e));
    i && ("singleClick" == r ? t.mouseDown = new eu(t, i, e, n) : ("doubleClick" == r ? function (t, e, n, o) {
      return Gp(t, "handleDoubleClickOn", e, n, o) || t.someProp("handleDoubleClick", function (n) {
        return n(t, e, o);
      });
    } : Zp)(t, i.pos, i.inside, e) ? e.preventDefault() : Up(t, "pointer"));
  };

  var eu = function (t, e, n, o) {
    var r,
        i,
        a = this;
    if (this.view = t, this.startDoc = t.state.doc, this.pos = e, this.event = n, this.flushed = o, this.selectNode = n[tu], this.allowDefault = n.shiftKey, e.inside > -1) r = t.state.doc.nodeAt(e.inside), i = e.inside;else {
      var s = t.state.doc.resolve(e.pos);
      r = s.parent, i = s.depth ? s.before() : 0;
    }
    this.mightDrag = null;
    var l = o ? null : n.target,
        c = l ? t.docView.nearestDesc(l, !0) : null;
    this.target = c ? c.dom : null, (r.type.spec.draggable && !1 !== r.type.spec.selectable || t.state.selection instanceof cl && i == t.state.selection.from) && (this.mightDrag = {
      node: r,
      pos: i,
      addAttr: this.target && !this.target.draggable,
      setUneditable: this.target && nc.gecko && !this.target.hasAttribute("contentEditable")
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(function () {
      return a.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), t.root.addEventListener("mouseup", this.up = this.up.bind(this)), t.root.addEventListener("mousemove", this.move = this.move.bind(this)), Up(t, "pointer");
  };

  function nu(t, e) {
    return !!t.composing || !!(nc.safari && Math.abs(e.timeStamp - t.compositionEndedAt) < 500) && (t.compositionEndedAt = -2e8, !0);
  }

  eu.prototype.done = function () {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !1), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.view.mouseDown = null;
  }, eu.prototype.up = function (t) {
    if (this.done(), this.view.dom.contains(3 == t.target.nodeType ? t.target.parentNode : t.target)) {
      var e = this.pos;
      this.view.state.doc != this.startDoc && (e = this.view.posAtCoords(Jp(t))), this.allowDefault || !e ? Up(this.view, "pointer") : Yp(this.view, e.pos, e.inside, t, this.selectNode) ? t.preventDefault() : !this.flushed && (!nc.chrome || this.view.state.selection instanceof sl || e.pos != this.view.state.selection.from && e.pos != this.view.state.selection.to) ? Up(this.view, "pointer") : (Xp(this.view, rl.near(this.view.state.doc.resolve(e.pos)), "pointer"), t.preventDefault());
    }
  }, eu.prototype.move = function (t) {
    !this.allowDefault && (Math.abs(this.event.x - t.clientX) > 4 || Math.abs(this.event.y - t.clientY) > 4) && (this.allowDefault = !0), Up(this.view, "pointer");
  }, Fp.touchdown = function (t) {
    Qp(t), Up(t, "pointer");
  }, Fp.contextmenu = function (t) {
    return Qp(t);
  };
  var ou = nc.android ? 5e3 : -1;

  function ru(t, e) {
    clearTimeout(t.composingTimeout), e > -1 && (t.composingTimeout = setTimeout(function () {
      return iu(t);
    }, e));
  }

  function iu(t, e) {
    for (t.composing = !1; t.compositionNodes.length > 0;) t.compositionNodes.pop().markParentsDirty();

    return !(!e && !t.docView.dirty) && (t.updateState(t.state), !0);
  }

  qp.compositionstart = qp.compositionupdate = function (t) {
    if (!t.composing) {
      t.domObserver.flush();
      var e = t.state,
          n = e.selection.$from;
      if (e.selection.empty && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some(function (t) {
        return !1 === t.type.spec.inclusive;
      }))) t.markCursor = t.state.storedMarks || n.marks(), iu(t, !0), t.markCursor = null;else if (iu(t), nc.gecko && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) for (var o = t.root.getSelection(), r = o.focusNode, i = o.focusOffset; r && 1 == r.nodeType && 0 != i;) {
        var a = i < 0 ? r.lastChild : r.childNodes[i - 1];
        if (!a) break;

        if (3 == a.nodeType) {
          o.collapse(a, a.nodeValue.length);
          break;
        }

        r = a, i = -1;
      }
      t.composing = !0;
    }

    ru(t, ou);
  }, qp.compositionend = function (t, e) {
    t.composing && (t.composing = !1, t.compositionEndedAt = e.timeStamp, ru(t, 20));
  };
  var au = nc.ie && nc.ie_version < 15 || nc.ios && nc.webkit_version < 604;

  function su(t, e, n, o) {
    var r = Lp(t, e, n, t.shiftKey, t.state.selection.$from);

    if (!t.someProp("handlePaste", function (e) {
      return e(t, o, r || Sa.empty);
    }) && r) {
      var i = function (t) {
        return 0 == t.openStart && 0 == t.openEnd && 1 == t.content.childCount ? t.content.firstChild : null;
      }(r),
          a = i ? t.state.tr.replaceSelectionWith(i, t.shiftKey) : t.state.tr.replaceSelection(r);

      t.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste"));
    }
  }

  Fp.copy = qp.cut = function (t, e) {
    var n = t.state.selection,
        o = "cut" == e.type;

    if (!n.empty) {
      var r = au ? null : e.clipboardData,
          i = Rp(t, n.content()),
          a = i.dom,
          s = i.text;
      r ? (e.preventDefault(), r.clearData(), r.setData("text/html", a.innerHTML), r.setData("text/plain", s)) : function (t, e) {
        var n = t.dom.ownerDocument,
            o = n.body.appendChild(n.createElement("div"));
        o.appendChild(e), o.style.cssText = "position: fixed; left: -10000px; top: 10px";
        var r = getSelection(),
            i = n.createRange();
        i.selectNodeContents(e), t.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(function () {
          n.body.removeChild(o), t.focus();
        }, 50);
      }(t, a), o && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
    }
  }, qp.paste = function (t, e) {
    var n = au ? null : e.clipboardData,
        o = n && n.getData("text/html"),
        r = n && n.getData("text/plain");
    n && (o || r || n.files.length) ? (su(t, r, o, e), e.preventDefault()) : function (t, e) {
      var n = t.dom.ownerDocument,
          o = t.shiftKey || t.state.selection.$from.parent.type.spec.code,
          r = n.body.appendChild(n.createElement(o ? "textarea" : "div"));
      o || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(), setTimeout(function () {
        t.focus(), n.body.removeChild(r), o ? su(t, r.value, null, e) : su(t, r.textContent, r.innerHTML, e);
      }, 50);
    }(t, e);
  };

  var lu = function (t, e) {
    this.slice = t, this.move = e;
  },
      cu = nc.mac ? "altKey" : "ctrlKey";

  for (var pu in Fp.dragstart = function (t, e) {
    var n = t.mouseDown;

    if (n && n.done(), e.dataTransfer) {
      var o = t.state.selection,
          r = o.empty ? null : t.posAtCoords(Jp(e));
      if (r && r.pos >= o.from && r.pos <= (o instanceof cl ? o.to - 1 : o.to)) ;else if (n && n.mightDrag) t.dispatch(t.state.tr.setSelection(cl.create(t.state.doc, n.mightDrag.pos)));else if (e.target && 1 == e.target.nodeType) {
        var i = t.docView.nearestDesc(e.target, !0);
        if (!i || !i.node.type.spec.draggable || i == t.docView) return;
        t.dispatch(t.state.tr.setSelection(cl.create(t.state.doc, i.posBefore)));
      }
      var a = t.state.selection.content(),
          s = Rp(t, a),
          l = s.dom,
          c = s.text;
      e.dataTransfer.clearData(), e.dataTransfer.setData(au ? "Text" : "text/html", l.innerHTML), au || e.dataTransfer.setData("text/plain", c), t.dragging = new lu(a, !e[cu]);
    }
  }, Fp.dragend = function (t) {
    window.setTimeout(function () {
      return t.dragging = null;
    }, 50);
  }, qp.dragover = qp.dragenter = function (t, e) {
    return e.preventDefault();
  }, qp.drop = function (t, e) {
    var n = t.dragging;

    if (t.dragging = null, e.dataTransfer) {
      var o = t.posAtCoords(Jp(e));

      if (o) {
        var r = t.state.doc.resolve(o.pos);

        if (r) {
          var i = n && n.slice || Lp(t, e.dataTransfer.getData(au ? "Text" : "text/plain"), au ? null : e.dataTransfer.getData("text/html"), !1, r);

          if (i && (e.preventDefault(), !t.someProp("handleDrop", function (o) {
            return o(t, e, i, n && n.move);
          }))) {
            var a = i ? function (t, e, n) {
              var o = t.resolve(e);
              if (!n.content.size) return e;

              for (var r = n.content, i = 0; i < n.openStart; i++) r = r.firstChild.content;

              for (var a = 1; a <= (0 == n.openStart && n.size ? 2 : 1); a++) for (var s = o.depth; s >= 0; s--) {
                var l = s == o.depth ? 0 : o.pos <= (o.start(s + 1) + o.end(s + 1)) / 2 ? -1 : 1,
                    c = o.index(s) + (l > 0 ? 1 : 0);
                if (1 == a ? o.node(s).canReplace(c, c, r) : o.node(s).contentMatchAt(c).findWrapping(r.firstChild.type)) return 0 == l ? o.pos : l < 0 ? o.before(s + 1) : o.after(s + 1);
              }

              return null;
            }(t.state.doc, r.pos, i) : r.pos;
            null == a && (a = r.pos);
            var s = t.state.tr;
            n && n.move && s.deleteSelection();
            var l = s.mapping.map(a),
                c = 0 == i.openStart && 0 == i.openEnd && 1 == i.content.childCount,
                p = s.doc;

            if (c ? s.replaceRangeWith(l, l, i.content.firstChild) : s.replaceRange(l, l, i), !s.doc.eq(p)) {
              var u = s.doc.resolve(l);
              c && cl.isSelectable(i.content.firstChild) && u.nodeAfter && u.nodeAfter.sameMarkup(i.content.firstChild) ? s.setSelection(new cl(u)) : s.setSelection(Op(t, u, s.doc.resolve(s.mapping.map(a)))), t.focus(), t.dispatch(s.setMeta("uiEvent", "drop"));
            }
          }
        }
      }
    }
  }, Fp.focus = function (t) {
    t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = !0);
  }, Fp.blur = function (t) {
    t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), t.domObserver.currentSelection.set({}), t.focused = !1);
  }, Fp.beforeinput = function (t, e) {
    if (nc.chrome && nc.android && "deleteContentBackward" == e.inputType) {
      var n = t.domChangeCount;
      setTimeout(function () {
        if (t.domChangeCount == n && (t.dom.blur(), t.focus(), !t.someProp("handleKeyDown", function (e) {
          return e(t, gc(8, "Backspace"));
        }))) {
          var e = t.state.selection.$cursor;
          e && e.pos > 0 && t.dispatch(t.state.tr.delete(e.pos - 1, e.pos).scrollIntoView());
        }
      }, 50);
    }
  }, qp) Fp[pu] = qp[pu];

  function uu(t, e) {
    if (t == e) return !0;

    for (var n in t) if (t[n] !== e[n]) return !1;

    for (var o in e) if (!(o in t)) return !1;

    return !0;
  }

  var fu = function (t, e) {
    this.spec = e || yu, this.side = this.spec.side || 0, this.toDOM = t;
  };

  fu.prototype.map = function (t, e, n, o) {
    var r = t.mapResult(e.from + o, this.side < 0 ? -1 : 1),
        i = r.pos;
    return r.deleted ? null : new vu(i - n, i - n, this);
  }, fu.prototype.valid = function () {
    return !0;
  }, fu.prototype.eq = function (t) {
    return this == t || t instanceof fu && (this.spec.key && this.spec.key == t.spec.key || this.toDOM == t.toDOM && uu(this.spec, t.spec));
  };

  var du = function (t, e) {
    this.spec = e || yu, this.attrs = t;
  };

  du.prototype.map = function (t, e, n, o) {
    var r = t.map(e.from + o, this.spec.inclusiveStart ? -1 : 1) - n,
        i = t.map(e.to + o, this.spec.inclusiveEnd ? 1 : -1) - n;
    return r >= i ? null : new vu(r, i, this);
  }, du.prototype.valid = function (t, e) {
    return e.from < e.to;
  }, du.prototype.eq = function (t) {
    return this == t || t instanceof du && uu(this.attrs, t.attrs) && uu(this.spec, t.spec);
  }, du.is = function (t) {
    return t.type instanceof du;
  };

  var hu = function (t, e) {
    this.spec = e || yu, this.attrs = t;
  };

  hu.prototype.map = function (t, e, n, o) {
    var r = t.mapResult(e.from + o, 1);
    if (r.deleted) return null;
    var i = t.mapResult(e.to + o, -1);
    return i.deleted || i.pos <= r.pos ? null : new vu(r.pos - n, i.pos - n, this);
  }, hu.prototype.valid = function (t, e) {
    var n = t.content.findIndex(e.from),
        o = n.index,
        r = n.offset;
    return r == e.from && r + t.child(o).nodeSize == e.to;
  }, hu.prototype.eq = function (t) {
    return this == t || t instanceof hu && uu(this.attrs, t.attrs) && uu(this.spec, t.spec);
  };

  var vu = function (t, e, n) {
    this.from = t, this.to = e, this.type = n;
  },
      mu = {
    spec: {
      configurable: !0
    }
  };

  vu.prototype.copy = function (t, e) {
    return new vu(t, e, this.type);
  }, vu.prototype.eq = function (t) {
    return this.type.eq(t.type) && this.from == t.from && this.to == t.to;
  }, vu.prototype.map = function (t, e, n) {
    return this.type.map(t, this, e, n);
  }, vu.widget = function (t, e, n) {
    return new vu(t, t, new fu(e, n));
  }, vu.inline = function (t, e, n, o) {
    return new vu(t, e, new du(n, o));
  }, vu.node = function (t, e, n, o) {
    return new vu(t, e, new hu(n, o));
  }, mu.spec.get = function () {
    return this.type.spec;
  }, Object.defineProperties(vu.prototype, mu);

  var gu = [],
      yu = {},
      bu = function (t, e) {
    this.local = t && t.length ? t : gu, this.children = e && e.length ? e : gu;
  };

  bu.create = function (t, e) {
    return e.length ? Ou(e, t, 0, yu) : wu;
  }, bu.prototype.find = function (t, e, n) {
    var o = [];
    return this.findInner(null == t ? 0 : t, null == e ? 1e9 : e, o, 0, n), o;
  }, bu.prototype.findInner = function (t, e, n, o, r) {
    for (var i = 0; i < this.local.length; i++) {
      var a = this.local[i];
      a.from <= e && a.to >= t && (!r || r(a.spec)) && n.push(a.copy(a.from + o, a.to + o));
    }

    for (var s = 0; s < this.children.length; s += 3) if (this.children[s] < e && this.children[s + 1] > t) {
      var l = this.children[s] + 1;
      this.children[s + 2].findInner(t - l, e - l, n, o + l, r);
    }
  }, bu.prototype.map = function (t, e, n) {
    return this == wu || 0 == t.maps.length ? this : this.mapInner(t, e, 0, 0, n || yu);
  }, bu.prototype.mapInner = function (t, e, n, o, r) {
    for (var i, a = 0; a < this.local.length; a++) {
      var s = this.local[a].map(t, n, o);
      s && s.type.valid(e, s) ? (i || (i = [])).push(s) : r.onRemove && r.onRemove(this.local[a].spec);
    }

    return this.children.length ? function (t, e, n, o, r, i, a) {
      for (var s = t.slice(), l = function (t, e, n, o) {
        for (var a = 0; a < s.length; a += 3) {
          var l = s[a + 1],
              c = void 0;
          -1 == l || t > l + i || (e >= s[a] + i ? s[a + 1] = -1 : (c = o - n - (e - t) + (i - r)) && (s[a] += c, s[a + 1] += c));
        }
      }, c = 0; c < n.maps.length; c++) n.maps[c].forEach(l);

      for (var p = !1, u = 0; u < s.length; u += 3) if (-1 == s[u + 1]) {
        var f = n.map(s[u] + i),
            d = f - r;

        if (d < 0 || d >= o.content.size) {
          p = !0;
          continue;
        }

        var h = n.map(t[u + 1] + i, -1),
            v = h - r,
            m = o.content.findIndex(d),
            g = m.index,
            y = m.offset,
            b = o.maybeChild(g);

        if (b && y == d && y + b.nodeSize == v) {
          var w = s[u + 2].mapInner(n, b, f + 1, s[u] + i + 1, a);
          w != wu ? (s[u] = d, s[u + 1] = v, s[u + 2] = w) : (s[u + 1] = -2, p = !0);
        } else p = !0;
      }

      if (p) {
        var S = function (t, e, n, o, r, i, a) {
          function s(t, e) {
            for (var i = 0; i < t.local.length; i++) {
              var l = t.local[i].map(o, r, e);
              l ? n.push(l) : a.onRemove && a.onRemove(t.local[i].spec);
            }

            for (var c = 0; c < t.children.length; c += 3) s(t.children[c + 2], t.children[c] + e + 1);
          }

          for (var l = 0; l < t.length; l += 3) -1 == t[l + 1] && s(t[l + 2], e[l] + i + 1);

          return n;
        }(s, t, e || [], n, r, i, a),
            C = Ou(S, o, 0, a);

        e = C.local;

        for (var x = 0; x < s.length; x += 3) s[x + 1] < 0 && (s.splice(x, 3), x -= 3);

        for (var k = 0, O = 0; k < C.children.length; k += 3) {
          for (var A = C.children[k]; O < s.length && s[O] < A;) O += 3;

          s.splice(O, 0, C.children[k], C.children[k + 1], C.children[k + 2]);
        }
      }

      return new bu(e && e.sort(Au), s);
    }(this.children, i, t, e, n, o, r) : i ? new bu(i.sort(Au)) : wu;
  }, bu.prototype.add = function (t, e) {
    return e.length ? this == wu ? bu.create(t, e) : this.addInner(t, e, 0) : this;
  }, bu.prototype.addInner = function (t, e, n) {
    var o,
        r = this,
        i = 0;
    t.forEach(function (t, a) {
      var s,
          l = a + n;

      if (s = xu(e, t, l)) {
        for (o || (o = r.children.slice()); i < o.length && o[i] < a;) i += 3;

        o[i] == a ? o[i + 2] = o[i + 2].addInner(t, s, l + 1) : o.splice(i, 0, a, a + t.nodeSize, Ou(s, t, l + 1, yu)), i += 3;
      }
    });
    var a = Cu(i ? ku(e) : e, -n);
    return new bu(a.length ? this.local.concat(a).sort(Au) : this.local, o || this.children);
  }, bu.prototype.remove = function (t) {
    return 0 == t.length || this == wu ? this : this.removeInner(t, 0);
  }, bu.prototype.removeInner = function (t, e) {
    for (var n = this.children, o = this.local, r = 0; r < n.length; r += 3) {
      for (var i = void 0, a = n[r] + e, s = n[r + 1] + e, l = 0, c = void 0; l < t.length; l++) (c = t[l]) && c.from > a && c.to < s && (t[l] = null, (i || (i = [])).push(c));

      if (i) {
        n == this.children && (n = this.children.slice());
        var p = n[r + 2].removeInner(i, a + 1);
        p != wu ? n[r + 2] = p : (n.splice(r, 3), r -= 3);
      }
    }

    if (o.length) for (var u = 0, f = void 0; u < t.length; u++) if (f = t[u]) for (var d = 0; d < o.length; d++) o[d].type.eq(f.type) && (o == this.local && (o = this.local.slice()), o.splice(d--, 1));
    return n == this.children && o == this.local ? this : o.length || n.length ? new bu(o, n) : wu;
  }, bu.prototype.forChild = function (t, e) {
    if (this == wu) return this;
    if (e.isLeaf) return bu.empty;

    for (var n, o, r = 0; r < this.children.length; r += 3) if (this.children[r] >= t) {
      this.children[r] == t && (n = this.children[r + 2]);
      break;
    }

    for (var i = t + 1, a = i + e.content.size, s = 0; s < this.local.length; s++) {
      var l = this.local[s];

      if (l.from < a && l.to > i && l.type instanceof du) {
        var c = Math.max(i, l.from) - i,
            p = Math.min(a, l.to) - i;
        c < p && (o || (o = [])).push(l.copy(c, p));
      }
    }

    if (o) {
      var u = new bu(o.sort(Au));
      return n ? new Su([u, n]) : u;
    }

    return n || wu;
  }, bu.prototype.eq = function (t) {
    if (this == t) return !0;
    if (!(t instanceof bu) || this.local.length != t.local.length || this.children.length != t.children.length) return !1;

    for (var e = 0; e < this.local.length; e++) if (!this.local[e].eq(t.local[e])) return !1;

    for (var n = 0; n < this.children.length; n += 3) if (this.children[n] != t.children[n] || this.children[n + 1] != t.children[n + 1] || !this.children[n + 2].eq(t.children[n + 2])) return !1;

    return !0;
  }, bu.prototype.locals = function (t) {
    return Tu(this.localsInner(t));
  }, bu.prototype.localsInner = function (t) {
    if (this == wu) return gu;
    if (t.inlineContent || !this.local.some(du.is)) return this.local;

    for (var e = [], n = 0; n < this.local.length; n++) this.local[n].type instanceof du || e.push(this.local[n]);

    return e;
  };
  var wu = new bu();
  bu.empty = wu, bu.removeOverlap = Tu;

  var Su = function (t) {
    this.members = t;
  };

  function Cu(t, e) {
    if (!e || !t.length) return t;

    for (var n = [], o = 0; o < t.length; o++) {
      var r = t[o];
      n.push(new vu(r.from + e, r.to + e, r.type));
    }

    return n;
  }

  function xu(t, e, n) {
    if (e.isLeaf) return null;

    for (var o = n + e.nodeSize, r = null, i = 0, a = void 0; i < t.length; i++) (a = t[i]) && a.from > n && a.to < o && ((r || (r = [])).push(a), t[i] = null);

    return r;
  }

  function ku(t) {
    for (var e = [], n = 0; n < t.length; n++) null != t[n] && e.push(t[n]);

    return e;
  }

  function Ou(t, e, n, o) {
    var r = [],
        i = !1;
    e.forEach(function (e, a) {
      var s = xu(t, e, a + n);

      if (s) {
        i = !0;
        var l = Ou(s, e, n + a + 1, o);
        l != wu && r.push(a, a + e.nodeSize, l);
      }
    });

    for (var a = Cu(i ? ku(t) : t, -n).sort(Au), s = 0; s < a.length; s++) a[s].type.valid(e, a[s]) || (o.onRemove && o.onRemove(a[s].spec), a.splice(s--, 1));

    return a.length || r.length ? new bu(a, r) : wu;
  }

  function Au(t, e) {
    return t.from - e.from || t.to - e.to;
  }

  function Tu(t) {
    for (var e = t, n = 0; n < e.length - 1; n++) {
      var o = e[n];
      if (o.from != o.to) for (var r = n + 1; r < e.length; r++) {
        var i = e[r];

        if (i.from != o.from) {
          i.from < o.to && (e == t && (e = t.slice()), e[n] = o.copy(o.from, i.from), Eu(e, r, o.copy(i.from, o.to)));
          break;
        }

        i.to != o.to && (e == t && (e = t.slice()), e[r] = i.copy(i.from, o.to), Eu(e, r + 1, i.copy(o.to, i.to)));
      }
    }

    return e;
  }

  function Eu(t, e, n) {
    for (; e < t.length && Au(n, t[e]) > 0;) e++;

    t.splice(e, 0, n);
  }

  function Mu(t) {
    var e = [];
    return t.someProp("decorations", function (n) {
      var o = n(t.state);
      o && o != wu && e.push(o);
    }), t.cursorWrapper && e.push(bu.create(t.state.doc, [t.cursorWrapper.deco])), Su.from(e);
  }

  Su.prototype.forChild = function (t, e) {
    if (e.isLeaf) return bu.empty;

    for (var n = [], o = 0; o < this.members.length; o++) {
      var r = this.members[o].forChild(t, e);
      r != wu && (r instanceof Su ? n = n.concat(r.members) : n.push(r));
    }

    return Su.from(n);
  }, Su.prototype.eq = function (t) {
    if (!(t instanceof Su) || t.members.length != this.members.length) return !1;

    for (var e = 0; e < this.members.length; e++) if (!this.members[e].eq(t.members[e])) return !1;

    return !0;
  }, Su.prototype.locals = function (t) {
    for (var e, n = !0, o = 0; o < this.members.length; o++) {
      var r = this.members[o].localsInner(t);
      if (r.length) if (e) {
        n && (e = e.slice(), n = !1);

        for (var i = 0; i < r.length; i++) e.push(r[i]);
      } else e = r;
    }

    return e ? Tu(n ? e : e.sort(Au)) : gu;
  }, Su.from = function (t) {
    switch (t.length) {
      case 0:
        return wu;

      case 1:
        return t[0];

      default:
        return new Su(t);
    }
  };

  var Nu,
      Ru,
      Lu = function (t, e) {
    this._props = e, this.state = e.state, this.dispatch = this.dispatch.bind(this), this._root = null, this.focused = !1, this.dom = t && t.mount || document.createElement("div"), t && (t.appendChild ? t.appendChild(this.dom) : t.apply ? t(this.dom) : t.mount && (this.mounted = !0)), this.editable = _u(this), this.markCursor = null, this.cursorWrapper = null, Du(this), this.nodeViews = Bu(this), this.docView = Fc(this.state.doc, Pu(this), Mu(this), this.dom, this), this.lastSelectedViewDesc = null, this.dragging = null, function (t) {
      t.shiftKey = !1, t.mouseDown = null, t.lastKeyCode = null, t.lastKeyCodeTime = 0, t.lastClick = {
        time: 0,
        x: 0,
        y: 0,
        type: ""
      }, t.lastSelectionOrigin = null, t.lastSelectionTime = 0, t.lastIOSEnter = 0, t.composing = !1, t.composingTimeout = null, t.compositionNodes = [], t.compositionEndedAt = -2e8, t.domObserver = new jp(t, function (e, n, o, r) {
        return Ep(t, e, n, o, r);
      }), t.domObserver.start(), t.domChangeCount = 0, t.eventHandlers = Object.create(null);

      var e = function (e) {
        var n = Fp[e];
        t.dom.addEventListener(e, t.eventHandlers[e] = function (e) {
          !function (t, e) {
            if (!e.bubbles) return !0;
            if (e.defaultPrevented) return !1;

            for (var n = e.target; n != t.dom; n = n.parentNode) if (!n || 11 == n.nodeType || n.pmViewDesc && n.pmViewDesc.stopEvent(e)) return !1;

            return !0;
          }(t, e) || Kp(t, e) || !t.editable && e.type in qp || n(t, e);
        });
      };

      for (var n in Fp) e(n);

      nc.safari && t.dom.addEventListener("input", function () {
        return null;
      }), Wp(t);
    }(this), this.pluginViews = [], this.updatePluginViews();
  },
      Iu = {
    props: {
      configurable: !0
    },
    root: {
      configurable: !0
    }
  };

  function Pu(t) {
    var e = Object.create(null);
    return e.class = "ProseMirror", e.contenteditable = String(t.editable), t.someProp("attributes", function (n) {
      if ("function" == typeof n && (n = n(t.state)), n) for (var o in n) "class" == o ? e.class += " " + n[o] : e[o] || "contenteditable" == o || "nodeName" == o || (e[o] = String(n[o]));
    }), [vu.node(0, t.state.doc.content.size, e)];
  }

  function Du(t) {
    var e = t.state.selection,
        n = e.$head,
        o = e.$anchor,
        r = e.visible;

    if (t.markCursor) {
      var i = document.createElement("img");
      i.setAttribute("mark-placeholder", "true"), t.cursorWrapper = {
        dom: i,
        deco: vu.widget(n.pos, i, {
          raw: !0,
          marks: t.markCursor
        })
      };
    } else if (r || n.pos != o.pos) t.cursorWrapper = null;else {
      var a;
      !t.cursorWrapper || t.cursorWrapper.dom.childNodes.length ? ((a = document.createElement("div")).style.position = "absolute", a.style.left = "-100000px") : t.cursorWrapper.deco.pos != n.pos && (a = t.cursorWrapper.dom), a && (t.cursorWrapper = {
        dom: a,
        deco: vu.widget(n.pos, a, {
          raw: !0
        })
      });
    }
  }

  function _u(t) {
    return !t.someProp("editable", function (e) {
      return !1 === e(t.state);
    });
  }

  function Bu(t) {
    var e = {};
    return t.someProp("nodeViews", function (t) {
      for (var n in t) Object.prototype.hasOwnProperty.call(e, n) || (e[n] = t[n]);
    }), e;
  }

  if (Iu.props.get = function () {
    if (this._props.state != this.state) {
      var t = this._props;

      for (var e in this._props = {}, t) this._props[e] = t[e];

      this._props.state = this.state;
    }

    return this._props;
  }, Lu.prototype.update = function (t) {
    t.handleDOMEvents != this._props.handleDOMEvents && Wp(this), this._props = t, this.updateStateInner(t.state, !0);
  }, Lu.prototype.setProps = function (t) {
    var e = {};

    for (var n in this._props) e[n] = this._props[n];

    for (var o in e.state = this.state, t) e[o] = t[o];

    this.update(e);
  }, Lu.prototype.updateState = function (t) {
    this.updateStateInner(t, this.state.plugins != t.plugins);
  }, Lu.prototype.updateStateInner = function (t, e) {
    var n = this,
        o = this.state,
        r = !1;

    if (this.state = t, e) {
      var i = Bu(this);
      (function (t, e) {
        var n = 0,
            o = 0;

        for (var r in t) {
          if (t[r] != e[r]) return !0;
          n++;
        }

        for (var i in e) o++;

        return n != o;
      })(i, this.nodeViews) && (this.nodeViews = i, r = !0), Wp(this);
    }

    this.editable = _u(this), Du(this);

    var a,
        s,
        l,
        c,
        p,
        u,
        f,
        d,
        h,
        v,
        m,
        g = Mu(this),
        y = Pu(this),
        b = e ? "reset" : t.scrollToSelection > o.scrollToSelection ? "to selection" : "preserve",
        w = r || !this.docView.matchesNode(t.doc, y, g),
        S = w || !t.selection.eq(o.selection),
        C = "preserve" == b && S && null == this.dom.style.overflowAnchor && function (t) {
      for (var e, n, o = t.dom.getBoundingClientRect(), r = Math.max(0, o.top), i = (o.left + o.right) / 2, a = r + 1; a < Math.min(innerHeight, o.bottom); a += 5) {
        var s = t.root.elementFromPoint(i, a);

        if (s != t.dom && t.dom.contains(s)) {
          var l = s.getBoundingClientRect();

          if (l.top >= r - 20) {
            e = s, n = l.top;
            break;
          }
        }
      }

      return {
        refDOM: e,
        refTop: n,
        stack: Sc(t.dom)
      };
    }(this);

    if (S) {
      this.domObserver.stop();
      var x = w && (nc.ie || nc.chrome) && !o.selection.empty && !t.selection.empty && (c = o.selection, p = t.selection, u = Math.min(c.$anchor.sharedDepth(c.head), p.$anchor.sharedDepth(p.head)), c.$anchor.node(u) != p.$anchor.node(u));
      w && (!r && this.docView.update(t.doc, y, g, this) || (this.docView.destroy(), this.docView = Fc(t.doc, y, g, this.dom, this))), x || !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && (a = this, s = a.docView.domFromPos(a.state.selection.anchor), l = a.root.getSelection(), uc(s.node, s.offset, l.anchorNode, l.anchorOffset))) ? yp(this, x) : (xp(this, t.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }

    if (this.updatePluginViews(o), "reset" == b) this.dom.scrollTop = 0;else if ("to selection" == b) {
      var k = this.root.getSelection().focusNode;
      this.someProp("handleScrollToSelection", function (t) {
        return t(n);
      }) || (t.selection instanceof cl ? wc(this, this.docView.domAfterPos(t.selection.from).getBoundingClientRect(), k) : wc(this, this.coordsAtPos(t.selection.head), k));
    } else C && (d = (f = C).refDOM, h = f.refTop, v = f.stack, m = d ? d.getBoundingClientRect().top : 0, Cc(v, 0 == m ? 0 : m - h));
  }, Lu.prototype.destroyPluginViews = function () {
    for (var t; t = this.pluginViews.pop();) t.destroy && t.destroy();
  }, Lu.prototype.updatePluginViews = function (t) {
    if (t && t.plugins == this.state.plugins) for (var e = 0; e < this.pluginViews.length; e++) {
      var n = this.pluginViews[e];
      n.update && n.update(this, t);
    } else {
      this.destroyPluginViews();

      for (var o = 0; o < this.state.plugins.length; o++) {
        var r = this.state.plugins[o];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    }
  }, Lu.prototype.someProp = function (t, e) {
    var n,
        o = this._props && this._props[t];
    if (null != o && (n = e ? e(o) : o)) return n;
    var r = this.state.plugins;
    if (r) for (var i = 0; i < r.length; i++) {
      var a = r[i].props[t];
      if (null != a && (n = e ? e(a) : a)) return n;
    }
  }, Lu.prototype.hasFocus = function () {
    return this.root.activeElement == this.dom;
  }, Lu.prototype.focus = function () {
    this.domObserver.stop(), this.editable && function (t) {
      if (t.setActive) return t.setActive();
      if (xc) return t.focus(xc);
      var e = Sc(t);
      t.focus(null == xc ? {
        get preventScroll() {
          return xc = {
            preventScroll: !0
          }, !0;
        }

      } : void 0), xc || (xc = !1, Cc(e, 0));
    }(this.dom), yp(this), this.domObserver.start();
  }, Iu.root.get = function () {
    var t = this._root;
    if (null == t) for (var e = this.dom.parentNode; e; e = e.parentNode) if (9 == e.nodeType || 11 == e.nodeType && e.host) return e.getSelection || (Object.getPrototypeOf(e).getSelection = function () {
      return document.getSelection();
    }), this._root = e;
    return t || document;
  }, Lu.prototype.posAtCoords = function (t) {
    return Ac(this, t);
  }, Lu.prototype.coordsAtPos = function (t) {
    return Ec(this, t);
  }, Lu.prototype.domAtPos = function (t) {
    return this.docView.domFromPos(t);
  }, Lu.prototype.nodeDOM = function (t) {
    var e = this.docView.descAt(t);
    return e ? e.nodeDOM : null;
  }, Lu.prototype.posAtDOM = function (t, e, n) {
    void 0 === n && (n = -1);
    var o = this.docView.posFromDOM(t, e, n);
    if (null == o) throw new RangeError("DOM position not inside the editor");
    return o;
  }, Lu.prototype.endOfTextblock = function (t, e) {
    return Dc(this, e || this.state, t);
  }, Lu.prototype.destroy = function () {
    this.docView && (!function (t) {
      for (var e in t.domObserver.stop(), t.eventHandlers) t.dom.removeEventListener(e, t.eventHandlers[e]);

      clearTimeout(t.composingTimeout);
    }(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Mu(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null);
  }, Lu.prototype.dispatchEvent = function (t) {
    return function (t, e) {
      Kp(t, e) || !Fp[e.type] || !t.editable && e.type in qp || Fp[e.type](t, e);
    }(this, t);
  }, Lu.prototype.dispatch = function (t) {
    var e = this._props.dispatchTransaction;
    e ? e.call(this, t) : this.updateState(this.state.apply(t));
  }, Object.defineProperties(Lu.prototype, Iu), "undefined" != typeof WeakMap) {
    var Vu = new WeakMap();
    Nu = function (t) {
      return Vu.get(t);
    }, Ru = function (t, e) {
      return Vu.set(t, e), e;
    };
  } else {
    var zu = [],
        $u = 0;
    Nu = function (t) {
      for (var e = 0; e < zu.length; e += 2) if (zu[e] == t) return zu[e + 1];
    }, Ru = function (t, e) {
      return 10 == $u && ($u = 0), zu[$u++] = t, zu[$u++] = e;
    };
  }

  var ju = function (t, e, n, o) {
    this.left = t, this.top = e, this.right = n, this.bottom = o;
  },
      Hu = function (t, e, n, o) {
    this.width = t, this.height = e, this.map = n, this.problems = o;
  };

  function Fu(t) {
    if (t.colwidth) return t.colwidth.slice();

    for (var e = [], n = 0; n < t.colspan; n++) e.push(0);

    return e;
  }

  Hu.prototype.findCell = function (t) {
    for (var e = 0; e < this.map.length; e++) {
      var n = this.map[e];

      if (n == t) {
        for (var o = e % this.width, r = e / this.width | 0, i = o + 1, a = r + 1, s = 1; i < this.width && this.map[e + s] == n; s++) i++;

        for (var l = 1; a < this.height && this.map[e + this.width * l] == n; l++) a++;

        return new ju(o, r, i, a);
      }
    }

    throw new RangeError("No cell with offset " + t + " found");
  }, Hu.prototype.colCount = function (t) {
    for (var e = 0; e < this.map.length; e++) if (this.map[e] == t) return e % this.width;

    throw new RangeError("No cell with offset " + t + " found");
  }, Hu.prototype.nextCell = function (t, e, n) {
    var o = this.findCell(t),
        r = o.left,
        i = o.right,
        a = o.top,
        s = o.bottom;
    return "horiz" == e ? (n < 0 ? 0 == r : i == this.width) ? null : this.map[a * this.width + (n < 0 ? r - 1 : i)] : (n < 0 ? 0 == a : s == this.height) ? null : this.map[r + this.width * (n < 0 ? a - 1 : s)];
  }, Hu.prototype.rectBetween = function (t, e) {
    var n = this.findCell(t),
        o = n.left,
        r = n.right,
        i = n.top,
        a = n.bottom,
        s = this.findCell(e),
        l = s.left,
        c = s.right,
        p = s.top,
        u = s.bottom;
    return new ju(Math.min(o, l), Math.min(i, p), Math.max(r, c), Math.max(a, u));
  }, Hu.prototype.cellsInRect = function (t) {
    for (var e = [], n = {}, o = t.top; o < t.bottom; o++) for (var r = t.left; r < t.right; r++) {
      var i = o * this.width + r,
          a = this.map[i];
      n[a] || (n[a] = !0, r == t.left && r && this.map[i - 1] == a || o == t.top && o && this.map[i - this.width] == a || e.push(a));
    }

    return e;
  }, Hu.prototype.positionAt = function (t, e, n) {
    for (var o = 0, r = 0;; o++) {
      var i = r + n.child(o).nodeSize;

      if (o == t) {
        for (var a = e + t * this.width, s = (t + 1) * this.width; a < s && this.map[a] < r;) a++;

        return a == s ? i - 1 : this.map[a];
      }

      r = i;
    }
  }, Hu.get = function (t) {
    return Nu(t) || Ru(t, function (t) {
      if ("table" != t.type.spec.tableRole) throw new RangeError("Not a table node: " + t.type.name);

      for (var e = function (t) {
        for (var e = -1, n = !1, o = 0; o < t.childCount; o++) {
          var r = t.child(o),
              i = 0;
          if (n) for (var a = 0; a < o; a++) for (var s = t.child(a), l = 0; l < s.childCount; l++) {
            var c = s.child(l);
            a + c.attrs.rowspan > o && (i += c.attrs.colspan);
          }

          for (var p = 0; p < r.childCount; p++) {
            var u = r.child(p);
            i += u.attrs.colspan, u.attrs.rowspan > 1 && (n = !0);
          }

          -1 == e ? e = i : e != i && (e = Math.max(e, i));
        }

        return e;
      }(t), n = t.childCount, o = [], r = 0, i = null, a = [], s = 0, l = e * n; s < l; s++) o[s] = 0;

      for (var c = 0, p = 0; c < n; c++) {
        var u = t.child(c);
        p++;

        for (var f = 0;; f++) {
          for (; r < o.length && 0 != o[r];) r++;

          if (f == u.childCount) break;

          for (var d = u.child(f), h = d.attrs, v = h.colspan, m = h.rowspan, g = h.colwidth, y = 0; y < m; y++) {
            if (y + c >= n) {
              (i || (i = [])).push({
                type: "overlong_rowspan",
                pos: p,
                n: m - y
              });
              break;
            }

            for (var b = r + y * e, w = 0; w < v; w++) {
              0 == o[b + w] ? o[b + w] = p : (i || (i = [])).push({
                type: "collision",
                row: c,
                pos: p,
                n: v - w
              });
              var S = g && g[w];

              if (S) {
                var C = (b + w) % e * 2,
                    x = a[C];
                null == x || x != S && 1 == a[C + 1] ? (a[C] = S, a[C + 1] = 1) : x == S && a[C + 1]++;
              }
            }
          }

          r += v, p += d.nodeSize;
        }

        for (var k = (c + 1) * e, O = 0; r < k;) 0 == o[r++] && O++;

        O && (i || (i = [])).push({
          type: "missing",
          row: c,
          n: O
        }), p++;
      }

      for (var A = new Hu(e, n, o, i), T = !1, E = 0; !T && E < a.length; E += 2) null != a[E] && a[E + 1] < n && (T = !0);

      T && function (t, e, n) {
        t.problems || (t.problems = []);

        for (var o = 0, r = {}; o < t.map.length; o++) {
          var i = t.map[o];

          if (!r[i]) {
            r[i] = !0;

            for (var a = n.nodeAt(i), s = null, l = 0; l < a.attrs.colspan; l++) {
              var c = (o + l) % t.width,
                  p = e[2 * c];
              null == p || a.attrs.colwidth && a.attrs.colwidth[l] == p || ((s || (s = Fu(a.attrs)))[l] = p);
            }

            s && t.problems.unshift({
              type: "colwidth mismatch",
              pos: i,
              colwidth: s
            });
          }
        }
      }(A, a, t);
      return A;
    }(t));
  };
  var qu = new Al("selectingCells");

  function Uu(t) {
    for (var e = t.depth - 1; e > 0; e--) if ("row" == t.node(e).type.spec.tableRole) return t.node(0).resolve(t.before(e + 1));

    return null;
  }

  function Wu(t) {
    for (var e = t.selection.$head, n = e.depth; n > 0; n--) if ("row" == e.node(n).type.spec.tableRole) return !0;

    return !1;
  }

  function Ku(t) {
    var e = t.selection;
    return e.$anchorCell ? e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell : e.node && "cell" == e.node.type.spec.tableRole ? e.$anchor : Uu(e.$head) || function (t) {
      for (var e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
        var o = e.type.spec.tableRole;
        if ("cell" == o || "header_cell" == o) return t.doc.resolve(n);
      }

      for (var r = t.nodeBefore, i = t.pos; r; r = r.lastChild, i--) {
        var a = r.type.spec.tableRole;
        if ("cell" == a || "header_cell" == a) return t.doc.resolve(i - r.nodeSize);
      }
    }(e.$head);
  }

  function Ju(t) {
    return "row" == t.parent.type.spec.tableRole && t.nodeAfter;
  }

  function Gu(t) {
    return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
  }

  function Xu(t, e) {
    return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
  }

  function Yu(t, e, n) {
    var o = t.start(-1),
        r = Hu.get(t.node(-1)).nextCell(t.pos - o, e, n);
    return null == r ? null : t.node(0).resolve(o + r);
  }

  function Zu(t, e, n) {
    var o = {};

    for (var r in t) o[r] = t[r];

    return o[e] = n, o;
  }

  function Qu(t, e, n) {
    void 0 === n && (n = 1);
    var o = Zu(t, "colspan", t.colspan - n);
    return o.colwidth && (o.colwidth = o.colwidth.slice(), o.colwidth.splice(e, n), o.colwidth.some(function (t) {
      return t > 0;
    }) || (o.colwidth = null)), o;
  }

  function tf(t, e, n) {
    void 0 === n && (n = 1);
    var o = Zu(t, "colspan", t.colspan + n);

    if (o.colwidth) {
      o.colwidth = o.colwidth.slice();

      for (var r = 0; r < n; r++) o.colwidth.splice(e, 0, 0);
    }

    return o;
  }

  var ef = function (t) {
    function e(e, n) {
      void 0 === n && (n = e);
      var o = e.node(-1),
          r = Hu.get(o),
          i = e.start(-1),
          a = r.rectBetween(e.pos - i, n.pos - i),
          s = e.node(0),
          l = r.cellsInRect(a).filter(function (t) {
        return t != n.pos - i;
      });
      l.unshift(n.pos - i);
      var c = l.map(function (t) {
        var e = o.nodeAt(t),
            n = t + i + 1;
        return new al(s.resolve(n), s.resolve(n + e.content.size));
      });
      t.call(this, c[0].$from, c[0].$to, c), this.$anchorCell = e, this.$headCell = n;
    }

    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.map = function (t, n) {
      var o = t.resolve(n.map(this.$anchorCell.pos)),
          r = t.resolve(n.map(this.$headCell.pos));

      if (Ju(o) && Ju(r) && Xu(o, r)) {
        var i = this.$anchorCell.node(-1) != o.node(-1);
        return i && this.isRowSelection() ? e.rowSelection(o, r) : i && this.isColSelection() ? e.colSelection(o, r) : new e(o, r);
      }

      return sl.between(o, r);
    }, e.prototype.content = function () {
      for (var t = this.$anchorCell.node(-1), e = Hu.get(t), n = this.$anchorCell.start(-1), o = e.rectBetween(this.$anchorCell.pos - n, this.$headCell.pos - n), r = {}, i = [], a = o.top; a < o.bottom; a++) {
        for (var s = [], l = a * e.width + o.left, c = o.left; c < o.right; c++, l++) {
          var p = e.map[l];

          if (!r[p]) {
            r[p] = !0;
            var u = e.findCell(p),
                f = t.nodeAt(p),
                d = o.left - u.left,
                h = u.right - o.right;

            if (d > 0 || h > 0) {
              var v = f.attrs;
              d > 0 && (v = Qu(v, 0, d)), h > 0 && (v = Qu(v, v.colspan - h, h)), f = u.left < o.left ? f.type.createAndFill(v) : f.type.create(v, f.content);
            }

            if (u.top < o.top || u.bottom > o.bottom) {
              var m = Zu(f.attrs, "rowspan", Math.min(u.bottom, o.bottom) - Math.max(u.top, o.top));
              f = u.top < o.top ? f.type.createAndFill(m) : f.type.create(m, f.content);
            }

            s.push(f);
          }
        }

        i.push(t.child(a).copy(ha.from(s)));
      }

      var g = this.isColSelection() && this.isRowSelection() ? t : i;
      return new Sa(ha.from(g), 1, 1);
    }, e.prototype.replace = function (e, n) {
      void 0 === n && (n = Sa.empty);

      for (var o = e.steps.length, r = this.ranges, i = 0; i < r.length; i++) {
        var a = r[i],
            s = a.$from,
            l = a.$to,
            c = e.mapping.slice(o);
        e.replace(c.map(s.pos), c.map(l.pos), i ? Sa.empty : n);
      }

      var p = t.findFrom(e.doc.resolve(e.mapping.slice(o).map(this.to)), -1);
      p && e.setSelection(p);
    }, e.prototype.replaceWith = function (t, e) {
      this.replace(t, new Sa(ha.from(e), 0, 0));
    }, e.prototype.forEachCell = function (t) {
      for (var e = this.$anchorCell.node(-1), n = Hu.get(e), o = this.$anchorCell.start(-1), r = n.cellsInRect(n.rectBetween(this.$anchorCell.pos - o, this.$headCell.pos - o)), i = 0; i < r.length; i++) t(e.nodeAt(r[i]), o + r[i]);
    }, e.prototype.isColSelection = function () {
      var t = this.$anchorCell.index(-1),
          e = this.$headCell.index(-1);
      if (Math.min(t, e) > 0) return !1;
      var n = t + this.$anchorCell.nodeAfter.attrs.rowspan,
          o = e + this.$headCell.nodeAfter.attrs.rowspan;
      return Math.max(n, o) == this.$headCell.node(-1).childCount;
    }, e.colSelection = function (t, n) {
      void 0 === n && (n = t);
      var o = Hu.get(t.node(-1)),
          r = t.start(-1),
          i = o.findCell(t.pos - r),
          a = o.findCell(n.pos - r),
          s = t.node(0);
      return i.top <= a.top ? (i.top > 0 && (t = s.resolve(r + o.map[i.left])), a.bottom < o.height && (n = s.resolve(r + o.map[o.width * (o.height - 1) + a.right - 1]))) : (a.top > 0 && (n = s.resolve(r + o.map[a.left])), i.bottom < o.height && (t = s.resolve(r + o.map[o.width * (o.height - 1) + i.right - 1]))), new e(t, n);
    }, e.prototype.isRowSelection = function () {
      var t = Hu.get(this.$anchorCell.node(-1)),
          e = this.$anchorCell.start(-1),
          n = t.colCount(this.$anchorCell.pos - e),
          o = t.colCount(this.$headCell.pos - e);
      if (Math.min(n, o) > 0) return !1;
      var r = n + this.$anchorCell.nodeAfter.attrs.colspan,
          i = o + this.$headCell.nodeAfter.attrs.colspan;
      return Math.max(r, i) == t.width;
    }, e.prototype.eq = function (t) {
      return t instanceof e && t.$anchorCell.pos == this.$anchorCell.pos && t.$headCell.pos == this.$headCell.pos;
    }, e.rowSelection = function (t, n) {
      void 0 === n && (n = t);
      var o = Hu.get(t.node(-1)),
          r = t.start(-1),
          i = o.findCell(t.pos - r),
          a = o.findCell(n.pos - r),
          s = t.node(0);
      return i.left <= a.left ? (i.left > 0 && (t = s.resolve(r + o.map[i.top * o.width])), a.right < o.width && (n = s.resolve(r + o.map[o.width * (a.top + 1) - 1]))) : (a.left > 0 && (n = s.resolve(r + o.map[a.top * o.width])), i.right < o.width && (t = s.resolve(r + o.map[o.width * (i.top + 1) - 1]))), new e(t, n);
    }, e.prototype.toJSON = function () {
      return {
        type: "cell",
        anchor: this.$anchorCell.pos,
        head: this.$headCell.pos
      };
    }, e.fromJSON = function (t, n) {
      return new e(t.resolve(n.anchor), t.resolve(n.head));
    }, e.create = function (t, n, o) {
      return void 0 === o && (o = n), new e(t.resolve(n), t.resolve(o));
    }, e.prototype.getBookmark = function () {
      return new nf(this.$anchorCell.pos, this.$headCell.pos);
    }, e;
  }(rl);

  ef.prototype.visible = !1, rl.jsonID("cell", ef);

  var nf = function (t, e) {
    this.anchor = t, this.head = e;
  };

  function of(t) {
    if (!(t.selection instanceof ef)) return null;
    var e = [];
    return t.selection.forEachCell(function (t, n) {
      e.push(vu.node(n, n + t.nodeSize, {
        class: "selectedCell"
      }));
    }), bu.create(t.doc, e);
  }

  function rf(t, e) {
    var n = t.getAttribute("data-colwidth"),
        o = n && /^\d+(,\d+)*$/.test(n) ? n.split(",").map(function (t) {
      return Number(t);
    }) : null,
        r = Number(t.getAttribute("colspan") || 1),
        i = {
      colspan: r,
      rowspan: Number(t.getAttribute("rowspan") || 1),
      colwidth: o && o.length == r ? o : null
    };

    for (var a in e) {
      var s = e[a].getFromDOM,
          l = s && s(t);
      null != l && (i[a] = l);
    }

    return i;
  }

  function af(t, e) {
    var n = {};

    for (var o in 1 != t.attrs.colspan && (n.colspan = t.attrs.colspan), 1 != t.attrs.rowspan && (n.rowspan = t.attrs.rowspan), t.attrs.colwidth && (n["data-colwidth"] = t.attrs.colwidth.join(",")), e) {
      var r = e[o].setDOMAttr;
      r && r(t.attrs[o], n);
    }

    return n;
  }

  function sf(t) {
    var e = t.cached.tableNodeTypes;
    if (!e) for (var n in e = t.cached.tableNodeTypes = {}, t.nodes) {
      var o = t.nodes[n],
          r = o.spec.tableRole;
      r && (e[r] = o);
    }
    return e;
  }

  function lf(t) {
    if (!t.size) return null;

    for (var e = t.content, n = t.openStart, o = t.openEnd; 1 == e.childCount && (n > 0 && o > 0 || "table" == e.firstChild.type.spec.tableRole);) n--, o--, e = e.firstChild.content;

    var r = e.firstChild,
        i = r.type.spec.tableRole,
        a = r.type.schema,
        s = [];
    if ("row" == i) for (var l = 0; l < e.childCount; l++) {
      var c = e.child(l).content,
          p = l ? 0 : Math.max(0, n - 1),
          u = l < e.childCount - 1 ? 0 : Math.max(0, o - 1);
      (p || u) && (c = cf(sf(a).row, new Sa(c, p, u)).content), s.push(c);
    } else {
      if ("cell" != i && "header_cell" != i) return null;
      s.push(n || o ? cf(sf(a).row, new Sa(e, n, o)).content : e);
    }
    return function (t, e) {
      for (var n = [], o = 0; o < e.length; o++) for (var r = e[o], i = r.childCount - 1; i >= 0; i--) for (var a = r.child(i).attrs, s = a.rowspan, l = a.colspan, c = o; c < o + s; c++) n[c] = (n[c] || 0) + l;

      for (var p = 0, u = 0; u < n.length; u++) p = Math.max(p, n[u]);

      for (var f = 0; f < n.length; f++) if (f >= e.length && e.push(ha.empty), n[f] < p) {
        for (var d = sf(t).cell.createAndFill(), h = [], v = n[f]; v < p; v++) h.push(d);

        e[f] = e[f].append(ha.from(h));
      }

      return {
        height: e.length,
        width: p,
        rows: e
      };
    }(a, s);
  }

  function cf(t, e) {
    var n = t.createAndFill();
    return new Is(n).replace(0, n.content.size, e).doc;
  }

  function pf(t, e, n) {
    var o = t.width,
        r = t.height,
        i = t.rows;

    if (o != e) {
      for (var a = [], s = [], l = 0; l < i.length; l++) {
        for (var c = i[l], p = [], u = a[l] || 0, f = 0; u < e; f++) {
          var d = c.child(f % c.childCount);
          u + d.attrs.colspan > e && (d = d.type.create(Qu(d.attrs, d.attrs.colspan, u + d.attrs.colspan - e), d.content)), p.push(d), u += d.attrs.colspan;

          for (var h = 1; h < d.attrs.rowspan; h++) a[l + h] = (a[l + h] || 0) + d.attrs.colspan;
        }

        s.push(ha.from(p));
      }

      i = s, o = e;
    }

    if (r != n) {
      for (var v = [], m = 0, g = 0; m < n; m++, g++) {
        for (var y = [], b = i[g % r], w = 0; w < b.childCount; w++) {
          var S = b.child(w);
          m + S.attrs.rowspan > n && (S = S.type.create(Zu(S.attrs, "rowspan", n - S.attrs.rowspan), S.content)), y.push(S);
        }

        v.push(ha.from(y));
      }

      i = v, r = n;
    }

    return {
      width: o,
      height: r,
      rows: i
    };
  }

  function uf(t, e, n, o, r, i, a, s) {
    if (0 == a || a == e.height) return !1;

    for (var l = !1, c = r; c < i; c++) {
      var p = a * e.width + c,
          u = e.map[p];

      if (e.map[p - e.width] == u) {
        l = !0;
        var f = n.nodeAt(u),
            d = e.findCell(u),
            h = d.top,
            v = d.left;
        t.setNodeMarkup(t.mapping.slice(s).map(u + o), null, Zu(f.attrs, "rowspan", a - h)), t.insert(t.mapping.slice(s).map(e.positionAt(a, v, n)), f.type.createAndFill(Zu(f.attrs, "rowspan", h + f.attrs.rowspan - a))), c += f.attrs.colspan - 1;
      }
    }

    return l;
  }

  function ff(t, e, n, o, r, i, a, s) {
    if (0 == a || a == e.width) return !1;

    for (var l = !1, c = r; c < i; c++) {
      var p = c * e.width + a,
          u = e.map[p];

      if (e.map[p - 1] == u) {
        l = !0;
        var f = n.nodeAt(u),
            d = e.colCount(u),
            h = t.mapping.slice(s).map(u + o);
        t.setNodeMarkup(h, null, Qu(f.attrs, a - d, f.attrs.colspan - (a - d))), t.insert(h + f.nodeSize, f.type.createAndFill(Qu(f.attrs, 0, a - d))), c += f.attrs.rowspan - 1;
      }
    }

    return l;
  }

  function df(t, e, n, o, r) {
    var i = n ? t.doc.nodeAt(n - 1) : t.doc,
        a = Hu.get(i),
        s = o.top,
        l = o.left,
        c = l + r.width,
        p = s + r.height,
        u = t.tr,
        f = 0;

    function d() {
      i = n ? u.doc.nodeAt(n - 1) : u.doc, a = Hu.get(i), f = u.mapping.maps.length;
    }

    (function (t, e, n, o, r, i, a) {
      var s,
          l,
          c = sf(t.doc.type.schema);
      if (r > e.width) for (var p = 0, u = 0; p < e.height; p++) {
        var f = n.child(p);
        u += f.nodeSize;
        var d = [],
            h = void 0;
        h = null == f.lastChild || f.lastChild.type == c.cell ? s || (s = c.cell.createAndFill()) : l || (l = c.header_cell.createAndFill());

        for (var v = e.width; v < r; v++) d.push(h);

        t.insert(t.mapping.slice(a).map(u - 1 + o), d);
      }

      if (i > e.height) {
        for (var m = [], g = 0, y = (e.height - 1) * e.width; g < Math.max(e.width, r); g++) {
          var b = !(g >= e.width) && n.nodeAt(e.map[y + g]).type == c.header_cell;
          m.push(b ? l || (l = c.header_cell.createAndFill()) : s || (s = c.cell.createAndFill()));
        }

        for (var w = c.row.create(null, ha.from(m)), S = [], C = e.height; C < i; C++) S.push(w);

        t.insert(t.mapping.slice(a).map(o + n.nodeSize - 2), S);
      }

      return !(!s && !l);
    })(u, a, i, n, c, p, f) && d(), uf(u, a, i, n, l, c, s, f) && d(), uf(u, a, i, n, l, c, p, f) && d(), ff(u, a, i, n, s, p, l, f) && d(), ff(u, a, i, n, s, p, c, f) && d();

    for (var h = s; h < p; h++) {
      var v = a.positionAt(h, l, i),
          m = a.positionAt(h, c, i);
      u.replace(u.mapping.slice(f).map(v + n), u.mapping.slice(f).map(m + n), new Sa(r.rows[h - s], 0, 0));
    }

    d(), u.setSelection(new ef(u.doc.resolve(n + a.positionAt(s, l, i)), u.doc.resolve(n + a.positionAt(p - 1, c - 1, i)))), e(u);
  }

  nf.prototype.map = function (t) {
    return new nf(t.map(this.anchor), t.map(this.head));
  }, nf.prototype.resolve = function (t) {
    var e = t.resolve(this.anchor),
        n = t.resolve(this.head);
    return "row" == e.parent.type.spec.tableRole && "row" == n.parent.type.spec.tableRole && e.index() < e.parent.childCount && n.index() < n.parent.childCount && Xu(e, n) ? new ef(e, n) : rl.near(n, 1);
  };
  var hf,
      vf,
      mf = (hf = {
    ArrowLeft: yf("horiz", -1),
    ArrowRight: yf("horiz", 1),
    ArrowUp: yf("vert", -1),
    ArrowDown: yf("vert", 1),
    "Shift-ArrowLeft": bf("horiz", -1),
    "Shift-ArrowRight": bf("horiz", 1),
    "Shift-ArrowUp": bf("vert", -1),
    "Shift-ArrowDown": bf("vert", 1),
    Backspace: wf,
    "Mod-Backspace": wf,
    Delete: wf,
    "Mod-Delete": wf
  }, vf = function (t) {
    var e = Object.create(null);

    for (var n in t) e[tc(n)] = t[n];

    return e;
  }(hf), function (t, e) {
    var n,
        o = Zl(e),
        r = 1 == o.length && " " != o,
        i = vf[ec(o, e, !r)];
    if (i && i(t.state, t.dispatch, t)) return !0;

    if (r && (e.shiftKey || e.altKey || e.metaKey) && (n = Hl[e.keyCode]) && n != o) {
      var a = vf[ec(n, e, !0)];
      if (a && a(t.state, t.dispatch, t)) return !0;
    } else if (r && e.shiftKey) {
      var s = vf[ec(o, e, !0)];
      if (s && s(t.state, t.dispatch, t)) return !0;
    }

    return !1;
  });

  function gf(t, e, n) {
    return !n.eq(t.selection) && (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
  }

  function yf(t, e) {
    return function (n, o, r) {
      var i = n.selection;
      if (i instanceof ef) return gf(n, o, rl.near(i.$headCell, e));
      if ("horiz" != t && !i.empty) return !1;
      var a = kf(r, t, e);
      if (null == a) return !1;
      if ("horiz" == t) return gf(n, o, rl.near(n.doc.resolve(i.head + e), e));
      var s,
          l = n.doc.resolve(a),
          c = Yu(l, t, e);
      return s = c ? rl.near(c, 1) : e < 0 ? rl.near(n.doc.resolve(l.before(-1)), -1) : rl.near(n.doc.resolve(l.after(-1)), 1), gf(n, o, s);
    };
  }

  function bf(t, e) {
    return function (n, o, r) {
      var i = n.selection;

      if (!(i instanceof ef)) {
        var a = kf(r, t, e);
        if (null == a) return !1;
        i = new ef(n.doc.resolve(a));
      }

      var s = Yu(i.$headCell, t, e);
      return !!s && gf(n, o, new ef(i.$anchorCell, s));
    };
  }

  function wf(t, e) {
    var n = t.selection;
    if (!(n instanceof ef)) return !1;

    if (e) {
      var o = t.tr,
          r = sf(t.schema).cell.createAndFill().content;
      n.forEachCell(function (t, e) {
        t.content.eq(r) || o.replace(o.mapping.map(e + 1), o.mapping.map(e + t.nodeSize - 1), new Sa(r, 0, 0));
      }), o.docChanged && e(o);
    }

    return !0;
  }

  function Sf(t, e) {
    var n = Uu(t.state.doc.resolve(e));
    return !!n && (t.dispatch(t.state.tr.setSelection(new ef(n))), !0);
  }

  function Cf(t, e, n) {
    if (!Wu(t.state)) return !1;
    var o = lf(n),
        r = t.state.selection;

    if (r instanceof ef) {
      o || (o = {
        width: 1,
        height: 1,
        rows: [ha.from(cf(sf(t.state.schema).cell, n))]
      });
      var i = r.$anchorCell.node(-1),
          a = r.$anchorCell.start(-1),
          s = Hu.get(i).rectBetween(r.$anchorCell.pos - a, r.$headCell.pos - a);
      return o = pf(o, s.right - s.left, s.bottom - s.top), df(t.state, t.dispatch, a, s, o), !0;
    }

    if (o) {
      var l = Ku(t.state),
          c = l.start(-1);
      return df(t.state, t.dispatch, c, Hu.get(l.node(-1)).findCell(l.pos - c), o), !0;
    }

    return !1;
  }

  function xf(t, e) {
    if (!e.ctrlKey && !e.metaKey) {
      var n,
          o = Of(t, e.target);
      if (e.shiftKey && t.state.selection instanceof ef) r(t.state.selection.$anchorCell, e), e.preventDefault();else if (e.shiftKey && o && null != (n = Uu(t.state.selection.$anchor)) && Af(t, e).pos != n.pos) r(n, e), e.preventDefault();else if (!o) return;
      t.root.addEventListener("mouseup", i), t.root.addEventListener("dragstart", i), t.root.addEventListener("mousemove", a);
    }

    function r(e, n) {
      var o = Af(t, n),
          r = null == qu.getState(t.state);

      if (!o || !Xu(e, o)) {
        if (!r) return;
        o = e;
      }

      var i = new ef(e, o);

      if (r || !t.state.selection.eq(i)) {
        var a = t.state.tr.setSelection(i);
        r && a.setMeta(qu, e.pos), t.dispatch(a);
      }
    }

    function i() {
      t.root.removeEventListener("mouseup", i), t.root.removeEventListener("dragstart", i), t.root.removeEventListener("mousemove", a), null != qu.getState(t.state) && t.dispatch(t.state.tr.setMeta(qu, -1));
    }

    function a(n) {
      var a,
          s = qu.getState(t.state);
      if (null != s) a = t.state.doc.resolve(s);else if (Of(t, n.target) != o && !(a = Af(t, e))) return i();
      a && r(a, n);
    }
  }

  function kf(t, e, n) {
    if (!(t.state.selection instanceof sl)) return null;

    for (var o = t.state.selection.$head, r = o.depth - 1; r >= 0; r--) {
      var i = o.node(r);
      if ((n < 0 ? o.index(r) : o.indexAfter(r)) != (n < 0 ? 0 : i.childCount)) return null;

      if ("cell" == i.type.spec.tableRole || "header_cell" == i.type.spec.tableRole) {
        var a = o.before(r),
            s = "vert" == e ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
        return t.endOfTextblock(s) ? a : null;
      }
    }

    return null;
  }

  function Of(t, e) {
    for (; e && e != t.dom; e = e.parentNode) if ("TD" == e.nodeName || "TH" == e.nodeName) return e;
  }

  function Af(t, e) {
    var n = t.posAtCoords({
      left: e.clientX,
      top: e.clientY
    });
    return n && n ? Uu(t.state.doc.resolve(n.pos)) : null;
  }

  var Tf = new Al("fix-tables");

  function Ef(t, e) {
    var n,
        o = function (e, o) {
      "table" == e.type.spec.tableRole && (n = function (t, e, n, o) {
        var r = Hu.get(e);
        if (!r.problems) return o;
        o || (o = t.tr);

        for (var i, a, s = [], l = 0; l < r.height; l++) s.push(0);

        for (var c = 0; c < r.problems.length; c++) {
          var p = r.problems[c];

          if ("collision" == p.type) {
            for (var u = e.nodeAt(p.pos), f = 0; f < u.attrs.rowspan; f++) s[p.row + f] += p.n;

            o.setNodeMarkup(o.mapping.map(n + 1 + p.pos), null, Qu(u.attrs, u.attrs.colspan - p.n, p.n));
          } else if ("missing" == p.type) s[p.row] += p.n;else if ("overlong_rowspan" == p.type) {
            var d = e.nodeAt(p.pos);
            o.setNodeMarkup(o.mapping.map(n + 1 + p.pos), null, Zu(d.attrs, "rowspan", d.attrs.rowspan - p.n));
          } else if ("colwidth mismatch" == p.type) {
            var h = e.nodeAt(p.pos);
            o.setNodeMarkup(o.mapping.map(n + 1 + p.pos), null, Zu(h.attrs, "colwidth", p.colwidth));
          }
        }

        for (var v = 0; v < s.length; v++) s[v] && (null == i && (i = v), a = v);

        for (var m = 0, g = n + 1; m < r.height; m++) {
          var y = e.child(m),
              b = g + y.nodeSize,
              w = s[m];

          if (w > 0) {
            var S = "cell";
            y.firstChild && (S = y.firstChild.type.spec.tableRole);

            for (var C = [], x = 0; x < w; x++) C.push(sf(t.schema)[S].createAndFill());

            var k = 0 != m && i != m - 1 || a != m ? b - 1 : g + 1;
            o.insert(o.mapping.map(k), C);
          }

          g = b;
        }

        return o.setMeta(Tf, {
          fixTables: !0
        });
      }(t, e, o, n));
    };

    return e ? e.doc != t.doc && function t(e, n, o, r) {
      var i = e.childCount,
          a = n.childCount;

      t: for (var s = 0, l = 0; s < a; s++) {
        for (var c = n.child(s), p = l, u = Math.min(i, s + 3); p < u; p++) if (e.child(p) == c) {
          l = p + 1, o += c.nodeSize;
          continue t;
        }

        r(c, o), l < i && e.child(l).sameMarkup(c) ? t(e.child(l), c, o + 1, r) : c.nodesBetween(0, c.content.size, r, o + 1), o += c.nodeSize;
      }
    }(e.doc, t.doc, 0, o) : t.doc.descendants(o), n;
  }

  function Mf(t) {
    var e,
        n = t.selection,
        o = Ku(t),
        r = o.node(-1),
        i = o.start(-1),
        a = Hu.get(r);
    return (e = n instanceof ef ? a.rectBetween(n.$anchorCell.pos - i, n.$headCell.pos - i) : a.findCell(o.pos - i)).tableStart = i, e.map = a, e.table = r, e;
  }

  function Nf(t, e, n) {
    var o = e.map,
        r = e.tableStart,
        i = e.table,
        a = n > 0 ? -1 : 0;
    (function (t, e, n) {
      for (var o = sf(e.type.schema).header_cell, r = 0; r < t.height; r++) if (e.nodeAt(t.map[n + r * t.width]).type != o) return !1;

      return !0;
    })(o, i, n + a) && (a = 0 == n || n == o.width ? null : 0);

    for (var s = 0; s < o.height; s++) {
      var l = s * o.width + n;

      if (n > 0 && n < o.width && o.map[l - 1] == o.map[l]) {
        var c = o.map[l],
            p = i.nodeAt(c);
        t.setNodeMarkup(t.mapping.map(r + c), null, tf(p.attrs, n - o.colCount(c))), s += p.attrs.rowspan - 1;
      } else {
        var u = null == a ? sf(i.type.schema).cell : i.nodeAt(o.map[l + a]).type,
            f = o.positionAt(s, n, i);
        t.insert(t.mapping.map(r + f), u.createAndFill());
      }
    }

    return t;
  }

  function Rf(t, e, n) {
    for (var o = e.map, r = e.table, i = e.tableStart, a = t.mapping.maps.length, s = 0; s < o.height;) {
      var l = s * o.width + n,
          c = o.map[l],
          p = r.nodeAt(c);
      if (n > 0 && o.map[l - 1] == c || n < o.width - 1 && o.map[l + 1] == c) t.setNodeMarkup(t.mapping.slice(a).map(i + c), null, Qu(p.attrs, n - o.colCount(c)));else {
        var u = t.mapping.slice(a).map(i + c);
        t.delete(u, u + p.nodeSize);
      }
      s += p.attrs.rowspan;
    }
  }

  function Lf(t, e, n) {
    for (var o = sf(e.type.schema).header_cell, r = 0; r < t.width; r++) if (e.nodeAt(t.map[r + n * t.width]).type != o) return !1;

    return !0;
  }

  function If(t, e, n) {
    for (var o = e.map, r = e.tableStart, i = e.table, a = r, s = 0; s < n; s++) a += i.child(s).nodeSize;

    var l = [],
        c = n > 0 ? -1 : 0;
    Lf(o, i, n + c) && (c = 0 == n || n == o.height ? null : 0);

    for (var p = 0, u = o.width * n; p < o.width; p++, u++) if (n > 0 && n < o.height && o.map[u] == o.map[u - o.width]) {
      var f = o.map[u],
          d = i.nodeAt(f).attrs;
      t.setNodeMarkup(r + f, null, Zu(d, "rowspan", d.rowspan + 1)), p += d.colspan - 1;
    } else {
      var h = null == c ? sf(i.type.schema).cell : i.nodeAt(o.map[u + c * o.width]).type;
      l.push(h.createAndFill());
    }

    return t.insert(a, sf(i.type.schema).row.create(null, l)), t;
  }

  function Pf(t, e, n) {
    for (var o = e.map, r = e.table, i = e.tableStart, a = 0, s = 0; s < n; s++) a += r.child(s).nodeSize;

    var l = a + r.child(n).nodeSize,
        c = t.mapping.maps.length;
    t.delete(a + i, l + i);

    for (var p = 0, u = n * o.width; p < o.width; p++, u++) {
      var f = o.map[u];

      if (n > 0 && f == o.map[u - o.width]) {
        var d = r.nodeAt(f).attrs;
        t.setNodeMarkup(t.mapping.slice(c).map(f + i), null, Zu(d, "rowspan", d.rowspan - 1)), p += d.colspan - 1;
      } else if (n < o.width && f == o.map[u + o.width]) {
        var h = r.nodeAt(f),
            v = h.type.create(Zu(h.attrs, "rowspan", h.attrs.rowspan - 1), h.content),
            m = o.positionAt(n + 1, p, r);
        t.insert(t.mapping.slice(c).map(i + m), v), p += h.attrs.colspan - 1;
      }
    }
  }

  function Df(t) {
    var e = t.content;
    return 1 == e.childCount && e.firstChild.isTextblock && 0 == e.firstChild.childCount;
  }

  function _f(t) {
    return function (e, n) {
      var o,
          r,
          i = e.selection;

      if (i instanceof ef) {
        if (i.$anchorCell.pos != i.$headCell.pos) return !1;
        o = i.$anchorCell.nodeAfter, r = i.$anchorCell.pos;
      } else {
        if (!(o = function (t) {
          for (var e = t.depth; e > 0; e--) {
            var n = t.node(e).type.spec.tableRole;
            if ("cell" === n || "header_cell" === n) return t.node(e);
          }

          return null;
        }(i.$from))) return !1;
        r = Uu(i.$from).pos;
      }

      if (1 == o.attrs.colspan && 1 == o.attrs.rowspan) return !1;

      if (n) {
        var a = o.attrs,
            s = [],
            l = a.colwidth;
        a.rowspan > 1 && (a = Zu(a, "rowspan", 1)), a.colspan > 1 && (a = Zu(a, "colspan", 1));

        for (var c, p = Mf(e), u = e.tr, f = 0; f < p.right - p.left; f++) s.push(l ? Zu(a, "colwidth", l && l[f] ? [l[f]] : null) : a);

        for (var d = p.top; d < p.bottom; d++) {
          var h = p.map.positionAt(d, p.left, p.table);
          d == p.top && (h += o.nodeSize);

          for (var v = p.left, m = 0; v < p.right; v++, m++) v == p.left && d == p.top || u.insert(c = u.mapping.map(h + p.tableStart, 1), t({
            node: o,
            row: d,
            col: v
          }).createAndFill(s[m]));
        }

        u.setNodeMarkup(r, t({
          node: o,
          row: p.top,
          col: p.left
        }), s[0]), i instanceof ef && u.setSelection(new ef(u.doc.resolve(i.$anchorCell.pos), c && u.doc.resolve(c))), n(u);
      }

      return !0;
    };
  }

  function Bf(t, e, n) {
    for (var o = e.map.cellsInRect({
      left: 0,
      top: 0,
      right: "row" == t ? e.map.width : 1,
      bottom: "column" == t ? e.map.height : 1
    }), r = 0; r < o.length; r++) {
      var i = e.table.nodeAt(o[r]);
      if (i && i.type !== n.header_cell) return !1;
    }

    return !0;
  }

  function Vf(t, e) {
    return (e = e || {
      useDeprecatedLogic: !1
    }).useDeprecatedLogic ? function (t) {
      return function (e, n) {
        if (!Wu(e)) return !1;

        if (n) {
          for (var o = sf(e.schema), r = Mf(e), i = e.tr, a = r.map.cellsInRect("column" == t ? new ju(r.left, 0, r.right, r.map.height) : "row" == t ? new ju(0, r.top, r.map.width, r.bottom) : r), s = a.map(function (t) {
            return r.table.nodeAt(t);
          }), l = 0; l < a.length; l++) s[l].type == o.header_cell && i.setNodeMarkup(r.tableStart + a[l], o.cell, s[l].attrs);

          if (0 == i.steps.length) for (var c = 0; c < a.length; c++) i.setNodeMarkup(r.tableStart + a[c], o.header_cell, s[c].attrs);
          n(i);
        }

        return !0;
      };
    }(t) : function (e, n) {
      if (!Wu(e)) return !1;

      if (n) {
        var o = sf(e.schema),
            r = Mf(e),
            i = e.tr,
            a = Bf("row", r, o),
            s = Bf("column", r, o),
            l = ("column" === t ? a : "row" === t && s) ? 1 : 0,
            c = "column" == t ? new ju(0, l, 1, r.map.height) : "row" == t ? new ju(l, 0, r.map.width, 1) : r,
            p = "column" == t ? s ? o.cell : o.header_cell : "row" == t ? a ? o.cell : o.header_cell : o.cell;
        r.map.cellsInRect(c).forEach(function (t) {
          var e = t + r.tableStart,
              n = i.doc.nodeAt(e);
          n && i.setNodeMarkup(e, p, n.attrs);
        }), n(i);
      }

      return !0;
    };
  }

  var zf = Vf("row", {
    useDeprecatedLogic: !0
  }),
      $f = Vf("column", {
    useDeprecatedLogic: !0
  }),
      jf = Vf("cell", {
    useDeprecatedLogic: !0
  });

  var Hf = function (t, e) {
    this.node = t, this.cellMinWidth = e, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), Ff(t, this.colgroup, this.table, e), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  };

  function Ff(t, e, n, o, r, i) {
    for (var a = 0, s = !0, l = e.firstChild, c = t.firstChild, p = 0, u = 0; p < c.childCount; p++) for (var f = c.child(p).attrs, d = f.colspan, h = f.colwidth, v = 0; v < d; v++, u++) {
      var m = r == u ? i : h && h[v],
          g = m ? m + "px" : "";
      a += m || o, m || (s = !1), l ? (l.style.width != g && (l.style.width = g), l = l.nextSibling) : e.appendChild(document.createElement("col")).style.width = g;
    }

    for (; l;) {
      var y = l.nextSibling;
      l.parentNode.removeChild(l), l = y;
    }

    s ? (n.style.width = a + "px", n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = a + "px");
  }

  Hf.prototype.update = function (t) {
    return t.type == this.node.type && (this.node = t, Ff(t, this.colgroup, this.table, this.cellMinWidth), !0);
  }, Hf.prototype.ignoreMutation = function (t) {
    return "attributes" == t.type && (t.target == this.table || this.colgroup.contains(t.target));
  };
  var qf = new Al("tableColumnResizing");

  var Uf = function (t, e) {
    this.activeHandle = t, this.dragging = e;
  };

  function Wf(t, e, n) {
    var o = t.posAtCoords({
      left: e.clientX,
      top: e.clientY
    }).pos,
        r = Uu(t.state.doc.resolve(o));
    if (!r) return -1;
    if ("right" == n) return r.pos;
    var i = Hu.get(r.node(-1)),
        a = r.start(-1),
        s = i.map.indexOf(r.pos - a);
    return s % i.width == 0 ? -1 : a + i.map[s - 1];
  }

  function Kf(t, e, n) {
    var o = e.clientX - t.startX;
    return Math.max(n, t.startWidth + o);
  }

  function Jf(t, e) {
    t.dispatch(t.state.tr.setMeta(qf, {
      setHandle: e
    }));
  }

  function Gf(t) {
    for (var e = [], n = 0; n < t; n++) e.push(0);

    return e;
  }

  Uf.prototype.apply = function (t) {
    var e = this,
        n = t.getMeta(qf);
    if (n && null != n.setHandle) return new Uf(n.setHandle, null);
    if (n && void 0 !== n.setDragging) return new Uf(e.activeHandle, n.setDragging);

    if (e.activeHandle > -1 && t.docChanged) {
      var o = t.mapping.map(e.activeHandle, -1);
      Ju(t.doc.resolve(o)) || (o = null), e = new Uf(o, e.dragging);
    }

    return e;
  };

  var Xf,
      Yf = Object.freeze({
    __proto__: null,
    CellSelection: ef,
    TableMap: Hu,
    __clipCells: pf,
    __insertCells: df,
    __pastedCells: lf,
    addColumn: Nf,
    addColumnAfter: function (t, e) {
      if (!Wu(t)) return !1;

      if (e) {
        var n = Mf(t);
        e(Nf(t.tr, n, n.right));
      }

      return !0;
    },
    addColumnBefore: function (t, e) {
      if (!Wu(t)) return !1;

      if (e) {
        var n = Mf(t);
        e(Nf(t.tr, n, n.left));
      }

      return !0;
    },
    addRow: If,
    addRowAfter: function (t, e) {
      if (!Wu(t)) return !1;

      if (e) {
        var n = Mf(t);
        e(If(t.tr, n, n.bottom));
      }

      return !0;
    },
    addRowBefore: function (t, e) {
      if (!Wu(t)) return !1;

      if (e) {
        var n = Mf(t);
        e(If(t.tr, n, n.top));
      }

      return !0;
    },
    cellAround: Uu,
    colCount: function (t) {
      return Hu.get(t.node(-1)).colCount(t.pos - t.start(-1));
    },
    columnResizing: function (t) {
      void 0 === t && (t = {});
      var e = t.handleWidth;
      void 0 === e && (e = 5);
      var n = t.cellMinWidth;
      void 0 === n && (n = 25);
      var o = t.View;
      void 0 === o && (o = Hf);
      var r = t.lastColumnResizable;
      return void 0 === r && (r = !0), new xl({
        key: qf,
        state: {
          init: function (t, e) {
            return this.spec.props.nodeViews[sf(e.schema).table.name] = function (t, e) {
              return new o(t, n, e);
            }, new Uf(-1, !1);
          },
          apply: function (t, e) {
            return e.apply(t);
          }
        },
        props: {
          attributes: function (t) {
            return qf.getState(t).activeHandle > -1 ? {
              class: "resize-cursor"
            } : null;
          },
          handleDOMEvents: {
            mousemove: function (t, n) {
              !function (t, e, n, o, r) {
                var i = qf.getState(t.state);

                if (!i.dragging) {
                  var a = function (t) {
                    for (; t && "TD" != t.nodeName && "TH" != t.nodeName;) t = t.classList.contains("ProseMirror") ? null : t.parentNode;

                    return t;
                  }(e.target),
                      s = -1;

                  if (a) {
                    var l = a.getBoundingClientRect(),
                        c = l.left,
                        p = l.right;
                    e.clientX - c <= n ? s = Wf(t, e, "left") : p - e.clientX <= n && (s = Wf(t, e, "right"));
                  }

                  if (s != i.activeHandle) {
                    if (!r && -1 !== s) {
                      var u = t.state.doc.resolve(s),
                          f = u.node(-1),
                          d = Hu.get(f),
                          h = u.start(-1),
                          v = d.colCount(u.pos - h) + u.nodeAfter.attrs.colspan - 1;
                      if (v == d.width - 1) return;
                    }

                    Jf(t, s);
                  }
                }
              }(t, n, e, 0, r);
            },
            mouseleave: function (t) {
              !function (t) {
                var e = qf.getState(t.state);
                e.activeHandle > -1 && !e.dragging && Jf(t, -1);
              }(t);
            },
            mousedown: function (t, e) {
              !function (t, e, n) {
                var o = qf.getState(t.state);
                if (-1 == o.activeHandle || o.dragging) return !1;

                var r = t.state.doc.nodeAt(o.activeHandle),
                    i = function (t, e, n) {
                  var o = n.colspan,
                      r = n.colwidth,
                      i = r && r[r.length - 1];
                  if (i) return i;
                  var a = t.domAtPos(e),
                      s = a.node.childNodes[a.offset].offsetWidth,
                      l = o;
                  if (r) for (var c = 0; c < o; c++) r[c] && (s -= r[c], l--);
                  return s / l;
                }(t, o.activeHandle, r.attrs);

                function a(e) {
                  window.removeEventListener("mouseup", a), window.removeEventListener("mousemove", s);
                  var o = qf.getState(t.state);
                  o.dragging && (function (t, e, n) {
                    for (var o = t.state.doc.resolve(e), r = o.node(-1), i = Hu.get(r), a = o.start(-1), s = i.colCount(o.pos - a) + o.nodeAfter.attrs.colspan - 1, l = t.state.tr, c = 0; c < i.height; c++) {
                      var p = c * i.width + s;

                      if (!c || i.map[p] != i.map[p - i.width]) {
                        var u = i.map[p],
                            f = r.nodeAt(u),
                            d = f.attrs,
                            h = 1 == d.colspan ? 0 : s - i.colCount(u);

                        if (!d.colwidth || d.colwidth[h] != n) {
                          var v = d.colwidth ? d.colwidth.slice() : Gf(d.colspan);
                          v[h] = n, l.setNodeMarkup(a + u, null, Zu(d, "colwidth", v));
                        }
                      }
                    }

                    l.docChanged && t.dispatch(l);
                  }(t, o.activeHandle, Kf(o.dragging, e, n)), t.dispatch(t.state.tr.setMeta(qf, {
                    setDragging: null
                  })));
                }

                function s(e) {
                  if (!e.which) return a(e);
                  var o = qf.getState(t.state),
                      r = Kf(o.dragging, e, n);
                  !function (t, e, n, o) {
                    for (var r = t.state.doc.resolve(e), i = r.node(-1), a = r.start(-1), s = Hu.get(i).colCount(r.pos - a) + r.nodeAfter.attrs.colspan - 1, l = t.domAtPos(r.start(-1)).node; "TABLE" != l.nodeName;) l = l.parentNode;

                    Ff(i, l.firstChild, l, o, s, n);
                  }(t, o.activeHandle, r, n);
                }

                t.dispatch(t.state.tr.setMeta(qf, {
                  setDragging: {
                    startX: e.clientX,
                    startWidth: i
                  }
                })), window.addEventListener("mouseup", a), window.addEventListener("mousemove", s), e.preventDefault();
              }(t, e, n);
            }
          },
          decorations: function (t) {
            var e = qf.getState(t);
            if (e.activeHandle > -1) return function (t, e) {
              for (var n = [], o = t.doc.resolve(e), r = o.node(-1), i = Hu.get(r), a = o.start(-1), s = i.colCount(o.pos - a) + o.nodeAfter.attrs.colspan, l = 0; l < i.height; l++) {
                var c = s + l * i.width - 1;

                if (!(s != i.width && i.map[c] == i.map[c + 1] || 0 != l && i.map[c - 1] == i.map[c - 1 - i.width])) {
                  var p = i.map[c],
                      u = a + p + r.nodeAt(p).nodeSize - 1,
                      f = document.createElement("div");
                  f.className = "column-resize-handle", n.push(vu.widget(u, f));
                }
              }

              return bu.create(t.doc, n);
            }(t, e.activeHandle);
          },
          nodeViews: {}
        }
      });
    },
    columnResizingPluginKey: qf,
    deleteColumn: function (t, e) {
      if (!Wu(t)) return !1;

      if (e) {
        var n = Mf(t),
            o = t.tr;
        if (0 == n.left && n.right == n.map.width) return !1;

        for (var r = n.right - 1; Rf(o, n, r), r != n.left; r--) n.table = n.tableStart ? o.doc.nodeAt(n.tableStart - 1) : o.doc, n.map = Hu.get(n.table);

        e(o);
      }

      return !0;
    },
    deleteRow: function (t, e) {
      if (!Wu(t)) return !1;

      if (e) {
        var n = Mf(t),
            o = t.tr;
        if (0 == n.top && n.bottom == n.map.height) return !1;

        for (var r = n.bottom - 1; Pf(o, n, r), r != n.top; r--) n.table = n.tableStart ? o.doc.nodeAt(n.tableStart - 1) : o.doc, n.map = Hu.get(n.table);

        e(o);
      }

      return !0;
    },
    deleteTable: function (t, e) {
      for (var n = t.selection.$anchor, o = n.depth; o > 0; o--) if ("table" == n.node(o).type.spec.tableRole) return e && e(t.tr.delete(n.before(o), n.after(o)).scrollIntoView()), !0;

      return !1;
    },
    findCell: function (t) {
      return Hu.get(t.node(-1)).findCell(t.pos - t.start(-1));
    },
    fixTables: Ef,
    fixTablesKey: Tf,
    goToNextCell: function (t) {
      return function (e, n) {
        if (!Wu(e)) return !1;

        var o = function (t, e) {
          if (e < 0) {
            var n = t.nodeBefore;
            if (n) return t.pos - n.nodeSize;

            for (var o = t.index(-1) - 1, r = t.before(); o >= 0; o--) {
              var i = t.node(-1).child(o);
              if (i.childCount) return r - 1 - i.lastChild.nodeSize;
              r -= i.nodeSize;
            }
          } else {
            if (t.index() < t.parent.childCount - 1) return t.pos + t.nodeAfter.nodeSize;

            for (var a = t.node(-1), s = t.indexAfter(-1), l = t.after(); s < a.childCount; s++) {
              var c = a.child(s);
              if (c.childCount) return l + 1;
              l += c.nodeSize;
            }
          }
        }(Ku(e), t);

        if (null != o) {
          if (n) {
            var r = e.doc.resolve(o);
            n(e.tr.setSelection(sl.between(r, Gu(r))).scrollIntoView());
          }

          return !0;
        }
      };
    },
    handlePaste: Cf,
    inSameTable: Xu,
    isInTable: Wu,
    mergeCells: function (t, e) {
      var n = t.selection;
      if (!(n instanceof ef) || n.$anchorCell.pos == n.$headCell.pos) return !1;
      var o = Mf(t),
          r = o.map;
      if (function (t, e) {
        for (var n = t.width, o = t.height, r = t.map, i = e.top * n + e.left, a = i, s = (e.bottom - 1) * n + e.left, l = i + (e.right - e.left - 1), c = e.top; c < e.bottom; c++) {
          if (e.left > 0 && r[a] == r[a - 1] || e.right < n && r[l] == r[l + 1]) return !0;
          a += n, l += n;
        }

        for (var p = e.left; p < e.right; p++) {
          if (e.top > 0 && r[i] == r[i - n] || e.bottom < o && r[s] == r[s + n]) return !0;
          i++, s++;
        }

        return !1;
      }(r, o)) return !1;

      if (e) {
        for (var i, a, s = t.tr, l = {}, c = ha.empty, p = o.top; p < o.bottom; p++) for (var u = o.left; u < o.right; u++) {
          var f = r.map[p * r.width + u],
              d = o.table.nodeAt(f);
          if (!l[f]) if (l[f] = !0, null == i) i = f, a = d;else {
            Df(d) || (c = c.append(d.content));
            var h = s.mapping.map(f + o.tableStart);
            s.delete(h, h + d.nodeSize);
          }
        }

        if (s.setNodeMarkup(i + o.tableStart, null, Zu(tf(a.attrs, a.attrs.colspan, o.right - o.left - a.attrs.colspan), "rowspan", o.bottom - o.top)), c.size) {
          var v = i + 1 + a.content.size,
              m = Df(a) ? i + 1 : v;
          s.replaceWith(m + o.tableStart, v + o.tableStart, c);
        }

        s.setSelection(new ef(s.doc.resolve(i + o.tableStart))), e(s);
      }

      return !0;
    },
    moveCellForward: Gu,
    nextCell: Yu,
    removeColumn: Rf,
    removeRow: Pf,
    rowIsHeader: Lf,
    selectedRect: Mf,
    selectionCell: Ku,
    setCellAttr: function (t, e) {
      return function (n, o) {
        if (!Wu(n)) return !1;
        var r = Ku(n);
        if (r.nodeAfter.attrs[t] === e) return !1;

        if (o) {
          var i = n.tr;
          n.selection instanceof ef ? n.selection.forEachCell(function (n, o) {
            n.attrs[t] !== e && i.setNodeMarkup(o, null, Zu(n.attrs, t, e));
          }) : i.setNodeMarkup(r.pos, null, Zu(r.nodeAfter.attrs, t, e)), o(i);
        }

        return !0;
      };
    },
    splitCell: function (t, e) {
      var n = sf(t.schema);
      return _f(function (t) {
        var e = t.node;
        return n[e.type.spec.tableRole];
      })(t, e);
    },
    splitCellWithType: _f,
    tableEditing: function (t) {
      void 0 === t && (t = {});
      var e = t.allowTableNodeSelection;
      return void 0 === e && (e = !1), new xl({
        key: qu,
        state: {
          init: function () {
            return null;
          },
          apply: function (t, e) {
            var n = t.getMeta(qu);
            if (null != n) return -1 == n ? null : n;
            if (null == e || !t.docChanged) return e;
            var o = t.mapping.mapResult(e),
                r = o.deleted,
                i = o.pos;
            return r ? null : i;
          }
        },
        props: {
          decorations: of,
          handleDOMEvents: {
            mousedown: xf
          },
          createSelectionBetween: function (t) {
            if (null != qu.getState(t.state)) return t.state.selection;
          },
          handleTripleClick: Sf,
          handleKeyDown: mf,
          handlePaste: Cf
        },
        appendTransaction: function (t, n, o) {
          return function (t, e, n) {
            var o,
                r,
                i = (e || t).selection,
                a = (e || t).doc;

            if (i instanceof cl && (r = i.node.type.spec.tableRole)) {
              if ("cell" == r || "header_cell" == r) o = ef.create(a, i.from);else if ("row" == r) {
                var s = a.resolve(i.from + 1);
                o = ef.rowSelection(s, s);
              } else if (!n) {
                var l = Hu.get(i.node),
                    c = i.from + 1,
                    p = c + l.map[l.width * l.height - 1];
                o = ef.create(a, c + 1, p);
              }
            } else i instanceof sl && function (t) {
              var e = t.$from,
                  n = t.$to;
              if (e.pos == n.pos || e.pos < e.pos - 6) return !1;

              for (var o = e.pos, r = n.pos, i = e.depth; i >= 0 && !(e.after(i + 1) < e.end(i)); i--, o++);

              for (var a = n.depth; a >= 0 && !(n.before(a + 1) > n.start(a)); a--, r--);

              return o == r && /row|table/.test(e.node(i).type.spec.tableRole);
            }(i) ? o = sl.create(a, i.from) : i instanceof sl && function (t) {
              for (var e, n, o = t.$from, r = t.$to, i = o.depth; i > 0; i--) {
                var a = o.node(i);

                if ("cell" === a.type.spec.tableRole || "header_cell" === a.type.spec.tableRole) {
                  e = a;
                  break;
                }
              }

              for (var s = r.depth; s > 0; s--) {
                var l = r.node(s);

                if ("cell" === l.type.spec.tableRole || "header_cell" === l.type.spec.tableRole) {
                  n = l;
                  break;
                }
              }

              return e !== n && 0 === r.parentOffset;
            }(i) && (o = sl.create(a, i.$from.start(), i.$from.end()));

            return o && (e || (e = t.tr)).setSelection(o), e;
          }(o, Ef(o, n), e);
        }
      });
    },
    tableEditingKey: qu,
    tableNodes: function (t) {
      var e = t.cellAttributes || {},
          n = {
        colspan: {
          default: 1
        },
        rowspan: {
          default: 1
        },
        colwidth: {
          default: null
        }
      };

      for (var o in e) n[o] = {
        default: e[o].default
      };

      return {
        table: {
          content: "table_row+",
          tableRole: "table",
          isolating: !0,
          group: t.tableGroup,
          parseDOM: [{
            tag: "table"
          }],
          toDOM: function () {
            return ["table", ["tbody", 0]];
          }
        },
        table_row: {
          content: "(table_cell | table_header)*",
          tableRole: "row",
          parseDOM: [{
            tag: "tr"
          }],
          toDOM: function () {
            return ["tr", 0];
          }
        },
        table_cell: {
          content: t.cellContent,
          attrs: n,
          tableRole: "cell",
          isolating: !0,
          parseDOM: [{
            tag: "td",
            getAttrs: function (t) {
              return rf(t, e);
            }
          }],
          toDOM: function (t) {
            return ["td", af(t, e), 0];
          }
        },
        table_header: {
          content: t.cellContent,
          attrs: n,
          tableRole: "header_cell",
          isolating: !0,
          parseDOM: [{
            tag: "th",
            getAttrs: function (t) {
              return rf(t, e);
            }
          }],
          toDOM: function (t) {
            return ["th", af(t, e), 0];
          }
        }
      };
    },
    toggleHeader: Vf,
    toggleHeaderCell: jf,
    toggleHeaderColumn: $f,
    toggleHeaderRow: zf,
    updateColumnsOnResize: Ff
  }),
      Zf = v(function (t, e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    });

    var n = function (t, e) {
      return function (n) {
        Array.isArray(t) || (t = [t]);

        for (var o = 0, r = t.length; o < r; o++) {
          var i = E(t[o])(n.selection);

          if (i) {
            var a = u(i.pos, e)(n);
            if (a !== n) return a;
          }
        }

        return n;
      };
    },
        o = function (t) {
      return function (e) {
        if (l(e.selection)) {
          var n = e.selection,
              o = n.$from,
              r = n.$to;
          if (t instanceof Os.Fragment && o.parent.canReplace(o.index(), o.indexAfter(), t) || o.parent.canReplaceWith(o.index(), o.indexAfter(), t.type)) return p(e.replaceWith(o.pos, r.pos, t).setSelection(new Tl.NodeSelection(e.doc.resolve(o.pos))));
        }

        return e;
      };
    },
        r = function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
      return function (n) {
        var o = Tl.Selection.findFrom(n.doc.resolve(t), e, !0);
        return o ? n.setSelection(o) : n;
      };
    },
        i = function (t) {
      return t.type && t.type.spec.selectable;
    },
        a = function (t, e, n) {
      return function (t) {
        return i(t) && t.type.isLeaf;
      }(t) ? n.setSelection(new Tl.NodeSelection(n.doc.resolve(e))) : r(e)(n);
    },
        s = function (t, e, r) {
      return function (s) {
        var c = "number" == typeof e,
            u = s.selection.$from,
            f = c ? s.doc.resolve(e) : l(s.selection) ? s.doc.resolve(u.pos + 1) : u,
            d = f.parent;
        if (l(s.selection) && r && s !== (s = o(t)(s))) return s;

        if (m(d) && s !== (s = n(d.type, t)(s))) {
          var h = i(t) ? f.before(f.depth) : f.pos;
          return a(t, h, s);
        }

        if (v(f, t)) {
          s.insert(f.pos, t);
          var g = c ? f.pos : i(t) ? s.selection.$anchor.pos - 1 : s.selection.$anchor.pos;
          return p(a(t, g, s));
        }

        for (var y = f.depth; y > 0; y--) {
          var b = f.after(y),
              w = s.doc.resolve(b);
          if (v(w, t)) return s.insert(b, t), p(a(t, b, s));
        }

        return s;
      };
    },
        l = function (t) {
      return t instanceof Tl.NodeSelection;
    },
        c = function (t, e) {
      return Array.isArray(t) && t.indexOf(e.type) > -1 || e.type === t;
    },
        p = function (t) {
      return Object.assign(Object.create(t), t).setTime(Date.now());
    },
        u = function (t, e) {
      return function (n) {
        var o = n.doc.nodeAt(t),
            i = n.doc.resolve(t);

        if (f(i, e)) {
          var a = (n = n.replaceWith(t, t + o.nodeSize, e)).selection.$from.pos - 1;
          return n = r(Math.max(a, 0), -1)(n), n = r(n.selection.$from.start())(n), p(n);
        }

        return n;
      };
    },
        f = function (t, e) {
      var n = t.node(t.depth);
      return n && n.type.validContent(e instanceof Os.Fragment ? e : Os.Fragment.from(e));
    },
        d = function (t) {
      return function (e) {
        var n = e.doc.nodeAt(t);
        return p(e.delete(t, t + n.nodeSize));
      };
    },
        h = function (t) {
      if (t.cached.tableNodeTypes) return t.cached.tableNodeTypes;
      var e = {};
      return Object.keys(t.nodes).forEach(function (n) {
        var o = t.nodes[n];
        o.spec.tableRole && (e[o.spec.tableRole] = o);
      }), t.cached.tableNodeTypes = e, e;
    },
        v = function (t, e) {
      var n = t.index();
      return e instanceof Os.Fragment ? t.parent.canReplace(n, n, e) : e instanceof Os.Node && t.parent.canReplaceWith(n, n, e.type);
    },
        m = function (t) {
      return !t || "paragraph" === t.type.name && 2 === t.nodeSize;
    },
        g = function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
      return e ? t.createChecked(null, e) : t.createAndFill();
    },
        y = function (t) {
      return function (e) {
        for (var n = Yf.TableMap.get(e.$anchorCell.node(-1)), o = e.$anchorCell.start(-1), r = n.cellsInRect(t), i = n.cellsInRect(n.rectBetween(e.$anchorCell.pos - o, e.$headCell.pos - o)), a = 0, s = r.length; a < s; a++) if (-1 === i.indexOf(r[a])) return !1;

        return !0;
      };
    },
        b = function (t) {
      return t[0].map(function (e, n) {
        return t.map(function (t) {
          return t[n];
        });
      });
    },
        w = function (t) {
      for (var e = Yf.TableMap.get(t), n = [], o = 0; o < e.height; o++) {
        for (var r = [], i = {}, a = 0; a < e.width; a++) {
          var s = e.map[o * e.width + a],
              l = t.nodeAt(s),
              c = e.findCell(s);
          i[s] || c.top !== o ? r.push(null) : (i[s] = !0, r.push(l));
        }

        n.push(r);
      }

      return n;
    },
        S = function (t, e) {
      for (var n = [], o = Yf.TableMap.get(t), r = 0; r < o.height; r++) {
        for (var i = t.child(r), a = [], s = 0; s < o.width; s++) if (e[r][s]) {
          var l = o.map[r * o.width + s],
              c = e[r][s],
              p = t.nodeAt(l).type.createChecked(Object.assign({}, c.attrs), c.content, c.marks);
          a.push(p);
        }

        n.push(i.type.createChecked(i.attrs, a, i.marks));
      }

      return t.type.createChecked(t.attrs, n, t.marks);
    },
        C = function (t, e, n, o) {
      var r = e[0] > n[0] ? -1 : 1,
          i = t.splice(e[0], e.length),
          a = i.length % 2 == 0 ? 1 : 0,
          s = void 0;
      return s = -1 === o && 1 === r ? n[0] - 1 : 1 === o && -1 === r ? n[n.length - 1] - a + 1 : -1 === r ? n[0] : n[n.length - 1] - a, t.splice.apply(t, [s, 0].concat(i)), t;
    },
        x = function (t, e, n, o) {
      var r = "Target position is invalid, you can't move the " + o + " " + t + " to " + e + ", the target can't be split. You could use tryToFit option.";

      if (1 === (t > e ? -1 : 1)) {
        if (-1 !== n.slice(0, n.length - 1).indexOf(e)) throw new Error(r);
      } else if (-1 !== n.slice(1).indexOf(e)) throw new Error(r);

      return !0;
    },
        k = function (t) {
      return function (e) {
        var n = e.$from;
        return O(n, t);
      };
    },
        O = function (t, e) {
      for (var n = t.depth; n > 0; n--) {
        var o = t.node(n);
        if (e(o)) return {
          pos: n > 0 ? t.before(n) : 0,
          start: t.start(n),
          depth: n,
          node: o
        };
      }
    },
        A = function (t, e) {
      return function (n) {
        var o = k(t)(n);
        if (o) return N(o.pos, e);
      };
    },
        T = function (t) {
      return function (e) {
        return !!k(t)(e);
      };
    },
        E = function (t) {
      return function (e) {
        return k(function (e) {
          return c(t, e);
        })(e);
      };
    },
        M = function (t) {
      var e = t.$from.nodeBefore,
          n = Tl.Selection.findFrom(t.$from, -1);

      if (n && e) {
        var o = E(e.type)(n);
        return o ? o.pos : n.$from.pos;
      }
    },
        N = function (t, e) {
      var n = e(t),
          o = n.node.childNodes[n.offset];
      return n.node.nodeType === Node.TEXT_NODE ? n.node.parentNode : o && o.nodeType !== Node.TEXT_NODE ? o : n.node;
    },
        R = function (t) {
      var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      if (!t) throw new Error('Invalid "node" parameter');
      var n = [];
      return t.descendants(function (t, o) {
        if (n.push({
          node: t,
          pos: o
        }), !e) return !1;
      }), n;
    },
        L = function (t, e, n) {
      if (!t) throw new Error('Invalid "node" parameter');
      if (!e) throw new Error('Invalid "predicate" parameter');
      return R(t, n).filter(function (t) {
        return e(t.node);
      });
    },
        I = function (t, e, n) {
      return L(t, function (t) {
        return t.type === e;
      }, n);
    };

    var P = function (t) {
      return k(function (t) {
        return t.type.spec.tableRole && "table" === t.type.spec.tableRole;
      })(t);
    },
        D = function (t) {
      return t instanceof Yf.CellSelection;
    },
        _ = function (t) {
      if (D(t)) {
        var e = Yf.TableMap.get(t.$anchorCell.node(-1));
        return y({
          left: 0,
          right: e.width,
          top: 0,
          bottom: e.height
        })(t);
      }

      return !1;
    },
        B = function (t) {
      return function (e) {
        var n = P(e);

        if (n) {
          var o = Yf.TableMap.get(n.node);
          return (Array.isArray(t) ? t : Array.from([t])).reduce(function (t, e) {
            if (e >= 0 && e <= o.width - 1) {
              var r = o.cellsInRect({
                left: e,
                right: e + 1,
                top: 0,
                bottom: o.height
              });
              return t.concat(r.map(function (t) {
                var e = n.node.nodeAt(t),
                    o = t + n.start;
                return {
                  pos: o,
                  start: o + 1,
                  node: e
                };
              }));
            }
          }, []);
        }
      };
    },
        V = function (t) {
      return function (e) {
        var n = P(e);

        if (n) {
          var o = Yf.TableMap.get(n.node);
          return (Array.isArray(t) ? t : Array.from([t])).reduce(function (t, e) {
            if (e >= 0 && e <= o.height - 1) {
              var r = o.cellsInRect({
                left: 0,
                right: o.width,
                top: e,
                bottom: e + 1
              });
              return t.concat(r.map(function (t) {
                var e = n.node.nodeAt(t),
                    o = t + n.start;
                return {
                  pos: o,
                  start: o + 1,
                  node: e
                };
              }));
            }
          }, []);
        }
      };
    },
        z = function (t) {
      return function (e, n) {
        return function (o) {
          var r = P(o.selection),
              i = "row" === t;

          if (r) {
            var a = Yf.TableMap.get(r.node);

            if (e >= 0 && e < (i ? a.height : a.width)) {
              var s = i ? 0 : e,
                  l = i ? e : 0,
                  c = i ? a.width : e + 1,
                  u = i ? e + 1 : a.height;

              if (n) {
                var f = K(o.selection.$from);
                if (!f) return o;
                var d = a.findCell(f.pos - r.start);
                i ? (l = Math.min(l, d.top), u = Math.max(u, d.bottom)) : (s = Math.min(s, d.left), c = Math.max(c, d.right));
              }

              var h = a.cellsInRect({
                left: s,
                top: l,
                right: i ? c : s + 1,
                bottom: i ? l + 1 : u
              }),
                  v = u - l == 1 ? h : a.cellsInRect({
                left: i ? s : c - 1,
                top: i ? u - 1 : l,
                right: c,
                bottom: u
              }),
                  m = r.start + h[0],
                  g = r.start + v[v.length - 1],
                  y = o.doc.resolve(m),
                  b = o.doc.resolve(g);
              return p(o.setSelection(new Yf.CellSelection(b, y)));
            }
          }

          return o;
        };
      };
    },
        $ = z("column"),
        j = z("row"),
        H = function (t) {
      return function (e) {
        var n = P(e.selection);

        if (n) {
          var o = Yf.TableMap.get(n.node);

          if (t >= 0 && t <= o.height) {
            for (var r = n.node, i = h(r.type.schema), a = n.start, l = 0; l < t + 1; l++) a += r.child(l).nodeSize;

            var c = r.child(t),
                p = [],
                u = 0;

            if (c.forEach(function (t) {
              1 === t.attrs.rowspan && (u += t.attrs.colspan, p.push(i[t.type.spec.tableRole].createAndFill(t.attrs, t.marks)));
            }), u < o.width) {
              for (var f = [], d = function (n) {
                var o = G(n, function (e, o) {
                  var r = e.node.attrs.rowspan;
                  return r > 1 && n + r > t;
                })(e);
                f.push.apply(f, function (t) {
                  if (Array.isArray(t)) {
                    for (var e = 0, n = Array(t.length); e < t.length; e++) n[e] = t[e];

                    return n;
                  }

                  return Array.from(t);
                }(o));
              }, v = t; v >= 0; v--) d(v);

              f.length && f.forEach(function (t) {
                e = W(t, {
                  rowspan: t.node.attrs.rowspan + 1
                })(e);
              });
            }

            return s(i.row.create(c.attrs, p), a)(e);
          }
        }

        return e;
      };
    },
        F = function (t) {
      return function (e) {
        var n = P(e.selection);

        if (n) {
          var o = Yf.TableMap.get(n.node);
          if (0 === t && 1 === o.width) return U(e);
          if (t >= 0 && t <= o.width) return Yf.removeColumn(e, {
            map: o,
            tableStart: n.start,
            table: n.node
          }, t), p(e);
        }

        return e;
      };
    },
        q = function (t) {
      return function (e) {
        var n = P(e.selection);

        if (n) {
          var o = Yf.TableMap.get(n.node);
          if (0 === t && 1 === o.height) return U(e);
          if (t >= 0 && t <= o.height) return Yf.removeRow(e, {
            map: o,
            tableStart: n.start,
            table: n.node
          }, t), p(e);
        }

        return e;
      };
    },
        U = function (t) {
      for (var e = t.selection.$from, n = e.depth; n > 0; n--) {
        if ("table" === e.node(n).type.spec.tableRole) return p(t.delete(e.before(n), e.after(n)));
      }

      return t;
    },
        W = function (t, e) {
      return function (n) {
        return t ? (n.setNodeMarkup(t.pos, null, Object.assign({}, t.node.attrs, e)), p(n)) : n;
      };
    },
        K = function (t) {
      return O(t, function (t) {
        return t.type.spec.tableRole && /cell/i.test(t.type.spec.tableRole);
      });
    },
        J = function (t) {
      var e = K(t);

      if (e) {
        var n = function (t) {
          return O(t, function (t) {
            return t.type.spec.tableRole && /table/i.test(t.type.spec.tableRole);
          });
        }(t),
            o = Yf.TableMap.get(n.node),
            r = e.pos - n.start;

        return o.rectBetween(r, r);
      }
    },
        G = function (t, e) {
      return function (n) {
        var o = [],
            r = V(t)(n.selection);
        if (r) for (var i = r.length - 1; i >= 0; i--) e(r[i], n) && o.push(r[i]);
        return o;
      };
    },
        X = function (t) {
      return function (e) {
        for (var n = t, o = t, r = function (t) {
          var r = B(t)(e.selection);
          r && r.forEach(function (e) {
            var r = e.node.attrs.colspan + t - 1;
            r >= n && (n = t), r > o && (o = r);
          });
        }, i = t; i >= 0; i--) r(i);

        var a = function (t) {
          var n = B(t)(e.selection);
          n && n.forEach(function (e) {
            var n = e.node.attrs.colspan + t - 1;
            e.node.attrs.colspan > 1 && n > o && (o = n);
          });
        };

        for (i = t; i <= o; i++) a(i);

        var s = [];

        for (i = n; i <= o; i++) {
          var l = B(i)(e.selection);
          l && l.length && s.push(i);
        }

        n = s[0], o = s[s.length - 1];

        for (var c = B(n)(e.selection), p = V(0)(e.selection), u = e.doc.resolve(c[c.length - 1].pos), f = void 0, d = o; d >= n; d--) {
          var h = B(d)(e.selection);

          if (h && h.length) {
            for (var v = p.length - 1; v >= 0; v--) if (p[v].pos === h[0].pos) {
              f = h[0];
              break;
            }

            if (f) break;
          }
        }

        return {
          $anchor: u,
          $head: e.doc.resolve(f.pos),
          indexes: s
        };
      };
    },
        Y = function (t) {
      return function (e) {
        for (var n = t, o = t, r = function (t) {
          V(t)(e.selection).forEach(function (e) {
            var r = e.node.attrs.rowspan + t - 1;
            r >= n && (n = t), r > o && (o = r);
          });
        }, i = t; i >= 0; i--) r(i);

        var a = function (t) {
          V(t)(e.selection).forEach(function (e) {
            var n = e.node.attrs.rowspan + t - 1;
            e.node.attrs.rowspan > 1 && n > o && (o = n);
          });
        };

        for (i = t; i <= o; i++) a(i);

        var s = [];

        for (i = n; i <= o; i++) {
          var l = V(i)(e.selection);
          l && l.length && s.push(i);
        }

        n = s[0], o = s[s.length - 1];

        for (var c = V(n)(e.selection), p = B(0)(e.selection), u = e.doc.resolve(c[c.length - 1].pos), f = void 0, d = o; d >= n; d--) {
          var h = V(d)(e.selection);

          if (h && h.length) {
            for (var v = p.length - 1; v >= 0; v--) if (p[v].pos === h[0].pos) {
              f = h[0];
              break;
            }

            if (f) break;
          }
        }

        return {
          $anchor: u,
          $head: e.doc.resolve(f.pos),
          indexes: s
        };
      };
    };

    e.isNodeSelection = l, e.canInsert = v, e.convertTableNodeToArrayOfRows = w, e.convertArrayOfRowsToTableNode = S, e.findParentNode = k, e.findParentNodeClosestToPos = O, e.findParentDomRef = A, e.hasParentNode = T, e.findParentNodeOfType = E, e.findParentNodeOfTypeClosestToPos = function (t, e) {
      return O(t, function (t) {
        return c(e, t);
      });
    }, e.hasParentNodeOfType = function (t) {
      return function (e) {
        return T(function (e) {
          return c(t, e);
        })(e);
      };
    }, e.findParentDomRefOfType = function (t, e) {
      return function (n) {
        return A(function (e) {
          return c(t, e);
        }, e)(n);
      };
    }, e.findSelectedNodeOfType = function (t) {
      return function (e) {
        if (l(e)) {
          var n = e.node,
              o = e.$from;
          if (c(t, n)) return {
            node: n,
            pos: o.pos,
            depth: o.depth
          };
        }
      };
    }, e.findPositionOfNodeBefore = M, e.findDomRefAtPos = N, e.flatten = R, e.findChildren = L, e.findTextNodes = function (t, e) {
      return L(t, function (t) {
        return t.isText;
      }, e);
    }, e.findInlineNodes = function (t, e) {
      return L(t, function (t) {
        return t.isInline;
      }, e);
    }, e.findBlockNodes = function (t, e) {
      return L(t, function (t) {
        return t.isBlock;
      }, e);
    }, e.findChildrenByAttr = function (t, e, n) {
      return L(t, function (t) {
        return !!e(t.attrs);
      }, n);
    }, e.findChildrenByType = I, e.findChildrenByMark = function (t, e, n) {
      return L(t, function (t) {
        return e.isInSet(t.marks);
      }, n);
    }, e.contains = function (t, e) {
      return !!I(t, e).length;
    }, e.findTable = P, e.isCellSelection = D, e.getSelectionRect = function (t) {
      if (D(t)) {
        var e = t.$anchorCell.start(-1);
        return Yf.TableMap.get(t.$anchorCell.node(-1)).rectBetween(t.$anchorCell.pos - e, t.$headCell.pos - e);
      }
    }, e.isColumnSelected = function (t) {
      return function (e) {
        if (D(e)) {
          var n = Yf.TableMap.get(e.$anchorCell.node(-1));
          return y({
            left: t,
            right: t + 1,
            top: 0,
            bottom: n.height
          })(e);
        }

        return !1;
      };
    }, e.isRowSelected = function (t) {
      return function (e) {
        if (D(e)) {
          var n = Yf.TableMap.get(e.$anchorCell.node(-1));
          return y({
            left: 0,
            right: n.width,
            top: t,
            bottom: t + 1
          })(e);
        }

        return !1;
      };
    }, e.isTableSelected = _, e.getCellsInColumn = B, e.getCellsInRow = V, e.getCellsInTable = function (t) {
      var e = P(t);

      if (e) {
        var n = Yf.TableMap.get(e.node);
        return n.cellsInRect({
          left: 0,
          right: n.width,
          top: 0,
          bottom: n.height
        }).map(function (t) {
          var n = e.node.nodeAt(t),
              o = t + e.start;
          return {
            pos: o,
            start: o + 1,
            node: n
          };
        });
      }
    }, e.selectColumn = $, e.selectRow = j, e.selectTable = function (t) {
      var e = P(t.selection);

      if (e) {
        var n = Yf.TableMap.get(e.node).map;

        if (n && n.length) {
          var o = e.start + n[0],
              r = e.start + n[n.length - 1],
              i = t.doc.resolve(o),
              a = t.doc.resolve(r);
          return p(t.setSelection(new Yf.CellSelection(a, i)));
        }
      }

      return t;
    }, e.emptyCell = function (t, e) {
      return function (n) {
        if (t) {
          var o = h(e).cell.createAndFill().content;
          if (!t.node.content.eq(o)) return n.replaceWith(t.pos + 1, t.pos + t.node.nodeSize, o), p(n);
        }

        return n;
      };
    }, e.addColumnAt = function (t) {
      return function (e) {
        var n = P(e.selection);

        if (n) {
          var o = Yf.TableMap.get(n.node);
          if (t >= 0 && t <= o.width) return p(Yf.addColumn(e, {
            map: o,
            tableStart: n.start,
            table: n.node
          }, t));
        }

        return e;
      };
    }, e.moveRow = function (t, e, n) {
      return function (o) {
        var r = Object.assign({
          tryToFit: !1,
          direction: 0
        }, n),
            i = P(o.selection);
        if (!i) return o;
        var a = Y(t)(o).indexes,
            s = Y(e)(o).indexes;
        if (a.indexOf(e) > -1) return o;
        !r.tryToFit && s.length > 1 && x(t, e, s, "row");

        var l = function (t, e, n, o) {
          var r = w(t.node);
          return r = C(r, e, n, o), S(t.node, r);
        }(i, a, s, r.direction);

        return p(o).replaceWith(i.pos, i.pos + i.node.nodeSize, l);
      };
    }, e.moveColumn = function (t, e, n) {
      return function (o) {
        var r = Object.assign({
          tryToFit: !1,
          direction: 0
        }, n),
            i = P(o.selection);
        if (!i) return o;
        var a = X(t)(o).indexes,
            s = X(e)(o).indexes;
        if (a.indexOf(e) > -1) return o;
        !r.tryToFit && s.length > 1 && x(t, e, s, "column");

        var l = function (t, e, n, o) {
          var r = b(w(t.node));
          return r = C(r, e, n, o), r = b(r), S(t.node, r);
        }(i, a, s, r.direction);

        return p(o).replaceWith(i.pos, i.pos + i.node.nodeSize, l);
      };
    }, e.addRowAt = function (t, e) {
      return function (n) {
        var o = P(n.selection);

        if (o) {
          var r = Yf.TableMap.get(o.node),
              i = t - 1;
          if (e && i >= 0) return p(H(i)(n));
          if (t >= 0 && t <= r.height) return p(Yf.addRow(n, {
            map: r,
            tableStart: o.start,
            table: o.node
          }, t));
        }

        return n;
      };
    }, e.cloneRowAt = H, e.removeColumnAt = F, e.removeRowAt = q, e.removeTable = U, e.removeSelectedColumns = function (t) {
      var e = t.selection;
      if (_(e)) return U(t);

      if (D(e)) {
        var n = P(e);

        if (n) {
          var o = Yf.TableMap.get(n.node),
              r = o.rectBetween(e.$anchorCell.pos - n.start, e.$headCell.pos - n.start);
          if (0 == r.left && r.right == o.width) return !1;

          for (var i = Object.assign({}, r, {
            map: o,
            table: n.node,
            tableStart: n.start
          }), a = i.right - 1; Yf.removeColumn(t, i, a), a !== i.left; a--) i.table = i.tableStart ? t.doc.nodeAt(i.tableStart - 1) : t.doc, i.map = Yf.TableMap.get(i.table);

          return p(t);
        }
      }

      return t;
    }, e.removeSelectedRows = function (t) {
      var e = t.selection;
      if (_(e)) return U(t);

      if (D(e)) {
        var n = P(e);

        if (n) {
          var o = Yf.TableMap.get(n.node),
              r = o.rectBetween(e.$anchorCell.pos - n.start, e.$headCell.pos - n.start);
          if (0 == r.top && r.bottom == o.height) return !1;

          for (var i = Object.assign({}, r, {
            map: o,
            table: n.node,
            tableStart: n.start
          }), a = i.bottom - 1; Yf.removeRow(t, i, a), a !== i.top; a--) i.table = i.tableStart ? t.doc.nodeAt(i.tableStart - 1) : t.doc, i.map = Yf.TableMap.get(i.table);

          return p(t);
        }
      }

      return t;
    }, e.removeColumnClosestToPos = function (t) {
      return function (e) {
        var n = J(t);
        return n ? F(n.left)(r(t.pos)(e)) : e;
      };
    }, e.removeRowClosestToPos = function (t) {
      return function (e) {
        var n = J(t);
        return n ? q(n.top)(r(t.pos)(e)) : e;
      };
    }, e.forEachCellInColumn = function (t, e, n) {
      return function (o) {
        var r = B(t)(o.selection);

        if (r) {
          for (var i = r.length - 1; i >= 0; i--) o = e(r[i], o);

          if (n) {
            var a = o.doc.resolve(o.mapping.map(r[r.length - 1].pos));
            o.setSelection(Tl.Selection.near(a));
          }

          return p(o);
        }

        return o;
      };
    }, e.forEachCellInRow = function (t, e, n) {
      return function (o) {
        var r = V(t)(o.selection);

        if (r) {
          for (var i = r.length - 1; i >= 0; i--) o = e(r[i], o);

          if (n) {
            var a = o.doc.resolve(o.mapping.map(r[r.length - 1].pos));
            o.setSelection(Tl.Selection.near(a));
          }
        }

        return o;
      };
    }, e.setCellAttrs = W, e.createTable = function (t) {
      for (var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 3, o = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null, i = h(t), a = i.cell, s = i.header_cell, l = i.row, c = i.table, p = [], u = [], f = 0; f < n; f++) p.push(g(a, r)), o && u.push(g(s, r));

      for (var d = [], v = 0; v < e; v++) d.push(l.createChecked(null, o && 0 === v ? u : p));

      return c.createChecked(null, d);
    }, e.findCellClosestToPos = K, e.findCellRectClosestToPos = J, e.getSelectionRangeInColumn = X, e.getSelectionRangeInRow = Y, e.removeParentNodeOfType = function (t) {
      return function (e) {
        var n = E(t)(e.selection);
        return n ? d(n.pos)(e) : e;
      };
    }, e.replaceParentNodeOfType = n, e.removeSelectedNode = function (t) {
      if (l(t.selection)) {
        var e = t.selection.$from.pos,
            n = t.selection.$to.pos;
        return p(t.delete(e, n));
      }

      return t;
    }, e.replaceSelectedNode = o, e.setTextSelection = r, e.safeInsert = s, e.setParentNodeMarkup = function (t, e, n, o) {
      return function (r) {
        var i = E(t)(r.selection);
        return i ? p(r.setNodeMarkup(i.pos, e, Object.assign({}, i.node.attrs, n), o)) : r;
      };
    }, e.selectParentNodeOfType = function (t) {
      return function (e) {
        if (!l(e.selection)) {
          var n = E(t)(e.selection);
          if (n) return p(e.setSelection(Tl.NodeSelection.create(e.doc, n.pos)));
        }

        return e;
      };
    }, e.removeNodeBefore = function (t) {
      var e = M(t.selection);
      return "number" == typeof e ? d(e)(t) : t;
    };
  });
  (Xf = Zf) && Xf.__esModule && Object.prototype.hasOwnProperty.call(Xf, "default") && Xf.default;
  Zf.isNodeSelection, Zf.canInsert, Zf.convertTableNodeToArrayOfRows, Zf.convertArrayOfRowsToTableNode, Zf.findParentNode, Zf.findParentNodeClosestToPos, Zf.findParentDomRef, Zf.hasParentNode, Zf.findParentNodeOfType, Zf.findParentNodeOfTypeClosestToPos, Zf.hasParentNodeOfType, Zf.findParentDomRefOfType, Zf.findSelectedNodeOfType, Zf.findPositionOfNodeBefore, Zf.findDomRefAtPos, Zf.flatten, Zf.findChildren, Zf.findTextNodes, Zf.findInlineNodes, Zf.findBlockNodes, Zf.findChildrenByAttr, Zf.findChildrenByType, Zf.findChildrenByMark, Zf.contains, Zf.findTable, Zf.isCellSelection, Zf.getSelectionRect, Zf.isColumnSelected, Zf.isRowSelected, Zf.isTableSelected, Zf.getCellsInColumn, Zf.getCellsInRow, Zf.getCellsInTable, Zf.selectColumn, Zf.selectRow, Zf.selectTable, Zf.emptyCell, Zf.addColumnAt, Zf.moveRow, Zf.moveColumn, Zf.addRowAt, Zf.cloneRowAt, Zf.removeColumnAt, Zf.removeRowAt, Zf.removeTable, Zf.removeSelectedColumns, Zf.removeSelectedRows, Zf.removeColumnClosestToPos, Zf.removeRowClosestToPos, Zf.forEachCellInColumn, Zf.forEachCellInRow, Zf.setCellAttrs, Zf.createTable, Zf.findCellClosestToPos, Zf.findCellRectClosestToPos, Zf.getSelectionRangeInColumn, Zf.getSelectionRangeInRow, Zf.removeParentNodeOfType, Zf.replaceParentNodeOfType, Zf.removeSelectedNode, Zf.replaceSelectedNode, Zf.setTextSelection, Zf.safeInsert, Zf.setParentNodeMarkup, Zf.selectParentNodeOfType, Zf.removeNodeBefore;

  var Qf = Un({
    render: function () {
      var t = this.$createElement,
          e = this._self._c || t;
      return e("li", {
        staticClass: "tiptap-vuetify-todo-item-view",
        attrs: {
          "data-type": this.node.type.name,
          "data-done": this.node.attrs.done.toString(),
          "data-drag-handle": ""
        }
      }, [e("VCheckbox", {
        staticClass: "mr-2 mt-3 pt-1",
        attrs: {
          "input-value": this.node.attrs.done,
          "hide-details": ""
        },
        on: {
          change: this.onChange
        }
      }), this._v(" "), e("div", {
        ref: "content",
        staticClass: "todo-content",
        attrs: {
          contenteditable: this.view.editable.toString()
        }
      })], 1);
    },
    staticRenderFns: []
  }, void 0, function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return a(e, t), e.prototype.onChange = function () {
      this.updateAttrs({
        done: !this.node.attrs.done
      });
    }, l([En({
      type: Object,
      required: !0
    }), c("design:type", Object)], e.prototype, "node", void 0), l([En({
      type: Object,
      required: !0
    }), c("design:type", Object)], e.prototype, "view", void 0), l([En({
      type: Function,
      required: !0
    }), c("design:type", Function)], e.prototype, "updateAttrs", void 0), e = l([An({
      components: {
        VCheckbox: o.VCheckbox
      }
    })], e);
  }(e), void 0, !1, void 0, void 0, void 0),
      td = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "name", {
      get: function () {
        return "todo_item";
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "defaultOptions", {
      get: function () {
        return {
          nested: !1
        };
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "view", {
      get: function () {
        return Qf;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function () {
        var t = this;
        return {
          attrs: {
            done: {
              default: !1
            }
          },
          draggable: !0,
          content: this.options.nested ? "(paragraph|todo_list)+" : "paragraph+",
          toDOM: function (e) {
            var n = e.attrs.done;
            return ["li", {
              "data-type": t.name,
              "data-done": n.toString()
            }, ["span", {
              class: "todo-checkbox",
              contenteditable: "false"
            }], ["div", {
              class: "todo-content"
            }, 0]];
          },
          parseDOM: [{
            priority: 51,
            tag: '[data-type="' + this.name + '"]',
            getAttrs: function (t) {
              return {
                done: "true" === t.getAttribute("data-done")
              };
            }
          }]
        };
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.keys = function (t) {
      var e,
          n = t.type;
      return {
        Enter: (e = n, function (t, n) {
          var o = t.selection,
              r = o.$from,
              i = o.$to,
              a = o.node;
          if (a && a.isBlock || r.depth < 2 || !r.sameParent(i)) return !1;
          var s = r.node(-1);
          if (s.type != e) return !1;

          if (0 == r.parent.content.size) {
            if (2 == r.depth || r.node(-3).type != e || r.index(-2) != r.node(-2).childCount - 1) return !1;

            if (n) {
              for (var l = ha.empty, c = r.index(-1) > 0, p = r.depth - (c ? 1 : 2); p >= r.depth - 3; p--) l = ha.from(r.node(p).copy(l));

              l = l.append(ha.from(e.createAndFill()));
              var u = t.tr.replace(r.before(c ? null : -1), r.after(-3), new Sa(l, c ? 3 : 2, 2));
              u.setSelection(t.selection.constructor.near(u.doc.resolve(r.pos + (c ? 3 : 2)))), n(u.scrollIntoView());
            }

            return !0;
          }

          var f = i.pos == r.end() ? s.contentMatchAt(r.indexAfter(-1)).defaultType : null,
              d = t.tr.delete(r.pos, i.pos),
              h = f && [{
            type: e
          }, {
            type: f
          }];
          return h || (h = [{
            type: e
          }, null]), !!function (t, e) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                o = arguments.length > 3 ? arguments[3] : void 0,
                r = t.resolve(e),
                i = r.depth - n,
                a = o && o[o.length - 1] || r.parent;
            if (i < 0 || r.parent.type.spec.isolating || !r.parent.canReplace(r.index(), r.parent.childCount) || !a.type.validContent(r.parent.content.cutByIndex(r.index(), r.parent.childCount))) return !1;

            for (var s = r.depth - 1, l = n - 2; s > i; s--, l--) {
              var c = r.node(s),
                  p = r.index(s);
              if (c.type.spec.isolating) return !1;
              var u = c.content.cutByIndex(p, c.childCount),
                  f = o && o[l] || c;
              if (f != c && (u = u.replaceChild(0, f.type.create(f.attrs))), !c.canReplace(p + 1, c.childCount)) return !1;
            }

            var d = r.indexAfter(i),
                h = o && o[0];
            return r.node(i).canReplaceWith(d, d, h ? h.type : r.node(i + 1).type);
          }(d.doc, r.pos, 2, h) && (n && n(d.split(r.pos, 2, h).scrollIntoView()), !0);
        }),
        Tab: this.options.nested ? $l(n) : function () {},
        "Shift-Tab": zl(n)
      };
    }, e;
  }(n.Node),
      ed = function (t) {
    function e(e) {
      return t.call(this, e, td) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        return [];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      nd = "value",
      od = "context",
      rd = "editor",
      id = "imageSourcesOverride",
      ad = "nativeExtensionName";

  var sd,
      ld = Un({
    render: function () {
      var t = this,
          e = t.$createElement,
          n = t._self._c || e;
      return n("v-dialog", {
        attrs: {
          value: t.value,
          "max-width": "500px"
        }
      }, [n("v-card", [n("v-card-title", [n("span", {
        staticClass: "headline"
      }, [t._v("\n        Tables\n      ")]), t._v(" "), n("v-spacer"), t._v(" "), n("v-btn", {
        attrs: {
          icon: ""
        },
        on: {
          click: t.close
        }
      }, [n("v-icon", [t._v(t._s(t.COMMON_ICONS.close[t.$tiptapVuetify.iconsGroup]))])], 1)], 1), t._v(" "), n("v-card-text", [n("v-text-field", {
        attrs: {
          label: "Rows count"
        },
        model: {
          value: t.form.rowsCount,
          callback: function (e) {
            t.$set(t.form, "rowsCount", e);
          },
          expression: "form.rowsCount"
        }
      }), t._v(" "), n("v-text-field", {
        attrs: {
          label: "Cols count"
        },
        model: {
          value: t.form.colsCount,
          callback: function (e) {
            t.$set(t.form, "colsCount", e);
          },
          expression: "form.colsCount"
        }
      }), t._v(" "), n("v-checkbox", {
        attrs: {
          label: "With header row"
        },
        model: {
          value: t.form.withHeaderRow,
          callback: function (e) {
            t.$set(t.form, "withHeaderRow", e);
          },
          expression: "form.withHeaderRow"
        }
      })], 1), t._v(" "), n("v-card-actions", [n("v-btn", {
        attrs: {
          text: ""
        },
        on: {
          click: t.close
        }
      }, [t._v("\n        Close\n      ")]), t._v(" "), n("v-btn", {
        attrs: {
          text: ""
        },
        on: {
          click: t.apply
        }
      }, [t._v("\n        Apply\n      ")])], 1)], 1)], 1);
    },
    staticRenderFns: []
  }, void 0, function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.COMMON_ICONS = Pr, e.form = {
        rowsCount: 2,
        colsCount: 3,
        withHeaderRow: !1
      }, e;
    }

    var n, r, i, s, p;
    return a(e, t), e.prototype.apply = function () {
      this[od].commands.createTable({
        rowsCount: this.form.rowsCount,
        colsCount: this.form.colsCount,
        withHeaderRow: this.form.withHeaderRow
      }), this.close(), this[rd].focus();
    }, e.prototype.close = function () {
      this.$destroy(), this.$el.parentNode.removeChild(this.$el);
    }, n = nd, r = ad, i = od, s = rd, p = id, l([En({
      type: Boolean,
      default: !1
    }), c("design:type", Boolean)], e.prototype, n, void 0), l([En({
      type: String,
      required: !0
    }), c("design:type", String)], e.prototype, r, void 0), l([En({
      type: Object,
      required: !0
    }), c("design:type", Object)], e.prototype, i, void 0), l([En({
      type: Object,
      required: !0
    }), c("design:type", Object)], e.prototype, s, void 0), l([En({
      type: Boolean,
      required: !1
    }), c("design:type", Object)], e.prototype, p, void 0), e = l([An({
      components: {
        VRow: o.VRow,
        VCol: o.VCol,
        VDialog: o.VDialog,
        VCard: o.VCard,
        VCardTitle: o.VCardTitle,
        VCardText: o.VCardText,
        VCardActions: o.VCardActions,
        VBtn: o.VBtn,
        VSpacer: o.VSpacer,
        VIcon: o.VIcon,
        VTextField: o.VTextField,
        VCheckbox: o.VCheckbox
      }
    })], e);
  }(Cn(Lo)), void 0, !1, void 0, void 0, void 0),
      cd = function (t) {
    function n(e) {
      return t.call(this, e, r.Table) || this;
    }

    return a(n, t), Object.defineProperty(n.prototype, "availableActions", {
      get: function () {
        var t;
        return [{
          render: new Kn({
            tooltip: "TODO",
            icons: (t = {}, t.md = new Bn("table"), t.fa = new Bn("fas fa-table"), t.mdi = new Bn("mdi-table"), t.mdiSvg = new Bn("M8.5,13.5L11,16.5L14.5,12L19,18H5M21,19V5C21,3.89 20.1,3 19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19Z"), t),
            nativeExtensionName: "table",
            onClick: function (t) {
              var n = t.context,
                  o = t.editor;
              return p(this, void 0, void 0, function () {
                var t, r;
                return u(this, function (i) {
                  return t = e.extend(ld), (r = new t({
                    vuetify: e.prototype.tiptapVuetifyPlugin.vuetify,
                    propsData: {
                      value: !0,
                      nativeExtensionName: "table",
                      context: n,
                      editor: o
                    }
                  })).$mount(), document.querySelector("body").appendChild(r.$el), [2];
                });
              });
            }
          })
        }];
      },
      enumerable: !0,
      configurable: !0
    }), n;
  }(zr),
      pd = function (t) {
    function e(e) {
      return t.call(this, e, r.TableCell) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        return [];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      ud = function (t) {
    function e(e) {
      return t.call(this, e, r.TableHeader) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        return [];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      fd = function (t) {
    function e(e) {
      return t.call(this, e, r.TableRow) || this;
    }

    return a(e, t), Object.defineProperty(e.prototype, "availableActions", {
      get: function () {
        return [];
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(zr),
      dd = new (function () {
    function t() {
      this.installed = !1;
    }

    return Object.defineProperty(t.prototype, "vuetifyLang", {
      get: function () {
        return this.vuetify.framework.lang.current;
      },
      enumerable: !0,
      configurable: !0
    }), t.prototype.install = function (t, e) {
      if (e && e.vuetify) {
        var n = e.vuetify,
            o = e.iconsGroup,
            r = void 0 === o ? Ir : o;
        t.prototype.tiptapVuetifyPlugin = dd, t.prototype.$tiptapVuetify = {
          iconsGroup: r
        }, this.vuetify = n, this.installed = !0;
      } else Fn.error('Please, specify in options the Vuetify Object ("vuetify" property)');
    }, t;
  }())();

  sd = null, "undefined" != typeof window ? sd = window : "undefined" != typeof global && (sd = global), sd && sd.Vue && (sd.Vue.use(dd, s({
    vuetify: sd.vuetify
  }, sd.tiptapVuetifyPluginOptions)), sd.Vue.component("tiptap-vuetify", Lr)), t.Blockquote = Yr, t.Bold = jr, t.BulletList = Jr, t.Code = Ur, t.CodeBlock = Wr, t.HardBreak = Zr, t.Heading = $r, t.History = ti, t.HorizontalRule = Qr, t.Image = zi, t.Italic = Hr, t.Link = oi, t.ListItem = Xr, t.OrderedList = Gr, t.Paragraph = Kr, t.Strike = Fr, t.Table = cd, t.TableCell = pd, t.TableHeader = ud, t.TableRow = fd, t.TiptapVuetify = Lr, t.TiptapVuetifyPlugin = dd, t.TodoItem = ed, t.TodoList = $i, t.Underline = qr, Object.defineProperty(t, "__esModule", {
    value: !0
  });
});

/***/ }),
/* 432 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 433 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 434 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 435 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 436 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 437 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 438 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 439 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 440 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 441 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 442 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 443 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 444 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 445 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 446 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 447 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 448 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 449 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 450 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 451 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 452 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 453 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 454 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 455 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 456 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 457 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 458 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 459 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 460 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 461 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 462 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 463 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 464 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 465 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 466 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 467 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 468 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 469 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 470 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 471 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 472 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 473 */,
/* 474 */,
/* 475 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_1_node_modules_sass_loader_dist_cjs_js_ref_7_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_formulario_blog_vue_vue_type_style_index_0_id_52ab93fa_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(426);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_1_node_modules_sass_loader_dist_cjs_js_ref_7_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_formulario_blog_vue_vue_type_style_index_0_id_52ab93fa_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_1_node_modules_sass_loader_dist_cjs_js_ref_7_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_formulario_blog_vue_vue_type_style_index_0_id_52ab93fa_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_1_node_modules_sass_loader_dist_cjs_js_ref_7_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_formulario_blog_vue_vue_type_style_index_0_id_52ab93fa_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_1_node_modules_sass_loader_dist_cjs_js_ref_7_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_formulario_blog_vue_vue_type_style_index_0_id_52ab93fa_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


/***/ }),
/* 476 */,
/* 477 */,
/* 478 */,
/* 479 */,
/* 480 */,
/* 481 */,
/* 482 */,
/* 483 */,
/* 484 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/blogs/formulario-blog.vue?vue&type=template&id=52ab93fa&scoped=true&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"container"},[_c('client-only',[_c('v-tabs',{staticClass:"mt-3",attrs:{"fixed-tabs":"","optional":"","color":"#683bce"},model:{value:(_vm.tabs),callback:function ($$v) {_vm.tabs=$$v},expression:"tabs"}},[_c('v-tabs-slider'),_vm._v(" "),_c('v-tab',{attrs:{"href":"#mobile-tabs-5-1"}},[_c('v-icon',{attrs:{"left":""}},[_vm._v("\n          mdi-book-open-variant\n        ")]),_vm._v("\n        Datos del blog\n      ")],1),_vm._v(" "),(_vm.accion !== 'leer')?_c('v-tab',{attrs:{"href":"#mobile-tabs-5-2"}},[_c('v-icon',{attrs:{"left":""}},[_vm._v("\n          mdi-book-open-page-variant\n        ")]),_vm._v("\n        Contenido del blog\n      ")],1):_vm._e(),_vm._v(" "),(_vm.accion !== 'leer')?_c('v-tab',{attrs:{"href":"#mobile-tabs-5-3"}},[_c('v-icon',{attrs:{"left":""}},[_vm._v("\n          mdi-book-open-page-variant\n        ")]),_vm._v("\n        Contenido del blog (Markdown)\n      ")],1):_vm._e(),_vm._v(" "),(_vm.accion === 'leer')?_c('v-tab',{attrs:{"href":"#mobile-tabs-5-4"}},[_c('v-icon',{attrs:{"left":""}},[_vm._v("\n          mdi-book-open-page-variant\n        ")]),_vm._v("\n        Contenido del blog\n      ")],1):_vm._e()],1),_vm._v(" "),_c('form',[_c('v-tabs-items',{model:{value:(_vm.tabs),callback:function ($$v) {_vm.tabs=$$v},expression:"tabs"}},[(_vm.tabs === 'mobile-tabs-5-1')?_c('v-tab-item',{staticClass:"pb-15",attrs:{"value":'mobile-tabs-5-1'}},[_c('v-card',{staticClass:"mt-10",attrs:{"flat":""}},[_c('h2',[_vm._v("Datos blogs")]),_vm._v(" "),_c('v-divider'),_vm._v(" "),_c('v-row',{staticClass:"mt-2"},[_c('v-col',{attrs:{"cols":"12","sm":"6"}},[(_vm.accion === 'leer')?_c('v-text-field',{staticClass:"mt-1",attrs:{"label":"Id del blog","readonly":_vm.accion === 'leer'},model:{value:(_vm.datosBlogAux.uid),callback:function ($$v) {_vm.$set(_vm.datosBlogAux, "uid", $$v)},expression:"datosBlogAux.uid"}}):_vm._e(),_vm._v(" "),_c('v-text-field',{class:_vm.accion === 'leer' ? 'mt-7' : 'mt-1',attrs:{"error-messages":_vm.referenciaErr,"counter":100,"label":"Referencia","required":"","readonly":_vm.accion === 'leer'},on:{"input":function($event){return _vm.$v.datosBlogAux.referencia.$touch()},"blur":function($event){return _vm.$v.datosBlogAux.referencia.$touch()}},model:{value:(_vm.datosBlogAux.referencia),callback:function ($$v) {_vm.$set(_vm.datosBlogAux, "referencia", $$v)},expression:"datosBlogAux.referencia"}}),_vm._v(" "),_c('v-text-field',{staticClass:"mt-7",attrs:{"error-messages":_vm.tituloErr,"counter":100,"label":"Titulo","required":"","readonly":_vm.accion === 'leer'},on:{"input":function($event){return _vm.$v.datosBlogAux.titulo.$touch()},"blur":function($event){return _vm.$v.datosBlogAux.titulo.$touch()}},model:{value:(_vm.datosBlogAux.titulo),callback:function ($$v) {_vm.$set(_vm.datosBlogAux, "titulo", $$v)},expression:"datosBlogAux.titulo"}}),_vm._v(" "),_c('v-textarea',{staticClass:"mt-7",attrs:{"error-messages":_vm.descripcionErr,"counter":500,"label":"Descripción","required":"","readonly":_vm.accion === 'leer'},on:{"input":function($event){return _vm.$v.datosBlogAux.descripcion.$touch()},"blur":function($event){return _vm.$v.datosBlogAux.descripcion.$touch()}},model:{value:(_vm.datosBlogAux.descripcion),callback:function ($$v) {_vm.$set(_vm.datosBlogAux, "descripcion", $$v)},expression:"datosBlogAux.descripcion"}}),_vm._v(" "),(_vm.accion === 'leer')?_c('v-text-field',{staticClass:"mt-7",attrs:{"label":"Id del publicador","readonly":_vm.accion === 'leer'},model:{value:(_vm.datosBlogAux.publicador),callback:function ($$v) {_vm.$set(_vm.datosBlogAux, "publicador", $$v)},expression:"datosBlogAux.publicador"}}):_vm._e(),_vm._v(" "),(_vm.accion === 'leer')?_c('v-text-field',{staticClass:"mt-7",attrs:{"label":"Cantidad de me gusta","readonly":_vm.accion === 'leer'},model:{value:(_vm.datosBlogAux.cantidadMeGusta),callback:function ($$v) {_vm.$set(_vm.datosBlogAux, "cantidadMeGusta", $$v)},expression:"datosBlogAux.cantidadMeGusta"}}):_vm._e()],1),_vm._v(" "),_c('v-col',{attrs:{"cols":"12","sm":"6"}},[_c('v-select',{staticClass:"mt-1",attrs:{"hint":_vm.seccionSelected.uid ? ("Sección: " + (_vm.seccionSelected.nombre)) : ("Se seleccionó: " + (_vm.seccionSelected.nombre)),"items":_vm.listaSecciones,"item-text":"nombre","item-value":"uid","label":"Seleccionar una sección","persistent-hint":"","return-object":"","single-line":"","readonly":_vm.accion === 'leer'},model:{value:(_vm.seccionSelected),callback:function ($$v) {_vm.seccionSelected=$$v},expression:"seccionSelected"}}),_vm._v(" "),_c('v-select',{staticClass:"mt-7",attrs:{"hint":("" + (_vm.categoriaSelected.nombre ? ("Categoría: " + (_vm.categoriaSelected.nombre)) : 'No se seleccionó nada')),"items":_vm.listaCategorias,"disabled":!_vm.listaCategorias.length,"item-text":"nombre","item-value":"uid","label":"Seleccionar una categoria","persistent-hint":"","return-object":"","single-line":"","readonly":_vm.accion === 'leer'},model:{value:(_vm.categoriaSelected),callback:function ($$v) {_vm.categoriaSelected=$$v},expression:"categoriaSelected"}}),_vm._v(" "),_c('v-select',{staticClass:"mt-7",attrs:{"hint":("" + (_vm.subCategoriasSelected.length ? ("Se seleccionó " + (_vm.subCategoriasSelected.length) + " sub-categorias.") : 'No se seleccionó nada.')),"items":_vm.listaSubCategorias,"disabled":!_vm.listaSubCategorias.length,"item-text":"nombre","item-value":"uid","label":"Seleccionar una sub-categoria","persistent-hint":"","return-object":"","single-line":"","readonly":_vm.accion === 'leer',"attach":"","chips":"","multiple":""},model:{value:(_vm.subCategoriasSelected),callback:function ($$v) {_vm.subCategoriasSelected=$$v},expression:"subCategoriasSelected"}}),_vm._v(" "),(_vm.accion === 'leer')?_c('v-checkbox',{staticClass:"mt-7",attrs:{"value":"","readonly":_vm.accion === 'leer',"color":"#683bce","label":"Estado de habilitación"},model:{value:(_vm.datosBlogAux.habilitado),callback:function ($$v) {_vm.$set(_vm.datosBlogAux, "habilitado", $$v)},expression:"datosBlogAux.habilitado"}}):_vm._e(),_vm._v(" "),_c('v-checkbox',{staticClass:"mt-7",attrs:{"value":"","readonly":_vm.accion === 'leer',"color":"#683bce","label":"Estado publicado (puedes cambiarlo luego)"},model:{value:(_vm.datosBlogAux.publicado),callback:function ($$v) {_vm.$set(_vm.datosBlogAux, "publicado", $$v)},expression:"datosBlogAux.publicado"}}),_vm._v(" "),(_vm.accion === 'leer')?_c('v-checkbox',{staticClass:"mt-7",attrs:{"value":"","readonly":_vm.accion === 'leer',"color":"#683bce","label":"Estado de revisión"},model:{value:(_vm.datosBlogAux.revision),callback:function ($$v) {_vm.$set(_vm.datosBlogAux, "revision", $$v)},expression:"datosBlogAux.revision"}}):_vm._e(),_vm._v(" "),(_vm.accion === 'leer')?_c('div',{staticClass:"mt-5"},[_vm._v("\n                  Fecha de creación:\n                  "),_c('v-date-picker',{attrs:{"no-title":"","full-width":"","readonly":_vm.accion === 'leer'},model:{value:(_vm.datosBlogAux.fechaCreacion),callback:function ($$v) {_vm.$set(_vm.datosBlogAux, "fechaCreacion", $$v)},expression:"datosBlogAux.fechaCreacion"}})],1):_vm._e(),_vm._v(" "),(_vm.accion === 'leer')?_c('div',{staticClass:"mt-5"},[_vm._v("\n                  Fecha de actualización:\n                  "),_c('v-date-picker',{attrs:{"no-title":"","full-width":"","readonly":_vm.accion === 'leer'},model:{value:(_vm.datosBlogAux.fechaActualizacion),callback:function ($$v) {_vm.$set(_vm.datosBlogAux, "fechaActualizacion", $$v)},expression:"datosBlogAux.fechaActualizacion"}})],1):_vm._e()],1)],1)],1)],1):_vm._e(),_vm._v(" "),(_vm.tabs === 'mobile-tabs-5-2' && _vm.accion !== 'leer')?_c('v-tab-item',{attrs:{"value":'mobile-tabs-5-2'}},[_c('v-card',{attrs:{"flat":""}},[_c('section',[_c('div',{staticClass:"mt-10 mb-5"},[_c('h2',[_vm._v(" Editor del contenido del blog ")]),_vm._v(" "),_c('v-divider'),_vm._v(" "),_c('p',{staticClass:"mt-5"},[_vm._v("\n                  Cantidad de carácteres: "),_c('strong',[_vm._v(_vm._s(_vm.cantidadCaracteres))])]),_vm._v(" "),_c('editor',{staticClass:"mb-5",model:{value:(_vm.contenidoHtml),callback:function ($$v) {_vm.contenidoHtml=$$v},expression:"contenidoHtml"}}),_vm._v(" "),(_vm.errorContenidoBlog)?_c('p',{staticStyle:{"color":"red"}},[_vm._v("\n                  "+_vm._s(_vm.errorContenidoBlog)+"\n                ")]):_vm._e()],1),_vm._v(" "),_c('div',{staticClass:"mt-15 mb-5"},[_c('h2',[_vm._v(" Vista del contenido del blog ")]),_vm._v(" "),_c('v-divider'),_vm._v(" "),_c('div',{staticClass:"pl-5 pt-5 pr-5 pb-5"},[_c('visualizador-blog',{attrs:{"contenidoBlog":_vm.contenidoBlogHTML}})],1)],1),_vm._v(" "),_c('v-divider',{staticClass:"mt-10 mb-5"})],1)])],1):_vm._e(),_vm._v(" "),(_vm.tabs === 'mobile-tabs-5-3' && _vm.accion !== 'leer')?_c('v-tab-item',{attrs:{"value":'mobile-tabs-5-3'}},[_c('v-card',{attrs:{"flat":""}},[_c('section',[_c('div',{staticClass:"mt-10 mb-5"},[_c('h2',[_vm._v(" Editor del contenido del blog ")]),_vm._v(" "),_c('v-divider'),_vm._v(" "),_c('p',{staticClass:"mt-5"},[_vm._v("\n                  Cantidad de carácteres: "),_c('strong',[_vm._v(_vm._s(_vm.cantidadCaracteres))])]),_vm._v(" "),_c('v-textarea',{attrs:{"name":"input-7-1","label":"¡Escriba un blog en Markdown!"},model:{value:(_vm.contenidoMarkdown),callback:function ($$v) {_vm.contenidoMarkdown=$$v},expression:"contenidoMarkdown"}}),_vm._v(" "),(_vm.errorContenidoBlog)?_c('p',{staticStyle:{"color":"red"}},[_vm._v("\n                  "+_vm._s(_vm.errorContenidoBlog)+"\n                ")]):_vm._e()],1),_vm._v(" "),_c('div',{staticClass:"mt-15 mb-5"},[_c('h2',[_vm._v(" Vista del contenido del blog ")]),_vm._v(" "),_c('v-divider'),_vm._v(" "),_c('div',{staticClass:"pl-5 pt-5 pr-5 pb-5"},[_c('visualizador-blog',{attrs:{"contenidoBlog":_vm.contenidoBlogHTML}})],1)],1),_vm._v(" "),_c('v-divider',{staticClass:"mt-10 mb-5"})],1)])],1):_vm._e(),_vm._v(" "),(_vm.tabs === 'mobile-tabs-5-4' && _vm.accion === 'leer')?_c('v-tab-item',{attrs:{"value":'mobile-tabs-5-4'}},[_c('v-card',{attrs:{"flat":""}},[_c('section',[_c('div',{staticClass:"mt-15 mb-5"},[_c('h2',[_vm._v(" Vista del contenido del blog ")]),_vm._v(" "),_c('v-divider'),_vm._v(" "),_c('div',{staticClass:"pl-5 pt-5 pr-5 pb-5"},[_c('visualizador-blog',{attrs:{"contenidoBlog":_vm.contenidoBlogHTML}})],1)],1)])])],1):_vm._e()],1),_vm._v(" "),(_vm.accion !== 'leer')?_c('div',{staticClass:"text-center contenedor_botonesDeAcciones mt-10"},[_c('div',{staticClass:"botonesDeAcciones"},[_c('v-btn',{staticClass:"mb-5",attrs:{"block":"","outlined":"","color":"#683bce","disabled":_vm.$v.$anyError},on:{"click":_vm.enviarDatos}},[_vm._v("\n            "+_vm._s(_vm.accion === 'crear' ? 'Crear blog' : 'Actualizar blog')+"\n          ")]),_vm._v(" "),_c('v-btn',{staticClass:"mt-0",attrs:{"block":"","outlined":"","color":"#ff1d89"},on:{"click":_vm.reiniciar}},[_vm._v("\n            Reiniciar\n          ")])],1)]):_vm._e()],1)],1)],1)}
var staticRenderFns = []


// CONCATENATED MODULE: ./components/blogs/formulario-blog.vue?vue&type=template&id=52ab93fa&scoped=true&

// EXTERNAL MODULE: external "vuelidate"
var external_vuelidate_ = __webpack_require__(236);

// EXTERNAL MODULE: external "vuelidate/lib/validators"
var validators_ = __webpack_require__(237);

// EXTERNAL MODULE: ./components/blogs/Visualizador.vue + 4 modules
var Visualizador = __webpack_require__(429);

// EXTERNAL MODULE: ./components/Editor.vue + 4 modules
var Editor = __webpack_require__(408);

// EXTERNAL MODULE: ./helpers/informacionSecciones.js
var informacionSecciones = __webpack_require__(276);

// EXTERNAL MODULE: external "showdown"
var external_showdown_ = __webpack_require__(239);
var external_showdown_default = /*#__PURE__*/__webpack_require__.n(external_showdown_);

// EXTERNAL MODULE: external "turndown"
var external_turndown_ = __webpack_require__(248);
var external_turndown_default = /*#__PURE__*/__webpack_require__.n(external_turndown_);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/blogs/formulario-blog.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//







/* harmony default export */ var formulario_blogvue_type_script_lang_js_ = ({
  components: {
    'editor': Editor["default"],
    'visualizador-blog': Visualizador["default"]
  },
  mixins: [external_vuelidate_["validationMixin"]],
  validations: {
    datosBlogAux: {
      referencia: {
        required: validators_["required"],
        maxLength: Object(validators_["maxLength"])(100)
      },
      titulo: {
        required: validators_["required"],
        maxLength: Object(validators_["maxLength"])(100)
      },
      descripcion: {
        required: validators_["required"],
        maxLength: Object(validators_["maxLength"])(500)
      },
      seccion: {
        required: validators_["required"]
      },
      categoria: {
        required: validators_["required"]
      },
      subCategorias: {
        required: validators_["required"],
        minLength: Object(validators_["minLength"])(1),
        maxLength: Object(validators_["maxLength"])(3),
        $each: {
          minLength: Object(validators_["minLength"])(0),
          maxLength: Object(validators_["maxLength"])(20)
        }
      },
      publicado: {}
    }
  },
  props: {
    accion: String,
    datosBlog: Object,
    contenidoBlog: String
  },

  data() {
    return {
      datosBlogAux: {
        referencia: '',
        // requerido
        titulo: '',
        // requerido
        descripcion: '',
        // requerido
        publicador: '',
        // requerido
        seccion: '',
        // requerido
        categoria: '',
        // requerido
        subCategorias: [],
        // requerido
        publicado: true // opcional

      },
      contenidoBlogHTML: '',
      contenidoBlogHTML_Aux: '',
      contenidoBlogMD: '',
      tabs: 'mobile-tabs-5-1',
      informacionSecciones: informacionSecciones["a" /* default */],
      listaSecciones: [],
      listaCategorias: [],
      listaSubCategorias: [],
      seccionSelected: {
        uid: '',
        nombre: 'Blog normal'
      },
      categoriaSelected: {
        uid: '',
        nombre: ''
      },
      subCategoriasSelected: [],
      cantidadCaracteres: 0,
      errorContenidoBlog: 'La longitud mínima para un blog es 50.'
    };
  },

  computed: {
    referenciaErr() {
      const errors = [];
      if (!this.$v.datosBlogAux.referencia.$dirty) return errors;
      !this.$v.datosBlogAux.referencia.maxLength && errors.push('La referencia es muy larga.');
      !this.$v.datosBlogAux.referencia.required && errors.push('La referencia es requerida.');
      return errors;
    },

    tituloErr() {
      const errors = [];
      if (!this.$v.datosBlogAux.titulo.$dirty) return errors;
      !this.$v.datosBlogAux.titulo.maxLength && errors.push('El titulo es muy largo.');
      !this.$v.datosBlogAux.titulo.required && errors.push('El titulo es requerido.');
      return errors;
    },

    descripcionErr() {
      const errors = [];
      if (!this.$v.datosBlogAux.descripcion.$dirty) return errors;
      !this.$v.datosBlogAux.descripcion.maxLength && errors.push('La descripción ds muy larga');
      !this.$v.datosBlogAux.descripcion.required && errors.push('La descripción es requerida.');
      return errors;
    },

    // seccionErr () {
    //   const errors = []
    //   if (!this.$v.datosBlogAux.seccion.$dirty) return errors
    //   !this.$v.datosBlogAux.seccion.required && errors.push('La sección es requerida.')
    //   return errors
    // },
    // categoriaErr () {
    //   const errors = []
    //   if (!this.$v.datosBlogAux.categoria.$dirty) return errors
    //   !this.$v.datosBlogAux.categoria.required && errors.push('La categoría es requerida.')
    //   return errors
    // },
    // subCategoriaErr () {
    //   const errors = []
    //   if (!this.$v.datosBlogAux.subCategorias.$dirty) return errors
    //   !this.$v.datosBlogAux.subCategorias.required && errors.push('Las sub-categorias son requeridas.')
    //   !this.$v.datosBlogAux.subCategorias.minLength && errors.push('Las sub-categorias son requeridas.')
    //   !this.$v.datosBlogAux.subCategorias.maxLength && errors.push('Un blog solo puede tener 3 sub-categorias.')
    //   return errors
    // },
    contenidoMarkdown: {
      // getter
      get: function () {
        return this.contenidoBlogMD;
      },
      // setter
      set: function (md) {
        this.contenidoBlogHTML = this.mdToHtml(md);
        this.contenidoBlogHTML_Aux = this.mdToHtml(md); // Sirve para que el HTML se mantenga actualizado desde el MD

        this.contenidoBlogMD = md;
      }
    },
    contenidoHtml: {
      // getter
      get: function () {
        return this.contenidoBlogHTML_Aux;
      },
      // setter
      set: function (html) {
        this.contenidoBlogHTML = html;
        this.contenidoBlogMD = this.htmlToMd(html);
      }
    }
  },
  methods: {
    htmlToMd(HTML) {
      var options = {
        emDelimiter: '*',
        linkReferenceStyle: 'full',
        linkStyle: 'referenced'
      };
      let turndownService = new external_turndown_default.a();
      let markdown = turndownService.turndown(HTML);
      return markdown;
    },

    mdToHtml(MD) {
      let converter = new external_showdown_default.a.Converter();
      let html = converter.makeHtml(MD);
      return html;
    },

    filtroDeDatosActualizados() {
      let datosBlog = {};
      let contenidoBlog = {};

      if (this.datosBlogAux.referencia !== this.datosBlog.referencia) {
        datosBlog.referencia = this.datosBlogAux.referencia;
      }

      if (this.datosBlogAux.titulo !== this.datosBlog.titulo) {
        datosBlog.titulo = this.datosBlogAux.titulo;
      }

      if (this.datosBlogAux.descripcion !== this.datosBlog.descripcion) {
        datosBlog.descripcion = this.datosBlogAux.descripcion;
      }

      if (this.datosBlogAux.seccion !== this.datosBlog.seccion) {
        datosBlog.seccion = this.datosBlogAux.seccion;
      }

      if (this.datosBlogAux.categoria !== this.datosBlog.categoria) {
        datosBlog.categoria = this.datosBlogAux.categoria;
      }

      if (this.datosBlogAux.subCategorias.length !== this.datosBlog.subCategorias.length) {
        datosBlog.subCategorias = this.datosBlogAux.subCategorias;
      } else {
        let cambio = false;

        for (let i = 0; i < this.datosBlogAux.subCategorias.length; i++) {
          const newElement = this.datosBlogAux.subCategorias[i];
          cambio = !this.datosBlog.subCategorias.includes(newElement);

          if (cambio) {
            datosBlog.subCategorias = this.datosBlogAux.subCategorias;
            break;
          }
        }
      }

      if (this.datosBlogAux.publicado !== this.datosBlog.publicado) {
        datosBlog.publicado = this.datosBlogAux.publicado;
      }

      if (this.contenidoBlogHTML !== this.contenidoBlog) {
        contenidoBlog = {
          html: this.contenidoBlogHTML,
          md: this.contenidoBlogMD
        };
      }

      return {
        datosBlog,
        contenidoBlog
      };
    },

    enviarDatos() {
      if (this.accion === 'actualizar') {
        const actualizados = {
          uidBlog: this.datosBlog.uid,
          ...this.filtroDeDatosActualizados()
        };
        this.$emit('actualizarBlog', actualizados);
        return;
      }

      this.$emit('crearBlog', {
        datosBlog: this.datosBlogAux,
        contenidoBlog: {
          html: this.contenidoBlogHTML,
          md: this.contenidoBlogMD
        }
      });
    },

    async reiniciar() {
      this.datosBlogAux = {
        referencia: '',
        // requerido
        titulo: '',
        // requerido
        descripcion: '',
        // requerido
        publicador: this.$store.state.modules.usuarios.uid,
        // requerido
        seccion: '',
        // requerido
        categoria: '',
        // requerido
        subCategorias: [],
        // requerido
        publicado: true // opcional

      };
      this.contenidoBlogHTML = '';
      this.contenidoBlogHTML_Aux = '';
      this.contenidoBlogMD = '';
      this.listaSecciones = [];
      this.listaCategorias = [];
      this.listaSubCategorias = [];
      this.seccionSelected = {
        uid: '',
        nombre: 'Blog normal'
      };
      this.categoriaSelected = {
        uid: '',
        nombre: ''
      };
      this.subCategoriasSelected = [];
      this.cantidadCaracteres = 0;
      this.errorContenidoBlog = 'La longitud mínima para un blog es 50.';
      await this.$nextTick();
      this.setListaSecciones();

      if (this.accion === 'actualizar' || this.accion === 'leer') {
        this.datosBlogAux = JSON.parse(JSON.stringify(this.datosBlog));
        this.contenidoBlogHTML = this.contenidoBlog;
        this.contenidoBlogHTML_Aux = this.contenidoBlog;
        this.contenidoBlogMD = this.htmlToMd(this.contenidoBlog);

        if (this.accion === 'leer') {
          let fechaC = new Date(this.datosBlogAux.fechaCreacion.seconds * 1000);
          let fechaA = new Date(this.datosBlogAux.fechaActualizacion.seconds * 1000);
          this.datosBlogAux.fechaCreacion = new Date(fechaC.getTime() - new Date().getTimezoneOffset() * 60000).toISOString().substr(0, 10);
          this.datosBlogAux.fechaActualizacion = new Date(fechaA.getTime() - new Date().getTimezoneOffset() * 60000).toISOString().substr(0, 10);
        }

        if (this.datosBlog.seccion) {
          this.seccionSelected = {
            uid: this.informacionSecciones[this.datosBlog.seccion].uid,
            nombre: this.informacionSecciones[this.datosBlog.seccion].nombre
          };
          await this.$nextTick();
          this.categoriaSelected = {
            uid: this.informacionSecciones[this.datosBlog.seccion].categorias[this.datosBlog.categoria].uid,
            nombre: this.informacionSecciones[this.datosBlog.seccion].categorias[this.datosBlog.categoria].nombre
          };
          await this.$nextTick();

          for (let i = 0; i < this.datosBlog.subCategorias.length; i++) {
            const element = this.datosBlog.subCategorias[i];
            this.subCategoriasSelected.push({
              uid: this.informacionSecciones[this.datosBlog.seccion].categorias[this.datosBlog.categoria].subCategorias[element].uid,
              nombre: this.informacionSecciones[this.datosBlog.seccion].categorias[this.datosBlog.categoria].subCategorias[element].nombre
            });
          }
        }

        this.cantidadCaracteres = this.cantidadCaracteresHtml(this.contenidoBlog);
        this.errorContenidoBlog = '';
      }
    },

    setListaSecciones() {
      let arr = Object.keys(this.informacionSecciones);
      this.listaSecciones.push({
        uid: '',
        nombre: 'Blog normal'
      });

      for (let i = 0; i < arr.length; i++) {
        const element = arr[i];
        this.listaSecciones.push({
          uid: this.informacionSecciones[element].uid,
          nombre: this.informacionSecciones[element].nombre
        });
      }
    },

    setListaCategorias(idSeccion) {
      let arr = Object.keys(this.informacionSecciones[idSeccion].categorias);

      for (let i = 0; i < arr.length; i++) {
        const element = arr[i];
        this.listaCategorias.push({
          uid: this.informacionSecciones[idSeccion].categorias[element].uid,
          nombre: this.informacionSecciones[idSeccion].categorias[element].nombre
        });
      }
    },

    setListaSubCategorias(idSeccion, idCategoria) {
      let arr = Object.keys(this.informacionSecciones[idSeccion].categorias[idCategoria].subCategorias);

      for (let i = 0; i < arr.length; i++) {
        const element = arr[i];
        this.listaSubCategorias.push({
          uid: this.informacionSecciones[idSeccion].categorias[idCategoria].subCategorias[element].uid,
          nombre: this.informacionSecciones[idSeccion].categorias[idCategoria].subCategorias[element].nombre
        });
      }
    },

    cantidadCaracteresHtml(html) {
      let soloTexto = html.replace(/(<([^>]+)>)/ig, "");
      soloTexto = soloTexto.replace(/[\n\r]+/g, '');
      soloTexto = soloTexto.replace(/\s{2,10}/g, ' ');
      soloTexto = soloTexto.trim();
      return soloTexto.length;
    }

  },
  watch: {
    tabs: function (n, v) {
      if (!n) {
        this.tabs = v;
        return;
      }

      if (n === 'mobile-tabs-5-1') return; // MD -> HTML: Lo realizado en MD, actualizar al HTML

      if (n === 'mobile-tabs-5-2') {
        this.contenidoBlogHTML_Aux = this.contenidoBlogHTML;
      }
    },
    contenidoBlogHTML: function (n, v) {
      let textoHtml = n;
      this.cantidadCaracteres = this.cantidadCaracteresHtml(textoHtml);

      if (this.cantidadCaracteres < 50) {
        this.errorContenidoBlog = 'La longitud mínima para un blog es 50.';
      } else {
        this.errorContenidoBlog = '';
      }
    },
    seccionSelected: function (n, v) {
      if (n.uid == v.uid) return;
      this.datosBlogAux.seccion = n.uid;
      this.categoriaSelected = {
        uid: '',
        nombre: ''
      };
      this.listaCategorias = [];
      this.subCategoriasSelected = [];
      this.listaSubCategorias = [];
      n.uid ? this.setListaCategorias(n.uid) : '';
    },
    categoriaSelected: function (n, v) {
      if (n.uid === v.uid) return;
      if (!this.seccionSelected.uid) return;
      this.datosBlogAux.categoria = n.uid;
      this.subCategoriasSelected = [];
      this.listaSubCategorias = [];
      this.seccionSelected.uid && n.uid ? this.setListaSubCategorias(this.seccionSelected.uid, n.uid) : '';
    },
    subCategoriasSelected: function (n, v) {
      if (n.length === v.length) return;
      if (!this.seccionSelected.uid) return;
      this.datosBlogAux.subCategorias = [];

      for (let i = 0; i < n.length; i++) {
        const element = n[i];
        this.datosBlogAux.subCategorias.push(element.uid);
      }
    }
  },

  async created() {
    await this.reiniciar();
  }

});
// CONCATENATED MODULE: ./components/blogs/formulario-blog.vue?vue&type=script&lang=js&
 /* harmony default export */ var blogs_formulario_blogvue_type_script_lang_js_ = (formulario_blogvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/vuetify-loader/lib/runtime/installComponents.js
var installComponents = __webpack_require__(10);
var installComponents_default = /*#__PURE__*/__webpack_require__.n(installComponents);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VBtn/VBtn.js
var VBtn = __webpack_require__(51);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VCard/VCard.js
var VCard = __webpack_require__(82);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VCheckbox/VCheckbox.js
var VCheckbox = __webpack_require__(398);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VGrid/VCol.js
var VCol = __webpack_require__(277);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VDatePicker/VDatePicker.js
var VDatePicker = __webpack_require__(386);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VDivider/VDivider.js
var VDivider = __webpack_require__(210);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VIcon/VIcon.js
var VIcon = __webpack_require__(72);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VGrid/VRow.js
var VRow = __webpack_require__(278);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VSelect/VSelect.js + 2 modules
var VSelect = __webpack_require__(266);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VTabs/VTab.js
var VTab = __webpack_require__(232);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VTabs/VTabItem.js
var VTabItem = __webpack_require__(399);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VTabs/VTabs.js + 1 modules
var VTabs = __webpack_require__(238);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VTabs/VTabsItems.js
var VTabsItems = __webpack_require__(99);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VTabs/VTabsSlider.js
var VTabsSlider = __webpack_require__(100);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VTextField/VTextField.js
var VTextField = __webpack_require__(201);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VTextarea/VTextarea.js
var VTextarea = __webpack_require__(387);

// CONCATENATED MODULE: ./components/blogs/formulario-blog.vue



function injectStyles (context) {
  
  var style0 = __webpack_require__(475)
if (style0.__inject__) style0.__inject__(context)

}

/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  blogs_formulario_blogvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  injectStyles,
  "52ab93fa",
  "1c8c92c1"
  
)

/* harmony default export */ var formulario_blog = __webpack_exports__["default"] = (component.exports);

/* nuxt-component-imports */
installComponents_default()(component, {Editor: __webpack_require__(408).default})


/* vuetify-loader */

















installComponents_default()(component, {VBtn: VBtn["a" /* default */],VCard: VCard["a" /* default */],VCheckbox: VCheckbox["a" /* default */],VCol: VCol["a" /* default */],VDatePicker: VDatePicker["a" /* default */],VDivider: VDivider["a" /* default */],VIcon: VIcon["a" /* default */],VRow: VRow["a" /* default */],VSelect: VSelect["a" /* default */],VTab: VTab["a" /* default */],VTabItem: VTabItem["a" /* default */],VTabs: VTabs["a" /* default */],VTabsItems: VTabsItems["a" /* default */],VTabsSlider: VTabsSlider["a" /* default */],VTextField: VTextField["a" /* default */],VTextarea: VTextarea["a" /* default */]})


/***/ }),
/* 485 */,
/* 486 */,
/* 487 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _pad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(282);
// Adds leading zero to month/day if necessary, returns 'YYYY' if type = 'year',
// 'YYYY-MM' if 'month' and 'YYYY-MM-DD' if 'date'

/* harmony default export */ __webpack_exports__["a"] = ((dateString, type) => {
  const [year, month = 1, date = 1] = dateString.split('-');
  return `${year}-${Object(_pad__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(month)}-${Object(_pad__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(date)}`.substr(0, {
    date: 10,
    month: 7,
    year: 4
  }[type]);
});

/***/ }),
/* 488 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _pad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(282);


function createNativeLocaleFormatter(locale, options, substrOptions = {
  start: 0,
  length: 0
}) {
  const makeIsoString = dateString => {
    const [year, month, date] = dateString.trim().split(' ')[0].split('-');
    return [Object(_pad__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(year, 4), Object(_pad__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(month || 1), Object(_pad__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(date || 1)].join('-');
  };

  try {
    const intlFormatter = new Intl.DateTimeFormat(locale || undefined, options);
    return dateString => intlFormatter.format(new Date(`${makeIsoString(dateString)}T00:00:00+00:00`));
  } catch (e) {
    return substrOptions.start || substrOptions.length ? dateString => makeIsoString(dateString).substr(substrOptions.start || 0, substrOptions.length) : undefined;
  }
}

/* harmony default export */ __webpack_exports__["a"] = (createNativeLocaleFormatter);

/***/ }),
/* 489 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _pad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(282);

/**
 * @param {String} value YYYY-MM format
 * @param {Number} sign -1 or +1
 */

/* harmony default export */ __webpack_exports__["a"] = ((value, sign) => {
  const [year, month] = value.split('-').map(Number);

  if (month + sign === 0) {
    return `${year - 1}-12`;
  } else if (month + sign === 13) {
    return `${year + 1}-01`;
  } else {
    return `${year}-${Object(_pad__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(month + sign)}`;
  }
});

/***/ }),
/* 490 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createItemTypeNativeListeners; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createItemTypeListeners; });
function createItemTypeNativeListeners(instance, itemTypeSuffix, value) {
  return Object.keys(instance.$listeners).reduce((on, eventName) => {
    if (eventName.endsWith(itemTypeSuffix)) {
      on[eventName.slice(0, -itemTypeSuffix.length)] = event => instance.$emit(eventName, value, event);
    }

    return on;
  }, {});
}
function createItemTypeListeners(instance, itemTypeSuffix) {
  return Object.keys(instance.$listeners).reduce((on, eventName) => {
    if (eventName.endsWith(itemTypeSuffix)) {
      on[eventName] = instance.$listeners[eventName];
    }

    return on;
  }, {});
}

/***/ }),
/* 491 */,
/* 492 */,
/* 493 */,
/* 494 */,
/* 495 */,
/* 496 */,
/* 497 */,
/* 498 */,
/* 499 */,
/* 500 */,
/* 501 */,
/* 502 */,
/* 503 */,
/* 504 */,
/* 505 */,
/* 506 */,
/* 507 */,
/* 508 */,
/* 509 */,
/* 510 */,
/* 511 */
/***/ (function(module, exports) {

// Exports
module.exports = {

};


/***/ }),
/* 512 */,
/* 513 */,
/* 514 */,
/* 515 */,
/* 516 */,
/* 517 */,
/* 518 */,
/* 519 */,
/* 520 */,
/* 521 */,
/* 522 */,
/* 523 */,
/* 524 */,
/* 525 */,
/* 526 */,
/* 527 */,
/* 528 */,
/* 529 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_1_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_referencia_vue_vue_type_style_index_0_id_3a0172e3_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(511);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_1_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_referencia_vue_vue_type_style_index_0_id_3a0172e3_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_1_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_referencia_vue_vue_type_style_index_0_id_3a0172e3_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_1_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_referencia_vue_vue_type_style_index_0_id_3a0172e3_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_1_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_referencia_vue_vue_type_style_index_0_id_3a0172e3_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


/***/ }),
/* 530 */,
/* 531 */,
/* 532 */,
/* 533 */,
/* 534 */,
/* 535 */,
/* 536 */,
/* 537 */,
/* 538 */,
/* 539 */,
/* 540 */,
/* 541 */,
/* 542 */,
/* 543 */,
/* 544 */,
/* 545 */,
/* 546 */,
/* 547 */,
/* 548 */,
/* 549 */,
/* 550 */,
/* 551 */,
/* 552 */,
/* 553 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./pages/miembro-jekuaa/blog/actualizar/_referencia.vue?vue&type=template&id=3a0172e3&scoped=true&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"container"},[(_vm.datosBlog)?_vm._ssrNode("<div data-v-3a0172e3>","</div>",[_c('formulario-blog',{attrs:{"datosBlog":_vm.datosBlog,"contenidoBlog":_vm.contenidoBlog,"accion":'actualizar'},on:{"actualizarBlog":function($event){return _vm.actualizarBlog($event)}}}),_vm._ssrNode(" "),(_vm.datosActualizacion.visible && _vm.datosActualizacion.actualizado)?_vm._ssrNode("<div data-v-3a0172e3>","</div>",[_c('v-snackbar',{attrs:{"multi-line":_vm.multiLine,"timeout":-1,"value":true,"color":"#683BCE","elevation":"24"},scopedSlots:_vm._u([{key:"action",fn:function(ref){
var attrs = ref.attrs;
return [_c('v-btn',_vm._b({attrs:{"color":"#ff1d89"},on:{"click":function($event){_vm.datosActualizacion.visible = false}}},'v-btn',attrs,false),[_vm._v("\n                        Cerrar\n                    ")])]}}],null,false,3992070066),model:{value:(_vm.datosActualizacion.visible),callback:function ($$v) {_vm.$set(_vm.datosActualizacion, "visible", $$v)},expression:"datosActualizacion.visible"}},[_vm._v("\n                ¡Se actualizó el blog de forma exitosa!\n\n                ")])],1):_vm._e()],2):_vm._ssrNode("<div class=\"loadingMovie\" data-v-3a0172e3>","</div>",[_c('spinner')],1)])}
var staticRenderFns = []


// CONCATENATED MODULE: ./pages/miembro-jekuaa/blog/actualizar/_referencia.vue?vue&type=template&id=3a0172e3&scoped=true&

// EXTERNAL MODULE: ./components/Spinner.vue + 4 modules
var Spinner = __webpack_require__(122);

// EXTERNAL MODULE: external "showdown"
var external_showdown_ = __webpack_require__(239);
var external_showdown_default = /*#__PURE__*/__webpack_require__.n(external_showdown_);

// EXTERNAL MODULE: ./components/blogs/formulario-blog.vue + 4 modules
var formulario_blog = __webpack_require__(484);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./pages/miembro-jekuaa/blog/actualizar/_referencia.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var _referenciavue_type_script_lang_js_ = ({
  name: '',
  layout: 'miembroJekuaa',
  middleware: 'esMiembroJekuaa',

  data() {
    return {
      datosBlog: null,
      contenidoBlog: '',
      imgBlog: '',
      datosActualizacion: {
        visible: false,
        actualizado: false
      }
    };
  },

  components: {
    'formulario-blog': formulario_blog["default"],
    'spinner': Spinner["default"]
  },
  methods: {
    async actualizarBlog(datos) {
      try {
        const {
          uidBlog,
          datosBlog,
          contenidoBlog
        } = datos;
        let token = this.$firebase.auth().currentUser;
        token = token ? await token.getIdToken() : '';
        this.$store.commit('modules/usuarios/setTOKEN', token);
        let cambioDatosBlog = !!Object.keys(datosBlog).length;
        let cambioContenidoBlog = !!Object.keys(contenidoBlog).length;
        let body = {};
        if (cambioDatosBlog) body.datosBlog = datosBlog;
        if (cambioContenidoBlog) body.contenidoBlog = contenidoBlog.md;
        let config = {
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${token}`
          }
        };
        const respuesta = await this.$axios.$put(`/blog/miembroJekuaa/actualizarBlog/${uidBlog}`, body, config);
        this.datosActualizacion.visible = true;
        this.datosActualizacion.actualizado = true;
      } catch (error) {
        console.log('error', error);
        const accion = await this.$store.dispatch('modules/sistema/errorHandler', error);
      }
    }

  },
  watch: {},

  async mounted() {
    try {
      // Obtener datos de blog desde firebase
      const db = this.$firebase.firestore();
      const ref = db.collection('Blogs').where('referencia', '==', this.$route.params.referencia);
      const docs = await ref.get();
      const doc = docs.docs[0];
      if (!doc.exists) this.$router.push('/miembro-jekuaa/blogs/mis-blogs'); // Obtener contenido del blog desde la api de Jekuaa

      let usuario = this.$firebase.auth().currentUser;
      let token = usuario ? await usuario.getIdToken() : '';
      this.$store.commit('modules/usuarios/setTOKEN', token);
      const response = await this.$axios.get(`/blog/miembroJekuaa/obtenerContenido/${doc.data().uid}`, {
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        }
      });
      let converter = new external_showdown_default.a.Converter();
      this.datosBlog = doc.data();
      this.contenidoBlog = converter.makeHtml(response.data.resultado);
    } catch (error) {
      console.log('error', error);
      const accion = await this.$store.dispatch('modules/sistema/errorHandler', error);
      this.$router.push('/miembro-jekuaa/blogs/mis-blogs');
    }
  } // async asyncData({isDev, route, $firebase, $axios, store, env, params, query, req, res, redirect, error}) {
  //     try {
  //         // Variables
  //         let datosBlog = null
  //         let contenidoBlog = ''
  //         let imgBlog = ''
  //         // Obtener datos de blog desde firebase
  //         const db = $firebase.firestore()
  //         const ref = db.collection('Blogs').where('referencia', '==', params.referencia)
  //         const docs = await ref.get()
  //         const doc = docs.docs[0]
  //         if (!doc.exists) {
  //             redirect('/miembro-jekuaa/blogs/mis-blogs')
  //         }
  //         datosBlog = doc.data()
  //         // Obtener contenido del blog desde la api de Jekuaa
  //         const token = store.state.modules.usuarios.token
  //         const response = await $axios.get(`/blog/miembroJekuaa/obtenerContenido/${datosBlog.uid}`, {
  //             headers: {
  //                 'Content-Type': 'application/json',
  //                 Authorization: `Bearer ${token}`
  //             }
  //         })
  //         let converter = new showdown.Converter()
  //         contenidoBlog = converter.makeHtml(response.data.resultado.contenido)
  //         imgBlog = response.data.resultado.imgBlog
  //         return {
  //             datosBlog,
  //             contenidoBlog,
  //             imgBlog,
  //         }
  //     } catch (error) {
  //         console.log('err', error)
  //         redirect('/miembro-jekuaa/blogs/mis-blogs')
  //     }
  // },


});
// CONCATENATED MODULE: ./pages/miembro-jekuaa/blog/actualizar/_referencia.vue?vue&type=script&lang=js&
 /* harmony default export */ var actualizar_referenciavue_type_script_lang_js_ = (_referenciavue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/vuetify-loader/lib/runtime/installComponents.js
var installComponents = __webpack_require__(10);
var installComponents_default = /*#__PURE__*/__webpack_require__.n(installComponents);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VBtn/VBtn.js
var VBtn = __webpack_require__(51);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VSnackbar/VSnackbar.js
var VSnackbar = __webpack_require__(234);

// CONCATENATED MODULE: ./pages/miembro-jekuaa/blog/actualizar/_referencia.vue



function injectStyles (context) {
  
  var style0 = __webpack_require__(529)
if (style0.__inject__) style0.__inject__(context)

}

/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  actualizar_referenciavue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  injectStyles,
  "3a0172e3",
  "274da572"
  
)

/* harmony default export */ var _referencia = __webpack_exports__["default"] = (component.exports);

/* nuxt-component-imports */
installComponents_default()(component, {Spinner: __webpack_require__(122).default})


/* vuetify-loader */



installComponents_default()(component, {VBtn: VBtn["a" /* default */],VSnackbar: VSnackbar["a" /* default */]})


/***/ })
]);;
//# sourceMappingURL=_referencia.js.map