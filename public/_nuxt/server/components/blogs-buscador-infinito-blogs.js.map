{"version":3,"file":"components/blogs-buscador-infinito-blogs.js","sources":["webpack:///components/blogs-buscador-infinito-blogs.js"],"sourcesContent":["exports.ids = [8,11];\nexports.modules = {\n\n/***/ 255:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"capitalize\", function() { return /* reexport */ utils_capitalize; });\n__webpack_require__.d(__webpack_exports__, \"defer\", function() { return /* reexport */ defer[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"isDomElement\", function() { return /* reexport */ utils_isDomElement; });\n__webpack_require__.d(__webpack_exports__, \"getContainerNode\", function() { return /* reexport */ utils_getContainerNode; });\n__webpack_require__.d(__webpack_exports__, \"isSpecialClick\", function() { return /* reexport */ utils_isSpecialClick; });\n__webpack_require__.d(__webpack_exports__, \"prepareTemplateProps\", function() { return /* reexport */ utils_prepareTemplateProps; });\n__webpack_require__.d(__webpack_exports__, \"renderTemplate\", function() { return /* reexport */ utils_renderTemplate; });\n__webpack_require__.d(__webpack_exports__, \"getRefinements\", function() { return /* reexport */ getRefinements[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"clearRefinements\", function() { return /* reexport */ clearRefinements[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"escapeRefinement\", function() { return /* reexport */ escapeRefinement[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"unescapeRefinement\", function() { return /* reexport */ unescapeRefinement[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"checkRendering\", function() { return /* reexport */ checkRendering[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"checkIndexUiState\", function() { return /* reexport */ checkIndexUiState; });\n__webpack_require__.d(__webpack_exports__, \"getPropertyByPath\", function() { return /* reexport */ getPropertyByPath[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"getObjectType\", function() { return /* reexport */ getObjectType[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"noop\", function() { return /* reexport */ noop[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"isFiniteNumber\", function() { return /* reexport */ isFiniteNumber[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"isPlainObject\", function() { return /* reexport */ isPlainObject[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"uniq\", function() { return /* reexport */ uniq[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"range\", function() { return /* reexport */ range[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"isEqual\", function() { return /* reexport */ isEqual[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"escape\", function() { return /* reexport */ utils_escape[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"unescape\", function() { return /* reexport */ utils_unescape[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"concatHighlightedParts\", function() { return /* reexport */ concatHighlightedParts[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"getHighlightedParts\", function() { return /* reexport */ getHighlightedParts[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"getHighlightFromSiblings\", function() { return /* reexport */ getHighlightFromSiblings[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"reverseHighlightedParts\", function() { return /* reexport */ reverseHighlightedParts[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"find\", function() { return /* reexport */ find[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"findIndex\", function() { return /* reexport */ findIndex[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"mergeSearchParameters\", function() { return /* reexport */ mergeSearchParameters[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"resolveSearchParameters\", function() { return /* reexport */ resolveSearchParameters[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"toArray\", function() { return /* reexport */ toArray[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"warning\", function() { return /* reexport */ logger[\"b\" /* warning */]; });\n__webpack_require__.d(__webpack_exports__, \"deprecate\", function() { return /* reexport */ logger[\"a\" /* deprecate */]; });\n__webpack_require__.d(__webpack_exports__, \"escapeHits\", function() { return /* reexport */ escape_highlight[\"d\" /* escapeHits */]; });\n__webpack_require__.d(__webpack_exports__, \"TAG_PLACEHOLDER\", function() { return /* reexport */ escape_highlight[\"a\" /* TAG_PLACEHOLDER */]; });\n__webpack_require__.d(__webpack_exports__, \"TAG_REPLACEMENT\", function() { return /* reexport */ escape_highlight[\"b\" /* TAG_REPLACEMENT */]; });\n__webpack_require__.d(__webpack_exports__, \"escapeFacets\", function() { return /* reexport */ escape_highlight[\"c\" /* escapeFacets */]; });\n__webpack_require__.d(__webpack_exports__, \"createDocumentationLink\", function() { return /* reexport */ documentation[\"a\" /* createDocumentationLink */]; });\n__webpack_require__.d(__webpack_exports__, \"createDocumentationMessageGenerator\", function() { return /* reexport */ documentation[\"b\" /* createDocumentationMessageGenerator */]; });\n__webpack_require__.d(__webpack_exports__, \"aroundLatLngToPosition\", function() { return /* reexport */ geo_search[\"a\" /* aroundLatLngToPosition */]; });\n__webpack_require__.d(__webpack_exports__, \"insideBoundingBoxToBoundingBox\", function() { return /* reexport */ geo_search[\"b\" /* insideBoundingBoxToBoundingBox */]; });\n__webpack_require__.d(__webpack_exports__, \"addAbsolutePosition\", function() { return /* reexport */ hits_absolute_position[\"a\" /* addAbsolutePosition */]; });\n__webpack_require__.d(__webpack_exports__, \"addQueryID\", function() { return /* reexport */ hits_query_id[\"a\" /* addQueryID */]; });\n__webpack_require__.d(__webpack_exports__, \"isFacetRefined\", function() { return /* reexport */ isFacetRefined[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"createSendEventForFacet\", function() { return /* reexport */ createSendEventForFacet[\"a\" /* createSendEventForFacet */]; });\n__webpack_require__.d(__webpack_exports__, \"createSendEventForHits\", function() { return /* reexport */ createSendEventForHits[\"b\" /* createSendEventForHits */]; });\n__webpack_require__.d(__webpack_exports__, \"createBindEventForHits\", function() { return /* reexport */ createSendEventForHits[\"a\" /* createBindEventForHits */]; });\n__webpack_require__.d(__webpack_exports__, \"getAppIdAndApiKey\", function() { return /* reexport */ getAppIdAndApiKey; });\n__webpack_require__.d(__webpack_exports__, \"convertNumericRefinementsToFilters\", function() { return /* reexport */ convertNumericRefinementsToFilters[\"a\" /* convertNumericRefinementsToFilters */]; });\n__webpack_require__.d(__webpack_exports__, \"createConcurrentSafePromise\", function() { return /* reexport */ createConcurrentSafePromise[\"a\" /* createConcurrentSafePromise */]; });\n__webpack_require__.d(__webpack_exports__, \"debounce\", function() { return /* reexport */ debounce[\"a\" /* debounce */]; });\n__webpack_require__.d(__webpack_exports__, \"serializePayload\", function() { return /* reexport */ serializer[\"b\" /* serializePayload */]; });\n__webpack_require__.d(__webpack_exports__, \"deserializePayload\", function() { return /* reexport */ serializer[\"a\" /* deserializePayload */]; });\n__webpack_require__.d(__webpack_exports__, \"getWidgetAttribute\", function() { return /* reexport */ getWidgetAttribute[\"a\" /* getWidgetAttribute */]; });\n__webpack_require__.d(__webpack_exports__, \"safelyRunOnBrowser\", function() { return /* reexport */ safelyRunOnBrowser[\"a\" /* safelyRunOnBrowser */]; });\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/capitalize.js\nfunction capitalize(text) {\n  return text.toString().charAt(0).toUpperCase() + text.toString().slice(1);\n}\n\n/* harmony default export */ var utils_capitalize = (capitalize);\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/defer.js\nvar defer = __webpack_require__(378);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/isDomElement.js\nfunction isDomElement(object) {\n  return object instanceof HTMLElement || Boolean(object) && object.nodeType > 0;\n}\n\n/* harmony default export */ var utils_isDomElement = (isDomElement);\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/getContainerNode.js\n\n/**\n * Return the container. If it's a string, it is considered a\n * css selector and retrieves the first matching element. Otherwise\n * test if it validates that it's a correct DOMElement.\n *\n * @param {string|HTMLElement} selectorOrHTMLElement CSS Selector or container node.\n * @return {HTMLElement} Container node\n * @throws Error when the type is not correct\n */\n\nfunction getContainerNode(selectorOrHTMLElement) {\n  var isSelectorString = typeof selectorOrHTMLElement === 'string';\n  var domElement = isSelectorString ? document.querySelector(selectorOrHTMLElement) : selectorOrHTMLElement;\n\n  if (!utils_isDomElement(domElement)) {\n    var errorMessage = 'Container must be `string` or `HTMLElement`.';\n\n    if (isSelectorString) {\n      errorMessage += \" Unable to find \".concat(selectorOrHTMLElement);\n    }\n\n    throw new Error(errorMessage);\n  }\n\n  return domElement;\n}\n\n/* harmony default export */ var utils_getContainerNode = (getContainerNode);\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/isSpecialClick.js\nfunction isSpecialClick(event) {\n  var isMiddleClick = event.button === 1;\n  return isMiddleClick || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;\n}\n\n/* harmony default export */ var utils_isSpecialClick = (isSpecialClick);\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/uniq.js\nvar uniq = __webpack_require__(284);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/prepareTemplateProps.js\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\n\n\nfunction prepareTemplates( // can not use = {} here, since the template could have different constraints\ndefaultTemplates) {\n  var templates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var allKeys = Object(uniq[\"a\" /* default */])([].concat(_toConsumableArray(Object.keys(defaultTemplates || {})), _toConsumableArray(Object.keys(templates))));\n  return allKeys.reduce(function (config, key) {\n    var defaultTemplate = defaultTemplates ? defaultTemplates[key] : undefined;\n    var customTemplate = templates[key];\n    var isCustomTemplate = customTemplate !== undefined && customTemplate !== defaultTemplate;\n    config.templates[key] = isCustomTemplate ? customTemplate // typescript doesn't recognize that this condition asserts customTemplate is defined\n    : defaultTemplate;\n    config.useCustomCompileOptions[key] = isCustomTemplate;\n    return config;\n  }, {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    templates: {},\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    useCustomCompileOptions: {}\n  });\n}\n/**\n * Prepares an object to be passed to the Template widget\n */\n\n\nfunction prepareTemplateProps(_ref) {\n  var defaultTemplates = _ref.defaultTemplates,\n      templates = _ref.templates,\n      templatesConfig = _ref.templatesConfig;\n  var preparedTemplates = prepareTemplates(defaultTemplates, templates);\n  return _objectSpread({\n    templatesConfig: templatesConfig\n  }, preparedTemplates);\n}\n\n/* harmony default export */ var utils_prepareTemplateProps = (prepareTemplateProps);\n// EXTERNAL MODULE: external \"hogan.js\"\nvar external_hogan_js_ = __webpack_require__(236);\nvar external_hogan_js_default = /*#__PURE__*/__webpack_require__.n(external_hogan_js_);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/renderTemplate.js\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction renderTemplate_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction renderTemplate_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      renderTemplate_ownKeys(Object(source), true).forEach(function (key) {\n        renderTemplate_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      renderTemplate_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction renderTemplate_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n // We add all our template helper methods to the template as lambdas. Note\n// that lambdas in Mustache are supposed to accept a second argument of\n// `render` to get the rendered value, not the literal `{{value}}`. But\n// this is currently broken (see https://github.com/twitter/hogan.js/issues/222).\n\nfunction transformHelpersToHogan() {\n  var helpers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var compileOptions = arguments.length > 1 ? arguments[1] : undefined;\n  var data = arguments.length > 2 ? arguments[2] : undefined;\n  return Object.keys(helpers).reduce(function (acc, helperKey) {\n    return renderTemplate_objectSpread(renderTemplate_objectSpread({}, acc), {}, renderTemplate_defineProperty({}, helperKey, function () {\n      var _this = this;\n\n      return function (text) {\n        var render = function render(value) {\n          return external_hogan_js_default.a.compile(value, compileOptions).render(_this);\n        };\n\n        return helpers[helperKey].call(data, text, render);\n      };\n    }));\n  }, {});\n}\n\nfunction renderTemplate(_ref) {\n  var templates = _ref.templates,\n      templateKey = _ref.templateKey,\n      compileOptions = _ref.compileOptions,\n      helpers = _ref.helpers,\n      data = _ref.data,\n      bindEvent = _ref.bindEvent;\n  var template = templates[templateKey];\n\n  if (typeof template !== 'string' && typeof template !== 'function') {\n    throw new Error(\"Template must be 'string' or 'function', was '\".concat(_typeof(template), \"' (key: \").concat(templateKey, \")\"));\n  }\n\n  if (typeof template === 'function') {\n    return template(data, bindEvent);\n  }\n\n  var transformedHelpers = transformHelpersToHogan(helpers, compileOptions, data);\n  return external_hogan_js_default.a.compile(template, compileOptions).render(renderTemplate_objectSpread(renderTemplate_objectSpread({}, data), {}, {\n    helpers: transformedHelpers\n  })).replace(/[ \\n\\r\\t\\f\\xA0]+/g, function (spaces) {\n    return spaces.replace(/(^|\\xA0+)[^\\xA0]+/g, '$1 ');\n  }).trim();\n}\n\n/* harmony default export */ var utils_renderTemplate = (renderTemplate);\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getRefinements.js\nvar getRefinements = __webpack_require__(362);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/clearRefinements.js\nvar clearRefinements = __webpack_require__(360);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/escapeRefinement.js\nvar escapeRefinement = __webpack_require__(372);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/unescapeRefinement.js\nvar unescapeRefinement = __webpack_require__(314);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/checkRendering.js\nvar checkRendering = __webpack_require__(359);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/typedObject.js\n/**\n * A typed version of Object.keys, to use when looping over a static object\n * inspired from https://stackoverflow.com/a/65117465/3185307\n */\nvar keys = Object.keys;\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/checkIndexUiState.js\nfunction checkIndexUiState_toConsumableArray(arr) {\n  return checkIndexUiState_arrayWithoutHoles(arr) || checkIndexUiState_iterableToArray(arr) || checkIndexUiState_unsupportedIterableToArray(arr) || checkIndexUiState_nonIterableSpread();\n}\n\nfunction checkIndexUiState_nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction checkIndexUiState_iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction checkIndexUiState_arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return checkIndexUiState_arrayLikeToArray(arr);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || checkIndexUiState_unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction checkIndexUiState_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return checkIndexUiState_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return checkIndexUiState_arrayLikeToArray(o, minLen);\n}\n\nfunction checkIndexUiState_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\n\n\n // Some connectors are responsible for multiple widgets so we need\n// to map them.\n\nfunction getWidgetNames(connectorName) {\n  switch (connectorName) {\n    case 'range':\n      return [];\n\n    case 'menu':\n      return ['menu', 'menuSelect'];\n\n    default:\n      return [connectorName];\n  }\n}\n\nvar stateToWidgetsMap = {\n  query: {\n    connectors: ['connectSearchBox'],\n    widgets: ['ais.searchBox', 'ais.autocomplete', 'ais.voiceSearch']\n  },\n  refinementList: {\n    connectors: ['connectRefinementList'],\n    widgets: ['ais.refinementList']\n  },\n  menu: {\n    connectors: ['connectMenu'],\n    widgets: ['ais.menu']\n  },\n  hierarchicalMenu: {\n    connectors: ['connectHierarchicalMenu'],\n    widgets: ['ais.hierarchicalMenu']\n  },\n  numericMenu: {\n    connectors: ['connectNumericMenu'],\n    widgets: ['ais.numericMenu']\n  },\n  ratingMenu: {\n    connectors: ['connectRatingMenu'],\n    widgets: ['ais.ratingMenu']\n  },\n  range: {\n    connectors: ['connectRange'],\n    widgets: ['ais.rangeInput', 'ais.rangeSlider', 'ais.range']\n  },\n  toggle: {\n    connectors: ['connectToggleRefinement'],\n    widgets: ['ais.toggleRefinement']\n  },\n  geoSearch: {\n    connectors: ['connectGeoSearch'],\n    widgets: ['ais.geoSearch']\n  },\n  sortBy: {\n    connectors: ['connectSortBy'],\n    widgets: ['ais.sortBy']\n  },\n  page: {\n    connectors: ['connectPagination'],\n    widgets: ['ais.pagination', 'ais.infiniteHits']\n  },\n  hitsPerPage: {\n    connectors: ['connectHitsPerPage'],\n    widgets: ['ais.hitsPerPage']\n  },\n  configure: {\n    connectors: ['connectConfigure'],\n    widgets: ['ais.configure']\n  },\n  places: {\n    connectors: [],\n    widgets: ['ais.places']\n  }\n};\nfunction checkIndexUiState(_ref) {\n  var index = _ref.index,\n      indexUiState = _ref.indexUiState;\n  var mountedWidgets = index.getWidgets().map(function (widget) {\n    return widget.$$type;\n  }).filter(Boolean);\n  var missingWidgets = keys(indexUiState).reduce(function (acc, parameter) {\n    var widgetUiState = stateToWidgetsMap[parameter];\n\n    if (!widgetUiState) {\n      return acc;\n    }\n\n    var requiredWidgets = widgetUiState.widgets;\n\n    if (requiredWidgets && !requiredWidgets.some(function (requiredWidget) {\n      return mountedWidgets.includes(requiredWidget);\n    })) {\n      acc.push([parameter, {\n        connectors: widgetUiState.connectors,\n        widgets: widgetUiState.widgets.map(function (widgetIdentifier) {\n          return widgetIdentifier.split('ais.')[1];\n        })\n      }]);\n    }\n\n    return acc;\n  }, []);\n   false ? undefined : void 0;\n}\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getPropertyByPath.js\nvar getPropertyByPath = __webpack_require__(374);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getObjectType.js\nvar getObjectType = __webpack_require__(311);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/noop.js\nvar noop = __webpack_require__(310);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/isFiniteNumber.js\nvar isFiniteNumber = __webpack_require__(369);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/isPlainObject.js\nvar isPlainObject = __webpack_require__(317);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/range.js\nvar range = __webpack_require__(370);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/isEqual.js\nvar isEqual = __webpack_require__(367);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/escape.js\nvar utils_escape = __webpack_require__(316);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/unescape.js\nvar utils_unescape = __webpack_require__(320);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/concatHighlightedParts.js\nvar concatHighlightedParts = __webpack_require__(379);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getHighlightedParts.js\nvar getHighlightedParts = __webpack_require__(380);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getHighlightFromSiblings.js\nvar getHighlightFromSiblings = __webpack_require__(321);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/reverseHighlightedParts.js\nvar reverseHighlightedParts = __webpack_require__(381);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/find.js\nvar find = __webpack_require__(313);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/findIndex.js\nvar findIndex = __webpack_require__(312);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/mergeSearchParameters.js\nvar mergeSearchParameters = __webpack_require__(361);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/resolveSearchParameters.js\nvar resolveSearchParameters = __webpack_require__(382);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/toArray.js\nvar toArray = __webpack_require__(371);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/logger.js\nvar logger = __webpack_require__(286);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/escape-highlight.js\nvar escape_highlight = __webpack_require__(264);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/documentation.js\nvar documentation = __webpack_require__(309);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/geo-search.js\nvar geo_search = __webpack_require__(319);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/hits-absolute-position.js\nvar hits_absolute_position = __webpack_require__(365);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/hits-query-id.js\nvar hits_query_id = __webpack_require__(366);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/isFacetRefined.js\nvar isFacetRefined = __webpack_require__(315);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/createSendEventForFacet.js\nvar createSendEventForFacet = __webpack_require__(363);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/createSendEventForHits.js\nvar createSendEventForHits = __webpack_require__(364);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/getAppIdAndApiKey.js\n// typed as any, since it accepts the _real_ js clients, not the interface we otherwise expect\nfunction getAppIdAndApiKey(searchClient) {\n  if (searchClient.transporter) {\n    // searchClient v4\n    var _searchClient$transpo = searchClient.transporter,\n        headers = _searchClient$transpo.headers,\n        queryParameters = _searchClient$transpo.queryParameters;\n    var APP_ID = 'x-algolia-application-id';\n    var API_KEY = 'x-algolia-api-key';\n    var appId = headers[APP_ID] || queryParameters[APP_ID];\n    var apiKey = headers[API_KEY] || queryParameters[API_KEY];\n    return [appId, apiKey];\n  } else {\n    // searchClient v3\n    return [searchClient.applicationID, searchClient.apiKey];\n  }\n}\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/convertNumericRefinementsToFilters.js\nvar convertNumericRefinementsToFilters = __webpack_require__(368);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/createConcurrentSafePromise.js\nvar createConcurrentSafePromise = __webpack_require__(375);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/debounce.js\nvar debounce = __webpack_require__(376);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/serializer.js\nvar serializer = __webpack_require__(285);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getWidgetAttribute.js\nvar getWidgetAttribute = __webpack_require__(377);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/safelyRunOnBrowser.js\nvar safelyRunOnBrowser = __webpack_require__(373);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/***/ }),\n\n/***/ 264:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return TAG_PLACEHOLDER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return TAG_REPLACEMENT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return escapeHits; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return escapeFacets; });\n/* harmony import */ var _escape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(316);\n/* harmony import */ var _isPlainObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(317);\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\n\nvar TAG_PLACEHOLDER = {\n  highlightPreTag: '__ais-highlight__',\n  highlightPostTag: '__/ais-highlight__'\n};\nvar TAG_REPLACEMENT = {\n  highlightPreTag: '<mark>',\n  highlightPostTag: '</mark>'\n};\n\nfunction replaceTagsAndEscape(value) {\n  return Object(_escape__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(value).replace(new RegExp(TAG_PLACEHOLDER.highlightPreTag, 'g'), TAG_REPLACEMENT.highlightPreTag).replace(new RegExp(TAG_PLACEHOLDER.highlightPostTag, 'g'), TAG_REPLACEMENT.highlightPostTag);\n}\n\nfunction recursiveEscape(input) {\n  if (Object(_isPlainObject__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(input) && typeof input.value !== 'string') {\n    return Object.keys(input).reduce(function (acc, key) {\n      return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, key, recursiveEscape(input[key])));\n    }, {});\n  }\n\n  if (Array.isArray(input)) {\n    return input.map(recursiveEscape);\n  }\n\n  return _objectSpread(_objectSpread({}, input), {}, {\n    value: replaceTagsAndEscape(input.value)\n  });\n}\n\nfunction escapeHits(hits) {\n  if (hits.__escaped === undefined) {\n    // We don't override the value on hit because it will mutate the raw results\n    // instead we make a shallow copy and we assign the escaped values on it.\n    hits = hits.map(function (_ref) {\n      var hit = _extends({}, _ref);\n\n      if (hit._highlightResult) {\n        hit._highlightResult = recursiveEscape(hit._highlightResult);\n      }\n\n      if (hit._snippetResult) {\n        hit._snippetResult = recursiveEscape(hit._snippetResult);\n      }\n\n      return hit;\n    });\n    hits.__escaped = true;\n  }\n\n  return hits;\n}\nfunction escapeFacets(facetHits) {\n  return facetHits.map(function (h) {\n    return _objectSpread(_objectSpread({}, h), {}, {\n      highlighted: replaceTagsAndEscape(h.highlighted)\n    });\n  });\n}\n\n/***/ }),\n\n/***/ 284:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction uniq(array) {\n  return array.filter(function (value, index, self) {\n    return self.indexOf(value) === index;\n  });\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (uniq);\n\n/***/ }),\n\n/***/ 285:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return serializePayload; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return deserializePayload; });\nfunction serializePayload(payload) {\n  return btoa(encodeURIComponent(JSON.stringify(payload)));\n}\nfunction deserializePayload(serialized) {\n  return JSON.parse(decodeURIComponent(atob(serialized)));\n}\n\n/***/ }),\n\n/***/ 286:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export warn */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return deprecate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return _warning; });\n/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(310);\n\n/**\n * Logs a warning when this function is called, in development environment only.\n */\n\nvar deprecate = function deprecate(fn, message) {\n  return fn;\n};\n/**\n * Logs a warning\n * This is used to log issues in development environment only.\n */\n\n\nvar warn = _noop__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"];\n/**\n * Logs a warning if the condition is not met.\n * This is used to log issues in development environment only.\n */\n\nvar _warning = _noop__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"];\n\nif (false) {}\n\n\n\n/***/ }),\n\n/***/ 287:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return component; });\nvar NAMESPACE = 'ais';\nvar component = function component(componentName) {\n  return function () {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        descendantName = _ref.descendantName,\n        modifierName = _ref.modifierName;\n\n    var descendent = descendantName ? \"-\".concat(descendantName) : '';\n    var modifier = modifierName ? \"--\".concat(modifierName) : '';\n    return \"\".concat(NAMESPACE, \"-\").concat(componentName).concat(descendent).concat(modifier);\n  };\n};\n\n/***/ }),\n\n/***/ 309:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return createDocumentationLink; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return createDocumentationMessageGenerator; });\nvar createDocumentationLink = function createDocumentationLink(_ref) {\n  var name = _ref.name,\n      _ref$connector = _ref.connector,\n      connector = _ref$connector === void 0 ? false : _ref$connector;\n  return ['https://www.algolia.com/doc/api-reference/widgets/', name, '/js/', connector ? '#connector' : ''].join('');\n};\nvar createDocumentationMessageGenerator = function createDocumentationMessageGenerator() {\n  for (var _len = arguments.length, widgets = new Array(_len), _key = 0; _key < _len; _key++) {\n    widgets[_key] = arguments[_key];\n  }\n\n  var links = widgets.map(function (widget) {\n    return createDocumentationLink(widget);\n  }).join(', ');\n  return function (message) {\n    return [message, \"See documentation: \".concat(links)].filter(Boolean).join('\\n\\n');\n  };\n};\n\n/***/ }),\n\n/***/ 310:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction noop() {}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (noop);\n\n/***/ }),\n\n/***/ 311:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction getObjectType(object) {\n  return Object.prototype.toString.call(object).slice(8, -1);\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (getObjectType);\n\n/***/ }),\n\n/***/ 312:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// We aren't using the native `Array.prototype.findIndex` because the refactor away from Lodash is not\n// published as a major version.\n// Relying on the `findIndex` polyfill on user-land, which before was only required for niche use-cases,\n// was decided as too risky.\n// @MAJOR Replace with the native `Array.prototype.findIndex` method\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex\nfunction findIndex(array, comparator) {\n  if (!Array.isArray(array)) {\n    return -1;\n  }\n\n  for (var i = 0; i < array.length; i++) {\n    if (comparator(array[i])) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (findIndex);\n\n/***/ }),\n\n/***/ 313:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// We aren't using the native `Array.prototype.find` because the refactor away from Lodash is not\n// published as a major version.\n// Relying on the `find` polyfill on user-land, which before was only required for niche use-cases,\n// was decided as too risky.\n// @MAJOR Replace with the native `Array.prototype.find` method\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find\nfunction find(items, predicate) {\n  var value;\n\n  for (var i = 0; i < items.length; i++) {\n    value = items[i]; // inlined for performance: if (Call(predicate, thisArg, [value, i, list])) {\n\n    if (predicate(value, i, items)) {\n      return value;\n    }\n  }\n\n  return undefined;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (find);\n\n/***/ }),\n\n/***/ 314:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction unescapeRefinement(value) {\n  return String(value).replace(/^\\\\-/, '-');\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (unescapeRefinement);\n\n/***/ }),\n\n/***/ 315:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return isFacetRefined; });\nfunction isFacetRefined(helper, facet, value) {\n  if (helper.state.isHierarchicalFacet(facet)) {\n    return helper.state.isHierarchicalFacetRefined(facet, value);\n  } else if (helper.state.isConjunctiveFacet(facet)) {\n    return helper.state.isFacetRefined(facet, value);\n  } else {\n    return helper.state.isDisjunctiveFacetRefined(facet, value);\n  }\n}\n\n/***/ }),\n\n/***/ 316:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * This implementation is taken from Lodash implementation.\n * See: https://github.com/lodash/lodash/blob/4.17.11-npm/escape.js\n */\n// Used to map characters to HTML entities.\nvar htmlEscapes = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;'\n}; // Used to match HTML entities and HTML characters.\n\nvar regexUnescapedHtml = /[&<>\"']/g;\nvar regexHasUnescapedHtml = RegExp(regexUnescapedHtml.source);\n/**\n * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n * corresponding HTML entities.\n */\n\nfunction escape(value) {\n  return value && regexHasUnescapedHtml.test(value) ? value.replace(regexUnescapedHtml, function (character) {\n    return htmlEscapes[character];\n  }) : value;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (escape);\n\n/***/ }),\n\n/***/ 317:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n/**\n * This implementation is taken from Lodash implementation.\n * See: https://github.com/lodash/lodash/blob/master/isPlainObject.js\n */\n\n\nfunction getTag(value) {\n  if (value === null) {\n    return value === undefined ? '[object Undefined]' : '[object Null]';\n  }\n\n  return Object.prototype.toString.call(value);\n}\n\nfunction isObjectLike(value) {\n  return _typeof(value) === 'object' && value !== null;\n}\n/**\n * Checks if `value` is a plain object.\n *\n * A plain object is an object created by the `Object`\n * constructor or with a `[[Prototype]]` of `null`.\n */\n\n\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || getTag(value) !== '[object Object]') {\n    return false;\n  }\n\n  if (Object.getPrototypeOf(value) === null) {\n    return true;\n  }\n\n  var proto = value;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(value) === proto;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (isPlainObject);\n\n/***/ }),\n\n/***/ 318:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(309);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(367);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(310);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(359);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(364);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(264);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(365);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(366);\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\n\nvar withUsage = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_0__[/* createDocumentationMessageGenerator */ \"b\"])({\n  name: 'infinite-hits',\n  connector: true\n});\n\nfunction getStateWithoutPage(state) {\n  var _ref = state || {},\n      page = _ref.page,\n      rest = _objectWithoutProperties(_ref, [\"page\"]);\n\n  return rest;\n}\n\nfunction getInMemoryCache() {\n  var cachedHits = null;\n  var cachedState = null;\n  return {\n    read: function read(_ref2) {\n      var state = _ref2.state;\n      return Object(_lib_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(cachedState, getStateWithoutPage(state)) ? cachedHits : null;\n    },\n    write: function write(_ref3) {\n      var state = _ref3.state,\n          hits = _ref3.hits;\n      cachedState = getStateWithoutPage(state);\n      cachedHits = hits;\n    }\n  };\n}\n\nfunction extractHitsFromCachedHits(cachedHits) {\n  return Object.keys(cachedHits).map(Number).sort(function (a, b) {\n    return a - b;\n  }).reduce(function (acc, page) {\n    return acc.concat(cachedHits[page]);\n  }, []);\n}\n\nvar connectInfiniteHits = function connectInfiniteHits(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _lib_utils__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"];\n  Object(_lib_utils__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(renderFn, withUsage());\n  return function (widgetParams) {\n    var _ref4 = widgetParams || {},\n        _ref4$escapeHTML = _ref4.escapeHTML,\n        escapeHTML = _ref4$escapeHTML === void 0 ? true : _ref4$escapeHTML,\n        _ref4$transformItems = _ref4.transformItems,\n        transformItems = _ref4$transformItems === void 0 ? function (items) {\n      return items;\n    } : _ref4$transformItems,\n        _ref4$cache = _ref4.cache,\n        cache = _ref4$cache === void 0 ? getInMemoryCache() : _ref4$cache;\n\n    var showPrevious;\n    var showMore;\n    var sendEvent;\n    var bindEvent;\n\n    var getFirstReceivedPage = function getFirstReceivedPage(state, cachedHits) {\n      var _state$page = state.page,\n          page = _state$page === void 0 ? 0 : _state$page;\n      var pages = Object.keys(cachedHits).map(Number);\n\n      if (pages.length === 0) {\n        return page;\n      } else {\n        return Math.min.apply(Math, [page].concat(_toConsumableArray(pages)));\n      }\n    };\n\n    var getLastReceivedPage = function getLastReceivedPage(state, cachedHits) {\n      var _state$page2 = state.page,\n          page = _state$page2 === void 0 ? 0 : _state$page2;\n      var pages = Object.keys(cachedHits).map(Number);\n\n      if (pages.length === 0) {\n        return page;\n      } else {\n        return Math.max.apply(Math, [page].concat(_toConsumableArray(pages)));\n      }\n    };\n\n    var getShowPrevious = function getShowPrevious(helper) {\n      return function () {\n        // Using the helper's `overrideStateWithoutTriggeringChangeEvent` method\n        // avoid updating the browser URL when the user displays the previous page.\n        helper.overrideStateWithoutTriggeringChangeEvent(_objectSpread(_objectSpread({}, helper.state), {}, {\n          page: getFirstReceivedPage(helper.state, cache.read({\n            state: helper.state\n          }) || {}) - 1\n        })).searchWithoutTriggeringOnStateChange();\n      };\n    };\n\n    var getShowMore = function getShowMore(helper) {\n      return function () {\n        helper.setPage(getLastReceivedPage(helper.state, cache.read({\n          state: helper.state\n        }) || {}) + 1).search();\n      };\n    };\n\n    return {\n      $$type: 'ais.infiniteHits',\n      init: function init(initOptions) {\n        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: initOptions.instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n        var widgetRenderState = this.getWidgetRenderState(renderOptions);\n        sendEvent('view', widgetRenderState.currentPageHits);\n        renderFn(_objectSpread(_objectSpread({}, widgetRenderState), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return _objectSpread(_objectSpread({}, renderState), {}, {\n          infiniteHits: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref5) {\n        var results = _ref5.results,\n            helper = _ref5.helper,\n            state = _ref5.state,\n            instantSearchInstance = _ref5.instantSearchInstance;\n        var isFirstPage;\n        var currentPageHits = [];\n        var cachedHits = cache.read({\n          state: state\n        }) || {};\n\n        if (!results) {\n          showPrevious = getShowPrevious(helper);\n          showMore = getShowMore(helper);\n          sendEvent = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_4__[/* createSendEventForHits */ \"b\"])({\n            instantSearchInstance: instantSearchInstance,\n            index: helper.getIndex(),\n            widgetType: this.$$type\n          });\n          bindEvent = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_4__[/* createBindEventForHits */ \"a\"])({\n            index: helper.getIndex(),\n            widgetType: this.$$type\n          });\n          isFirstPage = helper.state.page === undefined || getFirstReceivedPage(helper.state, cachedHits) === 0;\n        } else {\n          var _state$page3 = state.page,\n              _page = _state$page3 === void 0 ? 0 : _state$page3;\n\n          if (escapeHTML && results.hits.length > 0) {\n            results.hits = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_5__[/* escapeHits */ \"d\"])(results.hits);\n          }\n\n          var hitsWithAbsolutePosition = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_6__[/* addAbsolutePosition */ \"a\"])(results.hits, results.page, results.hitsPerPage);\n          var hitsWithAbsolutePositionAndQueryID = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_7__[/* addQueryID */ \"a\"])(hitsWithAbsolutePosition, results.queryID);\n          var transformedHits = transformItems(hitsWithAbsolutePositionAndQueryID);\n\n          if (cachedHits[_page] === undefined) {\n            cachedHits[_page] = transformedHits;\n            cache.write({\n              state: state,\n              hits: cachedHits\n            });\n          }\n\n          currentPageHits = transformedHits;\n          isFirstPage = getFirstReceivedPage(state, cachedHits) === 0;\n        }\n\n        var hits = extractHitsFromCachedHits(cachedHits);\n        var isLastPage = results ? results.nbPages <= getLastReceivedPage(state, cachedHits) + 1 : true;\n        return {\n          hits: hits,\n          currentPageHits: currentPageHits,\n          sendEvent: sendEvent,\n          bindEvent: bindEvent,\n          results: results,\n          showPrevious: showPrevious,\n          showMore: showMore,\n          isFirstPage: isFirstPage,\n          isLastPage: isLastPage,\n          widgetParams: widgetParams\n        };\n      },\n      dispose: function dispose(_ref6) {\n        var state = _ref6.state;\n        unmountFn();\n        var stateWithoutPage = state.setQueryParameter('page', undefined);\n\n        if (!escapeHTML) {\n          return stateWithoutPage;\n        }\n\n        return stateWithoutPage.setQueryParameters(Object.keys(_lib_utils__WEBPACK_IMPORTED_MODULE_5__[/* TAG_PLACEHOLDER */ \"a\"]).reduce(function (acc, key) {\n          return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, key, undefined));\n        }, {}));\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref7) {\n        var searchParameters = _ref7.searchParameters;\n        var page = searchParameters.page || 0;\n\n        if (!page) {\n          // return without adding `page` to uiState\n          // because we don't want `page=1` in the URL\n          return uiState;\n        }\n\n        return _objectSpread(_objectSpread({}, uiState), {}, {\n          // The page in the UI state is incremented by one\n          // to expose the user value (not `0`).\n          page: page + 1\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref8) {\n        var uiState = _ref8.uiState;\n        var widgetSearchParameters = searchParameters;\n\n        if (escapeHTML) {\n          widgetSearchParameters = searchParameters.setQueryParameters(_lib_utils__WEBPACK_IMPORTED_MODULE_5__[/* TAG_PLACEHOLDER */ \"a\"]);\n        } // The page in the search parameters is decremented by one\n        // to get to the actual parameter value from the UI state.\n\n\n        var page = uiState.page ? uiState.page - 1 : 0;\n        return widgetSearchParameters.setQueryParameter('page', page);\n      }\n    };\n  };\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (connectInfiniteHits);\n\n/***/ }),\n\n/***/ 319:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return aroundLatLngToPosition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return insideBoundingBoxToBoundingBox; });\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar latLngRegExp = /^(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)$/;\nfunction aroundLatLngToPosition(value) {\n  var pattern = value.match(latLngRegExp); // Since the value provided is the one send with the request, the API should\n  // throw an error due to the wrong format. So throw an error should be safe.\n\n  if (!pattern) {\n    throw new Error(\"Invalid value for \\\"aroundLatLng\\\" parameter: \\\"\".concat(value, \"\\\"\"));\n  }\n\n  return {\n    lat: parseFloat(pattern[1]),\n    lng: parseFloat(pattern[2])\n  };\n}\n\nfunction insideBoundingBoxArrayToBoundingBox(value) {\n  var _value = _slicedToArray(value, 1),\n      _value$ = _value[0];\n\n  _value$ = _value$ === void 0 ? [undefined, undefined, undefined, undefined] : _value$;\n\n  var _value$2 = _slicedToArray(_value$, 4),\n      neLat = _value$2[0],\n      neLng = _value$2[1],\n      swLat = _value$2[2],\n      swLng = _value$2[3]; // Since the value provided is the one send with the request, the API should\n  // throw an error due to the wrong format. So throw an error should be safe.\n\n\n  if (!neLat || !neLng || !swLat || !swLng) {\n    throw new Error(\"Invalid value for \\\"insideBoundingBox\\\" parameter: [\".concat(value, \"]\"));\n  }\n\n  return {\n    northEast: {\n      lat: neLat,\n      lng: neLng\n    },\n    southWest: {\n      lat: swLat,\n      lng: swLng\n    }\n  };\n}\n\nfunction insideBoundingBoxStringToBoundingBox(value) {\n  var _value$split$map = value.split(',').map(parseFloat),\n      _value$split$map2 = _slicedToArray(_value$split$map, 4),\n      neLat = _value$split$map2[0],\n      neLng = _value$split$map2[1],\n      swLat = _value$split$map2[2],\n      swLng = _value$split$map2[3]; // Since the value provided is the one send with the request, the API should\n  // throw an error due to the wrong format. So throw an error should be safe.\n\n\n  if (!neLat || !neLng || !swLat || !swLng) {\n    throw new Error(\"Invalid value for \\\"insideBoundingBox\\\" parameter: \\\"\".concat(value, \"\\\"\"));\n  }\n\n  return {\n    northEast: {\n      lat: neLat,\n      lng: neLng\n    },\n    southWest: {\n      lat: swLat,\n      lng: swLng\n    }\n  };\n}\n\nfunction insideBoundingBoxToBoundingBox(value) {\n  if (Array.isArray(value)) {\n    return insideBoundingBoxArrayToBoundingBox(value);\n  }\n\n  return insideBoundingBoxStringToBoundingBox(value);\n}\n\n/***/ }),\n\n/***/ 320:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return unescape; });\n/**\n * This implementation is taken from Lodash implementation.\n * See: https://github.com/lodash/lodash/blob/4.17.11-npm/unescape.js\n */\n// Used to map HTML entities to characters.\nvar htmlEscapes = {\n  '&amp;': '&',\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&#39;': \"'\"\n}; // Used to match HTML entities and HTML characters.\n\nvar regexEscapedHtml = /&(amp|quot|lt|gt|#39);/g;\nvar regexHasEscapedHtml = RegExp(regexEscapedHtml.source);\n/**\n * Converts the HTML entities \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n * characters.\n */\n\nfunction unescape(value) {\n  return value && regexHasEscapedHtml.test(value) ? value.replace(regexEscapedHtml, function (character) {\n    return htmlEscapes[character];\n  }) : value;\n}\n\n/***/ }),\n\n/***/ 321:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return getHighlightFromSiblings; });\n/* harmony import */ var _unescape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(320);\n\nvar hasAlphanumeric = new RegExp(/\\w/i);\nfunction getHighlightFromSiblings(parts, i) {\n  var _parts, _parts2;\n\n  var current = parts[i];\n  var isNextHighlighted = ((_parts = parts[i + 1]) === null || _parts === void 0 ? void 0 : _parts.isHighlighted) || true;\n  var isPreviousHighlighted = ((_parts2 = parts[i - 1]) === null || _parts2 === void 0 ? void 0 : _parts2.isHighlighted) || true;\n\n  if (!hasAlphanumeric.test(Object(_unescape__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(current.value)) && isPreviousHighlighted === isNextHighlighted) {\n    return isPreviousHighlighted;\n  }\n\n  return current.isHighlighted;\n}\n\n/***/ }),\n\n/***/ 359:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _getObjectType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(311);\n\n\nfunction checkRendering(rendering, usage) {\n  if (rendering === undefined || typeof rendering !== 'function') {\n    throw new Error(\"The render function is not valid (received type \".concat(Object(_getObjectType__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(rendering), \").\\n\\n\").concat(usage));\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (checkRendering);\n\n/***/ }),\n\n/***/ 360:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Clears the refinements of a SearchParameters object based on rules provided.\n * The included attributes list is applied before the excluded attributes list. If the list\n * is not provided, this list of all the currently refined attributes is used as included attributes.\n * @param {object} $0 parameters\n * @param {Helper} $0.helper instance of the Helper\n * @param {string[]} [$0.attributesToClear = []] list of parameters to clear\n * @returns {SearchParameters} search parameters with refinements cleared\n */\nfunction clearRefinements(_ref) {\n  var helper = _ref.helper,\n      _ref$attributesToClea = _ref.attributesToClear,\n      attributesToClear = _ref$attributesToClea === void 0 ? [] : _ref$attributesToClea;\n  var finalState = helper.state.setPage(0);\n  finalState = attributesToClear.reduce(function (state, attribute) {\n    if (finalState.isNumericRefined(attribute)) {\n      return state.removeNumericRefinement(attribute);\n    }\n\n    if (finalState.isHierarchicalFacet(attribute)) {\n      return state.removeHierarchicalFacetRefinement(attribute);\n    }\n\n    if (finalState.isDisjunctiveFacet(attribute)) {\n      return state.removeDisjunctiveFacetRefinement(attribute);\n    }\n\n    if (finalState.isConjunctiveFacet(attribute)) {\n      return state.removeFacetRefinement(attribute);\n    }\n\n    return state;\n  }, finalState);\n\n  if (attributesToClear.indexOf('query') !== -1) {\n    finalState = finalState.setQuery('');\n  }\n\n  return finalState;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (clearRefinements);\n\n/***/ }),\n\n/***/ 361:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _findIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(312);\n/* harmony import */ var _uniq__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(284);\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\n\n\n\nvar mergeWithRest = function mergeWithRest(left, right) {\n  var facets = right.facets,\n      disjunctiveFacets = right.disjunctiveFacets,\n      facetsRefinements = right.facetsRefinements,\n      facetsExcludes = right.facetsExcludes,\n      disjunctiveFacetsRefinements = right.disjunctiveFacetsRefinements,\n      numericRefinements = right.numericRefinements,\n      tagRefinements = right.tagRefinements,\n      hierarchicalFacets = right.hierarchicalFacets,\n      hierarchicalFacetsRefinements = right.hierarchicalFacetsRefinements,\n      ruleContexts = right.ruleContexts,\n      rest = _objectWithoutProperties(right, [\"facets\", \"disjunctiveFacets\", \"facetsRefinements\", \"facetsExcludes\", \"disjunctiveFacetsRefinements\", \"numericRefinements\", \"tagRefinements\", \"hierarchicalFacets\", \"hierarchicalFacetsRefinements\", \"ruleContexts\"]);\n\n  return left.setQueryParameters(rest);\n}; // Merge facets\n\n\nvar mergeFacets = function mergeFacets(left, right) {\n  return right.facets.reduce(function (_, name) {\n    return _.addFacet(name);\n  }, left);\n};\n\nvar mergeDisjunctiveFacets = function mergeDisjunctiveFacets(left, right) {\n  return right.disjunctiveFacets.reduce(function (_, name) {\n    return _.addDisjunctiveFacet(name);\n  }, left);\n};\n\nvar mergeHierarchicalFacets = function mergeHierarchicalFacets(left, right) {\n  return left.setQueryParameters({\n    hierarchicalFacets: right.hierarchicalFacets.reduce(function (facets, facet) {\n      var index = Object(_findIndex__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(facets, function (_) {\n        return _.name === facet.name;\n      });\n\n      if (index === -1) {\n        return facets.concat(facet);\n      }\n\n      var nextFacets = facets.slice();\n      nextFacets.splice(index, 1, facet);\n      return nextFacets;\n    }, left.hierarchicalFacets)\n  });\n}; // Merge facet refinements\n\n\nvar mergeTagRefinements = function mergeTagRefinements(left, right) {\n  return right.tagRefinements.reduce(function (_, value) {\n    return _.addTagRefinement(value);\n  }, left);\n};\n\nvar mergeFacetRefinements = function mergeFacetRefinements(left, right) {\n  return left.setQueryParameters({\n    facetsRefinements: _objectSpread(_objectSpread({}, left.facetsRefinements), right.facetsRefinements)\n  });\n};\n\nvar mergeFacetsExcludes = function mergeFacetsExcludes(left, right) {\n  return left.setQueryParameters({\n    facetsExcludes: _objectSpread(_objectSpread({}, left.facetsExcludes), right.facetsExcludes)\n  });\n};\n\nvar mergeDisjunctiveFacetsRefinements = function mergeDisjunctiveFacetsRefinements(left, right) {\n  return left.setQueryParameters({\n    disjunctiveFacetsRefinements: _objectSpread(_objectSpread({}, left.disjunctiveFacetsRefinements), right.disjunctiveFacetsRefinements)\n  });\n};\n\nvar mergeNumericRefinements = function mergeNumericRefinements(left, right) {\n  return left.setQueryParameters({\n    numericRefinements: _objectSpread(_objectSpread({}, left.numericRefinements), right.numericRefinements)\n  });\n};\n\nvar mergeHierarchicalFacetsRefinements = function mergeHierarchicalFacetsRefinements(left, right) {\n  return left.setQueryParameters({\n    hierarchicalFacetsRefinements: _objectSpread(_objectSpread({}, left.hierarchicalFacetsRefinements), right.hierarchicalFacetsRefinements)\n  });\n};\n\nvar mergeRuleContexts = function mergeRuleContexts(left, right) {\n  var ruleContexts = Object(_uniq__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])([].concat(left.ruleContexts).concat(right.ruleContexts).filter(Boolean));\n\n  if (ruleContexts.length > 0) {\n    return left.setQueryParameters({\n      ruleContexts: ruleContexts\n    });\n  }\n\n  return left;\n};\n\nvar merge = function merge() {\n  for (var _len = arguments.length, parameters = new Array(_len), _key = 0; _key < _len; _key++) {\n    parameters[_key] = arguments[_key];\n  }\n\n  return parameters.reduce(function (left, right) {\n    var hierarchicalFacetsRefinementsMerged = mergeHierarchicalFacetsRefinements(left, right);\n    var hierarchicalFacetsMerged = mergeHierarchicalFacets(hierarchicalFacetsRefinementsMerged, right);\n    var tagRefinementsMerged = mergeTagRefinements(hierarchicalFacetsMerged, right);\n    var numericRefinementsMerged = mergeNumericRefinements(tagRefinementsMerged, right);\n    var disjunctiveFacetsRefinementsMerged = mergeDisjunctiveFacetsRefinements(numericRefinementsMerged, right);\n    var facetsExcludesMerged = mergeFacetsExcludes(disjunctiveFacetsRefinementsMerged, right);\n    var facetRefinementsMerged = mergeFacetRefinements(facetsExcludesMerged, right);\n    var disjunctiveFacetsMerged = mergeDisjunctiveFacets(facetRefinementsMerged, right);\n    var ruleContextsMerged = mergeRuleContexts(disjunctiveFacetsMerged, right);\n    var facetsMerged = mergeFacets(ruleContextsMerged, right);\n    return mergeWithRest(facetsMerged, right);\n  });\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (merge);\n\n/***/ }),\n\n/***/ 362:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(313);\n/* harmony import */ var _unescapeRefinement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);\n\n\n\nfunction getRefinement(state, type, attribute, name) {\n  var resultsFacets = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var res = {\n    type: type,\n    attribute: attribute,\n    name: name\n  };\n  var facet = Object(_find__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(resultsFacets, function (resultsFacet) {\n    return resultsFacet.name === attribute;\n  });\n  var count;\n\n  if (type === 'hierarchical') {\n    (function () {\n      var facetDeclaration = state.getHierarchicalFacetByName(attribute);\n      var nameParts = name.split(facetDeclaration.separator);\n\n      var getFacetRefinement = function getFacetRefinement(facetData) {\n        return function (refinementKey) {\n          return facetData[refinementKey];\n        };\n      };\n\n      var _loop = function _loop(i) {\n        facet = facet && facet.data && Object(_find__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(Object.keys(facet.data).map(getFacetRefinement(facet.data)), function (refinement) {\n          return refinement.name === nameParts[i];\n        });\n      };\n\n      for (var i = 0; facet !== undefined && i < nameParts.length; ++i) {\n        _loop(i);\n      }\n\n      count = facet && facet.count;\n    })();\n  } else {\n    count = facet && facet.data && facet.data[res.name];\n  }\n\n  var exhaustive = facet && facet.exhaustive;\n\n  if (count !== undefined) {\n    res.count = count;\n  }\n\n  if (exhaustive !== undefined) {\n    res.exhaustive = exhaustive;\n  }\n\n  return res;\n}\n\nfunction getRefinements(results, state) {\n  var includesQuery = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var refinements = [];\n  var _state$facetsRefineme = state.facetsRefinements,\n      facetsRefinements = _state$facetsRefineme === void 0 ? {} : _state$facetsRefineme,\n      _state$facetsExcludes = state.facetsExcludes,\n      facetsExcludes = _state$facetsExcludes === void 0 ? {} : _state$facetsExcludes,\n      _state$disjunctiveFac = state.disjunctiveFacetsRefinements,\n      disjunctiveFacetsRefinements = _state$disjunctiveFac === void 0 ? {} : _state$disjunctiveFac,\n      _state$hierarchicalFa = state.hierarchicalFacetsRefinements,\n      hierarchicalFacetsRefinements = _state$hierarchicalFa === void 0 ? {} : _state$hierarchicalFa,\n      _state$numericRefinem = state.numericRefinements,\n      numericRefinements = _state$numericRefinem === void 0 ? {} : _state$numericRefinem,\n      _state$tagRefinements = state.tagRefinements,\n      tagRefinements = _state$tagRefinements === void 0 ? [] : _state$tagRefinements;\n  Object.keys(facetsRefinements).forEach(function (attribute) {\n    var refinementNames = facetsRefinements[attribute];\n    refinementNames.forEach(function (refinementName) {\n      refinements.push(getRefinement(state, 'facet', attribute, refinementName, results.facets));\n    });\n  });\n  Object.keys(facetsExcludes).forEach(function (attribute) {\n    var refinementNames = facetsExcludes[attribute];\n    refinementNames.forEach(function (refinementName) {\n      refinements.push({\n        type: 'exclude',\n        attribute: attribute,\n        name: refinementName,\n        exclude: true\n      });\n    });\n  });\n  Object.keys(disjunctiveFacetsRefinements).forEach(function (attribute) {\n    var refinementNames = disjunctiveFacetsRefinements[attribute];\n    refinementNames.forEach(function (refinementName) {\n      refinements.push(getRefinement(state, 'disjunctive', attribute, // We unescape any disjunctive refined values with `unescapeRefinement` because\n      // they can be escaped on negative numeric values with `escapeRefinement`.\n      Object(_unescapeRefinement__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(refinementName), results.disjunctiveFacets));\n    });\n  });\n  Object.keys(hierarchicalFacetsRefinements).forEach(function (attribute) {\n    var refinementNames = hierarchicalFacetsRefinements[attribute];\n    refinementNames.forEach(function (refinement) {\n      refinements.push(getRefinement(state, 'hierarchical', attribute, refinement, results.hierarchicalFacets));\n    });\n  });\n  Object.keys(numericRefinements).forEach(function (attribute) {\n    var operators = numericRefinements[attribute];\n    Object.keys(operators).forEach(function (operatorOriginal) {\n      var operator = operatorOriginal;\n      var valueOrValues = operators[operator];\n      var refinementNames = Array.isArray(valueOrValues) ? valueOrValues : [valueOrValues];\n      refinementNames.forEach(function (refinementName) {\n        refinements.push({\n          type: 'numeric',\n          attribute: attribute,\n          name: \"\".concat(refinementName),\n          numericValue: refinementName,\n          operator: operator\n        });\n      });\n    });\n  });\n  tagRefinements.forEach(function (refinementName) {\n    refinements.push({\n      type: 'tag',\n      attribute: '_tags',\n      name: refinementName\n    });\n  });\n\n  if (includesQuery && state.query && state.query.trim()) {\n    refinements.push({\n      attribute: 'query',\n      type: 'query',\n      name: state.query,\n      query: state.query\n    });\n  }\n\n  return refinements;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (getRefinements);\n\n/***/ }),\n\n/***/ 363:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return createSendEventForFacet; });\n/* harmony import */ var _isFacetRefined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(315);\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n\nfunction createSendEventForFacet(_ref) {\n  var instantSearchInstance = _ref.instantSearchInstance,\n      helper = _ref.helper,\n      attribute = _ref.attribute,\n      widgetType = _ref.widgetType;\n\n  var sendEventForFacet = function sendEventForFacet() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var eventType = args[0],\n        facetValue = args[1],\n        _args$ = args[2],\n        eventName = _args$ === void 0 ? 'Filter Applied' : _args$;\n\n    if (args.length === 1 && _typeof(args[0]) === 'object') {\n      instantSearchInstance.sendEventToInsights(args[0]);\n    } else if (eventType === 'click' && (args.length === 2 || args.length === 3)) {\n      if (!Object(_isFacetRefined__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(helper, attribute, facetValue)) {\n        // send event only when the facet is being checked \"ON\"\n        instantSearchInstance.sendEventToInsights({\n          insightsMethod: 'clickedFilters',\n          widgetType: widgetType,\n          eventType: eventType,\n          payload: {\n            eventName: eventName,\n            index: helper.getIndex(),\n            filters: [\"\".concat(attribute, \":\").concat(facetValue)]\n          },\n          attribute: attribute\n        });\n      }\n    } else if (false) {}\n  };\n\n  return sendEventForFacet;\n}\n\n/***/ }),\n\n/***/ 364:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return createSendEventForHits; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return createBindEventForHits; });\n/* harmony import */ var _lib_utils_serializer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(285);\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n\n\nfunction chunk(arr) {\n  var chunkSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;\n  var chunks = [];\n\n  for (var i = 0; i < Math.ceil(arr.length / chunkSize); i++) {\n    chunks.push(arr.slice(i * chunkSize, (i + 1) * chunkSize));\n  }\n\n  return chunks;\n}\n\nvar buildPayloads = function buildPayloads(_ref) {\n  var index = _ref.index,\n      widgetType = _ref.widgetType,\n      methodName = _ref.methodName,\n      args = _ref.args; // when there's only one argument, that means it's custom\n\n  if (args.length === 1 && _typeof(args[0]) === 'object') {\n    return [args[0]];\n  }\n\n  var eventType = args[0];\n  var hits = args[1];\n  var eventName = args[2];\n\n  if (!hits) {\n    if (false) {} else {\n      return [];\n    }\n  }\n\n  if ((eventType === 'click' || eventType === 'conversion') && !eventName) {\n    if (false) {} else {\n      return [];\n    }\n  }\n\n  var hitsArray = Array.isArray(hits) ? removeEscapedFromHits(hits) : [hits];\n\n  if (hitsArray.length === 0) {\n    return [];\n  }\n\n  var queryID = hitsArray[0].__queryID;\n  var hitsChunks = chunk(hitsArray);\n  var objectIDsByChunk = hitsChunks.map(function (batch) {\n    return batch.map(function (hit) {\n      return hit.objectID;\n    });\n  });\n  var positionsByChunk = hitsChunks.map(function (batch) {\n    return batch.map(function (hit) {\n      return hit.__position;\n    });\n  });\n\n  if (eventType === 'view') {\n    return hitsChunks.map(function (batch, i) {\n      return {\n        insightsMethod: 'viewedObjectIDs',\n        widgetType: widgetType,\n        eventType: eventType,\n        payload: {\n          eventName: eventName || 'Hits Viewed',\n          index: index,\n          objectIDs: objectIDsByChunk[i]\n        },\n        hits: batch\n      };\n    });\n  } else if (eventType === 'click') {\n    return hitsChunks.map(function (batch, i) {\n      return {\n        insightsMethod: 'clickedObjectIDsAfterSearch',\n        widgetType: widgetType,\n        eventType: eventType,\n        payload: {\n          eventName: eventName,\n          index: index,\n          queryID: queryID,\n          objectIDs: objectIDsByChunk[i],\n          positions: positionsByChunk[i]\n        },\n        hits: batch\n      };\n    });\n  } else if (eventType === 'conversion') {\n    return hitsChunks.map(function (batch, i) {\n      return {\n        insightsMethod: 'convertedObjectIDsAfterSearch',\n        widgetType: widgetType,\n        eventType: eventType,\n        payload: {\n          eventName: eventName,\n          index: index,\n          queryID: queryID,\n          objectIDs: objectIDsByChunk[i]\n        },\n        hits: batch\n      };\n    });\n  } else if (false) {} else {\n    return [];\n  }\n};\n\nfunction removeEscapedFromHits(hits) {\n  // remove `hits.__escaped` without mutating\n  return hits.slice();\n}\n\nfunction createSendEventForHits(_ref2) {\n  var instantSearchInstance = _ref2.instantSearchInstance,\n      index = _ref2.index,\n      widgetType = _ref2.widgetType;\n\n  var sendEventForHits = function sendEventForHits() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var payloads = buildPayloads({\n      widgetType: widgetType,\n      index: index,\n      methodName: 'sendEvent',\n      args: args\n    });\n    payloads.forEach(function (payload) {\n      return instantSearchInstance.sendEventToInsights(payload);\n    });\n  };\n\n  return sendEventForHits;\n}\nfunction createBindEventForHits(_ref3) {\n  var index = _ref3.index,\n      widgetType = _ref3.widgetType;\n\n  var bindEventForHits = function bindEventForHits() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    var payloads = buildPayloads({\n      widgetType: widgetType,\n      index: index,\n      methodName: 'bindEvent',\n      args: args\n    });\n    return payloads.length ? \"data-insights-event=\".concat(Object(_lib_utils_serializer__WEBPACK_IMPORTED_MODULE_0__[/* serializePayload */ \"b\"])(payloads)) : '';\n  };\n\n  return bindEventForHits;\n}\n\n/***/ }),\n\n/***/ 365:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return addAbsolutePosition; });\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction addAbsolutePosition(hits, page, hitsPerPage) {\n  return hits.map(function (hit, idx) {\n    return _objectSpread(_objectSpread({}, hit), {}, {\n      __position: hitsPerPage * page + idx + 1\n    });\n  });\n}\n\n/***/ }),\n\n/***/ 366:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return addQueryID; });\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction addQueryID(hits, queryID) {\n  if (!queryID) {\n    return hits;\n  }\n\n  return hits.map(function (hit) {\n    return _objectSpread(_objectSpread({}, hit), {}, {\n      __queryID: queryID\n    });\n  });\n}\n\n/***/ }),\n\n/***/ 367:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction isPrimitive(obj) {\n  return obj !== Object(obj);\n}\n\nfunction isEqual(first, second) {\n  if (first === second) {\n    return true;\n  }\n\n  if (isPrimitive(first) || isPrimitive(second) || typeof first === 'function' || typeof second === 'function') {\n    return first === second;\n  }\n\n  if (Object.keys(first).length !== Object.keys(second).length) {\n    return false;\n  }\n\n  for (var _i = 0, _Object$keys = Object.keys(first); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n\n    if (!(key in second)) {\n      return false;\n    }\n\n    if (!isEqual(first[key], second[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (isEqual);\n\n/***/ }),\n\n/***/ 368:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return convertNumericRefinementsToFilters; });\nfunction convertNumericRefinementsToFilters(state, attribute) {\n  if (!state) {\n    return null;\n  }\n\n  var filtersObj = state.numericRefinements[attribute];\n  /*\n    filtersObj === {\n      \"<=\": [10],\n      \"=\": [],\n      \">=\": [5]\n    }\n  */\n\n  var filters = [];\n  Object.keys(filtersObj).filter(function (operator) {\n    return Array.isArray(filtersObj[operator]) && filtersObj[operator].length > 0;\n  }).forEach(function (operator) {\n    filtersObj[operator].forEach(function (value) {\n      filters.push(\"\".concat(attribute).concat(operator).concat(value));\n    });\n  });\n  return filters;\n}\n\n/***/ }),\n\n/***/ 369:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// This is the `Number.isFinite()` polyfill recommended by MDN.\n// We do not provide any tests for this function.\n// See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\nfunction isFiniteNumber(value) {\n  return typeof value === 'number' && isFinite(value);\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (isFiniteNumber);\n\n/***/ }),\n\n/***/ 370:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction range(_ref) {\n  var _ref$start = _ref.start,\n      start = _ref$start === void 0 ? 0 : _ref$start,\n      end = _ref.end,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 1 : _ref$step; // We can't divide by 0 so we re-assign the step to 1 if it happens.\n\n  var limitStep = step === 0 ? 1 : step; // In some cases the array to create has a decimal length.\n  // We therefore need to round the value.\n  // Example:\n  //   { start: 1, end: 5000, step: 500 }\n  //   => Array length = (5000 - 1) / 500 = 9.998\n\n  var arrayLength = Math.round((end - start) / limitStep);\n  return _toConsumableArray(Array(arrayLength)).map(function (_, current) {\n    return start + current * limitStep;\n  });\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (range);\n\n/***/ }),\n\n/***/ 371:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (toArray);\n\n/***/ }),\n\n/***/ 372:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction escapeRefinement(value) {\n  if (typeof value === 'number' && value < 0) {\n    value = String(value).replace(/^-/, '\\\\-');\n  }\n\n  return value;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (escapeRefinement);\n\n/***/ }),\n\n/***/ 373:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return safelyRunOnBrowser; });\n// eslint-disable-next-line no-restricted-globals\n\n/**\n * Runs code on browser enviromnents safely.\n */\nfunction safelyRunOnBrowser(callback) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    fallback: function fallback() {\n      return undefined;\n    }\n  },\n      fallback = _ref.fallback; // eslint-disable-next-line no-restricted-globals\n\n\n  if (typeof window === 'undefined') {\n    return fallback();\n  } // eslint-disable-next-line no-restricted-globals\n\n\n  return callback({\n    window: window\n  });\n}\n\n/***/ }),\n\n/***/ 374:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction getPropertyByPath(object, path) {\n  var parts = Array.isArray(path) ? path : path.split('.');\n  return parts.reduce(function (current, key) {\n    return current && current[key];\n  }, object);\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (getPropertyByPath);\n\n/***/ }),\n\n/***/ 375:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return createConcurrentSafePromise; });\n// copied from\n// https://github.com/algolia/autocomplete.js/blob/307a7acc4283e10a19cb7d067f04f1bea79dc56f/packages/autocomplete-core/src/utils/createConcurrentSafePromise.ts#L1:L1\n\n/**\n * Creates a runner that executes promises in a concurrent-safe way.\n *\n * This is useful to prevent older promises to resolve after a newer promise,\n * otherwise resulting in stale resolved values.\n */\nfunction createConcurrentSafePromise() {\n  var basePromiseId = -1;\n  var latestResolvedId = -1;\n  var latestResolvedValue = undefined;\n  return function runConcurrentSafePromise(promise) {\n    var currentPromiseId = ++basePromiseId;\n    return Promise.resolve(promise).then(function (x) {\n      // The promise might take too long to resolve and get outdated. This would\n      // result in resolving stale values.\n      // When this happens, we ignore the promise value and return the one\n      // coming from the latest resolved value.\n      //\n      // +----------------------------------+\n      // |        100ms                     |\n      // | run(1) +--->  R1                 |\n      // |        300ms                     |\n      // | run(2) +-------------> R2 (SKIP) |\n      // |        200ms                     |\n      // | run(3) +--------> R3             |\n      // +----------------------------------+\n      if (latestResolvedValue && currentPromiseId < latestResolvedId) {\n        return latestResolvedValue;\n      }\n\n      latestResolvedId = currentPromiseId;\n      latestResolvedValue = x;\n      return x;\n    });\n  };\n}\n\n/***/ }),\n\n/***/ 376:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return debounce; });\n// Debounce a function call to the trailing edge.\n// The debounced function returns a promise.\nfunction debounce(func, wait) {\n  var lastTimeout = null;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return new Promise(function (resolve, reject) {\n      if (lastTimeout) {\n        clearTimeout(lastTimeout);\n      }\n\n      lastTimeout = setTimeout(function () {\n        lastTimeout = null;\n        Promise.resolve(func.apply(void 0, args)).then(resolve).catch(reject);\n      }, wait);\n    });\n  };\n}\n\n/***/ }),\n\n/***/ 377:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return getWidgetAttribute; });\nfunction getWidgetAttribute(widget, initOptions) {\n  var _widget$getWidgetRend;\n\n  var renderState = (_widget$getWidgetRend = widget.getWidgetRenderState) === null || _widget$getWidgetRend === void 0 ? void 0 : _widget$getWidgetRend.call(widget, initOptions);\n  var attribute = null;\n\n  if (renderState && renderState.widgetParams) {\n    // casting as widgetParams is checked just before\n    var widgetParams = renderState.widgetParams;\n\n    if (widgetParams.attribute) {\n      attribute = widgetParams.attribute;\n    } else if (Array.isArray(widgetParams.attributes)) {\n      attribute = widgetParams.attributes[0];\n    }\n  }\n\n  if (typeof attribute !== 'string') {\n    throw new Error(\"Could not find the attribute of the widget:\\n\\n\".concat(JSON.stringify(widget), \"\\n\\nPlease check whether the widget's getWidgetRenderState returns widgetParams.attribute correctly.\"));\n  }\n\n  return attribute;\n}\n\n/***/ }),\n\n/***/ 378:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar nextMicroTask = Promise.resolve();\n\nvar defer = function defer(callback) {\n  var progress = null;\n  var cancelled = false;\n\n  var fn = function fn() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (progress !== null) {\n      return;\n    }\n\n    progress = nextMicroTask.then(function () {\n      progress = null;\n\n      if (cancelled) {\n        cancelled = false;\n        return;\n      }\n\n      callback.apply(void 0, args);\n    });\n  };\n\n  fn.wait = function () {\n    if (progress === null) {\n      throw new Error('The deferred function should be called before calling `wait()`');\n    }\n\n    return progress;\n  };\n\n  fn.cancel = function () {\n    if (progress === null) {\n      return;\n    }\n\n    cancelled = true;\n  };\n\n  return fn;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (defer);\n\n/***/ }),\n\n/***/ 379:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return concatHighlightedParts; });\n/* harmony import */ var _escape_highlight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(264);\n\nfunction concatHighlightedParts(parts) {\n  var highlightPreTag = _escape_highlight__WEBPACK_IMPORTED_MODULE_0__[/* TAG_REPLACEMENT */ \"b\"].highlightPreTag,\n      highlightPostTag = _escape_highlight__WEBPACK_IMPORTED_MODULE_0__[/* TAG_REPLACEMENT */ \"b\"].highlightPostTag;\n  return parts.map(function (part) {\n    return part.isHighlighted ? highlightPreTag + part.value + highlightPostTag : part.value;\n  }).join('');\n}\n\n/***/ }),\n\n/***/ 380:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return getHighlightedParts; });\n/* harmony import */ var _escape_highlight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(264);\n\nfunction getHighlightedParts(highlightedValue) {\n  var highlightPostTag = _escape_highlight__WEBPACK_IMPORTED_MODULE_0__[/* TAG_REPLACEMENT */ \"b\"].highlightPostTag,\n      highlightPreTag = _escape_highlight__WEBPACK_IMPORTED_MODULE_0__[/* TAG_REPLACEMENT */ \"b\"].highlightPreTag;\n  var splitByPreTag = highlightedValue.split(highlightPreTag);\n  var firstValue = splitByPreTag.shift();\n  var elements = !firstValue ? [] : [{\n    value: firstValue,\n    isHighlighted: false\n  }];\n  splitByPreTag.forEach(function (split) {\n    var splitByPostTag = split.split(highlightPostTag);\n    elements.push({\n      value: splitByPostTag[0],\n      isHighlighted: true\n    });\n\n    if (splitByPostTag[1] !== '') {\n      elements.push({\n        value: splitByPostTag[1],\n        isHighlighted: false\n      });\n    }\n  });\n  return elements;\n}\n\n/***/ }),\n\n/***/ 381:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return reverseHighlightedParts; });\n/* harmony import */ var _getHighlightFromSiblings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(321);\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\nfunction reverseHighlightedParts(parts) {\n  if (!parts.some(function (part) {\n    return part.isHighlighted;\n  })) {\n    return parts.map(function (part) {\n      return _objectSpread(_objectSpread({}, part), {}, {\n        isHighlighted: false\n      });\n    });\n  }\n\n  return parts.map(function (part, i) {\n    return _objectSpread(_objectSpread({}, part), {}, {\n      isHighlighted: !Object(_getHighlightFromSiblings__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(parts, i)\n    });\n  });\n}\n\n/***/ }),\n\n/***/ 382:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar resolveSearchParameters = function resolveSearchParameters(current) {\n  var parent = current.getParent();\n  var states = [current.getHelper().state];\n\n  while (parent !== null) {\n    states = [parent.getHelper().state].concat(states);\n    parent = parent.getParent();\n  }\n\n  return states;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (resolveSearchParameters);\n\n/***/ }),\n\n/***/ 383:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isIndexWidget\", function() { return isIndexWidget; });\n/* harmony import */ var algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(195);\n/* harmony import */ var algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(309);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(361);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(382);\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\n\n\nvar withUsage = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_1__[/* createDocumentationMessageGenerator */ \"b\"])({\n  name: 'index-widget'\n});\nfunction isIndexWidget(widget) {\n  return widget.$$type === 'ais.index';\n}\n/**\n * This is the same content as helper._change / setState, but allowing for extra\n * UiState to be synchronized.\n * see: https://github.com/algolia/algoliasearch-helper-js/blob/6b835ffd07742f2d6b314022cce6848f5cfecd4a/src/algoliasearch.helper.js#L1311-L1324\n */\n\nfunction privateHelperSetState(helper, _ref) {\n  var state = _ref.state,\n      isPageReset = _ref.isPageReset,\n      _uiState = _ref._uiState;\n\n  if (state !== helper.state) {\n    helper.state = state;\n    helper.emit('change', {\n      state: helper.state,\n      results: helper.lastResults,\n      isPageReset: isPageReset,\n      _uiState: _uiState\n    });\n  }\n}\n\nfunction getLocalWidgetsUiState(widgets, widgetStateOptions) {\n  var initialUiState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return widgets.reduce(function (uiState, widget) {\n    if (isIndexWidget(widget)) {\n      return uiState;\n    }\n\n    if (!widget.getWidgetUiState && !widget.getWidgetState) {\n      return uiState;\n    }\n\n    if (widget.getWidgetUiState) {\n      return widget.getWidgetUiState(uiState, widgetStateOptions);\n    }\n\n    return widget.getWidgetState(uiState, widgetStateOptions);\n  }, initialUiState);\n}\n\nfunction getLocalWidgetsSearchParameters(widgets, widgetSearchParametersOptions) {\n  var initialSearchParameters = widgetSearchParametersOptions.initialSearchParameters,\n      rest = _objectWithoutProperties(widgetSearchParametersOptions, [\"initialSearchParameters\"]);\n\n  return widgets.filter(function (widget) {\n    return !isIndexWidget(widget);\n  }).reduce(function (state, widget) {\n    if (!widget.getWidgetSearchParameters) {\n      return state;\n    }\n\n    return widget.getWidgetSearchParameters(state, rest);\n  }, initialSearchParameters);\n}\n\nfunction resetPageFromWidgets(widgets) {\n  var indexWidgets = widgets.filter(isIndexWidget);\n\n  if (indexWidgets.length === 0) {\n    return;\n  }\n\n  indexWidgets.forEach(function (widget) {\n    var widgetHelper = widget.getHelper();\n    privateHelperSetState(widgetHelper, {\n      state: widgetHelper.state.resetPage(),\n      isPageReset: true\n    });\n    resetPageFromWidgets(widget.getWidgets());\n  });\n}\n\nfunction resolveScopedResultsFromWidgets(widgets) {\n  var indexWidgets = widgets.filter(isIndexWidget);\n  return indexWidgets.reduce(function (scopedResults, current) {\n    return scopedResults.concat.apply(scopedResults, [{\n      indexId: current.getIndexId(),\n      results: current.getResults(),\n      helper: current.getHelper()\n    }].concat(_toConsumableArray(resolveScopedResultsFromWidgets(current.getWidgets()))));\n  }, []);\n}\n\nvar index = function index(widgetParams) {\n  if (widgetParams === undefined || widgetParams.indexName === undefined) {\n    throw new Error(withUsage('The `indexName` option is required.'));\n  }\n\n  var indexName = widgetParams.indexName,\n      _widgetParams$indexId = widgetParams.indexId,\n      indexId = _widgetParams$indexId === void 0 ? indexName : _widgetParams$indexId;\n  var localWidgets = [];\n  var localUiState = {};\n  var localInstantSearchInstance = null;\n  var localParent = null;\n  var helper = null;\n  var derivedHelper = null;\n  return {\n    $$type: 'ais.index',\n    $$widgetType: 'ais.index',\n    getIndexName: function getIndexName() {\n      return indexName;\n    },\n    getIndexId: function getIndexId() {\n      return indexId;\n    },\n    getHelper: function getHelper() {\n      return helper;\n    },\n    getResults: function getResults() {\n      return derivedHelper && derivedHelper.lastResults;\n    },\n    getScopedResults: function getScopedResults() {\n      var widgetParent = this.getParent(); // If the widget is the root, we consider itself as the only sibling.\n\n      var widgetSiblings = widgetParent ? widgetParent.getWidgets() : [this];\n      return resolveScopedResultsFromWidgets(widgetSiblings);\n    },\n    getParent: function getParent() {\n      return localParent;\n    },\n    createURL: function createURL(nextState) {\n      return localInstantSearchInstance._createURL(_defineProperty({}, indexId, getLocalWidgetsUiState(localWidgets, {\n        searchParameters: nextState,\n        helper: helper\n      })));\n    },\n    getWidgets: function getWidgets() {\n      return localWidgets;\n    },\n    addWidgets: function addWidgets(widgets) {\n      var _this = this;\n\n      if (!Array.isArray(widgets)) {\n        throw new Error(withUsage('The `addWidgets` method expects an array of widgets.'));\n      }\n\n      if (widgets.some(function (widget) {\n        return typeof widget.init !== 'function' && typeof widget.render !== 'function';\n      })) {\n        throw new Error(withUsage('The widget definition expects a `render` and/or an `init` method.'));\n      }\n\n      localWidgets = localWidgets.concat(widgets);\n\n      if (localInstantSearchInstance && Boolean(widgets.length)) {\n        privateHelperSetState(helper, {\n          state: getLocalWidgetsSearchParameters(localWidgets, {\n            uiState: localUiState,\n            initialSearchParameters: helper.state\n          }),\n          _uiState: localUiState\n        }); // We compute the render state before calling `init` in a separate loop\n        // to construct the whole render state object that is then passed to\n        // `init`.\n\n        widgets.forEach(function (widget) {\n          if (widget.getRenderState) {\n            var renderState = widget.getRenderState(localInstantSearchInstance.renderState[_this.getIndexId()] || {}, {\n              uiState: localInstantSearchInstance._initialUiState,\n              helper: _this.getHelper(),\n              parent: _this,\n              instantSearchInstance: localInstantSearchInstance,\n              state: helper.state,\n              renderState: localInstantSearchInstance.renderState,\n              templatesConfig: localInstantSearchInstance.templatesConfig,\n              createURL: _this.createURL,\n              scopedResults: [],\n              searchMetadata: {\n                isSearchStalled: localInstantSearchInstance._isSearchStalled\n              }\n            });\n            storeRenderState({\n              renderState: renderState,\n              instantSearchInstance: localInstantSearchInstance,\n              parent: _this\n            });\n          }\n        });\n        widgets.forEach(function (widget) {\n          if (widget.init) {\n            widget.init({\n              helper: helper,\n              parent: _this,\n              uiState: localInstantSearchInstance._initialUiState,\n              instantSearchInstance: localInstantSearchInstance,\n              state: helper.state,\n              renderState: localInstantSearchInstance.renderState,\n              templatesConfig: localInstantSearchInstance.templatesConfig,\n              createURL: _this.createURL,\n              scopedResults: [],\n              searchMetadata: {\n                isSearchStalled: localInstantSearchInstance._isSearchStalled\n              }\n            });\n          }\n        });\n        localInstantSearchInstance.scheduleSearch();\n      }\n\n      return this;\n    },\n    removeWidgets: function removeWidgets(widgets) {\n      var _this2 = this;\n\n      if (!Array.isArray(widgets)) {\n        throw new Error(withUsage('The `removeWidgets` method expects an array of widgets.'));\n      }\n\n      if (widgets.some(function (widget) {\n        return typeof widget.dispose !== 'function';\n      })) {\n        throw new Error(withUsage('The widget definition expects a `dispose` method.'));\n      }\n\n      localWidgets = localWidgets.filter(function (widget) {\n        return widgets.indexOf(widget) === -1;\n      });\n\n      if (localInstantSearchInstance && Boolean(widgets.length)) {\n        var nextState = widgets.reduce(function (state, widget) {\n          // the `dispose` method exists at this point we already assert it\n          var next = widget.dispose({\n            helper: helper,\n            state: state,\n            parent: _this2\n          });\n          return next || state;\n        }, helper.state);\n        localUiState = getLocalWidgetsUiState(localWidgets, {\n          searchParameters: nextState,\n          helper: helper\n        });\n        helper.setState(getLocalWidgetsSearchParameters(localWidgets, {\n          uiState: localUiState,\n          initialSearchParameters: nextState\n        }));\n\n        if (localWidgets.length) {\n          localInstantSearchInstance.scheduleSearch();\n        }\n      }\n\n      return this;\n    },\n    init: function init(_ref2) {\n      var _this3 = this;\n\n      var instantSearchInstance = _ref2.instantSearchInstance,\n          parent = _ref2.parent,\n          uiState = _ref2.uiState;\n\n      if (helper !== null) {\n        // helper is already initialized, therefore we do not need to set up\n        // any listeners\n        return;\n      }\n\n      localInstantSearchInstance = instantSearchInstance;\n      localParent = parent;\n      localUiState = uiState[indexId] || {}; // The `mainHelper` is already defined at this point. The instance is created\n      // inside InstantSearch at the `start` method, which occurs before the `init`\n      // step.\n\n      var mainHelper = instantSearchInstance.mainHelper;\n      var parameters = getLocalWidgetsSearchParameters(localWidgets, {\n        uiState: localUiState,\n        initialSearchParameters: new algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0___default.a.SearchParameters({\n          index: indexName\n        })\n      }); // This Helper is only used for state management we do not care about the\n      // `searchClient`. Only the \"main\" Helper created at the `InstantSearch`\n      // level is aware of the client.\n\n      helper = algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0___default()({}, parameters.index, parameters); // We forward the call to `search` to the \"main\" instance of the Helper\n      // which is responsible for managing the queries (it's the only one that is\n      // aware of the `searchClient`).\n\n      helper.search = function () {\n        if (instantSearchInstance.onStateChange) {\n          instantSearchInstance.onStateChange({\n            uiState: instantSearchInstance.mainIndex.getWidgetUiState({}),\n            setUiState: instantSearchInstance.setUiState.bind(instantSearchInstance)\n          }); // We don't trigger a search when controlled because it becomes the\n          // responsibility of `setUiState`.\n\n          return mainHelper;\n        }\n\n        return mainHelper.search();\n      };\n\n      helper.searchWithoutTriggeringOnStateChange = function () {\n        return mainHelper.search();\n      }; // We use the same pattern for the `searchForFacetValues`.\n\n\n      helper.searchForFacetValues = function (facetName, facetValue, maxFacetHits, userState) {\n        var state = helper.state.setQueryParameters(userState);\n        return mainHelper.searchForFacetValues(facetName, facetValue, maxFacetHits, state);\n      };\n\n      derivedHelper = mainHelper.derive(function () {\n        return _lib_utils__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"].apply(void 0, _toConsumableArray(Object(_lib_utils__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(_this3)));\n      }); // Subscribe to the Helper state changes for the page before widgets\n      // are initialized. This behavior mimics the original one of the Helper.\n      // It makes sense to replicate it at the `init` step. We have another\n      // listener on `change` below, once `init` is done.\n\n      helper.on('change', function (_ref3) {\n        var isPageReset = _ref3.isPageReset;\n\n        if (isPageReset) {\n          resetPageFromWidgets(localWidgets);\n        }\n      });\n      derivedHelper.on('search', function () {\n        // The index does not manage the \"staleness\" of the search. This is the\n        // responsibility of the main instance. It does not make sense to manage\n        // it at the index level because it's either: all of them or none of them\n        // that are stalled. The queries are performed into a single network request.\n        instantSearchInstance.scheduleStalledRender();\n\n        if (false) {}\n      });\n      derivedHelper.on('result', function (_ref4) {\n        var results = _ref4.results; // The index does not render the results it schedules a new render\n        // to let all the other indices emit their own results. It allows us to\n        // run the render process in one pass.\n\n        instantSearchInstance.scheduleRender(); // the derived helper is the one which actually searches, but the helper\n        // which is exposed e.g. via instance.helper, doesn't search, and thus\n        // does not have access to lastResults, which it used to in pre-federated\n        // search behavior.\n\n        helper.lastResults = results;\n      }); // We compute the render state before calling `init` in a separate loop\n      // to construct the whole render state object that is then passed to\n      // `init`.\n\n      localWidgets.forEach(function (widget) {\n        if (widget.getRenderState) {\n          var renderState = widget.getRenderState(instantSearchInstance.renderState[_this3.getIndexId()] || {}, {\n            uiState: uiState,\n            helper: helper,\n            parent: _this3,\n            instantSearchInstance: instantSearchInstance,\n            state: helper.state,\n            renderState: instantSearchInstance.renderState,\n            templatesConfig: instantSearchInstance.templatesConfig,\n            createURL: _this3.createURL,\n            scopedResults: [],\n            searchMetadata: {\n              isSearchStalled: instantSearchInstance._isSearchStalled\n            }\n          });\n          storeRenderState({\n            renderState: renderState,\n            instantSearchInstance: instantSearchInstance,\n            parent: _this3\n          });\n        }\n      });\n      localWidgets.forEach(function (widget) {\n         false ? undefined : void 0;\n\n        if (widget.init) {\n          widget.init({\n            uiState: uiState,\n            helper: helper,\n            parent: _this3,\n            instantSearchInstance: instantSearchInstance,\n            state: helper.state,\n            renderState: instantSearchInstance.renderState,\n            templatesConfig: instantSearchInstance.templatesConfig,\n            createURL: _this3.createURL,\n            scopedResults: [],\n            searchMetadata: {\n              isSearchStalled: instantSearchInstance._isSearchStalled\n            }\n          });\n        }\n      }); // Subscribe to the Helper state changes for the `uiState` once widgets\n      // are initialized. Until the first render, state changes are part of the\n      // configuration step. This is mainly for backward compatibility with custom\n      // widgets. When the subscription happens before the `init` step, the (static)\n      // configuration of the widget is pushed in the URL. That's what we want to avoid.\n      // https://github.com/algolia/instantsearch.js/pull/994/commits/4a672ae3fd78809e213de0368549ef12e9dc9454\n\n      helper.on('change', function (event) {\n        var state = event.state;\n        var _uiState = event._uiState;\n        localUiState = getLocalWidgetsUiState(localWidgets, {\n          searchParameters: state,\n          helper: helper\n        }, _uiState || {}); // We don't trigger an internal change when controlled because it\n        // becomes the responsibility of `setUiState`.\n\n        if (!instantSearchInstance.onStateChange) {\n          instantSearchInstance.onInternalStateChange();\n        }\n      });\n    },\n    render: function render(_ref5) {\n      var _this4 = this;\n\n      var instantSearchInstance = _ref5.instantSearchInstance;\n\n      if (!this.getResults()) {\n        return;\n      }\n\n      localWidgets.forEach(function (widget) {\n        if (widget.getRenderState) {\n          var renderState = widget.getRenderState(instantSearchInstance.renderState[_this4.getIndexId()] || {}, {\n            helper: _this4.getHelper(),\n            parent: _this4,\n            instantSearchInstance: instantSearchInstance,\n            results: _this4.getResults(),\n            scopedResults: _this4.getScopedResults(),\n            state: _this4.getResults()._state,\n            renderState: instantSearchInstance.renderState,\n            templatesConfig: instantSearchInstance.templatesConfig,\n            createURL: _this4.createURL,\n            searchMetadata: {\n              isSearchStalled: instantSearchInstance._isSearchStalled\n            }\n          });\n          storeRenderState({\n            renderState: renderState,\n            instantSearchInstance: instantSearchInstance,\n            parent: _this4\n          });\n        }\n      });\n      localWidgets.forEach(function (widget) {\n        // At this point, all the variables used below are set. Both `helper`\n        // and `derivedHelper` have been created at the `init` step. The attribute\n        // `lastResults` might be `null` though. It's possible that a stalled render\n        // happens before the result e.g with a dynamically added index the request might\n        // be delayed. The render is triggered for the complete tree but some parts do\n        // not have results yet.\n        if (widget.render) {\n          widget.render({\n            helper: helper,\n            parent: _this4,\n            instantSearchInstance: instantSearchInstance,\n            results: _this4.getResults(),\n            scopedResults: _this4.getScopedResults(),\n            state: _this4.getResults()._state,\n            renderState: instantSearchInstance.renderState,\n            templatesConfig: instantSearchInstance.templatesConfig,\n            createURL: _this4.createURL,\n            searchMetadata: {\n              isSearchStalled: instantSearchInstance._isSearchStalled\n            }\n          });\n        }\n      });\n    },\n    dispose: function dispose() {\n      var _this5 = this;\n\n      localWidgets.forEach(function (widget) {\n        if (widget.dispose) {\n          // The dispose function is always called once the instance is started\n          // (it's an effect of `removeWidgets`). The index is initialized and\n          // the Helper is available. We don't care about the return value of\n          // `dispose` because the index is removed. We can't call `removeWidgets`\n          // because we want to keep the widgets on the instance, to allow idempotent\n          // operations on `add` & `remove`.\n          widget.dispose({\n            helper: helper,\n            state: helper.state,\n            parent: _this5\n          });\n        }\n      });\n      localInstantSearchInstance = null;\n      localParent = null;\n      helper.removeAllListeners();\n      helper = null;\n      derivedHelper.detach();\n      derivedHelper = null;\n    },\n    getWidgetUiState: function getWidgetUiState(uiState) {\n      return localWidgets.filter(isIndexWidget).reduce(function (previousUiState, innerIndex) {\n        return innerIndex.getWidgetUiState(previousUiState);\n      }, _objectSpread(_objectSpread({}, uiState), {}, _defineProperty({}, this.getIndexId(), localUiState)));\n    },\n    getWidgetState: function getWidgetState(uiState) {\n       false ? undefined : void 0;\n      return this.getWidgetUiState(uiState);\n    },\n    getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref6) {\n      var uiState = _ref6.uiState;\n      return getLocalWidgetsSearchParameters(localWidgets, {\n        uiState: uiState,\n        initialSearchParameters: searchParameters\n      });\n    },\n    refreshUiState: function refreshUiState() {\n      localUiState = getLocalWidgetsUiState(localWidgets, {\n        searchParameters: this.getHelper().state,\n        helper: this.getHelper()\n      }, localUiState);\n    }\n  };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n\nfunction storeRenderState(_ref7) {\n  var renderState = _ref7.renderState,\n      instantSearchInstance = _ref7.instantSearchInstance,\n      parent = _ref7.parent;\n  var parentIndexName = parent ? parent.getIndexId() : instantSearchInstance.mainIndex.getIndexId();\n  instantSearchInstance.renderState = _objectSpread(_objectSpread({}, instantSearchInstance.renderState), {}, _defineProperty({}, parentIndexName, _objectSpread(_objectSpread({}, instantSearchInstance.renderState[parentIndexName]), renderState)));\n}\n\n/***/ }),\n\n/***/ 384:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = ('4.33.1');\n\n/***/ }),\n\n/***/ 385:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(386);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_utils__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _utils__WEBPACK_IMPORTED_MODULE_0__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _utils__WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _algoliasearch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(387);\n/* harmony import */ var _algoliasearch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_algoliasearch__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _algoliasearch__WEBPACK_IMPORTED_MODULE_1__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _algoliasearch__WEBPACK_IMPORTED_MODULE_1__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _results__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(388);\n/* harmony import */ var _results__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_results__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _results__WEBPACK_IMPORTED_MODULE_2__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _results__WEBPACK_IMPORTED_MODULE_2__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(389);\n/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_component__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _component__WEBPACK_IMPORTED_MODULE_3__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _component__WEBPACK_IMPORTED_MODULE_3__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _instantsearch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(390);\n/* harmony import */ var _instantsearch__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_instantsearch__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _instantsearch__WEBPACK_IMPORTED_MODULE_4__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _instantsearch__WEBPACK_IMPORTED_MODULE_4__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _middleware__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(391);\n/* harmony import */ var _middleware__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_middleware__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _middleware__WEBPACK_IMPORTED_MODULE_5__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _middleware__WEBPACK_IMPORTED_MODULE_5__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(392);\n/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_router__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _router__WEBPACK_IMPORTED_MODULE_6__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _router__WEBPACK_IMPORTED_MODULE_6__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _insights__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(393);\n/* harmony import */ var _insights__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_insights__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _insights__WEBPACK_IMPORTED_MODULE_7__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _insights__WEBPACK_IMPORTED_MODULE_7__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _connector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(394);\n/* harmony import */ var _connector__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_connector__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _connector__WEBPACK_IMPORTED_MODULE_8__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _connector__WEBPACK_IMPORTED_MODULE_8__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _widget_factory__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(395);\n/* harmony import */ var _widget_factory__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_widget_factory__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _widget_factory__WEBPACK_IMPORTED_MODULE_9__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _widget_factory__WEBPACK_IMPORTED_MODULE_9__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(396);\n/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_widget__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _widget__WEBPACK_IMPORTED_MODULE_10__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _widget__WEBPACK_IMPORTED_MODULE_10__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _ui_state__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(397);\n/* harmony import */ var _ui_state__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_ui_state__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _ui_state__WEBPACK_IMPORTED_MODULE_11__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _ui_state__WEBPACK_IMPORTED_MODULE_11__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(398);\n/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_render_state__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _render_state__WEBPACK_IMPORTED_MODULE_12__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _render_state__WEBPACK_IMPORTED_MODULE_12__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _templates__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(399);\n/* harmony import */ var _templates__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_templates__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _templates__WEBPACK_IMPORTED_MODULE_13__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _templates__WEBPACK_IMPORTED_MODULE_13__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n// internal\n // Algolia-related\n\n\n // component-related\n\n // instantsearch-related\n\n\n\n\n // widget-related\n\n\n\n\n\n\n\n\n/***/ }),\n\n/***/ 386:\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n\n/***/ 387:\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n\n/***/ 388:\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n\n/***/ 389:\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n\n/***/ 390:\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n\n/***/ 391:\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n\n/***/ 392:\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n\n/***/ 393:\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n\n/***/ 394:\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n\n/***/ 395:\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n\n/***/ 396:\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n\n/***/ 397:\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n\n/***/ 398:\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n\n/***/ 399:\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n\n/***/ 400:\n/***/ (function(module, exports) {\n\n// Exports\nmodule.exports = {\n\n};\n\n\n/***/ }),\n\n/***/ 411:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"connectClearRefinements\", function() { return /* reexport */ clear_refinements_connectClearRefinements; });\n__webpack_require__.d(__webpack_exports__, \"connectCurrentRefinements\", function() { return /* reexport */ current_refinements_connectCurrentRefinements; });\n__webpack_require__.d(__webpack_exports__, \"connectHierarchicalMenu\", function() { return /* reexport */ hierarchical_menu_connectHierarchicalMenu; });\n__webpack_require__.d(__webpack_exports__, \"connectHits\", function() { return /* reexport */ hits_connectHits; });\n__webpack_require__.d(__webpack_exports__, \"connectHitsWithInsights\", function() { return /* reexport */ hits_connectHitsWithInsights; });\n__webpack_require__.d(__webpack_exports__, \"connectHitsPerPage\", function() { return /* reexport */ hits_per_page_connectHitsPerPage; });\n__webpack_require__.d(__webpack_exports__, \"connectInfiniteHits\", function() { return /* reexport */ connectInfiniteHits[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"connectInfiniteHitsWithInsights\", function() { return /* reexport */ infinite_hits_connectInfiniteHitsWithInsights; });\n__webpack_require__.d(__webpack_exports__, \"connectMenu\", function() { return /* reexport */ menu_connectMenu; });\n__webpack_require__.d(__webpack_exports__, \"connectNumericMenu\", function() { return /* reexport */ numeric_menu_connectNumericMenu; });\n__webpack_require__.d(__webpack_exports__, \"connectPagination\", function() { return /* reexport */ pagination_connectPagination; });\n__webpack_require__.d(__webpack_exports__, \"connectRange\", function() { return /* reexport */ range_connectRange; });\n__webpack_require__.d(__webpack_exports__, \"connectRefinementList\", function() { return /* reexport */ refinement_list_connectRefinementList; });\n__webpack_require__.d(__webpack_exports__, \"connectSearchBox\", function() { return /* reexport */ search_box_connectSearchBox; });\n__webpack_require__.d(__webpack_exports__, \"connectSortBy\", function() { return /* reexport */ sort_by_connectSortBy; });\n__webpack_require__.d(__webpack_exports__, \"connectRatingMenu\", function() { return /* reexport */ rating_menu_connectRatingMenu; });\n__webpack_require__.d(__webpack_exports__, \"connectStats\", function() { return /* reexport */ stats_connectStats; });\n__webpack_require__.d(__webpack_exports__, \"connectToggleRefinement\", function() { return /* reexport */ toggle_refinement_connectToggleRefinement; });\n__webpack_require__.d(__webpack_exports__, \"connectBreadcrumb\", function() { return /* reexport */ breadcrumb_connectBreadcrumb; });\n__webpack_require__.d(__webpack_exports__, \"connectGeoSearch\", function() { return /* reexport */ geo_search_connectGeoSearch; });\n__webpack_require__.d(__webpack_exports__, \"connectPoweredBy\", function() { return /* reexport */ powered_by_connectPoweredBy; });\n__webpack_require__.d(__webpack_exports__, \"connectConfigure\", function() { return /* reexport */ configure_connectConfigure; });\n__webpack_require__.d(__webpack_exports__, \"EXPERIMENTAL_connectConfigureRelatedItems\", function() { return /* reexport */ configure_related_items_connectConfigureRelatedItems; });\n__webpack_require__.d(__webpack_exports__, \"connectAutocomplete\", function() { return /* reexport */ autocomplete_connectAutocomplete; });\n__webpack_require__.d(__webpack_exports__, \"connectQueryRules\", function() { return /* reexport */ query_rules_connectQueryRules; });\n__webpack_require__.d(__webpack_exports__, \"connectVoiceSearch\", function() { return /* reexport */ voice_search_connectVoiceSearch; });\n__webpack_require__.d(__webpack_exports__, \"EXPERIMENTAL_connectAnswers\", function() { return /* reexport */ answers_connectAnswers; });\n__webpack_require__.d(__webpack_exports__, \"connectRelevantSort\", function() { return /* reexport */ relevant_sort_connectRelevantSort; });\n__webpack_require__.d(__webpack_exports__, \"connectDynamicWidgets\", function() { return /* reexport */ dynamic_widgets_connectDynamicWidgets; });\n__webpack_require__.d(__webpack_exports__, \"EXPERIMENTAL_connectDynamicWidgets\", function() { return /* binding */ EXPERIMENTAL_connectDynamicWidgets; });\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/documentation.js\nvar documentation = __webpack_require__(309);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/noop.js\nvar noop = __webpack_require__(310);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/checkRendering.js\nvar checkRendering = __webpack_require__(359);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/clearRefinements.js\nvar clearRefinements = __webpack_require__(360);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/mergeSearchParameters.js\nvar mergeSearchParameters = __webpack_require__(361);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/uniq.js\nvar uniq = __webpack_require__(284);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getRefinements.js\nvar getRefinements = __webpack_require__(362);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/clear-refinements/connectClearRefinements.js\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\nvar withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'clear-refinements',\n  connector: true\n});\n\nvar connectClearRefinements_connectClearRefinements = function connectClearRefinements(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, withUsage());\n  return function (widgetParams) {\n    var _ref = widgetParams || {},\n        _ref$includedAttribut = _ref.includedAttributes,\n        includedAttributes = _ref$includedAttribut === void 0 ? [] : _ref$includedAttribut,\n        _ref$excludedAttribut = _ref.excludedAttributes,\n        excludedAttributes = _ref$excludedAttribut === void 0 ? ['query'] : _ref$excludedAttribut,\n        _ref$transformItems = _ref.transformItems,\n        transformItems = _ref$transformItems === void 0 ? function (items) {\n      return items;\n    } : _ref$transformItems;\n\n    if (widgetParams && widgetParams.includedAttributes && widgetParams.excludedAttributes) {\n      throw new Error(withUsage('The options `includedAttributes` and `excludedAttributes` cannot be used together.'));\n    }\n\n    var connectorState = {\n      refine: noop[\"a\" /* default */],\n      createURL: function createURL() {\n        return '';\n      },\n      attributesToClear: []\n    };\n\n    var cachedRefine = function cachedRefine() {\n      return connectorState.refine();\n    };\n\n    var cachedCreateURL = function cachedCreateURL() {\n      return connectorState.createURL();\n    };\n\n    return {\n      $$type: 'ais.clearRefinements',\n      init: function init(initOptions) {\n        var instantSearchInstance = initOptions.instantSearchInstance;\n        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      dispose: function dispose() {\n        unmountFn();\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return _objectSpread(_objectSpread({}, renderState), {}, {\n          clearRefinements: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref2) {\n        var createURL = _ref2.createURL,\n            scopedResults = _ref2.scopedResults;\n        connectorState.attributesToClear = scopedResults.reduce(function (results, scopedResult) {\n          return results.concat(getAttributesToClear({\n            scopedResult: scopedResult,\n            includedAttributes: includedAttributes,\n            excludedAttributes: excludedAttributes,\n            transformItems: transformItems\n          }));\n        }, []);\n\n        connectorState.refine = function () {\n          connectorState.attributesToClear.forEach(function (_ref3) {\n            var indexHelper = _ref3.helper,\n                items = _ref3.items;\n            indexHelper.setState(Object(clearRefinements[\"a\" /* default */])({\n              helper: indexHelper,\n              attributesToClear: items\n            })).search();\n          });\n        };\n\n        connectorState.createURL = function () {\n          return createURL(mergeSearchParameters[\"a\" /* default */].apply(void 0, _toConsumableArray(connectorState.attributesToClear.map(function (_ref4) {\n            var indexHelper = _ref4.helper,\n                items = _ref4.items;\n            return Object(clearRefinements[\"a\" /* default */])({\n              helper: indexHelper,\n              attributesToClear: items\n            });\n          }))));\n        };\n\n        var canRefine = connectorState.attributesToClear.some(function (attributeToClear) {\n          return attributeToClear.items.length > 0;\n        });\n        return {\n          canRefine: canRefine,\n          hasRefinements: canRefine,\n          refine: cachedRefine,\n          createURL: cachedCreateURL,\n          widgetParams: widgetParams\n        };\n      }\n    };\n  };\n};\n\nfunction getAttributesToClear(_ref5) {\n  var scopedResult = _ref5.scopedResult,\n      includedAttributes = _ref5.includedAttributes,\n      excludedAttributes = _ref5.excludedAttributes,\n      transformItems = _ref5.transformItems;\n  var includesQuery = includedAttributes.indexOf('query') !== -1 || excludedAttributes.indexOf('query') === -1;\n  return {\n    helper: scopedResult.helper,\n    items: transformItems(Object(uniq[\"a\" /* default */])(Object(getRefinements[\"a\" /* default */])(scopedResult.results, scopedResult.helper.state, includesQuery).map(function (refinement) {\n      return refinement.attribute;\n    }).filter(function (attribute) {\n      return (// If the array is empty (default case), we keep all the attributes\n        includedAttributes.length === 0 || // Otherwise, only add the specified attributes\n        includedAttributes.indexOf(attribute) !== -1\n      );\n    }).filter(function (attribute) {\n      return (// If the query is included, we ignore the default `excludedAttributes = ['query']`\n        attribute === 'query' && includesQuery || // Otherwise, ignore the excluded attributes\n        excludedAttributes.indexOf(attribute) === -1\n      );\n    })))\n  };\n}\n\n/* harmony default export */ var clear_refinements_connectClearRefinements = (connectClearRefinements_connectClearRefinements);\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/current-refinements/connectCurrentRefinements.js\nfunction connectCurrentRefinements_toConsumableArray(arr) {\n  return connectCurrentRefinements_arrayWithoutHoles(arr) || connectCurrentRefinements_iterableToArray(arr) || connectCurrentRefinements_unsupportedIterableToArray(arr) || connectCurrentRefinements_nonIterableSpread();\n}\n\nfunction connectCurrentRefinements_nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction connectCurrentRefinements_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return connectCurrentRefinements_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return connectCurrentRefinements_arrayLikeToArray(o, minLen);\n}\n\nfunction connectCurrentRefinements_iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction connectCurrentRefinements_arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return connectCurrentRefinements_arrayLikeToArray(arr);\n}\n\nfunction connectCurrentRefinements_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction connectCurrentRefinements_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectCurrentRefinements_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectCurrentRefinements_ownKeys(Object(source), true).forEach(function (key) {\n        connectCurrentRefinements_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectCurrentRefinements_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectCurrentRefinements_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\nvar connectCurrentRefinements_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'current-refinements',\n  connector: true\n});\n\nvar connectCurrentRefinements_connectCurrentRefinements = function connectCurrentRefinements(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectCurrentRefinements_withUsage());\n  return function (widgetParams) {\n    if ((widgetParams || {}).includedAttributes && (widgetParams || {}).excludedAttributes) {\n      throw new Error(connectCurrentRefinements_withUsage('The options `includedAttributes` and `excludedAttributes` cannot be used together.'));\n    }\n\n    var _ref = widgetParams || {},\n        includedAttributes = _ref.includedAttributes,\n        _ref$excludedAttribut = _ref.excludedAttributes,\n        excludedAttributes = _ref$excludedAttribut === void 0 ? ['query'] : _ref$excludedAttribut,\n        _ref$transformItems = _ref.transformItems,\n        transformItems = _ref$transformItems === void 0 ? function (items) {\n      return items;\n    } : _ref$transformItems;\n\n    return {\n      $$type: 'ais.currentRefinements',\n      init: function init(initOptions) {\n        var instantSearchInstance = initOptions.instantSearchInstance;\n        renderFn(connectCurrentRefinements_objectSpread(connectCurrentRefinements_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n        renderFn(connectCurrentRefinements_objectSpread(connectCurrentRefinements_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      dispose: function dispose() {\n        unmountFn();\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectCurrentRefinements_objectSpread(connectCurrentRefinements_objectSpread({}, renderState), {}, {\n          currentRefinements: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref2) {\n        var results = _ref2.results,\n            scopedResults = _ref2.scopedResults,\n            _createURL = _ref2.createURL,\n            helper = _ref2.helper;\n\n        function getItems() {\n          if (!results) {\n            return transformItems(getRefinementsItems({\n              results: {},\n              helper: helper,\n              includedAttributes: includedAttributes,\n              excludedAttributes: excludedAttributes\n            }));\n          }\n\n          return scopedResults.reduce(function (accResults, scopedResult) {\n            return accResults.concat(transformItems(getRefinementsItems({\n              results: scopedResult.results,\n              helper: scopedResult.helper,\n              includedAttributes: includedAttributes,\n              excludedAttributes: excludedAttributes\n            })));\n          }, []);\n        }\n\n        var items = getItems();\n        return {\n          items: items,\n          canRefine: items.length > 0,\n          refine: function refine(refinement) {\n            return clearRefinement(helper, refinement);\n          },\n          createURL: function createURL(refinement) {\n            return _createURL(clearRefinementFromState(helper.state, refinement));\n          },\n          widgetParams: widgetParams\n        };\n      }\n    };\n  };\n};\n\nfunction getRefinementsItems(_ref3) {\n  var results = _ref3.results,\n      helper = _ref3.helper,\n      includedAttributes = _ref3.includedAttributes,\n      excludedAttributes = _ref3.excludedAttributes;\n  var includesQuery = (includedAttributes || []).indexOf('query') !== -1 || (excludedAttributes || []).indexOf('query') === -1;\n  var filterFunction = includedAttributes ? function (item) {\n    return includedAttributes.indexOf(item.attribute) !== -1;\n  } : function (item) {\n    return excludedAttributes.indexOf(item.attribute) === -1;\n  };\n  var items = Object(getRefinements[\"a\" /* default */])(results, helper.state, includesQuery).map(normalizeRefinement).filter(filterFunction);\n  return items.reduce(function (allItems, currentItem) {\n    return [].concat(connectCurrentRefinements_toConsumableArray(allItems.filter(function (item) {\n      return item.attribute !== currentItem.attribute;\n    })), [{\n      indexName: helper.state.index,\n      attribute: currentItem.attribute,\n      label: currentItem.attribute,\n      refinements: items.filter(function (result) {\n        return result.attribute === currentItem.attribute;\n      }) // We want to keep the order of refinements except the numeric ones.\n      .sort(function (a, b) {\n        return a.type === 'numeric' ? a.value - b.value : 0;\n      }),\n      refine: function refine(refinement) {\n        return clearRefinement(helper, refinement);\n      }\n    }]);\n  }, []);\n}\n\nfunction clearRefinementFromState(state, refinement) {\n  switch (refinement.type) {\n    case 'facet':\n      return state.removeFacetRefinement(refinement.attribute, String(refinement.value));\n\n    case 'disjunctive':\n      return state.removeDisjunctiveFacetRefinement(refinement.attribute, String(refinement.value));\n\n    case 'hierarchical':\n      return state.removeHierarchicalFacetRefinement(refinement.attribute);\n\n    case 'exclude':\n      return state.removeExcludeRefinement(refinement.attribute, String(refinement.value));\n\n    case 'numeric':\n      return state.removeNumericRefinement(refinement.attribute, refinement.operator, String(refinement.value));\n\n    case 'tag':\n      return state.removeTagRefinement(String(refinement.value));\n\n    case 'query':\n      return state.setQueryParameter('query', '');\n\n    default:\n       false ? undefined : void 0;\n      return state;\n  }\n}\n\nfunction clearRefinement(helper, refinement) {\n  helper.setState(clearRefinementFromState(helper.state, refinement)).search();\n}\n\nfunction getOperatorSymbol(operator) {\n  switch (operator) {\n    case '>=':\n      return '≥';\n\n    case '<=':\n      return '≤';\n\n    default:\n      return operator;\n  }\n}\n\nfunction normalizeRefinement(refinement) {\n  var value = refinement.type === 'numeric' ? Number(refinement.name) : refinement.name;\n  var label = refinement.operator ? \"\".concat(getOperatorSymbol(refinement.operator), \" \").concat(refinement.name) : refinement.name;\n  var normalizedRefinement = {\n    attribute: refinement.attribute,\n    type: refinement.type,\n    value: value,\n    label: label\n  };\n\n  if (refinement.operator !== undefined) {\n    normalizedRefinement.operator = refinement.operator;\n  }\n\n  if (refinement.count !== undefined) {\n    normalizedRefinement.count = refinement.count;\n  }\n\n  if (refinement.exhaustive !== undefined) {\n    normalizedRefinement.exhaustive = refinement.exhaustive;\n  }\n\n  return normalizedRefinement;\n}\n\n/* harmony default export */ var current_refinements_connectCurrentRefinements = (connectCurrentRefinements_connectCurrentRefinements);\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/createSendEventForFacet.js\nvar createSendEventForFacet = __webpack_require__(363);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/hierarchical-menu/connectHierarchicalMenu.js\nfunction connectHierarchicalMenu_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectHierarchicalMenu_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectHierarchicalMenu_ownKeys(Object(source), true).forEach(function (key) {\n        connectHierarchicalMenu_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectHierarchicalMenu_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectHierarchicalMenu_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || connectHierarchicalMenu_unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction connectHierarchicalMenu_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return connectHierarchicalMenu_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return connectHierarchicalMenu_arrayLikeToArray(o, minLen);\n}\n\nfunction connectHierarchicalMenu_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\n\nvar connectHierarchicalMenu_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'hierarchical-menu',\n  connector: true\n});\nvar DEFAULT_SORT = ['name:asc'];\n/**\n * **HierarchicalMenu** connector provides the logic to build a custom widget\n * that will give the user the ability to explore facets in a tree-like structure.\n *\n * This is commonly used for multi-level categorization of products on e-commerce\n * websites. From a UX point of view, we suggest not displaying more than two\n * levels deep.\n *\n * @type {Connector}\n * @param {function(HierarchicalMenuRenderingOptions, boolean)} renderFn Rendering function for the custom **HierarchicalMenu** widget.\n * @param {function} unmountFn Unmount function called when the widget is disposed.\n * @return {function(CustomHierarchicalMenuWidgetParams)} Re-usable widget factory for a custom **HierarchicalMenu** widget.\n */\n\nvar connectHierarchicalMenu_connectHierarchicalMenu = function connectHierarchicalMenu(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectHierarchicalMenu_withUsage());\n  return function (widgetParams) {\n    var _ref = widgetParams || {},\n        attributes = _ref.attributes,\n        _ref$separator = _ref.separator,\n        separator = _ref$separator === void 0 ? ' > ' : _ref$separator,\n        _ref$rootPath = _ref.rootPath,\n        rootPath = _ref$rootPath === void 0 ? null : _ref$rootPath,\n        _ref$showParentLevel = _ref.showParentLevel,\n        showParentLevel = _ref$showParentLevel === void 0 ? true : _ref$showParentLevel,\n        _ref$limit = _ref.limit,\n        limit = _ref$limit === void 0 ? 10 : _ref$limit,\n        _ref$showMore = _ref.showMore,\n        showMore = _ref$showMore === void 0 ? false : _ref$showMore,\n        _ref$showMoreLimit = _ref.showMoreLimit,\n        showMoreLimit = _ref$showMoreLimit === void 0 ? 20 : _ref$showMoreLimit,\n        _ref$sortBy = _ref.sortBy,\n        sortBy = _ref$sortBy === void 0 ? DEFAULT_SORT : _ref$sortBy,\n        _ref$transformItems = _ref.transformItems,\n        transformItems = _ref$transformItems === void 0 ? function (items) {\n      return items;\n    } : _ref$transformItems;\n\n    if (!attributes || !Array.isArray(attributes) || attributes.length === 0) {\n      throw new Error(connectHierarchicalMenu_withUsage('The `attributes` option expects an array of strings.'));\n    }\n\n    if (showMore === true && showMoreLimit <= limit) {\n      throw new Error(connectHierarchicalMenu_withUsage('The `showMoreLimit` option must be greater than `limit`.'));\n    } // we need to provide a hierarchicalFacet name for the search state\n    // so that we can always map $hierarchicalFacetName => real attributes\n    // we use the first attribute name\n\n\n    var _attributes = _slicedToArray(attributes, 1),\n        hierarchicalFacetName = _attributes[0];\n\n    var sendEvent; // Provide the same function to the `renderFn` so that way the user\n    // has to only bind it once when `isFirstRendering` for instance\n\n    var toggleShowMore = function toggleShowMore() {};\n\n    function cachedToggleShowMore() {\n      toggleShowMore();\n    }\n\n    var _refine;\n\n    var isShowingMore = false;\n\n    function createToggleShowMore(renderOptions, widget) {\n      return function () {\n        isShowingMore = !isShowingMore;\n        widget.render(renderOptions);\n      };\n    }\n\n    function getLimit() {\n      return isShowingMore ? showMoreLimit : limit;\n    }\n\n    function _prepareFacetValues(facetValues) {\n      return facetValues.slice(0, getLimit()).map(function (_ref2) {\n        var label = _ref2.name,\n            value = _ref2.path,\n            data = _ref2.data,\n            subValue = _objectWithoutProperties(_ref2, [\"name\", \"path\", \"data\"]);\n\n        var item = connectHierarchicalMenu_objectSpread(connectHierarchicalMenu_objectSpread({}, subValue), {}, {\n          label: label,\n          value: value,\n          data: null\n        });\n\n        if (Array.isArray(data)) {\n          item.data = _prepareFacetValues(data);\n        }\n\n        return item;\n      });\n    }\n\n    return {\n      $$type: 'ais.hierarchicalMenu',\n      init: function init(initOptions) {\n        var instantSearchInstance = initOptions.instantSearchInstance;\n        renderFn(connectHierarchicalMenu_objectSpread(connectHierarchicalMenu_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n        toggleShowMore = createToggleShowMore(renderOptions, this);\n        renderFn(connectHierarchicalMenu_objectSpread(connectHierarchicalMenu_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      dispose: function dispose(_ref3) {\n        var state = _ref3.state;\n        unmountFn();\n        return state.removeHierarchicalFacet(hierarchicalFacetName).setQueryParameter('maxValuesPerFacet', undefined);\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectHierarchicalMenu_objectSpread(connectHierarchicalMenu_objectSpread({}, renderState), {}, {\n          hierarchicalMenu: connectHierarchicalMenu_objectSpread(connectHierarchicalMenu_objectSpread({}, renderState.hierarchicalMenu), {}, connectHierarchicalMenu_defineProperty({}, hierarchicalFacetName, this.getWidgetRenderState(renderOptions)))\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref4) {\n        var results = _ref4.results,\n            state = _ref4.state,\n            createURL = _ref4.createURL,\n            instantSearchInstance = _ref4.instantSearchInstance,\n            helper = _ref4.helper;\n        var items = [];\n        var canToggleShowMore = false; // Bind createURL to this specific attribute\n\n        function _createURL(facetValue) {\n          return createURL(state.resetPage().toggleFacetRefinement(hierarchicalFacetName, facetValue));\n        }\n\n        if (!sendEvent) {\n          sendEvent = Object(createSendEventForFacet[\"a\" /* createSendEventForFacet */])({\n            instantSearchInstance: instantSearchInstance,\n            helper: helper,\n            attribute: hierarchicalFacetName,\n            widgetType: this.$$type\n          });\n        }\n\n        if (!_refine) {\n          _refine = function _refine(facetValue) {\n            sendEvent('click', facetValue);\n            helper.toggleFacetRefinement(hierarchicalFacetName, facetValue).search();\n          };\n        }\n\n        if (results) {\n          var facetValues = results.getFacetValues(hierarchicalFacetName, {\n            sortBy: sortBy,\n            facetOrdering: sortBy === DEFAULT_SORT\n          });\n          var facetItems = facetValues && !Array.isArray(facetValues) && facetValues.data ? facetValues.data : []; // If the limit is the max number of facet retrieved it is impossible to know\n          // if the facets are exhaustive. The only moment we are sure it is exhaustive\n          // is when it is strictly under the number requested unless we know that another\n          // widget has requested more values (maxValuesPerFacet > getLimit()).\n          // Because this is used for making the search of facets unable or not, it is important\n          // to be conservative here.\n\n          var hasExhaustiveItems = (state.maxValuesPerFacet || 0) > getLimit() ? facetItems.length <= getLimit() : facetItems.length < getLimit();\n          canToggleShowMore = showMore && (isShowingMore || !hasExhaustiveItems);\n          items = transformItems(_prepareFacetValues(facetItems));\n        }\n\n        return {\n          items: items,\n          refine: _refine,\n          canRefine: items.length > 0,\n          createURL: _createURL,\n          sendEvent: sendEvent,\n          widgetParams: widgetParams,\n          isShowingMore: isShowingMore,\n          toggleShowMore: cachedToggleShowMore,\n          canToggleShowMore: canToggleShowMore\n        };\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref5) {\n        var searchParameters = _ref5.searchParameters;\n        var path = searchParameters.getHierarchicalFacetBreadcrumb(hierarchicalFacetName);\n\n        if (!path.length) {\n          return uiState;\n        }\n\n        return connectHierarchicalMenu_objectSpread(connectHierarchicalMenu_objectSpread({}, uiState), {}, {\n          hierarchicalMenu: connectHierarchicalMenu_objectSpread(connectHierarchicalMenu_objectSpread({}, uiState.hierarchicalMenu), {}, connectHierarchicalMenu_defineProperty({}, hierarchicalFacetName, path))\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref6) {\n        var uiState = _ref6.uiState;\n        var values = uiState.hierarchicalMenu && uiState.hierarchicalMenu[hierarchicalFacetName];\n\n        if (searchParameters.isHierarchicalFacet(hierarchicalFacetName)) {\n          var facet = searchParameters.getHierarchicalFacetByName(hierarchicalFacetName);\n           false ? undefined : void 0;\n        }\n\n        var withFacetConfiguration = searchParameters.removeHierarchicalFacet(hierarchicalFacetName).addHierarchicalFacet({\n          name: hierarchicalFacetName,\n          attributes: attributes,\n          separator: separator,\n          rootPath: rootPath,\n          showParentLevel: showParentLevel\n        });\n        var currentMaxValuesPerFacet = withFacetConfiguration.maxValuesPerFacet || 0;\n        var nextMaxValuesPerFacet = Math.max(currentMaxValuesPerFacet, showMore ? showMoreLimit : limit);\n        var withMaxValuesPerFacet = withFacetConfiguration.setQueryParameter('maxValuesPerFacet', nextMaxValuesPerFacet);\n\n        if (!values) {\n          return withMaxValuesPerFacet.setQueryParameters({\n            hierarchicalFacetsRefinements: connectHierarchicalMenu_objectSpread(connectHierarchicalMenu_objectSpread({}, withMaxValuesPerFacet.hierarchicalFacetsRefinements), {}, connectHierarchicalMenu_defineProperty({}, hierarchicalFacetName, []))\n          });\n        }\n\n        return withMaxValuesPerFacet.addHierarchicalFacetRefinement(hierarchicalFacetName, values.join(separator));\n      }\n    };\n  };\n};\n\n/* harmony default export */ var hierarchical_menu_connectHierarchicalMenu = (connectHierarchicalMenu_connectHierarchicalMenu);\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/createSendEventForHits.js\nvar createSendEventForHits = __webpack_require__(364);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/escape-highlight.js\nvar escape_highlight = __webpack_require__(264);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/hits-absolute-position.js\nvar hits_absolute_position = __webpack_require__(365);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/hits-query-id.js\nvar hits_query_id = __webpack_require__(366);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/hits/connectHits.js\nfunction connectHits_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectHits_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectHits_ownKeys(Object(source), true).forEach(function (key) {\n        connectHits_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectHits_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectHits_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\nvar connectHits_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'hits',\n  connector: true\n});\n\nvar connectHits_connectHits = function connectHits(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectHits_withUsage());\n  return function (widgetParams) {\n    var _ref = widgetParams || {},\n        _ref$escapeHTML = _ref.escapeHTML,\n        escapeHTML = _ref$escapeHTML === void 0 ? true : _ref$escapeHTML,\n        _ref$transformItems = _ref.transformItems,\n        transformItems = _ref$transformItems === void 0 ? function (items) {\n      return items;\n    } : _ref$transformItems;\n\n    var sendEvent;\n    var bindEvent;\n    return {\n      $$type: 'ais.hits',\n      init: function init(initOptions) {\n        renderFn(connectHits_objectSpread(connectHits_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: initOptions.instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var renderState = this.getWidgetRenderState(renderOptions);\n        renderState.sendEvent('view', renderState.hits);\n        renderFn(connectHits_objectSpread(connectHits_objectSpread({}, renderState), {}, {\n          instantSearchInstance: renderOptions.instantSearchInstance\n        }), false);\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectHits_objectSpread(connectHits_objectSpread({}, renderState), {}, {\n          hits: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref2) {\n        var results = _ref2.results,\n            helper = _ref2.helper,\n            instantSearchInstance = _ref2.instantSearchInstance;\n\n        if (!sendEvent) {\n          sendEvent = Object(createSendEventForHits[\"b\" /* createSendEventForHits */])({\n            instantSearchInstance: instantSearchInstance,\n            index: helper.getIndex(),\n            widgetType: this.$$type\n          });\n        }\n\n        if (!bindEvent) {\n          bindEvent = Object(createSendEventForHits[\"a\" /* createBindEventForHits */])({\n            index: helper.getIndex(),\n            widgetType: this.$$type\n          });\n        }\n\n        if (!results) {\n          return {\n            hits: [],\n            results: undefined,\n            sendEvent: sendEvent,\n            bindEvent: bindEvent,\n            widgetParams: widgetParams\n          };\n        }\n\n        if (escapeHTML && results.hits.length > 0) {\n          results.hits = Object(escape_highlight[\"d\" /* escapeHits */])(results.hits);\n        }\n\n        var hitsWithAbsolutePosition = Object(hits_absolute_position[\"a\" /* addAbsolutePosition */])(results.hits, results.page, results.hitsPerPage);\n        var hitsWithAbsolutePositionAndQueryID = Object(hits_query_id[\"a\" /* addQueryID */])(hitsWithAbsolutePosition, results.queryID);\n        var transformedHits = transformItems(hitsWithAbsolutePositionAndQueryID);\n        return {\n          hits: transformedHits,\n          results: results,\n          sendEvent: sendEvent,\n          bindEvent: bindEvent,\n          widgetParams: widgetParams\n        };\n      },\n      dispose: function dispose(_ref3) {\n        var state = _ref3.state;\n        unmountFn();\n\n        if (!escapeHTML) {\n          return state;\n        }\n\n        return state.setQueryParameters(Object.keys(escape_highlight[\"a\" /* TAG_PLACEHOLDER */]).reduce(function (acc, key) {\n          return connectHits_objectSpread(connectHits_objectSpread({}, acc), {}, connectHits_defineProperty({}, key, undefined));\n        }, {}));\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(state) {\n        if (!escapeHTML) {\n          return state;\n        }\n\n        return state.setQueryParameters(escape_highlight[\"a\" /* TAG_PLACEHOLDER */]);\n      }\n    };\n  };\n};\n\n/* harmony default export */ var hits_connectHits = (connectHits_connectHits);\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/find.js\nvar find = __webpack_require__(313);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/insights/client.js\nfunction client_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction client_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      client_ownKeys(Object(source), true).forEach(function (key) {\n        client_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      client_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction client_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\n\nvar client_getSelectedHits = function getSelectedHits(hits, selectedObjectIDs) {\n  return selectedObjectIDs.map(function (objectID) {\n    var hit = Object(find[\"a\" /* default */])(hits, function (h) {\n      return h.objectID === objectID;\n    });\n\n    if (typeof hit === 'undefined') {\n      throw new Error(\"Could not find objectID \\\"\".concat(objectID, \"\\\" passed to `clickedObjectIDsAfterSearch` in the returned hits. This is necessary to infer the absolute position and the query ID.\"));\n    }\n\n    return hit;\n  });\n};\n\nvar client_getQueryID = function getQueryID(selectedHits) {\n  var queryIDs = Object(uniq[\"a\" /* default */])(selectedHits.map(function (hit) {\n    return hit.__queryID;\n  }));\n\n  if (queryIDs.length > 1) {\n    throw new Error('Insights currently allows a single `queryID`. The `objectIDs` provided map to multiple `queryID`s.');\n  }\n\n  var queryID = queryIDs[0];\n\n  if (typeof queryID !== 'string') {\n    throw new Error(\"Could not infer `queryID`. Ensure InstantSearch `clickAnalytics: true` was added with the Configure widget.\\n\\nSee: https://alg.li/lNiZZ7\");\n  }\n\n  return queryID;\n};\n\nvar getPositions = function getPositions(selectedHits) {\n  return selectedHits.map(function (hit) {\n    return hit.__position;\n  });\n};\n\nvar inferPayload = function inferPayload(_ref) {\n  var method = _ref.method,\n      results = _ref.results,\n      hits = _ref.hits,\n      objectIDs = _ref.objectIDs;\n  var index = results.index;\n  var selectedHits = client_getSelectedHits(hits, objectIDs);\n  var queryID = client_getQueryID(selectedHits);\n\n  switch (method) {\n    case 'clickedObjectIDsAfterSearch':\n      {\n        var positions = getPositions(selectedHits);\n        return {\n          index: index,\n          queryID: queryID,\n          objectIDs: objectIDs,\n          positions: positions\n        };\n      }\n\n    case 'convertedObjectIDsAfterSearch':\n      return {\n        index: index,\n        queryID: queryID,\n        objectIDs: objectIDs\n      };\n\n    default:\n      throw new Error(\"Unsupported method passed to insights: \\\"\".concat(method, \"\\\".\"));\n  }\n};\n\nvar client_wrapInsightsClient = function wrapInsightsClient(aa, results, hits) {\n  return function (method) {\n    for (var _len = arguments.length, payloads = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      payloads[_key - 1] = arguments[_key];\n    }\n\n    var payload = payloads[0];\n     false ? undefined : void 0;\n\n    if (!aa) {\n      var withInstantSearchUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n        name: 'instantsearch'\n      });\n      throw new Error(withInstantSearchUsage('The `insightsClient` option has not been provided to `instantsearch`.'));\n    }\n\n    if (!Array.isArray(payload.objectIDs)) {\n      throw new TypeError('Expected `objectIDs` to be an array.');\n    }\n\n    var inferredPayload = inferPayload({\n      method: method,\n      results: results,\n      hits: hits,\n      objectIDs: payload.objectIDs\n    });\n    aa(method, client_objectSpread(client_objectSpread({}, inferredPayload), payload));\n  };\n};\n/**\n * @deprecated This function will be still supported in 4.x releases, but not further. It is replaced by the `insights` middleware. For more information, visit https://www.algolia.com/doc/guides/getting-insights-and-analytics/search-analytics/click-through-and-conversions/how-to/send-click-and-conversion-events-with-instantsearch/js/\n * It passes `insights` to `HitsWithInsightsListener` and `InfiniteHitsWithInsightsListener`.\n */\n\n\nfunction withInsights(connector) {\n  return function (renderFn, unmountFn) {\n    return connector(function (renderOptions, isFirstRender) {\n      var results = renderOptions.results,\n          hits = renderOptions.hits,\n          instantSearchInstance = renderOptions.instantSearchInstance;\n\n      if (results && hits && instantSearchInstance) {\n        var insights = client_wrapInsightsClient(instantSearchInstance.insightsClient, results, hits);\n        return renderFn(client_objectSpread(client_objectSpread({}, renderOptions), {}, {\n          insights: insights\n        }), isFirstRender);\n      }\n\n      return renderFn(renderOptions, isFirstRender);\n    }, unmountFn);\n  };\n}\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/hits/connectHitsWithInsights.js\n\n\nvar connectHitsWithInsights = withInsights(hits_connectHits);\n/* harmony default export */ var hits_connectHitsWithInsights = (connectHitsWithInsights);\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/hits-per-page/connectHitsPerPage.js\nfunction connectHitsPerPage_toConsumableArray(arr) {\n  return connectHitsPerPage_arrayWithoutHoles(arr) || connectHitsPerPage_iterableToArray(arr) || connectHitsPerPage_unsupportedIterableToArray(arr) || connectHitsPerPage_nonIterableSpread();\n}\n\nfunction connectHitsPerPage_nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction connectHitsPerPage_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return connectHitsPerPage_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return connectHitsPerPage_arrayLikeToArray(o, minLen);\n}\n\nfunction connectHitsPerPage_iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction connectHitsPerPage_arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return connectHitsPerPage_arrayLikeToArray(arr);\n}\n\nfunction connectHitsPerPage_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction connectHitsPerPage_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectHitsPerPage_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectHitsPerPage_ownKeys(Object(source), true).forEach(function (key) {\n        connectHitsPerPage_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectHitsPerPage_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectHitsPerPage_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\nvar connectHitsPerPage_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'hits-per-page',\n  connector: true\n});\n\nvar connectHitsPerPage_connectHitsPerPage = function connectHitsPerPage(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectHitsPerPage_withUsage());\n  return function (widgetParams) {\n    var _ref = widgetParams || {},\n        userItems = _ref.items,\n        _ref$transformItems = _ref.transformItems,\n        transformItems = _ref$transformItems === void 0 ? function (items) {\n      return items;\n    } : _ref$transformItems;\n\n    if (!Array.isArray(userItems)) {\n      throw new Error(connectHitsPerPage_withUsage('The `items` option expects an array of objects.'));\n    }\n\n    var items = userItems;\n    var defaultItems = items.filter(function (item) {\n      return item.default === true;\n    });\n\n    if (defaultItems.length === 0) {\n      throw new Error(connectHitsPerPage_withUsage(\"A default value must be specified in `items`.\"));\n    }\n\n    if (defaultItems.length > 1) {\n      throw new Error(connectHitsPerPage_withUsage('More than one default value is specified in `items`.'));\n    }\n\n    var defaultItem = defaultItems[0];\n\n    var normalizeItems = function normalizeItems(_ref2) {\n      var hitsPerPage = _ref2.hitsPerPage;\n      return items.map(function (item) {\n        return connectHitsPerPage_objectSpread(connectHitsPerPage_objectSpread({}, item), {}, {\n          isRefined: Number(item.value) === Number(hitsPerPage)\n        });\n      });\n    };\n\n    var connectorState = {\n      getRefine: function getRefine(helper) {\n        return function (value) {\n          return !value && value !== 0 ? helper.setQueryParameter('hitsPerPage', undefined).search() : helper.setQueryParameter('hitsPerPage', value).search();\n        };\n      },\n      createURLFactory: function createURLFactory(_ref3) {\n        var state = _ref3.state,\n            createURL = _ref3.createURL;\n        return function (value) {\n          return createURL(state.resetPage().setQueryParameter('hitsPerPage', !value && value !== 0 ? undefined : value));\n        };\n      }\n    };\n    return {\n      $$type: 'ais.hitsPerPage',\n      init: function init(initOptions) {\n        var state = initOptions.state,\n            instantSearchInstance = initOptions.instantSearchInstance;\n        var isCurrentInOptions = items.some(function (item) {\n          return Number(state.hitsPerPage) === Number(item.value);\n        });\n\n        if (!isCurrentInOptions) {\n           false ? undefined : void 0;\n           false ? undefined : void 0;\n          items = [// The helper will convert the empty string to `undefined`.\n          {\n            value: '',\n            label: ''\n          }].concat(connectHitsPerPage_toConsumableArray(items));\n        }\n\n        renderFn(connectHitsPerPage_objectSpread(connectHitsPerPage_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(initOptions) {\n        var instantSearchInstance = initOptions.instantSearchInstance;\n        renderFn(connectHitsPerPage_objectSpread(connectHitsPerPage_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      dispose: function dispose(_ref4) {\n        var state = _ref4.state;\n        unmountFn();\n        return state.setQueryParameter('hitsPerPage', undefined);\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectHitsPerPage_objectSpread(connectHitsPerPage_objectSpread({}, renderState), {}, {\n          hitsPerPage: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref5) {\n        var state = _ref5.state,\n            results = _ref5.results,\n            createURL = _ref5.createURL,\n            helper = _ref5.helper;\n        return {\n          items: transformItems(normalizeItems(state)),\n          refine: connectorState.getRefine(helper),\n          createURL: connectorState.createURLFactory({\n            state: state,\n            createURL: createURL\n          }),\n          hasNoResults: results ? results.nbHits === 0 : true,\n          widgetParams: widgetParams\n        };\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref6) {\n        var searchParameters = _ref6.searchParameters;\n        var hitsPerPage = searchParameters.hitsPerPage;\n\n        if (hitsPerPage === undefined || hitsPerPage === defaultItem.value) {\n          return uiState;\n        }\n\n        return connectHitsPerPage_objectSpread(connectHitsPerPage_objectSpread({}, uiState), {}, {\n          hitsPerPage: hitsPerPage\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref7) {\n        var uiState = _ref7.uiState;\n        return searchParameters.setQueryParameters({\n          hitsPerPage: uiState.hitsPerPage || defaultItem.value\n        });\n      }\n    };\n  };\n};\n\n/* harmony default export */ var hits_per_page_connectHitsPerPage = (connectHitsPerPage_connectHitsPerPage);\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/connectors/infinite-hits/connectInfiniteHits.js\nvar connectInfiniteHits = __webpack_require__(318);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/infinite-hits/connectInfiniteHitsWithInsights.js\n\n\nvar connectInfiniteHitsWithInsights = withInsights(connectInfiniteHits[\"a\" /* default */]);\n/* harmony default export */ var infinite_hits_connectInfiniteHitsWithInsights = (connectInfiniteHitsWithInsights);\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/menu/connectMenu.js\nfunction connectMenu_objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = connectMenu_objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction connectMenu_objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction connectMenu_slicedToArray(arr, i) {\n  return connectMenu_arrayWithHoles(arr) || connectMenu_iterableToArrayLimit(arr, i) || connectMenu_unsupportedIterableToArray(arr, i) || connectMenu_nonIterableRest();\n}\n\nfunction connectMenu_nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction connectMenu_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return connectMenu_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return connectMenu_arrayLikeToArray(o, minLen);\n}\n\nfunction connectMenu_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction connectMenu_iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction connectMenu_arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction connectMenu_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectMenu_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectMenu_ownKeys(Object(source), true).forEach(function (key) {\n        connectMenu_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectMenu_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectMenu_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\nvar connectMenu_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'menu',\n  connector: true\n});\nvar connectMenu_DEFAULT_SORT = ['isRefined', 'name:asc'];\n/**\n * **Menu** connector provides the logic to build a widget that will give the user the ability to choose a single value for a specific facet. The typical usage of menu is for navigation in categories.\n *\n * This connector provides a `toggleShowMore()` function to display more or less items and a `refine()`\n * function to select an item. While selecting a new element, the `refine` will also unselect the\n * one that is currently selected.\n *\n * **Requirement:** the attribute passed as `attribute` must be present in \"attributes for faceting\" on the Algolia dashboard or configured as attributesForFaceting via a set settings call to the Algolia API.\n */\n\nvar connectMenu_connectMenu = function connectMenu(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectMenu_withUsage());\n  return function (widgetParams) {\n    var _ref = widgetParams || {},\n        attribute = _ref.attribute,\n        _ref$limit = _ref.limit,\n        limit = _ref$limit === void 0 ? 10 : _ref$limit,\n        _ref$showMore = _ref.showMore,\n        showMore = _ref$showMore === void 0 ? false : _ref$showMore,\n        _ref$showMoreLimit = _ref.showMoreLimit,\n        showMoreLimit = _ref$showMoreLimit === void 0 ? 20 : _ref$showMoreLimit,\n        _ref$sortBy = _ref.sortBy,\n        sortBy = _ref$sortBy === void 0 ? connectMenu_DEFAULT_SORT : _ref$sortBy,\n        _ref$transformItems = _ref.transformItems,\n        transformItems = _ref$transformItems === void 0 ? function (items) {\n      return items;\n    } : _ref$transformItems;\n\n    if (!attribute) {\n      throw new Error(connectMenu_withUsage('The `attribute` option is required.'));\n    }\n\n    if (showMore === true && showMoreLimit <= limit) {\n      throw new Error(connectMenu_withUsage('The `showMoreLimit` option must be greater than `limit`.'));\n    }\n\n    var sendEvent;\n\n    var _createURL;\n\n    var _refine; // Provide the same function to the `renderFn` so that way the user\n    // has to only bind it once when `isFirstRendering` for instance\n\n\n    var isShowingMore = false;\n\n    var toggleShowMore = function toggleShowMore() {};\n\n    function createToggleShowMore(renderOptions, widget) {\n      return function () {\n        isShowingMore = !isShowingMore;\n        widget.render(renderOptions);\n      };\n    }\n\n    function cachedToggleShowMore() {\n      toggleShowMore();\n    }\n\n    function getLimit() {\n      return isShowingMore ? showMoreLimit : limit;\n    }\n\n    return {\n      $$type: 'ais.menu',\n      init: function init(initOptions) {\n        var instantSearchInstance = initOptions.instantSearchInstance;\n        renderFn(connectMenu_objectSpread(connectMenu_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n        renderFn(connectMenu_objectSpread(connectMenu_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      dispose: function dispose(_ref2) {\n        var state = _ref2.state;\n        unmountFn();\n        return state.removeHierarchicalFacet(attribute).setQueryParameter('maxValuesPerFacet', undefined);\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectMenu_objectSpread(connectMenu_objectSpread({}, renderState), {}, {\n          menu: connectMenu_objectSpread(connectMenu_objectSpread({}, renderState.menu), {}, connectMenu_defineProperty({}, attribute, this.getWidgetRenderState(renderOptions)))\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(renderOptions) {\n        var results = renderOptions.results,\n            createURL = renderOptions.createURL,\n            instantSearchInstance = renderOptions.instantSearchInstance,\n            helper = renderOptions.helper;\n        var items = [];\n        var canToggleShowMore = false;\n\n        if (!sendEvent) {\n          sendEvent = Object(createSendEventForFacet[\"a\" /* createSendEventForFacet */])({\n            instantSearchInstance: instantSearchInstance,\n            helper: helper,\n            attribute: attribute,\n            widgetType: this.$$type\n          });\n        }\n\n        if (!_createURL) {\n          _createURL = function _createURL(facetValue) {\n            return createURL(helper.state.resetPage().toggleFacetRefinement(attribute, facetValue));\n          };\n        }\n\n        if (!_refine) {\n          _refine = function _refine(facetValue) {\n            var _helper$getHierarchic = helper.getHierarchicalFacetBreadcrumb(attribute),\n                _helper$getHierarchic2 = connectMenu_slicedToArray(_helper$getHierarchic, 1),\n                refinedItem = _helper$getHierarchic2[0];\n\n            sendEvent('click', facetValue ? facetValue : refinedItem);\n            helper.toggleFacetRefinement(attribute, facetValue ? facetValue : refinedItem).search();\n          };\n        }\n\n        if (renderOptions.results) {\n          toggleShowMore = createToggleShowMore(renderOptions, this);\n        }\n\n        if (results) {\n          var facetValues = results.getFacetValues(attribute, {\n            sortBy: sortBy,\n            facetOrdering: sortBy === connectMenu_DEFAULT_SORT\n          });\n          var facetItems = facetValues && !Array.isArray(facetValues) && facetValues.data ? facetValues.data : [];\n          canToggleShowMore = showMore && (isShowingMore || facetItems.length > getLimit());\n          items = transformItems(facetItems.slice(0, getLimit()).map(function (_ref3) {\n            var label = _ref3.name,\n                value = _ref3.path,\n                item = connectMenu_objectWithoutProperties(_ref3, [\"name\", \"path\"]);\n\n            return connectMenu_objectSpread(connectMenu_objectSpread({}, item), {}, {\n              label: label,\n              value: value\n            });\n          }));\n        }\n\n        return {\n          items: items,\n          createURL: _createURL,\n          refine: _refine,\n          sendEvent: sendEvent,\n          canRefine: items.length > 0,\n          widgetParams: widgetParams,\n          isShowingMore: isShowingMore,\n          toggleShowMore: cachedToggleShowMore,\n          canToggleShowMore: canToggleShowMore\n        };\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref4) {\n        var searchParameters = _ref4.searchParameters;\n\n        var _searchParameters$get = searchParameters.getHierarchicalFacetBreadcrumb(attribute),\n            _searchParameters$get2 = connectMenu_slicedToArray(_searchParameters$get, 1),\n            value = _searchParameters$get2[0];\n\n        if (!value) {\n          return uiState;\n        }\n\n        return connectMenu_objectSpread(connectMenu_objectSpread({}, uiState), {}, {\n          menu: connectMenu_objectSpread(connectMenu_objectSpread({}, uiState.menu), {}, connectMenu_defineProperty({}, attribute, value))\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref5) {\n        var uiState = _ref5.uiState;\n        var value = uiState.menu && uiState.menu[attribute];\n        var withFacetConfiguration = searchParameters.removeHierarchicalFacet(attribute).addHierarchicalFacet({\n          name: attribute,\n          attributes: [attribute]\n        });\n        var currentMaxValuesPerFacet = withFacetConfiguration.maxValuesPerFacet || 0;\n        var nextMaxValuesPerFacet = Math.max(currentMaxValuesPerFacet, showMore ? showMoreLimit : limit);\n        var withMaxValuesPerFacet = withFacetConfiguration.setQueryParameter('maxValuesPerFacet', nextMaxValuesPerFacet);\n\n        if (!value) {\n          return withMaxValuesPerFacet.setQueryParameters({\n            hierarchicalFacetsRefinements: connectMenu_objectSpread(connectMenu_objectSpread({}, withMaxValuesPerFacet.hierarchicalFacetsRefinements), {}, connectMenu_defineProperty({}, attribute, []))\n          });\n        }\n\n        return withMaxValuesPerFacet.addHierarchicalFacetRefinement(attribute, value);\n      }\n    };\n  };\n};\n\n/* harmony default export */ var menu_connectMenu = (connectMenu_connectMenu);\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/convertNumericRefinementsToFilters.js\nvar convertNumericRefinementsToFilters = __webpack_require__(368);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/isFiniteNumber.js\nvar isFiniteNumber = __webpack_require__(369);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/numeric-menu/connectNumericMenu.js\nfunction connectNumericMenu_slicedToArray(arr, i) {\n  return connectNumericMenu_arrayWithHoles(arr) || connectNumericMenu_iterableToArrayLimit(arr, i) || connectNumericMenu_unsupportedIterableToArray(arr, i) || connectNumericMenu_nonIterableRest();\n}\n\nfunction connectNumericMenu_nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction connectNumericMenu_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return connectNumericMenu_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return connectNumericMenu_arrayLikeToArray(o, minLen);\n}\n\nfunction connectNumericMenu_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction connectNumericMenu_iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction connectNumericMenu_arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction connectNumericMenu_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectNumericMenu_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectNumericMenu_ownKeys(Object(source), true).forEach(function (key) {\n        connectNumericMenu_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectNumericMenu_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectNumericMenu_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\nvar connectNumericMenu_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'numeric-menu',\n  connector: true\n});\nvar $$type = 'ais.numericMenu';\n\nvar connectNumericMenu_createSendEvent = function createSendEvent(_ref) {\n  var instantSearchInstance = _ref.instantSearchInstance,\n      helper = _ref.helper,\n      attribute = _ref.attribute;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (args.length === 1) {\n      instantSearchInstance.sendEventToInsights(args[0]);\n      return;\n    }\n\n    var eventType = args[0],\n        facetValue = args[1],\n        _args$ = args[2],\n        eventName = _args$ === void 0 ? 'Filter Applied' : _args$;\n\n    if (eventType !== 'click') {\n      return;\n    } // facetValue === \"%7B%22start%22:5,%22end%22:10%7D\"\n\n\n    var filters = Object(convertNumericRefinementsToFilters[\"a\" /* convertNumericRefinementsToFilters */])(connectNumericMenu_getRefinedState(helper.state, attribute, facetValue), attribute);\n\n    if (filters && filters.length > 0) {\n      /*\n        filters === [\"price<=10\", \"price>=5\"]\n      */\n      instantSearchInstance.sendEventToInsights({\n        insightsMethod: 'clickedFilters',\n        widgetType: $$type,\n        eventType: eventType,\n        payload: {\n          eventName: eventName,\n          index: helper.getIndex(),\n          filters: filters\n        },\n        attribute: attribute\n      });\n    }\n  };\n};\n\nvar connectNumericMenu_connectNumericMenu = function connectNumericMenu(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectNumericMenu_withUsage());\n  return function (widgetParams) {\n    var _ref2 = widgetParams || {},\n        _ref2$attribute = _ref2.attribute,\n        attribute = _ref2$attribute === void 0 ? '' : _ref2$attribute,\n        _ref2$items = _ref2.items,\n        items = _ref2$items === void 0 ? [] : _ref2$items,\n        _ref2$transformItems = _ref2.transformItems,\n        transformItems = _ref2$transformItems === void 0 ? function (x) {\n      return x;\n    } : _ref2$transformItems;\n\n    if (attribute === '') {\n      throw new Error(connectNumericMenu_withUsage('The `attribute` option is required.'));\n    }\n\n    if (!items || items.length === 0) {\n      throw new Error(connectNumericMenu_withUsage('The `items` option expects an array of objects.'));\n    }\n\n    var prepareItems = function prepareItems(state) {\n      return items.map(function (_ref3) {\n        var start = _ref3.start,\n            end = _ref3.end,\n            label = _ref3.label;\n        return {\n          label: label,\n          value: encodeURI(JSON.stringify({\n            start: start,\n            end: end\n          })),\n          isRefined: connectNumericMenu_isRefined(state, attribute, {\n            start: start,\n            end: end,\n            label: label\n          })\n        };\n      });\n    };\n\n    var connectorState = {};\n    return {\n      $$type: $$type,\n      init: function init(initOptions) {\n        var instantSearchInstance = initOptions.instantSearchInstance;\n        renderFn(connectNumericMenu_objectSpread(connectNumericMenu_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n        renderFn(connectNumericMenu_objectSpread(connectNumericMenu_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      dispose: function dispose(_ref4) {\n        var state = _ref4.state;\n        unmountFn();\n        return state.clearRefinements(attribute);\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref5) {\n        var searchParameters = _ref5.searchParameters;\n        var values = searchParameters.getNumericRefinements(attribute);\n        var equal = values['='] && values['='][0];\n\n        if (equal || equal === 0) {\n          return connectNumericMenu_objectSpread(connectNumericMenu_objectSpread({}, uiState), {}, {\n            numericMenu: connectNumericMenu_objectSpread(connectNumericMenu_objectSpread({}, uiState.numericMenu), {}, connectNumericMenu_defineProperty({}, attribute, \"\".concat(values['='])))\n          });\n        }\n\n        var min = values['>='] && values['>='][0] || '';\n        var max = values['<='] && values['<='][0] || '';\n\n        if (min === '' && max === '') {\n          return uiState;\n        }\n\n        return connectNumericMenu_objectSpread(connectNumericMenu_objectSpread({}, uiState), {}, {\n          numericMenu: connectNumericMenu_objectSpread(connectNumericMenu_objectSpread({}, uiState.numericMenu), {}, connectNumericMenu_defineProperty({}, attribute, \"\".concat(min, \":\").concat(max)))\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref6) {\n        var uiState = _ref6.uiState;\n        var value = uiState.numericMenu && uiState.numericMenu[attribute];\n        var withoutRefinements = searchParameters.clearRefinements(attribute);\n\n        if (!value) {\n          return withoutRefinements.setQueryParameters({\n            numericRefinements: connectNumericMenu_objectSpread(connectNumericMenu_objectSpread({}, withoutRefinements.numericRefinements), {}, connectNumericMenu_defineProperty({}, attribute, {}))\n          });\n        }\n\n        var isExact = value.indexOf(':') === -1;\n\n        if (isExact) {\n          return withoutRefinements.addNumericRefinement(attribute, '=', Number(value));\n        }\n\n        var _value$split$map = value.split(':').map(parseFloat),\n            _value$split$map2 = connectNumericMenu_slicedToArray(_value$split$map, 2),\n            min = _value$split$map2[0],\n            max = _value$split$map2[1];\n\n        var withMinRefinement = Object(isFiniteNumber[\"a\" /* default */])(min) ? withoutRefinements.addNumericRefinement(attribute, '>=', min) : withoutRefinements;\n        var withMaxRefinement = Object(isFiniteNumber[\"a\" /* default */])(max) ? withMinRefinement.addNumericRefinement(attribute, '<=', max) : withMinRefinement;\n        return withMaxRefinement;\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectNumericMenu_objectSpread(connectNumericMenu_objectSpread({}, renderState), {}, {\n          numericMenu: connectNumericMenu_objectSpread(connectNumericMenu_objectSpread({}, renderState.numericMenu), {}, connectNumericMenu_defineProperty({}, attribute, this.getWidgetRenderState(renderOptions)))\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref7) {\n        var results = _ref7.results,\n            state = _ref7.state,\n            instantSearchInstance = _ref7.instantSearchInstance,\n            helper = _ref7.helper,\n            createURL = _ref7.createURL;\n\n        if (!connectorState.refine) {\n          connectorState.refine = function (facetValue) {\n            var refinedState = connectNumericMenu_getRefinedState(helper.state, attribute, facetValue);\n            connectorState.sendEvent('click', facetValue);\n            helper.setState(refinedState).search();\n          };\n        }\n\n        if (!connectorState.createURL) {\n          connectorState.createURL = function (newState) {\n            return function (facetValue) {\n              return createURL(connectNumericMenu_getRefinedState(newState, attribute, facetValue));\n            };\n          };\n        }\n\n        if (!connectorState.sendEvent) {\n          connectorState.sendEvent = connectNumericMenu_createSendEvent({\n            instantSearchInstance: instantSearchInstance,\n            helper: helper,\n            attribute: attribute\n          });\n        }\n\n        return {\n          createURL: connectorState.createURL(state),\n          items: transformItems(prepareItems(state)),\n          hasNoResults: results ? results.nbHits === 0 : true,\n          refine: connectorState.refine,\n          sendEvent: connectorState.sendEvent,\n          widgetParams: widgetParams\n        };\n      }\n    };\n  };\n};\n\nfunction connectNumericMenu_isRefined(state, attribute, option) {\n  // @TODO: same as another spot, why is this mixing arrays & elements?\n  var currentRefinements = state.getNumericRefinements(attribute);\n\n  if (option.start !== undefined && option.end !== undefined) {\n    if (option.start === option.end) {\n      return hasNumericRefinement(currentRefinements, '=', option.start);\n    }\n  }\n\n  if (option.start !== undefined) {\n    return hasNumericRefinement(currentRefinements, '>=', option.start);\n  }\n\n  if (option.end !== undefined) {\n    return hasNumericRefinement(currentRefinements, '<=', option.end);\n  }\n\n  if (option.start === undefined && option.end === undefined) {\n    return Object.keys(currentRefinements).every(function (operator) {\n      return (currentRefinements[operator] || []).length === 0;\n    });\n  }\n\n  return false;\n}\n\nfunction connectNumericMenu_getRefinedState(state, attribute, facetValue) {\n  var resolvedState = state;\n  var refinedOption = JSON.parse(decodeURI(facetValue)); // @TODO: why is array / element mixed here & hasRefinements; seems wrong?\n\n  var currentRefinements = resolvedState.getNumericRefinements(attribute);\n\n  if (refinedOption.start === undefined && refinedOption.end === undefined) {\n    return resolvedState.removeNumericRefinement(attribute);\n  }\n\n  if (!connectNumericMenu_isRefined(resolvedState, attribute, refinedOption)) {\n    resolvedState = resolvedState.removeNumericRefinement(attribute);\n  }\n\n  if (refinedOption.start !== undefined && refinedOption.end !== undefined) {\n    if (refinedOption.start > refinedOption.end) {\n      throw new Error('option.start should be > to option.end');\n    }\n\n    if (refinedOption.start === refinedOption.end) {\n      if (hasNumericRefinement(currentRefinements, '=', refinedOption.start)) {\n        resolvedState = resolvedState.removeNumericRefinement(attribute, '=', refinedOption.start);\n      } else {\n        resolvedState = resolvedState.addNumericRefinement(attribute, '=', refinedOption.start);\n      }\n\n      return resolvedState;\n    }\n  }\n\n  if (refinedOption.start !== undefined) {\n    if (hasNumericRefinement(currentRefinements, '>=', refinedOption.start)) {\n      resolvedState = resolvedState.removeNumericRefinement(attribute, '>=', refinedOption.start);\n    } else {\n      resolvedState = resolvedState.addNumericRefinement(attribute, '>=', refinedOption.start);\n    }\n  }\n\n  if (refinedOption.end !== undefined) {\n    if (hasNumericRefinement(currentRefinements, '<=', refinedOption.end)) {\n      resolvedState = resolvedState.removeNumericRefinement(attribute, '<=', refinedOption.end);\n    } else {\n      resolvedState = resolvedState.addNumericRefinement(attribute, '<=', refinedOption.end);\n    }\n  }\n\n  if (typeof resolvedState.page === 'number') {\n    resolvedState.page = 0;\n  }\n\n  return resolvedState;\n}\n\nfunction hasNumericRefinement(currentRefinements, operator, value) {\n  return currentRefinements[operator] !== undefined && currentRefinements[operator].includes(value);\n}\n\n/* harmony default export */ var numeric_menu_connectNumericMenu = (connectNumericMenu_connectNumericMenu);\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/range.js\nvar range = __webpack_require__(370);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/pagination/Paginator.js\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction Paginator_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\n\nvar Paginator_Paginator = /*#__PURE__*/function () {\n  function Paginator(params) {\n    _classCallCheck(this, Paginator);\n\n    Paginator_defineProperty(this, \"currentPage\", void 0);\n\n    Paginator_defineProperty(this, \"total\", void 0);\n\n    Paginator_defineProperty(this, \"padding\", void 0);\n\n    this.currentPage = params.currentPage;\n    this.total = params.total;\n    this.padding = params.padding;\n  }\n\n  _createClass(Paginator, [{\n    key: \"pages\",\n    value: function pages() {\n      var total = this.total,\n          currentPage = this.currentPage,\n          padding = this.padding;\n      if (total === 0) return [0];\n      var totalDisplayedPages = this.nbPagesDisplayed(padding, total);\n\n      if (totalDisplayedPages === total) {\n        return Object(range[\"a\" /* default */])({\n          end: total\n        });\n      }\n\n      var paddingLeft = this.calculatePaddingLeft(currentPage, padding, total, totalDisplayedPages);\n      var paddingRight = totalDisplayedPages - paddingLeft;\n      var first = currentPage - paddingLeft;\n      var last = currentPage + paddingRight;\n      return Object(range[\"a\" /* default */])({\n        start: first,\n        end: last\n      });\n    }\n  }, {\n    key: \"nbPagesDisplayed\",\n    value: function nbPagesDisplayed(padding, total) {\n      return Math.min(2 * padding + 1, total);\n    }\n  }, {\n    key: \"calculatePaddingLeft\",\n    value: function calculatePaddingLeft(current, padding, total, totalDisplayedPages) {\n      if (current <= padding) {\n        return current;\n      }\n\n      if (current >= total - padding) {\n        return totalDisplayedPages - (total - current);\n      }\n\n      return padding;\n    }\n  }, {\n    key: \"isLastPage\",\n    value: function isLastPage() {\n      return this.currentPage === this.total - 1 || this.total === 0;\n    }\n  }, {\n    key: \"isFirstPage\",\n    value: function isFirstPage() {\n      return this.currentPage === 0;\n    }\n  }]);\n\n  return Paginator;\n}();\n\n/* harmony default export */ var pagination_Paginator = (Paginator_Paginator);\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/pagination/connectPagination.js\nfunction connectPagination_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectPagination_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectPagination_ownKeys(Object(source), true).forEach(function (key) {\n        connectPagination_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectPagination_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectPagination_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\n\nvar connectPagination_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'pagination',\n  connector: true\n});\n/**\n * **Pagination** connector provides the logic to build a widget that will let the user\n * choose the current page of the results.\n *\n * When using the pagination with Algolia, you should be aware that the engine won't provide you pages\n * beyond the 1000th hits by default. You can find more information on the [Algolia documentation](https://www.algolia.com/doc/guides/searching/pagination/#pagination-limitations).\n */\n\nvar connectPagination_connectPagination = function connectPagination(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectPagination_withUsage());\n  return function (widgetParams) {\n    var _ref = widgetParams || {},\n        totalPages = _ref.totalPages,\n        _ref$padding = _ref.padding,\n        padding = _ref$padding === void 0 ? 3 : _ref$padding;\n\n    var pager = new pagination_Paginator({\n      currentPage: 0,\n      total: 0,\n      padding: padding\n    });\n    var connectorState = {};\n\n    function getMaxPage(_ref2) {\n      var nbPages = _ref2.nbPages;\n      return totalPages !== undefined ? Math.min(totalPages, nbPages) : nbPages;\n    }\n\n    return {\n      $$type: 'ais.pagination',\n      init: function init(initOptions) {\n        var instantSearchInstance = initOptions.instantSearchInstance;\n        renderFn(connectPagination_objectSpread(connectPagination_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n        renderFn(connectPagination_objectSpread(connectPagination_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      dispose: function dispose(_ref3) {\n        var state = _ref3.state;\n        unmountFn();\n        return state.setQueryParameter('page', undefined);\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref4) {\n        var searchParameters = _ref4.searchParameters;\n        var page = searchParameters.page || 0;\n\n        if (!page) {\n          return uiState;\n        }\n\n        return connectPagination_objectSpread(connectPagination_objectSpread({}, uiState), {}, {\n          page: page + 1\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref5) {\n        var uiState = _ref5.uiState;\n        var page = uiState.page ? uiState.page - 1 : 0;\n        return searchParameters.setQueryParameter('page', page);\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref6) {\n        var results = _ref6.results,\n            helper = _ref6.helper,\n            createURL = _ref6.createURL;\n\n        if (!connectorState.refine) {\n          connectorState.refine = function (page) {\n            helper.setPage(page);\n            helper.search();\n          };\n        }\n\n        if (!connectorState.createURL) {\n          connectorState.createURL = function (state) {\n            return function (page) {\n              return createURL(state.setPage(page));\n            };\n          };\n        }\n\n        var state = helper.state;\n        var page = state.page || 0;\n        var nbPages = getMaxPage(results || {\n          nbPages: 0\n        });\n        pager.currentPage = page;\n        pager.total = nbPages;\n        return {\n          createURL: connectorState.createURL(state),\n          refine: connectorState.refine,\n          canRefine: nbPages > 1,\n          currentRefinement: page,\n          nbHits: (results === null || results === void 0 ? void 0 : results.nbHits) || 0,\n          nbPages: nbPages,\n          pages: results ? pager.pages() : [],\n          isFirstPage: pager.isFirstPage(),\n          isLastPage: pager.isLastPage(),\n          widgetParams: widgetParams\n        };\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectPagination_objectSpread(connectPagination_objectSpread({}, renderState), {}, {\n          pagination: this.getWidgetRenderState(renderOptions)\n        });\n      }\n    };\n  };\n};\n\n/* harmony default export */ var pagination_connectPagination = (connectPagination_connectPagination);\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/range/connectRange.js\nfunction connectRange_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectRange_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectRange_ownKeys(Object(source), true).forEach(function (key) {\n        connectRange_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectRange_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectRange_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction connectRange_slicedToArray(arr, i) {\n  return connectRange_arrayWithHoles(arr) || connectRange_iterableToArrayLimit(arr, i) || connectRange_unsupportedIterableToArray(arr, i) || connectRange_nonIterableRest();\n}\n\nfunction connectRange_nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction connectRange_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return connectRange_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return connectRange_arrayLikeToArray(o, minLen);\n}\n\nfunction connectRange_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction connectRange_iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction connectRange_arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\n\nvar connectRange_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'range-input',\n  connector: true\n}, {\n  name: 'range-slider',\n  connector: true\n});\nvar connectRange_$$type = 'ais.range';\n\nfunction toPrecision(_ref) {\n  var min = _ref.min,\n      max = _ref.max,\n      precision = _ref.precision;\n  var pow = Math.pow(10, precision);\n  return {\n    min: min ? Math.floor(min * pow) / pow : min,\n    max: max ? Math.ceil(max * pow) / pow : max\n  };\n}\n/**\n * **Range** connector provides the logic to create custom widget that will let\n * the user refine results using a numeric range.\n *\n * This connectors provides a `refine()` function that accepts bounds. It will also provide\n * information about the min and max bounds for the current result set.\n */\n\n\nvar connectRange_connectRange = function connectRange(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectRange_withUsage());\n  return function (widgetParams) {\n    var _ref2 = widgetParams || {},\n        _ref2$attribute = _ref2.attribute,\n        attribute = _ref2$attribute === void 0 ? '' : _ref2$attribute,\n        minBound = _ref2.min,\n        maxBound = _ref2.max,\n        _ref2$precision = _ref2.precision,\n        precision = _ref2$precision === void 0 ? 0 : _ref2$precision;\n\n    if (!attribute) {\n      throw new Error(connectRange_withUsage('The `attribute` option is required.'));\n    }\n\n    if (Object(isFiniteNumber[\"a\" /* default */])(minBound) && Object(isFiniteNumber[\"a\" /* default */])(maxBound) && minBound > maxBound) {\n      throw new Error(connectRange_withUsage(\"The `max` option can't be lower than `min`.\"));\n    }\n\n    var formatToNumber = function formatToNumber(v) {\n      return Number(Number(v).toFixed(precision));\n    };\n\n    var rangeFormatter = {\n      from: function from(v) {\n        return v.toLocaleString();\n      },\n      to: function to(v) {\n        return formatToNumber(v).toLocaleString();\n      }\n    }; // eslint-disable-next-line complexity\n\n    var getRefinedState = function getRefinedState(helper, currentRange, nextMin, nextMax) {\n      var resolvedState = helper.state;\n      var currentRangeMin = currentRange.min,\n          currentRangeMax = currentRange.max;\n\n      var _ref3 = resolvedState.getNumericRefinement(attribute, '>=') || [],\n          _ref4 = connectRange_slicedToArray(_ref3, 1),\n          min = _ref4[0];\n\n      var _ref5 = resolvedState.getNumericRefinement(attribute, '<=') || [],\n          _ref6 = connectRange_slicedToArray(_ref5, 1),\n          max = _ref6[0];\n\n      var isResetMin = nextMin === undefined || nextMin === '';\n      var isResetMax = nextMax === undefined || nextMax === '';\n\n      var _toPrecision = toPrecision({\n        min: !isResetMin ? parseFloat(nextMin) : undefined,\n        max: !isResetMax ? parseFloat(nextMax) : undefined,\n        precision: precision\n      }),\n          nextMinAsNumber = _toPrecision.min,\n          nextMaxAsNumber = _toPrecision.max;\n\n      var newNextMin;\n\n      if (!Object(isFiniteNumber[\"a\" /* default */])(minBound) && currentRangeMin === nextMinAsNumber) {\n        newNextMin = undefined;\n      } else if (Object(isFiniteNumber[\"a\" /* default */])(minBound) && isResetMin) {\n        newNextMin = minBound;\n      } else {\n        newNextMin = nextMinAsNumber;\n      }\n\n      var newNextMax;\n\n      if (!Object(isFiniteNumber[\"a\" /* default */])(maxBound) && currentRangeMax === nextMaxAsNumber) {\n        newNextMax = undefined;\n      } else if (Object(isFiniteNumber[\"a\" /* default */])(maxBound) && isResetMax) {\n        newNextMax = maxBound;\n      } else {\n        newNextMax = nextMaxAsNumber;\n      }\n\n      var isResetNewNextMin = newNextMin === undefined;\n      var isGreaterThanCurrentRange = Object(isFiniteNumber[\"a\" /* default */])(currentRangeMin) && currentRangeMin <= newNextMin;\n      var isMinValid = isResetNewNextMin || Object(isFiniteNumber[\"a\" /* default */])(newNextMin) && (!Object(isFiniteNumber[\"a\" /* default */])(currentRangeMin) || isGreaterThanCurrentRange);\n      var isResetNewNextMax = newNextMax === undefined;\n      var isLowerThanRange = Object(isFiniteNumber[\"a\" /* default */])(newNextMax) && currentRangeMax >= newNextMax;\n      var isMaxValid = isResetNewNextMax || Object(isFiniteNumber[\"a\" /* default */])(newNextMax) && (!Object(isFiniteNumber[\"a\" /* default */])(currentRangeMax) || isLowerThanRange);\n      var hasMinChange = min !== newNextMin;\n      var hasMaxChange = max !== newNextMax;\n\n      if ((hasMinChange || hasMaxChange) && isMinValid && isMaxValid) {\n        resolvedState = resolvedState.removeNumericRefinement(attribute);\n\n        if (Object(isFiniteNumber[\"a\" /* default */])(newNextMin)) {\n          resolvedState = resolvedState.addNumericRefinement(attribute, '>=', newNextMin);\n        }\n\n        if (Object(isFiniteNumber[\"a\" /* default */])(newNextMax)) {\n          resolvedState = resolvedState.addNumericRefinement(attribute, '<=', newNextMax);\n        }\n\n        return resolvedState.resetPage();\n      }\n\n      return null;\n    };\n\n    var sendEventWithRefinedState = function sendEventWithRefinedState(refinedState, instantSearchInstance, helper) {\n      var eventName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'Filter Applied';\n      var filters = Object(convertNumericRefinementsToFilters[\"a\" /* convertNumericRefinementsToFilters */])(refinedState, attribute);\n\n      if (filters && filters.length > 0) {\n        instantSearchInstance.sendEventToInsights({\n          insightsMethod: 'clickedFilters',\n          widgetType: connectRange_$$type,\n          eventType: 'click',\n          payload: {\n            eventName: eventName,\n            index: helper.getIndex(),\n            filters: filters\n          },\n          attribute: attribute\n        });\n      }\n    };\n\n    var createSendEvent = function createSendEvent(instantSearchInstance, helper, currentRange) {\n      return function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        if (args.length === 1) {\n          instantSearchInstance.sendEventToInsights(args[0]);\n          return;\n        }\n\n        var eventType = args[0],\n            facetValue = args[1],\n            eventName = args[2];\n\n        if (eventType !== 'click') {\n          return;\n        }\n\n        var _facetValue = connectRange_slicedToArray(facetValue, 2),\n            nextMin = _facetValue[0],\n            nextMax = _facetValue[1];\n\n        var refinedState = getRefinedState(helper, currentRange, nextMin, nextMax);\n        sendEventWithRefinedState(refinedState, instantSearchInstance, helper, eventName);\n      };\n    };\n\n    function _getCurrentRange(stats) {\n      var min;\n\n      if (Object(isFiniteNumber[\"a\" /* default */])(minBound)) {\n        min = minBound;\n      } else if (Object(isFiniteNumber[\"a\" /* default */])(stats.min)) {\n        min = stats.min;\n      } else {\n        min = 0;\n      }\n\n      var max;\n\n      if (Object(isFiniteNumber[\"a\" /* default */])(maxBound)) {\n        max = maxBound;\n      } else if (Object(isFiniteNumber[\"a\" /* default */])(stats.max)) {\n        max = stats.max;\n      } else {\n        max = 0;\n      }\n\n      return toPrecision({\n        min: min,\n        max: max,\n        precision: precision\n      });\n    }\n\n    function _getCurrentRefinement(helper) {\n      var _ref7 = helper.getNumericRefinement(attribute, '>=') || [],\n          _ref8 = connectRange_slicedToArray(_ref7, 1),\n          minValue = _ref8[0];\n\n      var _ref9 = helper.getNumericRefinement(attribute, '<=') || [],\n          _ref10 = connectRange_slicedToArray(_ref9, 1),\n          maxValue = _ref10[0];\n\n      var min = Object(isFiniteNumber[\"a\" /* default */])(minValue) ? minValue : -Infinity;\n      var max = Object(isFiniteNumber[\"a\" /* default */])(maxValue) ? maxValue : Infinity;\n      return [min, max];\n    }\n\n    function _refine(instantSearchInstance, helper, currentRange) {\n      return function () {\n        var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [undefined, undefined],\n            _ref12 = connectRange_slicedToArray(_ref11, 2),\n            nextMin = _ref12[0],\n            nextMax = _ref12[1];\n\n        var refinedState = getRefinedState(helper, currentRange, nextMin, nextMax);\n\n        if (refinedState) {\n          sendEventWithRefinedState(refinedState, instantSearchInstance, helper);\n          helper.setState(refinedState).search();\n        }\n      };\n    }\n\n    return {\n      $$type: connectRange_$$type,\n      init: function init(initOptions) {\n        renderFn(connectRange_objectSpread(connectRange_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: initOptions.instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        renderFn(connectRange_objectSpread(connectRange_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: renderOptions.instantSearchInstance\n        }), false);\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectRange_objectSpread(connectRange_objectSpread({}, renderState), {}, {\n          range: connectRange_objectSpread(connectRange_objectSpread({}, renderState.range), {}, connectRange_defineProperty({}, attribute, this.getWidgetRenderState(renderOptions)))\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref13) {\n        var results = _ref13.results,\n            helper = _ref13.helper,\n            instantSearchInstance = _ref13.instantSearchInstance;\n        var facetsFromResults = results && results.disjunctiveFacets || [];\n        var facet = Object(find[\"a\" /* default */])(facetsFromResults, function (facetResult) {\n          return facetResult.name === attribute;\n        });\n        var stats = facet && facet.stats || {\n          min: undefined,\n          max: undefined\n        };\n\n        var currentRange = _getCurrentRange(stats);\n\n        var start = _getCurrentRefinement(helper);\n\n        var refine;\n\n        if (!results) {\n          // On first render pass an empty range\n          // to be able to bypass the validation\n          // related to it\n          refine = _refine(instantSearchInstance, helper, {\n            min: undefined,\n            max: undefined\n          });\n        } else {\n          refine = _refine(instantSearchInstance, helper, currentRange);\n        }\n\n        return {\n          refine: refine,\n          canRefine: currentRange.min !== currentRange.max,\n          format: rangeFormatter,\n          range: currentRange,\n          sendEvent: createSendEvent(instantSearchInstance, helper, currentRange),\n          widgetParams: connectRange_objectSpread(connectRange_objectSpread({}, widgetParams), {}, {\n            precision: precision\n          }),\n          start: start\n        };\n      },\n      dispose: function dispose(_ref14) {\n        var state = _ref14.state;\n        unmountFn();\n        return state.removeDisjunctiveFacet(attribute).removeNumericRefinement(attribute);\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref15) {\n        var searchParameters = _ref15.searchParameters;\n\n        var _searchParameters$get = searchParameters.getNumericRefinements(attribute),\n            _searchParameters$get2 = _searchParameters$get['>='],\n            min = _searchParameters$get2 === void 0 ? [] : _searchParameters$get2,\n            _searchParameters$get3 = _searchParameters$get['<='],\n            max = _searchParameters$get3 === void 0 ? [] : _searchParameters$get3;\n\n        if (min.length === 0 && max.length === 0) {\n          return uiState;\n        }\n\n        return connectRange_objectSpread(connectRange_objectSpread({}, uiState), {}, {\n          range: connectRange_objectSpread(connectRange_objectSpread({}, uiState.range), {}, connectRange_defineProperty({}, attribute, \"\".concat(min, \":\").concat(max)))\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref16) {\n        var uiState = _ref16.uiState;\n        var widgetSearchParameters = searchParameters.addDisjunctiveFacet(attribute).setQueryParameters({\n          numericRefinements: connectRange_objectSpread(connectRange_objectSpread({}, searchParameters.numericRefinements), {}, connectRange_defineProperty({}, attribute, {}))\n        });\n\n        if (Object(isFiniteNumber[\"a\" /* default */])(minBound)) {\n          widgetSearchParameters = widgetSearchParameters.addNumericRefinement(attribute, '>=', minBound);\n        }\n\n        if (Object(isFiniteNumber[\"a\" /* default */])(maxBound)) {\n          widgetSearchParameters = widgetSearchParameters.addNumericRefinement(attribute, '<=', maxBound);\n        }\n\n        var value = uiState.range && uiState.range[attribute];\n\n        if (!value || value.indexOf(':') === -1) {\n          return widgetSearchParameters;\n        }\n\n        var _value$split$map = value.split(':').map(parseFloat),\n            _value$split$map2 = connectRange_slicedToArray(_value$split$map, 2),\n            lowerBound = _value$split$map2[0],\n            upperBound = _value$split$map2[1];\n\n        if (Object(isFiniteNumber[\"a\" /* default */])(lowerBound) && (!Object(isFiniteNumber[\"a\" /* default */])(minBound) || minBound < lowerBound)) {\n          widgetSearchParameters = widgetSearchParameters.removeNumericRefinement(attribute, '>=');\n          widgetSearchParameters = widgetSearchParameters.addNumericRefinement(attribute, '>=', lowerBound);\n        }\n\n        if (Object(isFiniteNumber[\"a\" /* default */])(upperBound) && (!Object(isFiniteNumber[\"a\" /* default */])(maxBound) || upperBound < maxBound)) {\n          widgetSearchParameters = widgetSearchParameters.removeNumericRefinement(attribute, '<=');\n          widgetSearchParameters = widgetSearchParameters.addNumericRefinement(attribute, '<=', upperBound);\n        }\n\n        return widgetSearchParameters;\n      }\n    };\n  };\n};\n\n/* harmony default export */ var range_connectRange = (connectRange_connectRange);\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/refinement-list/connectRefinementList.js\nfunction connectRefinementList_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectRefinementList_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectRefinementList_ownKeys(Object(source), true).forEach(function (key) {\n        connectRefinementList_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectRefinementList_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectRefinementList_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction connectRefinementList_objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = connectRefinementList_objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction connectRefinementList_objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\n\nvar connectRefinementList_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'refinement-list',\n  connector: true\n});\nvar connectRefinementList_DEFAULT_SORT = ['isRefined', 'count:desc', 'name:asc'];\n/**\n * **RefinementList** connector provides the logic to build a custom widget that\n * will let the user filter the results based on the values of a specific facet.\n *\n * **Requirement:** the attribute passed as `attribute` must be present in\n * attributesForFaceting of the searched index.\n *\n * This connector provides:\n * - a `refine()` function to select an item.\n * - a `toggleShowMore()` function to display more or less items\n * - a `searchForItems()` function to search within the items.\n */\n\nvar connectRefinementList_connectRefinementList = function connectRefinementList(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectRefinementList_withUsage());\n  return function (widgetParams) {\n    var _ref = widgetParams || {},\n        attribute = _ref.attribute,\n        _ref$operator = _ref.operator,\n        operator = _ref$operator === void 0 ? 'or' : _ref$operator,\n        _ref$limit = _ref.limit,\n        limit = _ref$limit === void 0 ? 10 : _ref$limit,\n        _ref$showMore = _ref.showMore,\n        showMore = _ref$showMore === void 0 ? false : _ref$showMore,\n        _ref$showMoreLimit = _ref.showMoreLimit,\n        showMoreLimit = _ref$showMoreLimit === void 0 ? 20 : _ref$showMoreLimit,\n        _ref$sortBy = _ref.sortBy,\n        sortBy = _ref$sortBy === void 0 ? connectRefinementList_DEFAULT_SORT : _ref$sortBy,\n        _ref$escapeFacetValue = _ref.escapeFacetValues,\n        escapeFacetValues = _ref$escapeFacetValue === void 0 ? true : _ref$escapeFacetValue,\n        _ref$transformItems = _ref.transformItems,\n        transformItems = _ref$transformItems === void 0 ? function (items) {\n      return items;\n    } : _ref$transformItems;\n\n    if (!attribute) {\n      throw new Error(connectRefinementList_withUsage('The `attribute` option is required.'));\n    }\n\n    if (!/^(and|or)$/.test(operator)) {\n      throw new Error(connectRefinementList_withUsage(\"The `operator` must one of: `\\\"and\\\"`, `\\\"or\\\"` (got \\\"\".concat(operator, \"\\\").\")));\n    }\n\n    if (showMore === true && showMoreLimit <= limit) {\n      throw new Error(connectRefinementList_withUsage('`showMoreLimit` should be greater than `limit`.'));\n    }\n\n    var formatItems = function formatItems(_ref2) {\n      var label = _ref2.name,\n          item = connectRefinementList_objectWithoutProperties(_ref2, [\"name\"]);\n\n      return connectRefinementList_objectSpread(connectRefinementList_objectSpread({}, item), {}, {\n        label: label,\n        value: label,\n        highlighted: label\n      });\n    };\n\n    var lastResultsFromMainSearch;\n    var lastItemsFromMainSearch = [];\n    var hasExhaustiveItems = true;\n    var triggerRefine;\n    var sendEvent;\n    var isShowingMore = false; // Provide the same function to the `renderFn` so that way the user\n    // has to only bind it once when `isFirstRendering` for instance\n\n    var toggleShowMore = function toggleShowMore() {};\n\n    function cachedToggleShowMore() {\n      toggleShowMore();\n    }\n\n    function createToggleShowMore(renderOptions, widget) {\n      return function () {\n        isShowingMore = !isShowingMore;\n        widget.render(renderOptions);\n      };\n    }\n\n    function getLimit() {\n      return isShowingMore ? showMoreLimit : limit;\n    }\n\n    var searchForFacetValues = function searchForFacetValues() {\n      return function () {};\n    };\n\n    var createSearchForFacetValues = function createSearchForFacetValues(helper, widget) {\n      return function (renderOptions) {\n        return function (query) {\n          var instantSearchInstance = renderOptions.instantSearchInstance;\n\n          if (query === '' && lastItemsFromMainSearch) {\n            // render with previous data from the helper.\n            renderFn(connectRefinementList_objectSpread(connectRefinementList_objectSpread({}, widget.getWidgetRenderState(connectRefinementList_objectSpread(connectRefinementList_objectSpread({}, renderOptions), {}, {\n              results: lastResultsFromMainSearch\n            }))), {}, {\n              instantSearchInstance: instantSearchInstance\n            }), false);\n          } else {\n            var tags = {\n              highlightPreTag: escapeFacetValues ? escape_highlight[\"a\" /* TAG_PLACEHOLDER */].highlightPreTag : escape_highlight[\"b\" /* TAG_REPLACEMENT */].highlightPreTag,\n              highlightPostTag: escapeFacetValues ? escape_highlight[\"a\" /* TAG_PLACEHOLDER */].highlightPostTag : escape_highlight[\"b\" /* TAG_REPLACEMENT */].highlightPostTag\n            };\n            helper.searchForFacetValues(attribute, query, // We cap the `maxFacetHits` value to 100 because the Algolia API\n            // doesn't support a greater number.\n            // See https://www.algolia.com/doc/api-reference/api-parameters/maxFacetHits/\n            Math.min(getLimit(), 100), tags).then(function (results) {\n              var facetValues = escapeFacetValues ? Object(escape_highlight[\"c\" /* escapeFacets */])(results.facetHits) : results.facetHits;\n              var normalizedFacetValues = transformItems(facetValues.map(function (_ref3) {\n                var value = _ref3.value,\n                    item = connectRefinementList_objectWithoutProperties(_ref3, [\"value\"]);\n\n                return connectRefinementList_objectSpread(connectRefinementList_objectSpread({}, item), {}, {\n                  value: value,\n                  label: value\n                });\n              }));\n              renderFn(connectRefinementList_objectSpread(connectRefinementList_objectSpread({}, widget.getWidgetRenderState(connectRefinementList_objectSpread(connectRefinementList_objectSpread({}, renderOptions), {}, {\n                results: lastResultsFromMainSearch\n              }))), {}, {\n                items: normalizedFacetValues,\n                canToggleShowMore: false,\n                canRefine: true,\n                isFromSearch: true,\n                instantSearchInstance: instantSearchInstance\n              }), false);\n            });\n          }\n        };\n      };\n    };\n\n    return {\n      $$type: 'ais.refinementList',\n      init: function init(initOptions) {\n        renderFn(connectRefinementList_objectSpread(connectRefinementList_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: initOptions.instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        renderFn(connectRefinementList_objectSpread(connectRefinementList_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: renderOptions.instantSearchInstance\n        }), false);\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectRefinementList_objectSpread(connectRefinementList_objectSpread({}, renderState), {}, {\n          refinementList: connectRefinementList_objectSpread(connectRefinementList_objectSpread({}, renderState.refinementList), {}, connectRefinementList_defineProperty({}, attribute, this.getWidgetRenderState(renderOptions)))\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(renderOptions) {\n        var results = renderOptions.results,\n            state = renderOptions.state,\n            _createURL = renderOptions.createURL,\n            instantSearchInstance = renderOptions.instantSearchInstance,\n            helper = renderOptions.helper;\n        var items = [];\n        var facetValues = [];\n\n        if (!sendEvent || !triggerRefine || !searchForFacetValues) {\n          sendEvent = Object(createSendEventForFacet[\"a\" /* createSendEventForFacet */])({\n            instantSearchInstance: instantSearchInstance,\n            helper: helper,\n            attribute: attribute,\n            widgetType: this.$$type\n          });\n\n          triggerRefine = function triggerRefine(facetValue) {\n            sendEvent('click', facetValue);\n            helper.toggleFacetRefinement(attribute, facetValue).search();\n          };\n\n          searchForFacetValues = createSearchForFacetValues(helper, this);\n        }\n\n        if (results) {\n          var values = results.getFacetValues(attribute, {\n            sortBy: sortBy,\n            facetOrdering: sortBy === connectRefinementList_DEFAULT_SORT\n          });\n          facetValues = values && Array.isArray(values) ? values : [];\n          items = transformItems(facetValues.slice(0, getLimit()).map(formatItems));\n          var maxValuesPerFacetConfig = state.maxValuesPerFacet;\n          var currentLimit = getLimit(); // If the limit is the max number of facet retrieved it is impossible to know\n          // if the facets are exhaustive. The only moment we are sure it is exhaustive\n          // is when it is strictly under the number requested unless we know that another\n          // widget has requested more values (maxValuesPerFacet > getLimit()).\n          // Because this is used for making the search of facets unable or not, it is important\n          // to be conservative here.\n\n          hasExhaustiveItems = maxValuesPerFacetConfig > currentLimit ? facetValues.length <= currentLimit : facetValues.length < currentLimit;\n          lastResultsFromMainSearch = results;\n          lastItemsFromMainSearch = items;\n\n          if (renderOptions.results) {\n            toggleShowMore = createToggleShowMore(renderOptions, this);\n          }\n        } // Do not mistake searchForFacetValues and searchFacetValues which is the actual search\n        // function\n\n\n        var searchFacetValues = searchForFacetValues && searchForFacetValues(renderOptions);\n        var canShowLess = isShowingMore && lastItemsFromMainSearch.length > limit;\n        var canShowMore = showMore && !hasExhaustiveItems;\n        var canToggleShowMore = canShowLess || canShowMore;\n        return {\n          createURL: function createURL(facetValue) {\n            return _createURL(state.resetPage().toggleFacetRefinement(attribute, facetValue));\n          },\n          items: items,\n          refine: triggerRefine,\n          searchForItems: searchFacetValues,\n          isFromSearch: false,\n          canRefine: items.length > 0,\n          widgetParams: widgetParams,\n          isShowingMore: isShowingMore,\n          canToggleShowMore: canToggleShowMore,\n          toggleShowMore: cachedToggleShowMore,\n          sendEvent: sendEvent,\n          hasExhaustiveItems: hasExhaustiveItems\n        };\n      },\n      dispose: function dispose(_ref4) {\n        var state = _ref4.state;\n        unmountFn();\n        var withoutMaxValuesPerFacet = state.setQueryParameter('maxValuesPerFacet', undefined);\n\n        if (operator === 'and') {\n          return withoutMaxValuesPerFacet.removeFacet(attribute);\n        }\n\n        return withoutMaxValuesPerFacet.removeDisjunctiveFacet(attribute);\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref5) {\n        var searchParameters = _ref5.searchParameters;\n        var values = operator === 'or' ? searchParameters.getDisjunctiveRefinements(attribute) : searchParameters.getConjunctiveRefinements(attribute);\n\n        if (!values.length) {\n          return uiState;\n        }\n\n        return connectRefinementList_objectSpread(connectRefinementList_objectSpread({}, uiState), {}, {\n          refinementList: connectRefinementList_objectSpread(connectRefinementList_objectSpread({}, uiState.refinementList), {}, connectRefinementList_defineProperty({}, attribute, values))\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref6) {\n        var uiState = _ref6.uiState;\n        var isDisjunctive = operator === 'or';\n        var values = uiState.refinementList && uiState.refinementList[attribute];\n        var withoutRefinements = searchParameters.clearRefinements(attribute);\n        var withFacetConfiguration = isDisjunctive ? withoutRefinements.addDisjunctiveFacet(attribute) : withoutRefinements.addFacet(attribute);\n        var currentMaxValuesPerFacet = withFacetConfiguration.maxValuesPerFacet || 0;\n        var nextMaxValuesPerFacet = Math.max(currentMaxValuesPerFacet, showMore ? showMoreLimit : limit);\n        var withMaxValuesPerFacet = withFacetConfiguration.setQueryParameter('maxValuesPerFacet', nextMaxValuesPerFacet);\n\n        if (!values) {\n          var key = isDisjunctive ? 'disjunctiveFacetsRefinements' : 'facetsRefinements';\n          return withMaxValuesPerFacet.setQueryParameters(connectRefinementList_defineProperty({}, key, connectRefinementList_objectSpread(connectRefinementList_objectSpread({}, withMaxValuesPerFacet[key]), {}, connectRefinementList_defineProperty({}, attribute, []))));\n        }\n\n        return values.reduce(function (parameters, value) {\n          return isDisjunctive ? parameters.addDisjunctiveFacetRefinement(attribute, value) : parameters.addFacetRefinement(attribute, value);\n        }, withMaxValuesPerFacet);\n      }\n    };\n  };\n};\n\n/* harmony default export */ var refinement_list_connectRefinementList = (connectRefinementList_connectRefinementList);\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/search-box/connectSearchBox.js\nfunction connectSearchBox_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectSearchBox_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectSearchBox_ownKeys(Object(source), true).forEach(function (key) {\n        connectSearchBox_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectSearchBox_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectSearchBox_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\nvar connectSearchBox_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'search-box',\n  connector: true\n});\n/**\n * **SearchBox** connector provides the logic to build a widget that will let the user search for a query.\n *\n * The connector provides to the rendering: `refine()` to set the query. The behaviour of this function\n * may be impacted by the `queryHook` widget parameter.\n */\n\nvar connectSearchBox_connectSearchBox = function connectSearchBox(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectSearchBox_withUsage());\n  return function (widgetParams) {\n    var _ref = widgetParams || {},\n        queryHook = _ref.queryHook;\n\n    function clear(helper) {\n      return function () {\n        helper.setQuery('').search();\n      };\n    }\n\n    var _refine;\n\n    var _clear = function _clear() {};\n\n    function _cachedClear() {\n      _clear();\n    }\n\n    return {\n      $$type: 'ais.searchBox',\n      init: function init(initOptions) {\n        var instantSearchInstance = initOptions.instantSearchInstance;\n        renderFn(connectSearchBox_objectSpread(connectSearchBox_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n        renderFn(connectSearchBox_objectSpread(connectSearchBox_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      dispose: function dispose(_ref2) {\n        var state = _ref2.state;\n        unmountFn();\n        return state.setQueryParameter('query', undefined);\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectSearchBox_objectSpread(connectSearchBox_objectSpread({}, renderState), {}, {\n          searchBox: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref3) {\n        var helper = _ref3.helper,\n            searchMetadata = _ref3.searchMetadata;\n\n        if (!_refine) {\n          var setQueryAndSearch = function setQueryAndSearch(query) {\n            if (query !== helper.state.query) {\n              helper.setQuery(query).search();\n            }\n          };\n\n          _refine = function _refine(query) {\n            if (queryHook) {\n              queryHook(query, setQueryAndSearch);\n              return;\n            }\n\n            setQueryAndSearch(query);\n          };\n        }\n\n        _clear = clear(helper);\n        return {\n          query: helper.state.query || '',\n          refine: _refine,\n          clear: _cachedClear,\n          widgetParams: widgetParams,\n          isSearchStalled: searchMetadata.isSearchStalled\n        };\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref4) {\n        var searchParameters = _ref4.searchParameters;\n        var query = searchParameters.query || '';\n\n        if (query === '' || uiState && uiState.query === query) {\n          return uiState;\n        }\n\n        return connectSearchBox_objectSpread(connectSearchBox_objectSpread({}, uiState), {}, {\n          query: query\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref5) {\n        var uiState = _ref5.uiState;\n        return searchParameters.setQueryParameter('query', uiState.query || '');\n      }\n    };\n  };\n};\n\n/* harmony default export */ var search_box_connectSearchBox = (connectSearchBox_connectSearchBox);\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/sort-by/connectSortBy.js\nfunction connectSortBy_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectSortBy_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectSortBy_ownKeys(Object(source), true).forEach(function (key) {\n        connectSortBy_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectSortBy_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectSortBy_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\nvar connectSortBy_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'sort-by',\n  connector: true\n});\n/**\n * The **SortBy** connector provides the logic to build a custom widget that will display a\n * list of indices. With Algolia, this is most commonly used for changing ranking strategy. This allows\n * a user to change how the hits are being sorted.\n */\n\nvar connectSortBy_connectSortBy = function connectSortBy(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectSortBy_withUsage());\n  var connectorState = {};\n  return function (widgetParams) {\n    var _ref = widgetParams || {},\n        items = _ref.items,\n        _ref$transformItems = _ref.transformItems,\n        transformItems = _ref$transformItems === void 0 ? function (x) {\n      return x;\n    } : _ref$transformItems;\n\n    if (!Array.isArray(items)) {\n      throw new Error(connectSortBy_withUsage('The `items` option expects an array of objects.'));\n    }\n\n    return {\n      $$type: 'ais.sortBy',\n      init: function init(initOptions) {\n        var instantSearchInstance = initOptions.instantSearchInstance;\n        var widgetRenderState = this.getWidgetRenderState(initOptions);\n        var currentIndex = widgetRenderState.currentRefinement;\n        var isCurrentIndexInItems = Object(find[\"a\" /* default */])(items, function (item) {\n          return item.value === currentIndex;\n        });\n         false ? undefined : void 0;\n        renderFn(connectSortBy_objectSpread(connectSortBy_objectSpread({}, widgetRenderState), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n        renderFn(connectSortBy_objectSpread(connectSortBy_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      dispose: function dispose(_ref2) {\n        var state = _ref2.state;\n        unmountFn();\n        return connectorState.initialIndex ? state.setIndex(connectorState.initialIndex) : state;\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectSortBy_objectSpread(connectSortBy_objectSpread({}, renderState), {}, {\n          sortBy: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref3) {\n        var results = _ref3.results,\n            helper = _ref3.helper,\n            parent = _ref3.parent;\n\n        if (!connectorState.initialIndex && parent) {\n          connectorState.initialIndex = parent.getIndexName();\n        }\n\n        if (!connectorState.setIndex) {\n          connectorState.setIndex = function (indexName) {\n            helper.setIndex(indexName).search();\n          };\n        }\n\n        return {\n          currentRefinement: helper.state.index,\n          options: transformItems(items),\n          refine: connectorState.setIndex,\n          hasNoResults: results ? results.nbHits === 0 : true,\n          widgetParams: widgetParams\n        };\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref4) {\n        var searchParameters = _ref4.searchParameters;\n        var currentIndex = searchParameters.index;\n        return connectSortBy_objectSpread(connectSortBy_objectSpread({}, uiState), {}, {\n          sortBy: currentIndex !== connectorState.initialIndex ? currentIndex : undefined\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref5) {\n        var uiState = _ref5.uiState;\n        return searchParameters.setQueryParameter('index', uiState.sortBy || connectorState.initialIndex || searchParameters.index);\n      }\n    };\n  };\n};\n\n/* harmony default export */ var sort_by_connectSortBy = (connectSortBy_connectSortBy);\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/rating-menu/connectRatingMenu.js\nfunction connectRatingMenu_toConsumableArray(arr) {\n  return connectRatingMenu_arrayWithoutHoles(arr) || connectRatingMenu_iterableToArray(arr) || connectRatingMenu_unsupportedIterableToArray(arr) || connectRatingMenu_nonIterableSpread();\n}\n\nfunction connectRatingMenu_nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction connectRatingMenu_iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction connectRatingMenu_arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return connectRatingMenu_arrayLikeToArray(arr);\n}\n\nfunction connectRatingMenu_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectRatingMenu_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectRatingMenu_ownKeys(Object(source), true).forEach(function (key) {\n        connectRatingMenu_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectRatingMenu_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectRatingMenu_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction connectRatingMenu_slicedToArray(arr, i) {\n  return connectRatingMenu_arrayWithHoles(arr) || connectRatingMenu_iterableToArrayLimit(arr, i) || connectRatingMenu_unsupportedIterableToArray(arr, i) || connectRatingMenu_nonIterableRest();\n}\n\nfunction connectRatingMenu_nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction connectRatingMenu_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return connectRatingMenu_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return connectRatingMenu_arrayLikeToArray(o, minLen);\n}\n\nfunction connectRatingMenu_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction connectRatingMenu_iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction connectRatingMenu_arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\n\nvar connectRatingMenu_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'rating-menu',\n  connector: true\n});\nvar connectRatingMenu_$$type = 'ais.ratingMenu';\nvar MAX_VALUES_PER_FACET_API_LIMIT = 1000;\nvar STEP = 1;\n\nvar connectRatingMenu_createSendEvent = function createSendEvent(_ref) {\n  var instantSearchInstance = _ref.instantSearchInstance,\n      helper = _ref.helper,\n      getRefinedStar = _ref.getRefinedStar,\n      attribute = _ref.attribute;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (args.length === 1) {\n      instantSearchInstance.sendEventToInsights(args[0]);\n      return;\n    }\n\n    var eventType = args[0],\n        facetValue = args[1],\n        _args$ = args[2],\n        eventName = _args$ === void 0 ? 'Filter Applied' : _args$;\n\n    if (eventType !== 'click') {\n      return;\n    }\n\n    var isRefined = getRefinedStar() === Number(facetValue);\n\n    if (!isRefined) {\n      instantSearchInstance.sendEventToInsights({\n        insightsMethod: 'clickedFilters',\n        widgetType: connectRatingMenu_$$type,\n        eventType: eventType,\n        payload: {\n          eventName: eventName,\n          index: helper.getIndex(),\n          filters: [\"\".concat(attribute, \">=\").concat(facetValue)]\n        },\n        attribute: attribute\n      });\n    }\n  };\n};\n/**\n * **StarRating** connector provides the logic to build a custom widget that will let\n * the user refine search results based on ratings.\n *\n * The connector provides to the rendering: `refine()` to select a value and\n * `items` that are the values that can be selected. `refine` should be used\n * with `items.value`.\n */\n\n\nvar connectRatingMenu_connectRatingMenu = function connectRatingMenu(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectRatingMenu_withUsage());\n  return function (widgetParams) {\n    var _ref2 = widgetParams || {},\n        attribute = _ref2.attribute,\n        _ref2$max = _ref2.max,\n        max = _ref2$max === void 0 ? 5 : _ref2$max;\n\n    var sendEvent;\n\n    if (!attribute) {\n      throw new Error(connectRatingMenu_withUsage('The `attribute` option is required.'));\n    }\n\n    var _getRefinedStar = function getRefinedStar(state) {\n      var _values$;\n\n      var values = state.getNumericRefinements(attribute);\n\n      if (!((_values$ = values['>=']) !== null && _values$ !== void 0 && _values$.length)) {\n        return undefined;\n      }\n\n      return values['>='][0];\n    };\n\n    var getFacetsMaxDecimalPlaces = function getFacetsMaxDecimalPlaces(facetResults) {\n      var maxDecimalPlaces = 0;\n      facetResults.forEach(function (facetResult) {\n        var _facetResult$name$spl = facetResult.name.split('.'),\n            _facetResult$name$spl2 = connectRatingMenu_slicedToArray(_facetResult$name$spl, 2),\n            _facetResult$name$spl3 = _facetResult$name$spl2[1],\n            decimal = _facetResult$name$spl3 === void 0 ? '' : _facetResult$name$spl3;\n\n        maxDecimalPlaces = Math.max(maxDecimalPlaces, decimal.length);\n      });\n      return maxDecimalPlaces;\n    };\n\n    var getFacetValuesWarningMessage = function getFacetValuesWarningMessage(_ref3) {\n      var maxDecimalPlaces = _ref3.maxDecimalPlaces,\n          maxFacets = _ref3.maxFacets,\n          maxValuesPerFacet = _ref3.maxValuesPerFacet;\n      var maxDecimalPlacesInRange = Math.max(0, Math.floor(Math.log10(MAX_VALUES_PER_FACET_API_LIMIT / max)));\n      var maxFacetsInRange = Math.min(MAX_VALUES_PER_FACET_API_LIMIT, Math.pow(10, maxDecimalPlacesInRange) * max);\n      var solutions = [];\n\n      if (maxFacets > MAX_VALUES_PER_FACET_API_LIMIT) {\n        solutions.push(\"- Update your records to lower the precision of the values in the \\\"\".concat(attribute, \"\\\" attribute (for example: \").concat(5.123456789.toPrecision(maxDecimalPlaces + 1), \" to \").concat(5.123456789.toPrecision(maxDecimalPlacesInRange + 1), \")\"));\n      }\n\n      if (maxValuesPerFacet < maxFacetsInRange) {\n        solutions.push(\"- Increase the maximum number of facet values to \".concat(maxFacetsInRange, \" using the \\\"configure\\\" widget \").concat(Object(documentation[\"a\" /* createDocumentationLink */])({\n          name: 'configure'\n        }), \" and the \\\"maxValuesPerFacet\\\" parameter https://www.algolia.com/doc/api-reference/api-parameters/maxValuesPerFacet/\"));\n      }\n\n      return \"The \".concat(attribute, \" attribute can have \").concat(maxFacets, \" different values (0 to \").concat(max, \" with a maximum of \").concat(maxDecimalPlaces, \" decimals = \").concat(maxFacets, \") but you retrieved only \").concat(maxValuesPerFacet, \" facet values. Therefore the number of results that match the refinements can be incorrect.\\n    \").concat(solutions.length ? \"To resolve this problem you can:\\n\".concat(solutions.join('\\n')) : \"\");\n    };\n\n    function getRefinedState(state, facetValue) {\n      var isRefined = _getRefinedStar(state) === Number(facetValue);\n      var emptyState = state.resetPage().removeNumericRefinement(attribute);\n\n      if (!isRefined) {\n        return emptyState.addNumericRefinement(attribute, '<=', max).addNumericRefinement(attribute, '>=', Number(facetValue));\n      }\n\n      return emptyState;\n    }\n\n    var toggleRefinement = function toggleRefinement(helper, facetValue) {\n      sendEvent('click', facetValue);\n      helper.setState(getRefinedState(helper.state, facetValue)).search();\n    };\n\n    var connectorState = {\n      toggleRefinementFactory: function toggleRefinementFactory(helper) {\n        return toggleRefinement.bind(null, helper);\n      },\n      createURLFactory: function createURLFactory(_ref4) {\n        var state = _ref4.state,\n            createURL = _ref4.createURL;\n        return function (value) {\n          return createURL(getRefinedState(state, value));\n        };\n      }\n    };\n    return {\n      $$type: connectRatingMenu_$$type,\n      init: function init(initOptions) {\n        var instantSearchInstance = initOptions.instantSearchInstance;\n        renderFn(connectRatingMenu_objectSpread(connectRatingMenu_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n        renderFn(connectRatingMenu_objectSpread(connectRatingMenu_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectRatingMenu_objectSpread(connectRatingMenu_objectSpread({}, renderState), {}, {\n          ratingMenu: connectRatingMenu_objectSpread(connectRatingMenu_objectSpread({}, renderState.ratingMenu), {}, connectRatingMenu_defineProperty({}, attribute, this.getWidgetRenderState(renderOptions)))\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref5) {\n        var helper = _ref5.helper,\n            results = _ref5.results,\n            state = _ref5.state,\n            instantSearchInstance = _ref5.instantSearchInstance,\n            createURL = _ref5.createURL;\n        var facetValues = [];\n\n        if (!sendEvent) {\n          sendEvent = connectRatingMenu_createSendEvent({\n            instantSearchInstance: instantSearchInstance,\n            helper: helper,\n            getRefinedStar: function getRefinedStar() {\n              return _getRefinedStar(helper.state);\n            },\n            attribute: attribute\n          });\n        }\n\n        if (results) {\n          var facetResults = results.getFacetValues(attribute, {});\n          var maxValuesPerFacet = facetResults.length;\n          var maxDecimalPlaces = getFacetsMaxDecimalPlaces(facetResults);\n          var maxFacets = Math.pow(10, maxDecimalPlaces) * max;\n           false ? undefined : void 0;\n\n          var refinedStar = _getRefinedStar(state);\n\n          var _loop = function _loop(star) {\n            var isRefined = refinedStar === star;\n            var count = facetResults.filter(function (f) {\n              return Number(f.name) >= star && Number(f.name) <= max;\n            }).map(function (f) {\n              return f.count;\n            }).reduce(function (sum, current) {\n              return sum + current;\n            }, 0);\n\n            if (refinedStar && !isRefined && count === 0) {\n              // skip count==0 when at least 1 refinement is enabled\n              // eslint-disable-next-line no-continue\n              return \"continue\";\n            }\n\n            var stars = connectRatingMenu_toConsumableArray(new Array(Math.floor(max / STEP))).map(function (_v, i) {\n              return i * STEP < star;\n            });\n\n            facetValues.push({\n              stars: stars,\n              name: String(star),\n              label: String(star),\n              value: String(star),\n              count: count,\n              isRefined: isRefined\n            });\n          };\n\n          for (var star = STEP; star < max; star += STEP) {\n            var _ret = _loop(star);\n\n            if (_ret === \"continue\") continue;\n          }\n        }\n\n        facetValues = facetValues.reverse();\n        return {\n          items: facetValues,\n          hasNoResults: results ? results.nbHits === 0 : true,\n          canRefine: facetValues.length > 0,\n          refine: connectorState.toggleRefinementFactory(helper),\n          sendEvent: sendEvent,\n          createURL: connectorState.createURLFactory({\n            state: state,\n            createURL: createURL\n          }),\n          widgetParams: widgetParams\n        };\n      },\n      dispose: function dispose(_ref6) {\n        var state = _ref6.state;\n        unmountFn();\n        return state.removeNumericRefinement(attribute);\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref7) {\n        var searchParameters = _ref7.searchParameters;\n\n        var value = _getRefinedStar(searchParameters);\n\n        if (typeof value !== 'number') {\n          return uiState;\n        }\n\n        return connectRatingMenu_objectSpread(connectRatingMenu_objectSpread({}, uiState), {}, {\n          ratingMenu: connectRatingMenu_objectSpread(connectRatingMenu_objectSpread({}, uiState.ratingMenu), {}, connectRatingMenu_defineProperty({}, attribute, value))\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref8) {\n        var uiState = _ref8.uiState;\n        var value = uiState.ratingMenu && uiState.ratingMenu[attribute];\n        var withoutRefinements = searchParameters.clearRefinements(attribute);\n        var withDisjunctiveFacet = withoutRefinements.addDisjunctiveFacet(attribute);\n\n        if (!value) {\n          return withDisjunctiveFacet.setQueryParameters({\n            numericRefinements: connectRatingMenu_objectSpread(connectRatingMenu_objectSpread({}, withDisjunctiveFacet.numericRefinements), {}, connectRatingMenu_defineProperty({}, attribute, {}))\n          });\n        }\n\n        return withDisjunctiveFacet.addNumericRefinement(attribute, '<=', max).addNumericRefinement(attribute, '>=', value);\n      }\n    };\n  };\n};\n\n/* harmony default export */ var rating_menu_connectRatingMenu = (connectRatingMenu_connectRatingMenu);\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/stats/connectStats.js\nfunction connectStats_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectStats_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectStats_ownKeys(Object(source), true).forEach(function (key) {\n        connectStats_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectStats_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectStats_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\nvar connectStats_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'stats',\n  connector: true\n});\n/**\n * **Stats** connector provides the logic to build a custom widget that will displays\n * search statistics (hits number and processing time).\n */\n\nvar connectStats_connectStats = function connectStats(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectStats_withUsage());\n  return function (widgetParams) {\n    return {\n      $$type: 'ais.stats',\n      init: function init(initOptions) {\n        var instantSearchInstance = initOptions.instantSearchInstance;\n        renderFn(connectStats_objectSpread(connectStats_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n        renderFn(connectStats_objectSpread(connectStats_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      dispose: function dispose() {\n        unmountFn();\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectStats_objectSpread(connectStats_objectSpread({}, renderState), {}, {\n          stats: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref) {\n        var results = _ref.results,\n            helper = _ref.helper;\n\n        if (!results) {\n          return {\n            hitsPerPage: helper.state.hitsPerPage,\n            nbHits: 0,\n            nbSortedHits: undefined,\n            areHitsSorted: false,\n            nbPages: 0,\n            page: helper.state.page || 0,\n            processingTimeMS: -1,\n            query: helper.state.query || '',\n            widgetParams: widgetParams\n          };\n        }\n\n        return {\n          hitsPerPage: results.hitsPerPage,\n          nbHits: results.nbHits,\n          nbSortedHits: results.nbSortedHits,\n          areHitsSorted: typeof results.appliedRelevancyStrictness !== 'undefined' && results.appliedRelevancyStrictness > 0 && results.nbSortedHits !== results.nbHits,\n          nbPages: results.nbPages,\n          page: results.page,\n          processingTimeMS: results.processingTimeMS,\n          query: results.query,\n          widgetParams: widgetParams\n        };\n      }\n    };\n  };\n};\n\n/* harmony default export */ var stats_connectStats = (connectStats_connectStats);\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/toArray.js\nvar toArray = __webpack_require__(371);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/escapeRefinement.js\nvar escapeRefinement = __webpack_require__(372);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/unescapeRefinement.js\nvar unescapeRefinement = __webpack_require__(314);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/toggle-refinement/connectToggleRefinement.js\nfunction connectToggleRefinement_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectToggleRefinement_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectToggleRefinement_ownKeys(Object(source), true).forEach(function (key) {\n        connectToggleRefinement_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectToggleRefinement_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectToggleRefinement_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\nvar connectToggleRefinement_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'toggle-refinement',\n  connector: true\n});\nvar connectToggleRefinement_$$type = 'ais.toggleRefinement';\n\nvar connectToggleRefinement_createSendEvent = function createSendEvent(_ref) {\n  var instantSearchInstance = _ref.instantSearchInstance,\n      helper = _ref.helper,\n      attribute = _ref.attribute,\n      on = _ref.on;\n\n  var sendEventForToggle = function sendEventForToggle() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (args.length === 1) {\n      instantSearchInstance.sendEventToInsights(args[0]);\n      return;\n    }\n\n    var eventType = args[0],\n        isRefined = args[1],\n        _args$ = args[2],\n        eventName = _args$ === void 0 ? 'Filter Applied' : _args$;\n\n    if (eventType !== 'click' || on === undefined) {\n      return;\n    } // only send an event when the refinement gets applied,\n    // not when it gets removed\n\n\n    if (!isRefined) {\n      instantSearchInstance.sendEventToInsights({\n        insightsMethod: 'clickedFilters',\n        widgetType: connectToggleRefinement_$$type,\n        eventType: eventType,\n        payload: {\n          eventName: eventName,\n          index: helper.getIndex(),\n          filters: on.map(function (value) {\n            return \"\".concat(attribute, \":\").concat(value);\n          })\n        },\n        attribute: attribute\n      });\n    }\n  };\n\n  return sendEventForToggle;\n};\n/**\n * **Toggle** connector provides the logic to build a custom widget that will provide\n * an on/off filtering feature based on an attribute value or values.\n *\n * Two modes are implemented in the custom widget:\n *  - with or without the value filtered\n *  - switch between two values.\n */\n\n\nvar connectToggleRefinement_connectToggleRefinement = function connectToggleRefinement(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectToggleRefinement_withUsage());\n  return function (widgetParams) {\n    var _ref2 = widgetParams || {},\n        attribute = _ref2.attribute,\n        _ref2$on = _ref2.on,\n        userOn = _ref2$on === void 0 ? true : _ref2$on,\n        userOff = _ref2.off;\n\n    if (!attribute) {\n      throw new Error(connectToggleRefinement_withUsage('The `attribute` option is required.'));\n    }\n\n    var hasAnOffValue = userOff !== undefined;\n    var on = Object(toArray[\"a\" /* default */])(userOn).map(escapeRefinement[\"a\" /* default */]);\n    var off = hasAnOffValue ? Object(toArray[\"a\" /* default */])(userOff).map(escapeRefinement[\"a\" /* default */]) : undefined;\n    var sendEvent;\n\n    var toggleRefinementFactory = function toggleRefinementFactory(helper) {\n      return function () {\n        var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n          isRefined: false\n        },\n            isRefined = _ref3.isRefined;\n\n        if (!isRefined) {\n          sendEvent('click', isRefined);\n\n          if (hasAnOffValue) {\n            off.forEach(function (v) {\n              return helper.removeDisjunctiveFacetRefinement(attribute, v);\n            });\n          }\n\n          on.forEach(function (v) {\n            return helper.addDisjunctiveFacetRefinement(attribute, v);\n          });\n        } else {\n          on.forEach(function (v) {\n            return helper.removeDisjunctiveFacetRefinement(attribute, v);\n          });\n\n          if (hasAnOffValue) {\n            off.forEach(function (v) {\n              return helper.addDisjunctiveFacetRefinement(attribute, v);\n            });\n          }\n        }\n\n        helper.search();\n      };\n    };\n\n    var connectorState = {\n      createURLFactory: function createURLFactory(isRefined, _ref4) {\n        var state = _ref4.state,\n            createURL = _ref4.createURL;\n        return function () {\n          state = state.resetPage();\n          var valuesToRemove = isRefined ? on : off;\n\n          if (valuesToRemove) {\n            valuesToRemove.forEach(function (v) {\n              state = state.removeDisjunctiveFacetRefinement(attribute, v);\n            });\n          }\n\n          var valuesToAdd = isRefined ? off : on;\n\n          if (valuesToAdd) {\n            valuesToAdd.forEach(function (v) {\n              state = state.addDisjunctiveFacetRefinement(attribute, v);\n            });\n          }\n\n          return createURL(state);\n        };\n      }\n    };\n    return {\n      $$type: connectToggleRefinement_$$type,\n      init: function init(initOptions) {\n        var instantSearchInstance = initOptions.instantSearchInstance;\n        renderFn(connectToggleRefinement_objectSpread(connectToggleRefinement_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n        renderFn(connectToggleRefinement_objectSpread(connectToggleRefinement_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      dispose: function dispose(_ref5) {\n        var state = _ref5.state;\n        unmountFn();\n        return state.removeDisjunctiveFacet(attribute);\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectToggleRefinement_objectSpread(connectToggleRefinement_objectSpread({}, renderState), {}, {\n          toggleRefinement: connectToggleRefinement_objectSpread(connectToggleRefinement_objectSpread({}, renderState.toggleRefinement), {}, connectToggleRefinement_defineProperty({}, attribute, this.getWidgetRenderState(renderOptions)))\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref6) {\n        var state = _ref6.state,\n            helper = _ref6.helper,\n            results = _ref6.results,\n            createURL = _ref6.createURL,\n            instantSearchInstance = _ref6.instantSearchInstance;\n        var isRefined = results ? on.every(function (v) {\n          return helper.state.isDisjunctiveFacetRefined(attribute, v);\n        }) : on.every(function (v) {\n          return state.isDisjunctiveFacetRefined(attribute, v);\n        });\n        var onFacetValue = {\n          isRefined: isRefined,\n          count: 0\n        };\n        var offFacetValue = {\n          isRefined: hasAnOffValue && !isRefined,\n          count: 0\n        };\n\n        if (results) {\n          var offValue = Object(toArray[\"a\" /* default */])(off || false);\n          var allFacetValues = results.getFacetValues(attribute, {}) || [];\n          var onData = on.map(function (v) {\n            return Object(find[\"a\" /* default */])(allFacetValues, function (_ref7) {\n              var name = _ref7.name;\n              return name === Object(unescapeRefinement[\"a\" /* default */])(v);\n            });\n          }).filter(function (v) {\n            return v !== undefined;\n          });\n          var offData = hasAnOffValue ? offValue.map(function (v) {\n            return Object(find[\"a\" /* default */])(allFacetValues, function (_ref8) {\n              var name = _ref8.name;\n              return name === Object(unescapeRefinement[\"a\" /* default */])(v);\n            });\n          }).filter(function (v) {\n            return v !== undefined;\n          }) : [];\n          onFacetValue = {\n            isRefined: onData.length ? onData.every(function (v) {\n              return v.isRefined;\n            }) : false,\n            count: onData.reduce(function (acc, v) {\n              return acc + v.count;\n            }, 0) || null\n          };\n          offFacetValue = {\n            isRefined: offData.length ? offData.every(function (v) {\n              return v.isRefined;\n            }) : false,\n            count: offData.reduce(function (acc, v) {\n              return acc + v.count;\n            }, 0) || allFacetValues.reduce(function (total, _ref9) {\n              var count = _ref9.count;\n              return total + count;\n            }, 0)\n          };\n        }\n\n        if (!sendEvent) {\n          sendEvent = connectToggleRefinement_createSendEvent({\n            instantSearchInstance: instantSearchInstance,\n            attribute: attribute,\n            on: on,\n            helper: helper\n          });\n        }\n\n        var nextRefinement = isRefined ? offFacetValue : onFacetValue;\n        return {\n          value: {\n            name: attribute,\n            isRefined: isRefined,\n            count: results ? nextRefinement.count : null,\n            onFacetValue: onFacetValue,\n            offFacetValue: offFacetValue\n          },\n          createURL: connectorState.createURLFactory(isRefined, {\n            state: state,\n            createURL: createURL\n          }),\n          sendEvent: sendEvent,\n          canRefine: Boolean(results ? nextRefinement.count : null),\n          refine: toggleRefinementFactory(helper),\n          widgetParams: widgetParams\n        };\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref10) {\n        var searchParameters = _ref10.searchParameters;\n        var isRefined = on && on.every(function (v) {\n          return searchParameters.isDisjunctiveFacetRefined(attribute, v);\n        });\n\n        if (!isRefined) {\n          return uiState;\n        }\n\n        return connectToggleRefinement_objectSpread(connectToggleRefinement_objectSpread({}, uiState), {}, {\n          toggle: connectToggleRefinement_objectSpread(connectToggleRefinement_objectSpread({}, uiState.toggle), {}, connectToggleRefinement_defineProperty({}, attribute, isRefined))\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref11) {\n        var uiState = _ref11.uiState;\n        var withFacetConfiguration = searchParameters.clearRefinements(attribute).addDisjunctiveFacet(attribute);\n        var isRefined = Boolean(uiState.toggle && uiState.toggle[attribute]);\n\n        if (isRefined) {\n          if (on) {\n            on.forEach(function (v) {\n              withFacetConfiguration = withFacetConfiguration.addDisjunctiveFacetRefinement(attribute, v);\n            });\n          }\n\n          return withFacetConfiguration;\n        } // It's not refined with an `off` value\n\n\n        if (hasAnOffValue) {\n          if (off) {\n            off.forEach(function (v) {\n              withFacetConfiguration = withFacetConfiguration.addDisjunctiveFacetRefinement(attribute, v);\n            });\n          }\n\n          return withFacetConfiguration;\n        } // It's not refined without an `off` value\n\n\n        return withFacetConfiguration.setQueryParameters({\n          disjunctiveFacetsRefinements: connectToggleRefinement_objectSpread(connectToggleRefinement_objectSpread({}, searchParameters.disjunctiveFacetsRefinements), {}, connectToggleRefinement_defineProperty({}, attribute, []))\n        });\n      }\n    };\n  };\n};\n\n/* harmony default export */ var toggle_refinement_connectToggleRefinement = (connectToggleRefinement_connectToggleRefinement);\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/breadcrumb/connectBreadcrumb.js\nfunction connectBreadcrumb_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectBreadcrumb_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectBreadcrumb_ownKeys(Object(source), true).forEach(function (key) {\n        connectBreadcrumb_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectBreadcrumb_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectBreadcrumb_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction connectBreadcrumb_slicedToArray(arr, i) {\n  return connectBreadcrumb_arrayWithHoles(arr) || connectBreadcrumb_iterableToArrayLimit(arr, i) || connectBreadcrumb_unsupportedIterableToArray(arr, i) || connectBreadcrumb_nonIterableRest();\n}\n\nfunction connectBreadcrumb_nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction connectBreadcrumb_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return connectBreadcrumb_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return connectBreadcrumb_arrayLikeToArray(o, minLen);\n}\n\nfunction connectBreadcrumb_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction connectBreadcrumb_iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction connectBreadcrumb_arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\n\nvar connectBreadcrumb_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'breadcrumb',\n  connector: true\n});\n\nvar connectBreadcrumb_connectBreadcrumb = function connectBreadcrumb(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectBreadcrumb_withUsage());\n  var connectorState = {};\n  return function (widgetParams) {\n    var _ref = widgetParams || {},\n        attributes = _ref.attributes,\n        _ref$separator = _ref.separator,\n        separator = _ref$separator === void 0 ? ' > ' : _ref$separator,\n        _ref$rootPath = _ref.rootPath,\n        rootPath = _ref$rootPath === void 0 ? null : _ref$rootPath,\n        _ref$transformItems = _ref.transformItems,\n        transformItems = _ref$transformItems === void 0 ? function (items) {\n      return items;\n    } : _ref$transformItems;\n\n    if (!attributes || !Array.isArray(attributes) || attributes.length === 0) {\n      throw new Error(connectBreadcrumb_withUsage('The `attributes` option expects an array of strings.'));\n    }\n\n    var _attributes = connectBreadcrumb_slicedToArray(attributes, 1),\n        hierarchicalFacetName = _attributes[0];\n\n    function getRefinedState(state, facetValue) {\n      if (!facetValue) {\n        var breadcrumb = state.getHierarchicalFacetBreadcrumb(hierarchicalFacetName);\n\n        if (breadcrumb.length > 0) {\n          return state.resetPage().toggleFacetRefinement(hierarchicalFacetName, breadcrumb[0]);\n        }\n      }\n\n      return state.resetPage().toggleFacetRefinement(hierarchicalFacetName, facetValue);\n    }\n\n    return {\n      $$type: 'ais.breadcrumb',\n      init: function init(initOptions) {\n        renderFn(connectBreadcrumb_objectSpread(connectBreadcrumb_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: initOptions.instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        renderFn(connectBreadcrumb_objectSpread(connectBreadcrumb_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: renderOptions.instantSearchInstance\n        }), false);\n      },\n      dispose: function dispose() {\n        unmountFn();\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectBreadcrumb_objectSpread(connectBreadcrumb_objectSpread({}, renderState), {}, {\n          breadcrumb: connectBreadcrumb_objectSpread(connectBreadcrumb_objectSpread({}, renderState.breadcrumb), {}, connectBreadcrumb_defineProperty({}, hierarchicalFacetName, this.getWidgetRenderState(renderOptions)))\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref2) {\n        var helper = _ref2.helper,\n            createURL = _ref2.createURL,\n            results = _ref2.results,\n            state = _ref2.state;\n\n        function getItems() {\n          if (!results) {\n            return [];\n          }\n\n          var _state$hierarchicalFa = connectBreadcrumb_slicedToArray(state.hierarchicalFacets, 1),\n              facetName = _state$hierarchicalFa[0].name;\n\n          var facetValues = results.getFacetValues(facetName, {});\n          var data = Array.isArray(facetValues.data) ? facetValues.data : [];\n          var items = transformItems(shiftItemsValues(connectBreadcrumb_prepareItems(data)));\n          return items;\n        }\n\n        var items = getItems();\n\n        if (!connectorState.createURL) {\n          connectorState.createURL = function (facetValue) {\n            return createURL(getRefinedState(helper.state, facetValue));\n          };\n        }\n\n        if (!connectorState.refine) {\n          connectorState.refine = function (facetValue) {\n            helper.setState(getRefinedState(helper.state, facetValue)).search();\n          };\n        }\n\n        return {\n          canRefine: items.length > 0,\n          createURL: connectorState.createURL,\n          items: items,\n          refine: connectorState.refine,\n          widgetParams: widgetParams\n        };\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters) {\n        if (searchParameters.isHierarchicalFacet(hierarchicalFacetName)) {\n          var facet = searchParameters.getHierarchicalFacetByName(hierarchicalFacetName);\n           false ? undefined : void 0;\n          return searchParameters;\n        }\n\n        return searchParameters.addHierarchicalFacet({\n          name: hierarchicalFacetName,\n          attributes: attributes,\n          separator: separator,\n          rootPath: rootPath\n        });\n      }\n    };\n  };\n};\n\nfunction connectBreadcrumb_prepareItems(data) {\n  return data.reduce(function (result, currentItem) {\n    if (currentItem.isRefined) {\n      result.push({\n        label: currentItem.name,\n        value: currentItem.path\n      });\n\n      if (Array.isArray(currentItem.data)) {\n        result = result.concat(connectBreadcrumb_prepareItems(currentItem.data));\n      }\n    }\n\n    return result;\n  }, []);\n}\n\nfunction shiftItemsValues(array) {\n  return array.map(function (x, idx) {\n    return {\n      label: x.label,\n      value: idx + 1 === array.length ? null : array[idx + 1].value\n    };\n  });\n}\n\n/* harmony default export */ var breadcrumb_connectBreadcrumb = (connectBreadcrumb_connectBreadcrumb);\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/geo-search.js\nvar geo_search = __webpack_require__(319);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/geo-search/connectGeoSearch.js\nfunction connectGeoSearch_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectGeoSearch_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectGeoSearch_ownKeys(Object(source), true).forEach(function (key) {\n        connectGeoSearch_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectGeoSearch_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectGeoSearch_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\nvar connectGeoSearch_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'geo-search',\n  connector: true\n}); // in this connector, we assume insideBoundingBox is only a string,\n// even though in the helper it's defined as number[][] alone.\n// This can be done, since the connector assumes \"control\" of the parameter\n\nfunction getBoundingBoxAsString(state) {\n  return state.insideBoundingBox || '';\n}\n\nfunction setBoundingBoxAsString(state, value) {\n  return state.setQueryParameter('insideBoundingBox', value);\n}\n\nvar connectGeoSearch_$$type = 'ais.geoSearch';\n/**\n * The **GeoSearch** connector provides the logic to build a widget that will display the results on a map. It also provides a way to search for results based on their position. The connector provides functions to manage the search experience (search on map interaction or control the interaction for example).\n *\n * @requirements\n *\n * Note that the GeoSearch connector uses the [geosearch](https://www.algolia.com/doc/guides/searching/geo-search) capabilities of Algolia. Your hits **must** have a `_geoloc` attribute in order to be passed to the rendering function.\n *\n * Currently, the feature is not compatible with multiple values in the _geoloc attribute.\n */\n\nvar connectGeoSearch_connectGeoSearch = function connectGeoSearch(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectGeoSearch_withUsage());\n  return function (widgetParams) {\n    var _ref = widgetParams || {},\n        _ref$enableRefineOnMa = _ref.enableRefineOnMapMove,\n        enableRefineOnMapMove = _ref$enableRefineOnMa === void 0 ? true : _ref$enableRefineOnMa,\n        _ref$transformItems = _ref.transformItems,\n        transformItems = _ref$transformItems === void 0 ? function (items) {\n      return items;\n    } : _ref$transformItems;\n\n    var widgetState = {\n      isRefineOnMapMove: enableRefineOnMapMove,\n      // @MAJOR hasMapMoveSinceLastRefine -> hasMapMovedSinceLastRefine\n      hasMapMoveSinceLastRefine: false,\n      lastRefinePosition: '',\n      lastRefineBoundingBox: '',\n      internalToggleRefineOnMapMove: noop[\"a\" /* default */],\n      internalSetMapMoveSinceLastRefine: noop[\"a\" /* default */]\n    };\n\n    var getPositionFromState = function getPositionFromState(state) {\n      return state.aroundLatLng ? Object(geo_search[\"a\" /* aroundLatLngToPosition */])(state.aroundLatLng) : undefined;\n    };\n\n    var getCurrentRefinementFromState = function getCurrentRefinementFromState(state) {\n      return state.insideBoundingBox && Object(geo_search[\"b\" /* insideBoundingBoxToBoundingBox */])(state.insideBoundingBox);\n    };\n\n    var refine = function refine(helper) {\n      return function (_ref2) {\n        var ne = _ref2.northEast,\n            sw = _ref2.southWest;\n        var boundingBox = [ne.lat, ne.lng, sw.lat, sw.lng].join();\n        helper.setState(setBoundingBoxAsString(helper.state, boundingBox).resetPage()).search();\n        widgetState.hasMapMoveSinceLastRefine = false;\n        widgetState.lastRefineBoundingBox = boundingBox;\n      };\n    };\n\n    var clearMapRefinement = function clearMapRefinement(helper) {\n      return function () {\n        helper.setQueryParameter('insideBoundingBox', undefined).search();\n      };\n    };\n\n    var isRefinedWithMap = function isRefinedWithMap(state) {\n      return function () {\n        return Boolean(state.insideBoundingBox);\n      };\n    };\n\n    var toggleRefineOnMapMove = function toggleRefineOnMapMove() {\n      return widgetState.internalToggleRefineOnMapMove();\n    };\n\n    var createInternalToggleRefinementOnMapMove = function createInternalToggleRefinementOnMapMove(renderOptions, render) {\n      return function () {\n        widgetState.isRefineOnMapMove = !widgetState.isRefineOnMapMove;\n        render(renderOptions);\n      };\n    };\n\n    var isRefineOnMapMove = function isRefineOnMapMove() {\n      return widgetState.isRefineOnMapMove;\n    };\n\n    var setMapMoveSinceLastRefine = function setMapMoveSinceLastRefine() {\n      return widgetState.internalSetMapMoveSinceLastRefine();\n    };\n\n    var createInternalSetMapMoveSinceLastRefine = function createInternalSetMapMoveSinceLastRefine(renderOptions, render) {\n      return function () {\n        var shouldTriggerRender = widgetState.hasMapMoveSinceLastRefine !== true;\n        widgetState.hasMapMoveSinceLastRefine = true;\n\n        if (shouldTriggerRender) {\n          render(renderOptions);\n        }\n      };\n    };\n\n    var hasMapMoveSinceLastRefine = function hasMapMoveSinceLastRefine() {\n      return widgetState.hasMapMoveSinceLastRefine;\n    };\n\n    var sendEvent;\n    return {\n      $$type: connectGeoSearch_$$type,\n      init: function init(initArgs) {\n        var instantSearchInstance = initArgs.instantSearchInstance;\n        var isFirstRendering = true;\n        widgetState.internalToggleRefineOnMapMove = createInternalToggleRefinementOnMapMove(initArgs, noop[\"a\" /* default */]);\n        widgetState.internalSetMapMoveSinceLastRefine = createInternalSetMapMoveSinceLastRefine(initArgs, noop[\"a\" /* default */]);\n        renderFn(connectGeoSearch_objectSpread(connectGeoSearch_objectSpread({}, this.getWidgetRenderState(initArgs)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), isFirstRendering);\n      },\n      render: function render(renderArgs) {\n        var helper = renderArgs.helper,\n            instantSearchInstance = renderArgs.instantSearchInstance;\n        var isFirstRendering = false; // We don't use the state provided by the render function because we need\n        // to be sure that the state is the latest one for the following condition\n\n        var state = helper.state;\n        var positionChangedSinceLastRefine = Boolean(state.aroundLatLng) && Boolean(widgetState.lastRefinePosition) && state.aroundLatLng !== widgetState.lastRefinePosition;\n        var boundingBoxChangedSinceLastRefine = !state.insideBoundingBox && Boolean(widgetState.lastRefineBoundingBox) && state.insideBoundingBox !== widgetState.lastRefineBoundingBox;\n\n        if (positionChangedSinceLastRefine || boundingBoxChangedSinceLastRefine) {\n          widgetState.hasMapMoveSinceLastRefine = false;\n        }\n\n        widgetState.lastRefinePosition = state.aroundLatLng || '';\n        widgetState.lastRefineBoundingBox = getBoundingBoxAsString(state);\n        widgetState.internalToggleRefineOnMapMove = createInternalToggleRefinementOnMapMove(renderArgs, this.render.bind(this));\n        widgetState.internalSetMapMoveSinceLastRefine = createInternalSetMapMoveSinceLastRefine(renderArgs, this.render.bind(this));\n        var widgetRenderState = this.getWidgetRenderState(renderArgs);\n        sendEvent('view', widgetRenderState.items);\n        renderFn(connectGeoSearch_objectSpread(connectGeoSearch_objectSpread({}, widgetRenderState), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), isFirstRendering);\n      },\n      getWidgetRenderState: function getWidgetRenderState(renderOptions) {\n        var helper = renderOptions.helper,\n            results = renderOptions.results,\n            instantSearchInstance = renderOptions.instantSearchInstance;\n        var state = helper.state;\n        var items = results ? transformItems(results.hits.filter(function (hit) {\n          return hit._geoloc;\n        })) : [];\n\n        if (!sendEvent) {\n          sendEvent = Object(createSendEventForHits[\"b\" /* createSendEventForHits */])({\n            instantSearchInstance: instantSearchInstance,\n            index: helper.getIndex(),\n            widgetType: connectGeoSearch_$$type\n          });\n        }\n\n        return {\n          items: items,\n          position: getPositionFromState(state),\n          currentRefinement: getCurrentRefinementFromState(state),\n          refine: refine(helper),\n          sendEvent: sendEvent,\n          clearMapRefinement: clearMapRefinement(helper),\n          isRefinedWithMap: isRefinedWithMap(state),\n          toggleRefineOnMapMove: toggleRefineOnMapMove,\n          isRefineOnMapMove: isRefineOnMapMove,\n          setMapMoveSinceLastRefine: setMapMoveSinceLastRefine,\n          hasMapMoveSinceLastRefine: hasMapMoveSinceLastRefine,\n          widgetParams: widgetParams\n        };\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectGeoSearch_objectSpread(connectGeoSearch_objectSpread({}, renderState), {}, {\n          geoSearch: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      dispose: function dispose(_ref3) {\n        var state = _ref3.state;\n        unmountFn();\n        return state.setQueryParameter('insideBoundingBox', undefined);\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref4) {\n        var searchParameters = _ref4.searchParameters;\n        var boundingBox = getBoundingBoxAsString(searchParameters);\n\n        if (!boundingBox || uiState && uiState.geoSearch && uiState.geoSearch.boundingBox === boundingBox) {\n          return uiState;\n        }\n\n        return connectGeoSearch_objectSpread(connectGeoSearch_objectSpread({}, uiState), {}, {\n          geoSearch: {\n            boundingBox: boundingBox\n          }\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref5) {\n        var uiState = _ref5.uiState;\n\n        if (!uiState || !uiState.geoSearch) {\n          return searchParameters.setQueryParameter('insideBoundingBox', undefined);\n        }\n\n        return setBoundingBoxAsString(searchParameters, uiState.geoSearch.boundingBox);\n      }\n    };\n  };\n};\n\n/* harmony default export */ var geo_search_connectGeoSearch = (connectGeoSearch_connectGeoSearch);\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/safelyRunOnBrowser.js\nvar safelyRunOnBrowser = __webpack_require__(373);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/powered-by/connectPoweredBy.js\nfunction connectPoweredBy_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectPoweredBy_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectPoweredBy_ownKeys(Object(source), true).forEach(function (key) {\n        connectPoweredBy_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectPoweredBy_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectPoweredBy_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\nvar connectPoweredBy_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'powered-by',\n  connector: true\n});\n/**\n * **PoweredBy** connector provides the logic to build a custom widget that will displays\n * the logo to redirect to Algolia.\n */\n\nvar connectPoweredBy_connectPoweredBy = function connectPoweredBy(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectPoweredBy_withUsage());\n  var defaultUrl = 'https://www.algolia.com/?' + 'utm_source=instantsearch.js&' + 'utm_medium=website&' + \"utm_content=\".concat(Object(safelyRunOnBrowser[\"a\" /* safelyRunOnBrowser */])(function (_ref) {\n    var _window$location;\n\n    var window = _ref.window;\n    return ((_window$location = window.location) === null || _window$location === void 0 ? void 0 : _window$location.hostname) || '';\n  }, {\n    fallback: function fallback() {\n      return '';\n    }\n  }), \"&\") + 'utm_campaign=poweredby';\n  return function (widgetParams) {\n    var _ref2 = widgetParams || {},\n        _ref2$url = _ref2.url,\n        url = _ref2$url === void 0 ? defaultUrl : _ref2$url;\n\n    return {\n      $$type: 'ais.poweredBy',\n      init: function init(initOptions) {\n        var instantSearchInstance = initOptions.instantSearchInstance;\n        renderFn(connectPoweredBy_objectSpread(connectPoweredBy_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n        renderFn(connectPoweredBy_objectSpread(connectPoweredBy_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectPoweredBy_objectSpread(connectPoweredBy_objectSpread({}, renderState), {}, {\n          poweredBy: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState() {\n        return {\n          url: url,\n          widgetParams: widgetParams\n        };\n      },\n      dispose: function dispose() {\n        unmountFn();\n      }\n    };\n  };\n};\n\n/* harmony default export */ var powered_by_connectPoweredBy = (connectPoweredBy_connectPoweredBy);\n// EXTERNAL MODULE: external \"algoliasearch-helper\"\nvar external_algoliasearch_helper_ = __webpack_require__(195);\nvar external_algoliasearch_helper_default = /*#__PURE__*/__webpack_require__.n(external_algoliasearch_helper_);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/isPlainObject.js\nvar isPlainObject = __webpack_require__(317);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/configure/connectConfigure.js\nfunction connectConfigure_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectConfigure_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectConfigure_ownKeys(Object(source), true).forEach(function (key) {\n        connectConfigure_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectConfigure_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectConfigure_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\n\n/**\n * Refine the given search parameters.\n */\n\nvar connectConfigure_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'configure',\n  connector: true\n});\n\nfunction getInitialSearchParameters(state, widgetParams) {\n  // We leverage the helper internals to remove the `widgetParams` from\n  // the state. The function `setQueryParameters` omits the values that\n  // are `undefined` on the next state.\n  return state.setQueryParameters(Object.keys(widgetParams.searchParameters).reduce(function (acc, key) {\n    return connectConfigure_objectSpread(connectConfigure_objectSpread({}, acc), {}, connectConfigure_defineProperty({}, key, undefined));\n  }, {}));\n}\n\nvar connectConfigure_connectConfigure = function connectConfigure() {\n  var renderFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop[\"a\" /* default */];\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  return function (widgetParams) {\n    if (!widgetParams || !Object(isPlainObject[\"a\" /* default */])(widgetParams.searchParameters)) {\n      throw new Error(connectConfigure_withUsage('The `searchParameters` option expects an object.'));\n    }\n\n    var connectorState = {};\n\n    function refine(helper) {\n      return function (searchParameters) {\n        // Merge new `searchParameters` with the ones set from other widgets\n        var actualState = getInitialSearchParameters(helper.state, widgetParams);\n        var nextSearchParameters = Object(mergeSearchParameters[\"a\" /* default */])(actualState, new external_algoliasearch_helper_default.a.SearchParameters(searchParameters)); // Update original `widgetParams.searchParameters` to the new refined one\n\n        widgetParams.searchParameters = searchParameters; // Trigger a search with the resolved search parameters\n\n        helper.setState(nextSearchParameters).search();\n      };\n    }\n\n    return {\n      $$type: 'ais.configure',\n      init: function init(initOptions) {\n        var instantSearchInstance = initOptions.instantSearchInstance;\n        renderFn(connectConfigure_objectSpread(connectConfigure_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n        renderFn(connectConfigure_objectSpread(connectConfigure_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      dispose: function dispose(_ref) {\n        var state = _ref.state;\n        unmountFn();\n        return getInitialSearchParameters(state, widgetParams);\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        var _renderState$configur;\n\n        var widgetRenderState = this.getWidgetRenderState(renderOptions);\n        return connectConfigure_objectSpread(connectConfigure_objectSpread({}, renderState), {}, {\n          configure: connectConfigure_objectSpread(connectConfigure_objectSpread({}, widgetRenderState), {}, {\n            widgetParams: connectConfigure_objectSpread(connectConfigure_objectSpread({}, widgetRenderState.widgetParams), {}, {\n              searchParameters: Object(mergeSearchParameters[\"a\" /* default */])(new external_algoliasearch_helper_default.a.SearchParameters((_renderState$configur = renderState.configure) === null || _renderState$configur === void 0 ? void 0 : _renderState$configur.widgetParams.searchParameters), new external_algoliasearch_helper_default.a.SearchParameters(widgetRenderState.widgetParams.searchParameters)).getQueryParams()\n            })\n          })\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref2) {\n        var helper = _ref2.helper;\n\n        if (!connectorState.refine) {\n          connectorState.refine = refine(helper);\n        }\n\n        return {\n          refine: connectorState.refine,\n          widgetParams: widgetParams\n        };\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(state, _ref3) {\n        var uiState = _ref3.uiState;\n        return Object(mergeSearchParameters[\"a\" /* default */])(state, new external_algoliasearch_helper_default.a.SearchParameters(connectConfigure_objectSpread(connectConfigure_objectSpread({}, uiState.configure), widgetParams.searchParameters)));\n      },\n      getWidgetUiState: function getWidgetUiState(uiState) {\n        return connectConfigure_objectSpread(connectConfigure_objectSpread({}, uiState), {}, {\n          configure: connectConfigure_objectSpread(connectConfigure_objectSpread({}, uiState.configure), widgetParams.searchParameters)\n        });\n      }\n    };\n  };\n};\n\n/* harmony default export */ var configure_connectConfigure = (connectConfigure_connectConfigure);\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getPropertyByPath.js\nvar getPropertyByPath = __webpack_require__(374);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/configure-related-items/connectConfigureRelatedItems.js\nfunction connectConfigureRelatedItems_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectConfigureRelatedItems_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectConfigureRelatedItems_ownKeys(Object(source), true).forEach(function (key) {\n        connectConfigureRelatedItems_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectConfigureRelatedItems_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectConfigureRelatedItems_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction connectConfigureRelatedItems_toConsumableArray(arr) {\n  return connectConfigureRelatedItems_arrayWithoutHoles(arr) || connectConfigureRelatedItems_iterableToArray(arr) || connectConfigureRelatedItems_unsupportedIterableToArray(arr) || connectConfigureRelatedItems_nonIterableSpread();\n}\n\nfunction connectConfigureRelatedItems_nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction connectConfigureRelatedItems_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return connectConfigureRelatedItems_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return connectConfigureRelatedItems_arrayLikeToArray(o, minLen);\n}\n\nfunction connectConfigureRelatedItems_iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction connectConfigureRelatedItems_arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return connectConfigureRelatedItems_arrayLikeToArray(arr);\n}\n\nfunction connectConfigureRelatedItems_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\n\n\n\nvar connectConfigureRelatedItems_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'configure-related-items',\n  connector: true\n});\n\nfunction createOptionalFilter(_ref) {\n  var attributeName = _ref.attributeName,\n      attributeValue = _ref.attributeValue,\n      attributeScore = _ref.attributeScore;\n  return \"\".concat(attributeName, \":\").concat(attributeValue, \"<score=\").concat(attributeScore || 1, \">\");\n}\n\nvar connectConfigureRelatedItems_connectConfigureRelatedItems = function connectConfigureRelatedItems(renderFn, unmountFn) {\n  return function (widgetParams) {\n    var _ref2 = widgetParams || {},\n        hit = _ref2.hit,\n        matchingPatterns = _ref2.matchingPatterns,\n        _ref2$transformSearch = _ref2.transformSearchParameters,\n        transformSearchParameters = _ref2$transformSearch === void 0 ? function (x) {\n      return x;\n    } : _ref2$transformSearch;\n\n    if (!hit) {\n      throw new Error(connectConfigureRelatedItems_withUsage('The `hit` option is required.'));\n    }\n\n    if (!matchingPatterns) {\n      throw new Error(connectConfigureRelatedItems_withUsage('The `matchingPatterns` option is required.'));\n    }\n\n    var optionalFilters = Object.keys(matchingPatterns).reduce(function (acc, attributeName) {\n      var attribute = matchingPatterns[attributeName];\n      var attributeValue = Object(getPropertyByPath[\"a\" /* default */])(hit, attributeName);\n      var attributeScore = attribute.score;\n\n      if (Array.isArray(attributeValue)) {\n        return [].concat(connectConfigureRelatedItems_toConsumableArray(acc), [attributeValue.map(function (attributeSubValue) {\n          return createOptionalFilter({\n            attributeName: attributeName,\n            attributeValue: attributeSubValue,\n            attributeScore: attributeScore\n          });\n        })]);\n      }\n\n      if (typeof attributeValue === 'string') {\n        return [].concat(connectConfigureRelatedItems_toConsumableArray(acc), [createOptionalFilter({\n          attributeName: attributeName,\n          attributeValue: attributeValue,\n          attributeScore: attributeScore\n        })]);\n      }\n\n       false ? undefined : void 0;\n      return acc;\n    }, []);\n\n    var searchParameters = connectConfigureRelatedItems_objectSpread({}, transformSearchParameters(new external_algoliasearch_helper_default.a.SearchParameters({\n      sumOrFiltersScores: true,\n      facetFilters: [\"objectID:-\".concat(hit.objectID)],\n      optionalFilters: optionalFilters\n    })));\n\n    var makeWidget = configure_connectConfigure(renderFn, unmountFn);\n    return connectConfigureRelatedItems_objectSpread(connectConfigureRelatedItems_objectSpread({}, makeWidget({\n      searchParameters: searchParameters\n    })), {}, {\n      $$type: 'ais.configureRelatedItems'\n    });\n  };\n};\n\n/* harmony default export */ var configure_related_items_connectConfigureRelatedItems = (connectConfigureRelatedItems_connectConfigureRelatedItems);\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/autocomplete/connectAutocomplete.js\nfunction connectAutocomplete_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectAutocomplete_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectAutocomplete_ownKeys(Object(source), true).forEach(function (key) {\n        connectAutocomplete_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectAutocomplete_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectAutocomplete_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\nvar connectAutocomplete_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'autocomplete',\n  connector: true\n});\n\nvar connectAutocomplete_connectAutocomplete = function connectAutocomplete(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectAutocomplete_withUsage());\n  return function (widgetParams) {\n    var _ref = widgetParams || {},\n        _ref$escapeHTML = _ref.escapeHTML,\n        escapeHTML = _ref$escapeHTML === void 0 ? true : _ref$escapeHTML;\n\n     false ? undefined : void 0;\n    var connectorState = {};\n    return {\n      $$type: 'ais.autocomplete',\n      init: function init(initOptions) {\n        var instantSearchInstance = initOptions.instantSearchInstance;\n        renderFn(connectAutocomplete_objectSpread(connectAutocomplete_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n        var renderState = this.getWidgetRenderState(renderOptions);\n        renderState.indices.forEach(function (_ref3) {\n          var sendEvent = _ref3.sendEvent,\n              hits = _ref3.hits;\n          sendEvent('view', hits);\n        });\n        renderFn(connectAutocomplete_objectSpread(connectAutocomplete_objectSpread({}, renderState), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectAutocomplete_objectSpread(connectAutocomplete_objectSpread({}, renderState), {}, {\n          autocomplete: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref4) {\n        var _this = this;\n\n        var helper = _ref4.helper,\n            scopedResults = _ref4.scopedResults,\n            instantSearchInstance = _ref4.instantSearchInstance;\n\n        if (!connectorState.refine) {\n          connectorState.refine = function (query) {\n            helper.setQuery(query).search();\n          };\n        }\n\n        var indices = scopedResults.map(function (scopedResult) {\n          // We need to escape the hits because highlighting\n          // exposes HTML tags to the end-user.\n          scopedResult.results.hits = escapeHTML ? Object(escape_highlight[\"d\" /* escapeHits */])(scopedResult.results.hits) : scopedResult.results.hits;\n          var sendEvent = Object(createSendEventForHits[\"b\" /* createSendEventForHits */])({\n            instantSearchInstance: instantSearchInstance,\n            index: scopedResult.results.index,\n            widgetType: _this.$$type\n          });\n          return {\n            indexId: scopedResult.indexId,\n            indexName: scopedResult.results.index,\n            hits: scopedResult.results.hits,\n            results: scopedResult.results,\n            sendEvent: sendEvent\n          };\n        });\n        return {\n          currentRefinement: helper.state.query || '',\n          indices: indices,\n          refine: connectorState.refine,\n          widgetParams: widgetParams\n        };\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref5) {\n        var searchParameters = _ref5.searchParameters;\n        var query = searchParameters.query || '';\n\n        if (query === '' || uiState && uiState.query === query) {\n          return uiState;\n        }\n\n        return connectAutocomplete_objectSpread(connectAutocomplete_objectSpread({}, uiState), {}, {\n          query: query\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref6) {\n        var uiState = _ref6.uiState;\n        var parameters = {\n          query: uiState.query || ''\n        };\n\n        if (!escapeHTML) {\n          return searchParameters.setQueryParameters(parameters);\n        }\n\n        return searchParameters.setQueryParameters(connectAutocomplete_objectSpread(connectAutocomplete_objectSpread({}, parameters), escape_highlight[\"a\" /* TAG_PLACEHOLDER */]));\n      },\n      dispose: function dispose(_ref7) {\n        var state = _ref7.state;\n        unmountFn();\n        var stateWithoutQuery = state.setQueryParameter('query', undefined);\n\n        if (!escapeHTML) {\n          return stateWithoutQuery;\n        }\n\n        return stateWithoutQuery.setQueryParameters(Object.keys(escape_highlight[\"a\" /* TAG_PLACEHOLDER */]).reduce(function (acc, key) {\n          return connectAutocomplete_objectSpread(connectAutocomplete_objectSpread({}, acc), {}, connectAutocomplete_defineProperty({}, key, undefined));\n        }, {}));\n      }\n    };\n  };\n};\n\n/* harmony default export */ var autocomplete_connectAutocomplete = (connectAutocomplete_connectAutocomplete);\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/isEqual.js\nvar isEqual = __webpack_require__(367);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/query-rules/connectQueryRules.js\nfunction connectQueryRules_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectQueryRules_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectQueryRules_ownKeys(Object(source), true).forEach(function (key) {\n        connectQueryRules_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectQueryRules_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectQueryRules_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction connectQueryRules_toConsumableArray(arr) {\n  return connectQueryRules_arrayWithoutHoles(arr) || connectQueryRules_iterableToArray(arr) || connectQueryRules_unsupportedIterableToArray(arr) || connectQueryRules_nonIterableSpread();\n}\n\nfunction connectQueryRules_nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction connectQueryRules_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return connectQueryRules_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return connectQueryRules_arrayLikeToArray(o, minLen);\n}\n\nfunction connectQueryRules_iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction connectQueryRules_arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return connectQueryRules_arrayLikeToArray(arr);\n}\n\nfunction connectQueryRules_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\n\nvar connectQueryRules_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'query-rules',\n  connector: true\n});\n\nfunction hasStateRefinements(state) {\n  return [state.disjunctiveFacetsRefinements, state.facetsRefinements, state.hierarchicalFacetsRefinements, state.numericRefinements].some(function (refinement) {\n    return Boolean(refinement && Object.keys(refinement).length > 0);\n  });\n} // A context rule must consist only of alphanumeric characters, hyphens, and underscores.\n// See https://www.algolia.com/doc/guides/managing-results/refine-results/merchandising-and-promoting/in-depth/implementing-query-rules/#context\n\n\nfunction escapeRuleContext(ruleName) {\n  return ruleName.replace(/[^a-z0-9-_]+/gi, '_');\n}\n\nfunction getRuleContextsFromTrackedFilters(_ref) {\n  var helper = _ref.helper,\n      sharedHelperState = _ref.sharedHelperState,\n      trackedFilters = _ref.trackedFilters;\n  var ruleContexts = Object.keys(trackedFilters).reduce(function (facets, facetName) {\n    var facetRefinements = Object(getRefinements[\"a\" /* default */])(helper.lastResults || {}, sharedHelperState, true).filter(function (refinement) {\n      return refinement.attribute === facetName;\n    }).map(function (refinement) {\n      return refinement.numericValue || refinement.name;\n    });\n    var getTrackedFacetValues = trackedFilters[facetName];\n    var trackedFacetValues = getTrackedFacetValues(facetRefinements);\n    return [].concat(connectQueryRules_toConsumableArray(facets), connectQueryRules_toConsumableArray(facetRefinements.filter(function (facetRefinement) {\n      return trackedFacetValues.includes(facetRefinement);\n    }).map(function (facetValue) {\n      return escapeRuleContext(\"ais-\".concat(facetName, \"-\").concat(facetValue));\n    })));\n  }, []);\n  return ruleContexts;\n}\n\nfunction applyRuleContexts(event) {\n  var helper = this.helper,\n      initialRuleContexts = this.initialRuleContexts,\n      trackedFilters = this.trackedFilters,\n      transformRuleContexts = this.transformRuleContexts;\n  var sharedHelperState = event.state;\n  var previousRuleContexts = sharedHelperState.ruleContexts || [];\n  var newRuleContexts = getRuleContextsFromTrackedFilters({\n    helper: helper,\n    sharedHelperState: sharedHelperState,\n    trackedFilters: trackedFilters\n  });\n  var nextRuleContexts = [].concat(connectQueryRules_toConsumableArray(initialRuleContexts), connectQueryRules_toConsumableArray(newRuleContexts));\n   false ? undefined : void 0;\n  var ruleContexts = transformRuleContexts(nextRuleContexts).slice(0, 10);\n\n  if (!Object(isEqual[\"a\" /* default */])(previousRuleContexts, ruleContexts)) {\n    helper.overrideStateWithoutTriggeringChangeEvent(connectQueryRules_objectSpread(connectQueryRules_objectSpread({}, sharedHelperState), {}, {\n      ruleContexts: ruleContexts\n    }));\n  }\n}\n\nvar connectQueryRules_connectQueryRules = function connectQueryRules(_render) {\n  var unmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(_render, connectQueryRules_withUsage());\n  return function (widgetParams) {\n    var _ref2 = widgetParams || {},\n        _ref2$trackedFilters = _ref2.trackedFilters,\n        trackedFilters = _ref2$trackedFilters === void 0 ? {} : _ref2$trackedFilters,\n        _ref2$transformRuleCo = _ref2.transformRuleContexts,\n        transformRuleContexts = _ref2$transformRuleCo === void 0 ? function (rules) {\n      return rules;\n    } : _ref2$transformRuleCo,\n        _ref2$transformItems = _ref2.transformItems,\n        transformItems = _ref2$transformItems === void 0 ? function (items) {\n      return items;\n    } : _ref2$transformItems;\n\n    Object.keys(trackedFilters).forEach(function (facetName) {\n      if (typeof trackedFilters[facetName] !== 'function') {\n        throw new Error(connectQueryRules_withUsage(\"'The \\\"\".concat(facetName, \"\\\" filter value in the `trackedFilters` option expects a function.\")));\n      }\n    });\n    var hasTrackedFilters = Object.keys(trackedFilters).length > 0; // We store the initial rule contexts applied before creating the widget\n    // so that we do not override them with the rules created from `trackedFilters`.\n\n    var initialRuleContexts = [];\n    var onHelperChange;\n    return {\n      $$type: 'ais.queryRules',\n      init: function init(initOptions) {\n        var helper = initOptions.helper,\n            state = initOptions.state,\n            instantSearchInstance = initOptions.instantSearchInstance;\n        initialRuleContexts = state.ruleContexts || [];\n        onHelperChange = applyRuleContexts.bind({\n          helper: helper,\n          initialRuleContexts: initialRuleContexts,\n          trackedFilters: trackedFilters,\n          transformRuleContexts: transformRuleContexts\n        });\n\n        if (hasTrackedFilters) {\n          // We need to apply the `ruleContexts` based on the `trackedFilters`\n          // before the helper changes state in some cases:\n          //   - Some filters are applied on the first load (e.g. using `configure`)\n          //   - The `transformRuleContexts` option sets initial `ruleContexts`.\n          if (hasStateRefinements(state) || Boolean(widgetParams.transformRuleContexts)) {\n            onHelperChange({\n              state: state\n            });\n          } // We track every change in the helper to override its state and add\n          // any `ruleContexts` needed based on the `trackedFilters`.\n\n\n          helper.on('change', onHelperChange);\n        }\n\n        _render(connectQueryRules_objectSpread(connectQueryRules_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n\n        _render(connectQueryRules_objectSpread(connectQueryRules_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref3) {\n        var results = _ref3.results;\n\n        var _ref4 = results || {},\n            _ref4$userData = _ref4.userData,\n            userData = _ref4$userData === void 0 ? [] : _ref4$userData;\n\n        var items = transformItems(userData);\n        return {\n          items: items,\n          widgetParams: widgetParams\n        };\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectQueryRules_objectSpread(connectQueryRules_objectSpread({}, renderState), {}, {\n          queryRules: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      dispose: function dispose(_ref5) {\n        var helper = _ref5.helper,\n            state = _ref5.state;\n        unmount();\n\n        if (hasTrackedFilters) {\n          helper.removeListener('change', onHelperChange);\n          return state.setQueryParameter('ruleContexts', initialRuleContexts);\n        }\n\n        return state;\n      }\n    };\n  };\n};\n\n/* harmony default export */ var query_rules_connectQueryRules = (connectQueryRules_connectQueryRules);\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/voiceSearchHelper/index.js\nfunction voiceSearchHelper_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction voiceSearchHelper_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      voiceSearchHelper_ownKeys(Object(source), true).forEach(function (key) {\n        voiceSearchHelper_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      voiceSearchHelper_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction voiceSearchHelper_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // `SpeechRecognition` is an API used on the browser so we can safely disable\n// the `window` check.\n\n/* eslint-disable no-restricted-globals */\n\n/* global SpeechRecognition SpeechRecognitionEvent */\n\n\nvar voiceSearchHelper_createVoiceSearchHelper = function createVoiceSearchHelper(_ref) {\n  var searchAsYouSpeak = _ref.searchAsYouSpeak,\n      language = _ref.language,\n      onQueryChange = _ref.onQueryChange,\n      onStateChange = _ref.onStateChange;\n  var SpeechRecognitionAPI = window.webkitSpeechRecognition || window.SpeechRecognition;\n\n  var getDefaultState = function getDefaultState(status) {\n    return {\n      status: status,\n      transcript: '',\n      isSpeechFinal: false,\n      errorCode: undefined\n    };\n  };\n\n  var state = getDefaultState('initial');\n  var recognition;\n\n  var isBrowserSupported = function isBrowserSupported() {\n    return Boolean(SpeechRecognitionAPI);\n  };\n\n  var isListening = function isListening() {\n    return state.status === 'askingPermission' || state.status === 'waiting' || state.status === 'recognizing';\n  };\n\n  var setState = function setState() {\n    var newState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    state = voiceSearchHelper_objectSpread(voiceSearchHelper_objectSpread({}, state), newState);\n    onStateChange();\n  };\n\n  var getState = function getState() {\n    return state;\n  };\n\n  var resetState = function resetState() {\n    var status = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'initial';\n    setState(getDefaultState(status));\n  };\n\n  var onStart = function onStart() {\n    setState({\n      status: 'waiting'\n    });\n  };\n\n  var onError = function onError(event) {\n    setState({\n      status: 'error',\n      errorCode: event.error\n    });\n  };\n\n  var onResult = function onResult(event) {\n    setState({\n      status: 'recognizing',\n      transcript: event.results[0] && event.results[0][0] && event.results[0][0].transcript || '',\n      isSpeechFinal: event.results[0] && event.results[0].isFinal\n    });\n\n    if (searchAsYouSpeak && state.transcript) {\n      onQueryChange(state.transcript);\n    }\n  };\n\n  var onEnd = function onEnd() {\n    if (!state.errorCode && state.transcript && !searchAsYouSpeak) {\n      onQueryChange(state.transcript);\n    }\n\n    if (state.status !== 'error') {\n      setState({\n        status: 'finished'\n      });\n    }\n  };\n\n  var startListening = function startListening() {\n    recognition = new SpeechRecognitionAPI();\n\n    if (!recognition) {\n      return;\n    }\n\n    resetState('askingPermission');\n    recognition.interimResults = true;\n\n    if (language) {\n      recognition.lang = language;\n    }\n\n    recognition.addEventListener('start', onStart);\n    recognition.addEventListener('error', onError);\n    recognition.addEventListener('result', onResult);\n    recognition.addEventListener('end', onEnd);\n    recognition.start();\n  };\n\n  var dispose = function dispose() {\n    if (!recognition) {\n      return;\n    }\n\n    recognition.stop();\n    recognition.removeEventListener('start', onStart);\n    recognition.removeEventListener('error', onError);\n    recognition.removeEventListener('result', onResult);\n    recognition.removeEventListener('end', onEnd);\n    recognition = undefined;\n  };\n\n  var stopListening = function stopListening() {\n    dispose(); // Because `dispose` removes event listeners, `end` listener is not called.\n    // So we're setting the `status` as `finished` here.\n    // If we don't do it, it will be still `waiting` or `recognizing`.\n\n    resetState('finished');\n  };\n\n  return {\n    getState: getState,\n    isBrowserSupported: isBrowserSupported,\n    isListening: isListening,\n    startListening: startListening,\n    stopListening: stopListening,\n    dispose: dispose\n  };\n};\n\n/* harmony default export */ var voiceSearchHelper = (voiceSearchHelper_createVoiceSearchHelper);\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/voice-search/connectVoiceSearch.js\nfunction connectVoiceSearch_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectVoiceSearch_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectVoiceSearch_ownKeys(Object(source), true).forEach(function (key) {\n        connectVoiceSearch_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectVoiceSearch_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectVoiceSearch_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\n\nvar connectVoiceSearch_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'voice-search',\n  connector: true\n});\n\nvar connectVoiceSearch_connectVoiceSearch = function connectVoiceSearch(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectVoiceSearch_withUsage());\n  return function (widgetParams) {\n    var _widgetParams$searchA = widgetParams.searchAsYouSpeak,\n        searchAsYouSpeak = _widgetParams$searchA === void 0 ? false : _widgetParams$searchA,\n        language = widgetParams.language,\n        additionalQueryParameters = widgetParams.additionalQueryParameters,\n        _widgetParams$createV = widgetParams.createVoiceSearchHelper,\n        createVoiceSearchHelper = _widgetParams$createV === void 0 ? voiceSearchHelper : _widgetParams$createV;\n    return {\n      $$type: 'ais.voiceSearch',\n      init: function init(initOptions) {\n        var instantSearchInstance = initOptions.instantSearchInstance;\n        renderFn(connectVoiceSearch_objectSpread(connectVoiceSearch_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n        renderFn(connectVoiceSearch_objectSpread(connectVoiceSearch_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectVoiceSearch_objectSpread(connectVoiceSearch_objectSpread({}, renderState), {}, {\n          voiceSearch: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(renderOptions) {\n        var _this = this;\n\n        var helper = renderOptions.helper,\n            instantSearchInstance = renderOptions.instantSearchInstance;\n\n        if (!this._refine) {\n          this._refine = function (query) {\n            if (query !== helper.state.query) {\n              var queryLanguages = language ? [language.split('-')[0]] : undefined;\n              helper.setQueryParameter('queryLanguages', queryLanguages);\n\n              if (typeof additionalQueryParameters === 'function') {\n                helper.setState(helper.state.setQueryParameters(connectVoiceSearch_objectSpread({\n                  ignorePlurals: true,\n                  removeStopWords: true,\n                  // @ts-ignore (optionalWords only allows array in v3, while string is also valid)\n                  optionalWords: query\n                }, additionalQueryParameters({\n                  query: query\n                }))));\n              }\n\n              helper.setQuery(query).search();\n            }\n          };\n        }\n\n        if (!this._voiceSearchHelper) {\n          this._voiceSearchHelper = createVoiceSearchHelper({\n            searchAsYouSpeak: searchAsYouSpeak,\n            language: language,\n            onQueryChange: function onQueryChange(query) {\n              return _this._refine(query);\n            },\n            onStateChange: function onStateChange() {\n              renderFn(connectVoiceSearch_objectSpread(connectVoiceSearch_objectSpread({}, _this.getWidgetRenderState(renderOptions)), {}, {\n                instantSearchInstance: instantSearchInstance\n              }), false);\n            }\n          });\n        }\n\n        var _voiceSearchHelper = this._voiceSearchHelper,\n            isBrowserSupported = _voiceSearchHelper.isBrowserSupported,\n            isListening = _voiceSearchHelper.isListening,\n            startListening = _voiceSearchHelper.startListening,\n            stopListening = _voiceSearchHelper.stopListening,\n            getState = _voiceSearchHelper.getState;\n        return {\n          isBrowserSupported: isBrowserSupported(),\n          isListening: isListening(),\n          toggleListening: function toggleListening() {\n            if (!isBrowserSupported()) {\n              return;\n            }\n\n            if (isListening()) {\n              stopListening();\n            } else {\n              startListening();\n            }\n          },\n          voiceListeningState: getState(),\n          widgetParams: widgetParams\n        };\n      },\n      dispose: function dispose(_ref) {\n        var state = _ref.state;\n\n        this._voiceSearchHelper.dispose();\n\n        unmountFn();\n        var newState = state;\n\n        if (typeof additionalQueryParameters === 'function') {\n          var additional = additionalQueryParameters({\n            query: ''\n          });\n          var toReset = additional ? Object.keys(additional).reduce(function (acc, current) {\n            // @ts-ignore search parameters is typed as readonly in v4\n            acc[current] = undefined;\n            return acc;\n          }, {}) : {};\n          newState = state.setQueryParameters(connectVoiceSearch_objectSpread({\n            // @ts-ignore (queryLanguages is not added to algoliasearch v3)\n            queryLanguages: undefined,\n            ignorePlurals: undefined,\n            removeStopWords: undefined,\n            optionalWords: undefined\n          }, toReset));\n        }\n\n        return newState.setQueryParameter('query', undefined);\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref2) {\n        var searchParameters = _ref2.searchParameters;\n        var query = searchParameters.query || '';\n\n        if (!query) {\n          return uiState;\n        }\n\n        return connectVoiceSearch_objectSpread(connectVoiceSearch_objectSpread({}, uiState), {}, {\n          query: query\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref3) {\n        var uiState = _ref3.uiState;\n        return searchParameters.setQueryParameter('query', uiState.query || '');\n      }\n    };\n  };\n};\n\n/* harmony default export */ var voice_search_connectVoiceSearch = (connectVoiceSearch_connectVoiceSearch);\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/createConcurrentSafePromise.js\nvar createConcurrentSafePromise = __webpack_require__(375);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/debounce.js\nvar debounce = __webpack_require__(376);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/answers/connectAnswers.js\nfunction connectAnswers_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectAnswers_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectAnswers_ownKeys(Object(source), true).forEach(function (key) {\n        connectAnswers_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectAnswers_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectAnswers_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\n\nfunction hasFindAnswersMethod(answersIndex) {\n  return typeof answersIndex.findAnswers === 'function';\n}\n\nvar connectAnswers_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'answers',\n  connector: true\n});\n\nvar connectAnswers_connectAnswers = function connectAnswers(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectAnswers_withUsage());\n  return function (widgetParams) {\n    var _ref = widgetParams || {},\n        queryLanguages = _ref.queryLanguages,\n        attributesForPrediction = _ref.attributesForPrediction,\n        _ref$nbHits = _ref.nbHits,\n        nbHits = _ref$nbHits === void 0 ? 1 : _ref$nbHits,\n        _ref$renderDebounceTi = _ref.renderDebounceTime,\n        renderDebounceTime = _ref$renderDebounceTi === void 0 ? 100 : _ref$renderDebounceTi,\n        _ref$searchDebounceTi = _ref.searchDebounceTime,\n        searchDebounceTime = _ref$searchDebounceTi === void 0 ? 100 : _ref$searchDebounceTi,\n        _ref$escapeHTML = _ref.escapeHTML,\n        escapeHTML = _ref$escapeHTML === void 0 ? true : _ref$escapeHTML,\n        _ref$extraParameters = _ref.extraParameters,\n        extraParameters = _ref$extraParameters === void 0 ? {} : _ref$extraParameters; // @ts-expect-error checking for the wrong value\n\n\n    if (!queryLanguages || queryLanguages.length === 0) {\n      throw new Error(connectAnswers_withUsage('The `queryLanguages` expects an array of strings.'));\n    }\n\n    var runConcurrentSafePromise = Object(createConcurrentSafePromise[\"a\" /* createConcurrentSafePromise */])();\n    var lastHits = [];\n    var isLoading = false;\n    var debouncedRender = Object(debounce[\"a\" /* debounce */])(renderFn, renderDebounceTime); // this does not directly use DebouncedFunction<findAnswers>, since then the generic will disappear\n\n    var debouncedRefine;\n    return {\n      $$type: 'ais.answers',\n      init: function init(initOptions) {\n        var state = initOptions.state,\n            instantSearchInstance = initOptions.instantSearchInstance;\n        var answersIndex = instantSearchInstance.client.initIndex(state.index);\n\n        if (!hasFindAnswersMethod(answersIndex)) {\n          throw new Error(connectAnswers_withUsage('`algoliasearch` >= 4.8.0 required.'));\n        }\n\n        debouncedRefine = Object(debounce[\"a\" /* debounce */])(answersIndex.findAnswers, searchDebounceTime);\n        renderFn(connectAnswers_objectSpread(connectAnswers_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: initOptions.instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var _this = this;\n\n        var query = renderOptions.state.query;\n\n        if (!query) {\n          // renders nothing with empty query\n          lastHits = [];\n          isLoading = false;\n          renderFn(connectAnswers_objectSpread(connectAnswers_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n            instantSearchInstance: renderOptions.instantSearchInstance\n          }), false);\n          return;\n        } // render the loader\n\n\n        lastHits = [];\n        isLoading = true;\n        renderFn(connectAnswers_objectSpread(connectAnswers_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: renderOptions.instantSearchInstance\n        }), false); // call /answers API\n\n        runConcurrentSafePromise(debouncedRefine(query, queryLanguages, connectAnswers_objectSpread(connectAnswers_objectSpread({}, extraParameters), {}, {\n          nbHits: nbHits,\n          attributesForPrediction: attributesForPrediction\n        }))).then(function (result) {\n          if (!result) {\n            // It's undefined when it's debounced.\n            return;\n          }\n\n          if (escapeHTML && result.hits.length > 0) {\n            result.hits = Object(escape_highlight[\"d\" /* escapeHits */])(result.hits);\n          }\n\n          var hitsWithAbsolutePosition = Object(hits_absolute_position[\"a\" /* addAbsolutePosition */])(result.hits, 0, nbHits);\n          var hitsWithAbsolutePositionAndQueryID = Object(hits_query_id[\"a\" /* addQueryID */])(hitsWithAbsolutePosition, result.queryID);\n          lastHits = hitsWithAbsolutePositionAndQueryID;\n          isLoading = false;\n          debouncedRender(connectAnswers_objectSpread(connectAnswers_objectSpread({}, _this.getWidgetRenderState(renderOptions)), {}, {\n            instantSearchInstance: renderOptions.instantSearchInstance\n          }), false);\n        });\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectAnswers_objectSpread(connectAnswers_objectSpread({}, renderState), {}, {\n          answers: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState() {\n        return {\n          hits: lastHits,\n          isLoading: isLoading,\n          widgetParams: widgetParams\n        };\n      },\n      dispose: function dispose(_ref2) {\n        var state = _ref2.state;\n        unmountFn();\n        return state;\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(state) {\n        return state;\n      }\n    };\n  };\n};\n\n/* harmony default export */ var answers_connectAnswers = (connectAnswers_connectAnswers);\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/relevant-sort/connectRelevantSort.js\nfunction connectRelevantSort_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectRelevantSort_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectRelevantSort_ownKeys(Object(source), true).forEach(function (key) {\n        connectRelevantSort_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectRelevantSort_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectRelevantSort_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\n\nvar connectRelevantSort_connectRelevantSort = function connectRelevantSort() {\n  var renderFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop[\"a\" /* default */];\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  return function (widgetParams) {\n    var connectorState = {};\n    return {\n      $$type: 'ais.relevantSort',\n      init: function init(initOptions) {\n        var instantSearchInstance = initOptions.instantSearchInstance;\n        renderFn(connectRelevantSort_objectSpread(connectRelevantSort_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var instantSearchInstance = renderOptions.instantSearchInstance;\n        renderFn(connectRelevantSort_objectSpread(connectRelevantSort_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), false);\n      },\n      dispose: function dispose(_ref) {\n        var state = _ref.state;\n        unmountFn();\n        return state.setQueryParameter('relevancyStrictness', undefined);\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectRelevantSort_objectSpread(connectRelevantSort_objectSpread({}, renderState), {}, {\n          relevantSort: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref2) {\n        var results = _ref2.results,\n            helper = _ref2.helper;\n\n        if (!connectorState.refine) {\n          connectorState.refine = function (relevancyStrictness) {\n            helper.setQueryParameter('relevancyStrictness', relevancyStrictness).search();\n          };\n        }\n\n        var _ref3 = results || {},\n            appliedRelevancyStrictness = _ref3.appliedRelevancyStrictness;\n\n        var isVirtualReplica = appliedRelevancyStrictness !== undefined;\n        return {\n          isRelevantSorted: typeof appliedRelevancyStrictness !== 'undefined' && appliedRelevancyStrictness > 0,\n          isVirtualReplica: isVirtualReplica,\n          canRefine: isVirtualReplica,\n          refine: connectorState.refine,\n          widgetParams: widgetParams\n        };\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(state, _ref4) {\n        var _uiState$relevantSort;\n\n        var uiState = _ref4.uiState;\n        return state.setQueryParameter('relevancyStrictness', (_uiState$relevantSort = uiState.relevantSort) !== null && _uiState$relevantSort !== void 0 ? _uiState$relevantSort : state.relevancyStrictness);\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref5) {\n        var searchParameters = _ref5.searchParameters;\n        return connectRelevantSort_objectSpread(connectRelevantSort_objectSpread({}, uiState), {}, {\n          relevantSort: searchParameters.relevancyStrictness || uiState.relevantSort\n        });\n      }\n    };\n  };\n};\n\n/* harmony default export */ var relevant_sort_connectRelevantSort = (connectRelevantSort_connectRelevantSort);\n// EXTERNAL MODULE: external \"core-js/modules/esnext.map.delete-all.js\"\nvar esnext_map_delete_all_js_ = __webpack_require__(178);\n\n// EXTERNAL MODULE: external \"core-js/modules/esnext.map.every.js\"\nvar esnext_map_every_js_ = __webpack_require__(179);\n\n// EXTERNAL MODULE: external \"core-js/modules/esnext.map.filter.js\"\nvar esnext_map_filter_js_ = __webpack_require__(180);\n\n// EXTERNAL MODULE: external \"core-js/modules/esnext.map.find.js\"\nvar esnext_map_find_js_ = __webpack_require__(181);\n\n// EXTERNAL MODULE: external \"core-js/modules/esnext.map.find-key.js\"\nvar esnext_map_find_key_js_ = __webpack_require__(182);\n\n// EXTERNAL MODULE: external \"core-js/modules/esnext.map.includes.js\"\nvar esnext_map_includes_js_ = __webpack_require__(183);\n\n// EXTERNAL MODULE: external \"core-js/modules/esnext.map.key-of.js\"\nvar esnext_map_key_of_js_ = __webpack_require__(184);\n\n// EXTERNAL MODULE: external \"core-js/modules/esnext.map.map-keys.js\"\nvar esnext_map_map_keys_js_ = __webpack_require__(185);\n\n// EXTERNAL MODULE: external \"core-js/modules/esnext.map.map-values.js\"\nvar esnext_map_map_values_js_ = __webpack_require__(186);\n\n// EXTERNAL MODULE: external \"core-js/modules/esnext.map.merge.js\"\nvar esnext_map_merge_js_ = __webpack_require__(187);\n\n// EXTERNAL MODULE: external \"core-js/modules/esnext.map.reduce.js\"\nvar esnext_map_reduce_js_ = __webpack_require__(188);\n\n// EXTERNAL MODULE: external \"core-js/modules/esnext.map.some.js\"\nvar esnext_map_some_js_ = __webpack_require__(189);\n\n// EXTERNAL MODULE: external \"core-js/modules/esnext.map.update.js\"\nvar esnext_map_update_js_ = __webpack_require__(190);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getWidgetAttribute.js\nvar getWidgetAttribute = __webpack_require__(377);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/dynamic-widgets/connectDynamicWidgets.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction connectDynamicWidgets_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction connectDynamicWidgets_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      connectDynamicWidgets_ownKeys(Object(source), true).forEach(function (key) {\n        connectDynamicWidgets_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      connectDynamicWidgets_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction connectDynamicWidgets_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n\nvar connectDynamicWidgets_withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'dynamic-widgets',\n  connector: true\n});\n\nvar connectDynamicWidgets_connectDynamicWidgets = function connectDynamicWidgets(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop[\"a\" /* default */];\n  Object(checkRendering[\"a\" /* default */])(renderFn, connectDynamicWidgets_withUsage());\n  return function (widgetParams) {\n    var widgets = widgetParams.widgets,\n        _widgetParams$transfo = widgetParams.transformItems,\n        transformItems = _widgetParams$transfo === void 0 ? function (items) {\n      return items;\n    } : _widgetParams$transfo,\n        fallbackWidget = widgetParams.fallbackWidget;\n\n    if (!(widgets && Array.isArray(widgets) && widgets.every(function (widget) {\n      return _typeof(widget) === 'object';\n    }))) {\n      throw new Error(connectDynamicWidgets_withUsage('The `widgets` option expects an array of widgets.'));\n    }\n\n    var localWidgets = new Map();\n    return {\n      $$type: 'ais.dynamicWidgets',\n      init: function init(initOptions) {\n        widgets.forEach(function (widget) {\n          var attribute = Object(getWidgetAttribute[\"a\" /* getWidgetAttribute */])(widget, initOptions);\n          localWidgets.set(attribute, {\n            widget: widget,\n            isMounted: false\n          });\n        });\n        renderFn(connectDynamicWidgets_objectSpread(connectDynamicWidgets_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: initOptions.instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        var parent = renderOptions.parent;\n        var renderState = this.getWidgetRenderState(renderOptions);\n        var widgetsToUnmount = [];\n        var widgetsToMount = [];\n\n        if (fallbackWidget) {\n          renderState.attributesToRender.forEach(function (attribute) {\n            if (!localWidgets.has(attribute)) {\n              var widget = fallbackWidget({\n                attribute: attribute\n              });\n              localWidgets.set(attribute, {\n                widget: widget,\n                isMounted: false\n              });\n            }\n          });\n        }\n\n        localWidgets.forEach(function (_ref, attribute) {\n          var widget = _ref.widget,\n              isMounted = _ref.isMounted;\n          var shouldMount = renderState.attributesToRender.indexOf(attribute) > -1;\n\n          if (!isMounted && shouldMount) {\n            widgetsToMount.push(widget);\n            localWidgets.set(attribute, {\n              widget: widget,\n              isMounted: true\n            });\n          } else if (isMounted && !shouldMount) {\n            widgetsToUnmount.push(widget);\n            localWidgets.set(attribute, {\n              widget: widget,\n              isMounted: false\n            });\n          }\n        });\n        parent.addWidgets(widgetsToMount); // make sure this only happens after the regular render, otherwise it\n        // happens too quick, since render is \"deferred\" for the next microtask,\n        // so this needs to be a whole task later\n\n        setTimeout(function () {\n          return parent.removeWidgets(widgetsToUnmount);\n        }, 0);\n        renderFn(connectDynamicWidgets_objectSpread(connectDynamicWidgets_objectSpread({}, renderState), {}, {\n          instantSearchInstance: renderOptions.instantSearchInstance\n        }), false);\n      },\n      dispose: function dispose(_ref2) {\n        var parent = _ref2.parent;\n        var toRemove = [];\n        localWidgets.forEach(function (_ref3) {\n          var widget = _ref3.widget,\n              isMounted = _ref3.isMounted;\n\n          if (isMounted) {\n            toRemove.push(widget);\n          }\n        });\n        parent.removeWidgets(toRemove);\n        unmountFn();\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return connectDynamicWidgets_objectSpread(connectDynamicWidgets_objectSpread({}, renderState), {}, {\n          dynamicWidgets: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref4) {\n        var _results$renderingCon, _results$renderingCon2, _results$renderingCon3, _results$renderingCon4;\n\n        var results = _ref4.results;\n\n        if (!results) {\n          return {\n            attributesToRender: [],\n            widgetParams: widgetParams\n          };\n        }\n\n        var attributesToRender = (_results$renderingCon = (_results$renderingCon2 = results.renderingContent) === null || _results$renderingCon2 === void 0 ? void 0 : (_results$renderingCon3 = _results$renderingCon2.facetOrdering) === null || _results$renderingCon3 === void 0 ? void 0 : (_results$renderingCon4 = _results$renderingCon3.facets) === null || _results$renderingCon4 === void 0 ? void 0 : _results$renderingCon4.order) !== null && _results$renderingCon !== void 0 ? _results$renderingCon : [];\n        return {\n          attributesToRender: transformItems(attributesToRender, {\n            results: results\n          }),\n          widgetParams: widgetParams\n        };\n      }\n    };\n  };\n};\n\n/* harmony default export */ var dynamic_widgets_connectDynamicWidgets = (connectDynamicWidgets_connectDynamicWidgets);\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/logger.js\nvar logger = __webpack_require__(286);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** @deprecated use connectDynamicWidgets */\n\nvar EXPERIMENTAL_connectDynamicWidgets = Object(logger[\"a\" /* deprecate */])(dynamic_widgets_connectDynamicWidgets, 'use connectDynamicWidgets');\n\n/***/ }),\n\n/***/ 412:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n__webpack_require__(214);\n\n__webpack_require__(215);\n\n__webpack_require__(216);\n\n__webpack_require__(217);\n\n__webpack_require__(218);\n\n__webpack_require__(219);\n\n__webpack_require__(220);\n\n__webpack_require__(221);\n\n__webpack_require__(222);\n\n__webpack_require__(223);\n\n__webpack_require__(224);\n\n__webpack_require__(225);\n\n__webpack_require__(226);\n\n__webpack_require__(227);\n\n__webpack_require__(228);\n\n__webpack_require__(229);\n\n__webpack_require__(178);\n\n__webpack_require__(179);\n\n__webpack_require__(180);\n\n__webpack_require__(181);\n\n__webpack_require__(182);\n\n__webpack_require__(183);\n\n__webpack_require__(184);\n\n__webpack_require__(185);\n\n__webpack_require__(186);\n\n__webpack_require__(187);\n\n__webpack_require__(188);\n\n__webpack_require__(189);\n\n__webpack_require__(190);\n\nfunction _interopDefault(e) {\n  return e && \"object\" == typeof e && \"default\" in e ? e.default : e;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\n\nvar Vue = _interopDefault(__webpack_require__(1)),\n    connectors = __webpack_require__(411),\n    mitt = _interopDefault(__webpack_require__(235)),\n    utils = __webpack_require__(255),\n    indexWidget = _interopDefault(__webpack_require__(383)),\n    instantsearch = _interopDefault(__webpack_require__(428)),\n    algoliaHelper = _interopDefault(__webpack_require__(195));\n\nfunction suit(e, t, i) {\n  if (!e) throw new Error(\"You need to provide `widgetName` in your data\");\n  var n = [\"ais-\" + e];\n  return t && n.push(\"-\" + t), i && n.push(\"--\" + i), n.join(\"\");\n}\n\nvar createSuitMixin = function (e) {\n  var t = e.name;\n  return {\n    props: {\n      classNames: {\n        type: Object,\n        default: void 0\n      }\n    },\n    methods: {\n      suit: function (e, i) {\n        var n = suit(t, e, i),\n            s = this.classNames && this.classNames[n];\n        return s ? [n, s].join(\" \") : n;\n      }\n    }\n  };\n},\n    isVue2 = !0,\n    isVue3 = !1,\n    Vue2 = Vue,\n    version = Vue.version;\n\nfunction renderCompat(e) {\n  return function (t) {\n    return e.call(this, t);\n  };\n}\n\nfunction getDefaultSlot(e) {\n  return e.$slots.default;\n}\n\nvar cache = new Set();\n\nfunction warn(e) {\n  cache.has(e) || (cache.add(e), console.warn(e));\n}\n\nvar createWidgetMixin = function (e) {\n  var t;\n  void 0 === e && (e = {});\n  var i = e.connector;\n  return (t = {\n    inject: {\n      instantSearchInstance: {\n        from: \"$_ais_instantSearchInstance\",\n        default: function () {\n          var e = this.$options._componentTag;\n          throw new TypeError('It looks like you forgot to wrap your Algolia search component \"<' + e + '>\" inside of an \"<ais-instant-search>\" component.');\n        }\n      },\n      getParentIndex: {\n        from: \"$_ais_getParentIndex\",\n        default: function () {\n          var e = this;\n          return function () {\n            return e.instantSearchInstance.mainIndex;\n          };\n        }\n      }\n    },\n    data: function () {\n      return {\n        state: null\n      };\n    },\n    created: function () {\n      if (\"function\" == typeof i) {\n        if (this.factory = i(this.updateState, function () {}), this.widget = this.factory(this.widgetParams), this.getParentIndex().addWidgets([this.widget]), this.instantSearchInstance.__initialSearchResults && !this.instantSearchInstance.started) {\n          if (\"function\" != typeof this.instantSearchInstance.__forceRender) throw new Error(\"You are using server side rendering with <ais-instant-search> instead of <ais-instant-search-ssr>.\");\n\n          this.instantSearchInstance.__forceRender(this.widget, this.getParentIndex());\n        }\n      } else !0 !== i && warn(\"You are using the InstantSearch widget mixin, but didn't provide a connector.\\nWhile this is technically possible, and will give you access to the Helper,\\nit's not the recommended way of making custom components.\\n\\nIf you want to disable this message, pass { connector: true } to the mixin.\\n\\nRead more on using connectors: https://alg.li/vue-custom\");\n    }\n  }).beforeDestroy = function () {\n    this.widget && this.getParentIndex().removeWidgets([this.widget]);\n  }, t.watch = {\n    widgetParams: {\n      handler: function (e) {\n        this.state = null, this.getParentIndex().removeWidgets([this.widget]), this.widget = this.factory(e), this.getParentIndex().addWidgets([this.widget]);\n      },\n      deep: !0\n    }\n  }, t.methods = {\n    updateState: function (e, t) {\n      void 0 === e && (e = {}), t || (this.state = e);\n    }\n  }, t;\n},\n    Autocomplete = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: e.suit()\n    }, [e._t(\"default\", [i(\"p\", [e._v(\"This widget doesn't render anything without a filled in default slot.\")]), e._v(\" \"), i(\"p\", [e._v(\"query, function to refine and results are provided.\")]), e._v(\" \"), i(\"pre\", [e._v(\"refine: Function\")]), e._v(\" \"), i(\"pre\", [e._v('currentRefinement: \"' + e._s(e.state.currentRefinement) + '\"')]), e._v(\" \"), i(\"details\", [e._m(0), e._v(\" \"), i(\"pre\", [e._v(e._s(e.state.indices))])])], {\n      refine: e.state.refine,\n      currentRefinement: e.state.currentRefinement,\n      indices: e.state.indices\n    })], 2) : e._e();\n  },\n  staticRenderFns: [function () {\n    var e = this.$createElement,\n        t = this._self._c || e;\n    return t(\"summary\", [t(\"code\", [this._v(\"indices\")]), this._v(\":\")]);\n  }],\n  name: \"AisAutocomplete\",\n  mixins: [createWidgetMixin({\n    connector: connectors.connectAutocomplete\n  }), createSuitMixin({\n    name: \"Autocomplete\"\n  })],\n  props: {\n    escapeHTML: {\n      type: Boolean,\n      required: !1,\n      default: !0\n    }\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        escapeHTML: this.escapeHTML\n      };\n    }\n  }\n},\n    PANEL_EMITTER_NAMESPACE = \"instantSearchPanelEmitter\",\n    PANEL_CHANGE_EVENT = \"PANEL_CHANGE_EVENT\",\n    createPanelProviderMixin = function () {\n  var e;\n  return (e = {\n    props: {\n      emitter: {\n        type: Object,\n        required: !1,\n        default: function () {\n          return mitt();\n        }\n      }\n    },\n    provide: function () {\n      var e;\n      return (e = {})[PANEL_EMITTER_NAMESPACE] = this.emitter, e;\n    },\n    data: function () {\n      return {\n        canRefine: !0\n      };\n    },\n    created: function () {\n      var e = this;\n      this.emitter.on(PANEL_CHANGE_EVENT, function (t) {\n        e.updateCanRefine(t);\n      });\n    }\n  }).beforeDestroy = function () {\n    this.emitter.all.clear();\n  }, e.methods = {\n    updateCanRefine: function (e) {\n      this.canRefine = e;\n    }\n  }, e;\n},\n    createPanelConsumerMixin = function (e) {\n  var t = e.mapStateToCanRefine;\n  return {\n    inject: {\n      emitter: {\n        from: PANEL_EMITTER_NAMESPACE,\n        default: function () {\n          return {\n            emit: function () {}\n          };\n        }\n      }\n    },\n    data: function () {\n      return {\n        state: null,\n        hasAlreadyEmitted: !1\n      };\n    },\n    watch: {\n      state: {\n        immediate: !0,\n        handler: function (e, i) {\n          if (e) {\n            var n = t(i || {}),\n                s = t(e);\n            this.hasAlreadyEmitted && n === s || (this.emitter.emit(PANEL_CHANGE_EVENT, s), this.hasAlreadyEmitted = !0);\n          }\n        }\n      }\n    }\n  };\n},\n    Breadcrumb = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: [e.suit(), !e.state.canRefine && e.suit(\"\", \"noRefinement\")]\n    }, [e._t(\"default\", [i(\"ul\", {\n      class: e.suit(\"list\")\n    }, [i(\"li\", {\n      class: [e.suit(\"item\"), !e.state.items.length && e.suit(\"item\", \"selected\")]\n    }, [Boolean(e.state.items.length) ? i(\"a\", {\n      class: e.suit(\"link\"),\n      attrs: {\n        href: e.state.createURL()\n      },\n      on: {\n        click: function (t) {\n          return t.preventDefault(), e.state.refine();\n        }\n      }\n    }, [e._t(\"rootLabel\", [e._v(\"Home\")])], 2) : i(\"span\", [e._t(\"rootLabel\", [e._v(\"Home\")])], 2)]), e._v(\" \"), e._l(e.state.items, function (t, n) {\n      return i(\"li\", {\n        key: t.label,\n        class: [e.suit(\"item\"), e.isLastItem(n) && e.suit(\"item\", \"selected\")]\n      }, [i(\"span\", {\n        class: e.suit(\"separator\"),\n        attrs: {\n          \"aria-hidden\": \"true\"\n        }\n      }, [e._t(\"separator\", [e._v(\">\")])], 2), e._v(\" \"), e.isLastItem(n) ? i(\"span\", [e._v(e._s(t.label))]) : i(\"a\", {\n        class: e.suit(\"link\"),\n        attrs: {\n          href: e.state.createURL(t.value)\n        },\n        on: {\n          click: function (i) {\n            return i.preventDefault(), e.state.refine(t.value);\n          }\n        }\n      }, [e._v(e._s(t.label))])]);\n    })], 2)], {\n      items: e.state.items,\n      canRefine: e.state.canRefine,\n      refine: e.state.refine,\n      createURL: e.state.createURL\n    })], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisBreadcrumb\",\n  mixins: [createWidgetMixin({\n    connector: connectors.connectBreadcrumb\n  }), createPanelConsumerMixin({\n    mapStateToCanRefine: function (e) {\n      return Boolean(e.canRefine);\n    }\n  }), createSuitMixin({\n    name: \"Breadcrumb\"\n  })],\n  props: {\n    attributes: {\n      type: Array,\n      required: !0\n    },\n    separator: {\n      type: String,\n      default: void 0\n    },\n    rootPath: {\n      type: String,\n      default: void 0\n    },\n    transformItems: {\n      type: Function,\n      default: void 0\n    }\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        attributes: this.attributes,\n        separator: this.separator,\n        rootPath: this.rootPath,\n        transformItems: this.transformItems\n      };\n    }\n  },\n  methods: {\n    isLastItem: function (e) {\n      return this.state.items.length - 1 === e;\n    }\n  }\n},\n    ClearRefinements = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: e.suit()\n    }, [e._t(\"default\", [i(\"button\", {\n      class: [e.suit(\"button\"), !e.canRefine && e.suit(\"button\", \"disabled\")],\n      attrs: {\n        type: \"reset\",\n        disabled: !e.canRefine\n      },\n      on: {\n        click: function (t) {\n          return t.preventDefault(), e.state.refine(t);\n        }\n      }\n    }, [e._t(\"resetLabel\", [e._v(\"Clear refinements\")])], 2)], {\n      canRefine: e.canRefine,\n      refine: e.state.refine,\n      createURL: e.state.createURL\n    })], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisClearRefinements\",\n  mixins: [createWidgetMixin({\n    connector: connectors.connectClearRefinements\n  }), createPanelConsumerMixin({\n    mapStateToCanRefine: function (e) {\n      return Boolean(e.hasRefinements);\n    }\n  }), createSuitMixin({\n    name: \"ClearRefinements\"\n  })],\n  props: {\n    excludedAttributes: {\n      type: Array,\n      default: void 0\n    },\n    includedAttributes: {\n      type: Array,\n      default: void 0\n    },\n    transformItems: {\n      type: Function,\n      default: void 0\n    }\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        includedAttributes: this.includedAttributes,\n        excludedAttributes: this.excludedAttributes,\n        transformItems: this.transformItems\n      };\n    },\n    canRefine: function () {\n      return this.state.hasRefinements;\n    }\n  }\n},\n    Configure = {\n  inheritAttrs: !1,\n  name: \"AisConfigure\",\n  mixins: [createSuitMixin({\n    name: \"Configure\"\n  }), createWidgetMixin({\n    connector: connectors.connectConfigure\n  })],\n  computed: {\n    widgetParams: function () {\n      return {\n        searchParameters: this.$attrs\n      };\n    }\n  },\n  render: renderCompat(function (e) {\n    var t = this.$scopedSlots.default;\n    return this.state && t ? e(\"div\", {\n      class: this.suit()\n    }, [t({\n      refine: this.state.refine,\n      searchParameters: this.state.widgetParams.searchParameters\n    })]) : null;\n  })\n},\n    ConfigureRelatedItems = {\n  inheritAttrs: !1,\n  name: \"AisExperimentalConfigureRelatedItems\",\n  mixins: [createWidgetMixin({\n    connector: connectors.EXPERIMENTAL_connectConfigureRelatedItems\n  })],\n  props: {\n    hit: {\n      type: Object,\n      required: !0\n    },\n    matchingPatterns: {\n      type: Object,\n      required: !0\n    },\n    transformSearchParameters: {\n      type: Function,\n      required: !1\n    }\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        hit: this.hit,\n        matchingPatterns: this.matchingPatterns,\n        transformSearchParameters: this.transformSearchParameters\n      };\n    }\n  },\n  render: function () {\n    return null;\n  }\n},\n    CurrentRefinements = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: [e.suit(), e.noRefinement && e.suit(\"\", \"noRefinement\")]\n    }, [e._t(\"default\", [i(\"ul\", {\n      class: e.suit(\"list\")\n    }, e._l(e.state.items, function (t) {\n      return i(\"li\", {\n        key: t.attribute,\n        class: e.suit(\"item\")\n      }, [e._t(\"item\", [i(\"span\", {\n        class: e.suit(\"label\")\n      }, [e._v(e._s(e.capitalize(t.label)) + \": \")]), e._v(\" \"), e._l(t.refinements, function (n) {\n        return i(\"span\", {\n          key: e.createItemKey(n),\n          class: e.suit(\"category\")\n        }, [e._t(\"refinement\", [i(\"span\", {\n          class: e.suit(\"categoryLabel\")\n        }, [\"query\" === n.attribute ? i(\"q\", [e._v(e._s(n.label))]) : [e._v(\" \" + e._s(n.label) + \" \")]], 2), e._v(\" \"), i(\"button\", {\n          class: e.suit(\"delete\"),\n          on: {\n            click: function (e) {\n              return t.refine(n);\n            }\n          }\n        }, [e._v(\" ✕ \")])], {\n          refine: t.refine,\n          refinement: n,\n          createURL: e.state.createURL\n        })], 2);\n      })], {\n        refine: t.refine,\n        item: t,\n        createURL: e.state.createURL\n      })], 2);\n    }), 0)], {\n      refine: e.state.refine,\n      items: e.state.items,\n      createURL: e.state.createURL\n    })], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisCurrentRefinements\",\n  mixins: [createSuitMixin({\n    name: \"CurrentRefinements\"\n  }), createWidgetMixin({\n    connector: connectors.connectCurrentRefinements\n  }), createPanelConsumerMixin({\n    mapStateToCanRefine: function (e) {\n      return Boolean(e.items) && e.items.length > 0;\n    }\n  })],\n  props: {\n    includedAttributes: {\n      type: Array,\n      default: void 0\n    },\n    excludedAttributes: {\n      type: Array,\n      default: void 0\n    },\n    transformItems: {\n      type: Function,\n      default: void 0\n    }\n  },\n  computed: {\n    noRefinement: function () {\n      return this.state && 0 === this.state.items.length;\n    },\n    widgetParams: function () {\n      return {\n        includedAttributes: this.includedAttributes,\n        excludedAttributes: this.excludedAttributes,\n        transformItems: this.transformItems\n      };\n    }\n  },\n  methods: {\n    createItemKey: function (e) {\n      var t = e.attribute,\n          i = e.value;\n      return [t, e.type, i, e.operator].join(\":\");\n    },\n    capitalize: function (e) {\n      return e ? e.toString().charAt(0).toLocaleUpperCase() + e.toString().slice(1) : \"\";\n    }\n  }\n},\n    HierarchicalMenuList = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return i(\"ul\", {\n      class: [e.suit(\"list\"), e.level > 0 && e.suit(\"list\", \"child\"), e.suit(\"list\", \"lvl\" + e.level)]\n    }, e._l(e.items, function (t) {\n      return i(\"li\", {\n        key: t.value,\n        class: [e.suit(\"item\"), t.data && e.suit(\"item\", \"parent\"), t.isRefined && e.suit(\"item\", \"selected\")]\n      }, [i(\"a\", {\n        class: e.suit(\"link\"),\n        attrs: {\n          href: e.createURL(t.value)\n        },\n        on: {\n          click: function (i) {\n            return i.preventDefault(), e.refine(t.value);\n          }\n        }\n      }, [i(\"span\", {\n        class: e.suit(\"label\")\n      }, [e._v(e._s(t.label))]), e._v(\" \"), i(\"span\", {\n        class: e.suit(\"count\")\n      }, [e._v(e._s(t.count))])]), e._v(\" \"), t.data ? i(\"hierarchical-menu-list\", {\n        attrs: {\n          items: t.data,\n          level: e.level + 1,\n          refine: e.refine,\n          createURL: e.createURL,\n          suit: e.suit\n        }\n      }) : e._e()], 1);\n    }), 0);\n  },\n  staticRenderFns: [],\n  name: \"HierarchicalMenuList\",\n  props: {\n    items: {\n      type: Array,\n      required: !0\n    },\n    level: {\n      type: Number,\n      required: !0\n    },\n    refine: {\n      type: Function,\n      required: !0\n    },\n    createURL: {\n      type: Function,\n      required: !0\n    },\n    suit: {\n      type: Function,\n      required: !0\n    }\n  }\n},\n    mapStateToCanRefine = function (e) {\n  return Boolean(e.items) && e.items.length > 0;\n},\n    HierarchicalMenu = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: [e.suit(), !e.canRefine && e.suit(\"\", \"noRefinement\")]\n    }, [e._t(\"default\", [i(\"hierarchical-menu-list\", {\n      attrs: {\n        items: e.state.items,\n        level: 0,\n        refine: e.state.refine,\n        createURL: e.state.createURL,\n        suit: e.suit\n      }\n    }), e._v(\" \"), e.showMore ? i(\"button\", {\n      class: [e.suit(\"showMore\"), !e.state.canToggleShowMore && e.suit(\"showMore\", \"disabled\")],\n      attrs: {\n        disabled: !e.state.canToggleShowMore\n      },\n      on: {\n        click: function (t) {\n          return t.preventDefault(), e.state.toggleShowMore(t);\n        }\n      }\n    }, [e._t(\"showMoreLabel\", [e._v(e._s(e.state.isShowingMore ? \"Show less\" : \"Show more\"))], {\n      isShowingMore: e.state.isShowingMore\n    })], 2) : e._e()], {\n      items: e.state.items,\n      canRefine: e.canRefine,\n      canToggleShowMore: e.state.canToggleShowMore,\n      isShowingMore: e.state.isShowingMore,\n      refine: e.state.refine,\n      createURL: e.state.createURL,\n      toggleShowMore: e.state.toggleShowMore,\n      sendEvent: e.state.sendEvent\n    })], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisHierarchicalMenu\",\n  mixins: [createSuitMixin({\n    name: \"HierarchicalMenu\"\n  }), createWidgetMixin({\n    connector: connectors.connectHierarchicalMenu\n  }), createPanelConsumerMixin({\n    mapStateToCanRefine: mapStateToCanRefine\n  })],\n  components: {\n    HierarchicalMenuList: HierarchicalMenuList\n  },\n  props: {\n    attributes: {\n      type: Array,\n      required: !0\n    },\n    limit: {\n      type: Number,\n      default: void 0\n    },\n    showMoreLimit: {\n      type: Number,\n      default: void 0\n    },\n    showMore: {\n      type: Boolean,\n      default: !1\n    },\n    sortBy: {\n      type: [Array, Function],\n      default: void 0\n    },\n    separator: {\n      type: String,\n      default: void 0\n    },\n    rootPath: {\n      type: String,\n      default: void 0\n    },\n    showParentLevel: {\n      type: Boolean,\n      default: void 0\n    },\n    transformItems: {\n      type: Function,\n      default: void 0\n    }\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        attributes: this.attributes,\n        limit: this.limit,\n        showMore: this.showMore,\n        showMoreLimit: this.showMoreLimit,\n        separator: this.separator,\n        rootPath: this.rootPath,\n        showParentLevel: this.showParentLevel,\n        sortBy: this.sortBy,\n        transformItems: this.transformItems\n      };\n    },\n    canRefine: function () {\n      return mapStateToCanRefine(this.state);\n    }\n  }\n},\n    htmlUnescapes = {\n  \"&amp;\": \"&\",\n  \"&lt;\": \"<\",\n  \"&gt;\": \">\",\n  \"&quot;\": '\"',\n  \"&#39;\": \"'\"\n},\n    reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n    reHasEscapedHtml = RegExp(reEscapedHtml.source);\n\nfunction unescape(e) {\n  return e && reHasEscapedHtml.test(e) ? e.replace(reEscapedHtml, function (e) {\n    return htmlUnescapes[e];\n  }) : e;\n}\n\nvar TAG_PLACEHOLDER = {\n  highlightPreTag: \"__ais-highlight__\",\n  highlightPostTag: \"__/ais-highlight__\"\n};\n\nfunction parseHighlightedAttribute(e) {\n  var t = e.preTag,\n      i = e.postTag,\n      n = e.highlightedValue;\n  void 0 === n && (n = \"\");\n  var s = n.split(t),\n      a = s.shift(),\n      r = \"\" === a ? [] : [{\n    value: a,\n    isHighlighted: !1\n  }];\n\n  if (i === t) {\n    var o = !0;\n    s.forEach(function (e) {\n      r.push({\n        value: e,\n        isHighlighted: o\n      }), o = !o;\n    });\n  } else s.forEach(function (e) {\n    var t = e.split(i);\n    r.push({\n      value: t[0],\n      isHighlighted: !0\n    }), \"\" !== t[1] && r.push({\n      value: \" \" === t[1] ? \"  \" : t[1],\n      isHighlighted: !1\n    });\n  });\n\n  return r;\n}\n\nfunction parseAlgoliaHit(e) {\n  var t = e.preTag;\n  void 0 === t && (t = TAG_PLACEHOLDER.highlightPreTag);\n  var i = e.postTag;\n  void 0 === i && (i = TAG_PLACEHOLDER.highlightPostTag);\n  var n = e.highlightProperty,\n      s = e.attribute,\n      a = e.hit;\n  if (!a) throw new Error(\"`hit`, the matching record, must be provided\");\n  var r = utils.getPropertyByPath(a[n], s) || {};\n  return Array.isArray(r) ? r.map(function (e) {\n    return parseHighlightedAttribute({\n      preTag: t,\n      postTag: i,\n      highlightedValue: unescape(e.value)\n    });\n  }) : parseHighlightedAttribute({\n    preTag: t,\n    postTag: i,\n    highlightedValue: unescape(r.value)\n  });\n}\n\nvar TextNode = {\n  functional: !0,\n  render: function (e, t) {\n    return t.slots().default;\n  }\n},\n    AisHighlighter = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return i(\"span\", {\n      class: e.suit()\n    }, e._l(e.parsedHighlights, function (t, n) {\n      var s = t.value,\n          a = t.isHighlighted;\n      return i(a ? e.highlightedTagName : e.TextNode, {\n        key: n,\n        tag: \"component\",\n        class: [a && e.suit(\"highlighted\")]\n      }, [e._v(e._s(s))]);\n    }), 1);\n  },\n  staticRenderFns: [],\n  name: \"AisHighlighter\",\n  props: {\n    hit: {\n      type: Object,\n      required: !0\n    },\n    attribute: {\n      type: String,\n      required: !0\n    },\n    highlightedTagName: {\n      type: String,\n      default: \"mark\"\n    },\n    suit: {\n      type: Function,\n      required: !0\n    },\n    highlightProperty: {\n      type: String,\n      required: !0\n    },\n    preTag: {\n      type: String,\n      required: !0\n    },\n    postTag: {\n      type: String,\n      required: !0\n    }\n  },\n  data: function () {\n    return {\n      TextNode: TextNode\n    };\n  },\n  computed: {\n    parsedHighlights: function () {\n      return parseAlgoliaHit({\n        attribute: this.attribute,\n        hit: this.hit,\n        highlightProperty: this.highlightProperty,\n        preTag: this.preTag,\n        postTag: this.postTag\n      });\n    }\n  }\n},\n    AisHighlight = {\n  render: function () {\n    var e = this.$createElement;\n    return (this._self._c || e)(\"ais-highlighter\", {\n      attrs: {\n        hit: this.hit,\n        attribute: this.attribute,\n        \"highlighted-tag-name\": this.highlightedTagName,\n        suit: this.suit,\n        \"highlight-property\": \"_highlightResult\",\n        \"pre-tag\": \"<mark>\",\n        \"post-tag\": \"</mark>\"\n      }\n    });\n  },\n  staticRenderFns: [],\n  name: \"AisHighlight\",\n  mixins: [createSuitMixin({\n    name: \"Highlight\"\n  })],\n  components: {\n    AisHighlighter: AisHighlighter\n  },\n  props: {\n    hit: {\n      type: Object,\n      required: !0\n    },\n    attribute: {\n      type: String,\n      required: !0\n    },\n    highlightedTagName: {\n      type: String,\n      default: \"mark\"\n    }\n  }\n},\n    Hits = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: e.suit()\n    }, [e._t(\"default\", [i(\"ol\", {\n      class: e.suit(\"list\")\n    }, e._l(e.items, function (t, n) {\n      return i(\"li\", {\n        key: t.objectID,\n        class: e.suit(\"item\")\n      }, [e._t(\"item\", [e._v(\"objectID: \" + e._s(t.objectID) + \", index: \" + e._s(n))], {\n        item: t,\n        index: n,\n        insights: e.state.insights\n      })], 2);\n    }), 0)], {\n      items: e.items,\n      insights: e.state.insights,\n      sendEvent: e.state.sendEvent\n    })], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisHits\",\n  mixins: [createWidgetMixin({\n    connector: connectors.connectHitsWithInsights\n  }), createSuitMixin({\n    name: \"Hits\"\n  })],\n  props: {\n    escapeHTML: {\n      type: Boolean,\n      default: !0\n    },\n    transformItems: {\n      type: Function,\n      default: void 0\n    }\n  },\n  computed: {\n    items: function () {\n      return this.state.hits;\n    },\n    widgetParams: function () {\n      return {\n        escapeHTML: this.escapeHTML,\n        transformItems: this.transformItems\n      };\n    }\n  }\n},\n    HitsPerPage = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: e.suit()\n    }, [e._t(\"default\", [i(\"select\", {\n      directives: [{\n        name: \"model\",\n        rawName: \"v-model\",\n        value: e.selected,\n        expression: \"selected\"\n      }],\n      class: e.suit(\"select\"),\n      on: {\n        change: [function (t) {\n          var i = Array.prototype.filter.call(t.target.options, function (e) {\n            return e.selected;\n          }).map(function (e) {\n            return \"_value\" in e ? e._value : e.value;\n          });\n          e.selected = t.target.multiple ? i : i[0];\n        }, e.handleChange]\n      }\n    }, e._l(e.state.items, function (t) {\n      return i(\"option\", {\n        key: t.value,\n        class: e.suit(\"option\"),\n        domProps: {\n          value: t.value\n        }\n      }, [e._v(e._s(t.label))]);\n    }), 0)], {\n      items: e.state.items,\n      refine: e.state.refine,\n      hasNoResults: e.state.hasNoResults\n    })], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisHitsPerPage\",\n  mixins: [createSuitMixin({\n    name: \"HitsPerPage\"\n  }), createWidgetMixin({\n    connector: connectors.connectHitsPerPage\n  }), createPanelConsumerMixin({\n    mapStateToCanRefine: function (e) {\n      return !1 === e.hasNoResults;\n    }\n  })],\n  props: {\n    items: {\n      type: Array,\n      required: !0\n    },\n    transformItems: {\n      type: Function,\n      default: void 0\n    }\n  },\n  data: function () {\n    return {\n      selected: this.items.find(function (e) {\n        return !0 === e.default;\n      }).value\n    };\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        items: this.items,\n        transformItems: this.transformItems\n      };\n    }\n  },\n  methods: {\n    handleChange: function () {\n      this.state.refine(this.selected);\n    }\n  }\n},\n    connectIndex = function () {\n  return indexWidget;\n},\n    Index = {\n  name: \"AisIndex\",\n  mixins: [createSuitMixin({\n    name: \"Index\"\n  }), createWidgetMixin({\n    connector: connectIndex\n  })],\n  provide: function () {\n    var e = this;\n    return {\n      $_ais_getParentIndex: function () {\n        return e.widget;\n      }\n    };\n  },\n  props: {\n    indexName: {\n      type: String,\n      required: !0\n    },\n    indexId: {\n      type: String,\n      required: !1\n    }\n  },\n  render: renderCompat(function (e) {\n    return e(\"div\", {}, getDefaultSlot(this));\n  }),\n  computed: {\n    widgetParams: function () {\n      return {\n        indexName: this.indexName,\n        indexId: this.indexId\n      };\n    }\n  }\n},\n    version$1 = \"4.1.1\";\n\nfunction _objectSpread(e) {\n  for (var t = arguments, i = 1; i < arguments.length; i++) {\n    var n = null != t[i] ? t[i] : {},\n        s = Object.keys(n);\n    \"function\" == typeof Object.getOwnPropertySymbols && (s = s.concat(Object.getOwnPropertySymbols(n).filter(function (e) {\n      return Object.getOwnPropertyDescriptor(n, e).enumerable;\n    }))), s.forEach(function (t) {\n      _defineProperty(e, t, n[t]);\n    });\n  }\n\n  return e;\n}\n\nfunction _defineProperty(e, t, i) {\n  return t in e ? Object.defineProperty(e, t, {\n    value: i,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[t] = i, e;\n}\n\nvar createInstantSearchComponent = function (e) {\n  var t;\n  return _objectSpread(((t = {\n    mixins: [createSuitMixin({\n      name: \"InstantSearch\"\n    })],\n    provide: function () {\n      return {\n        $_ais_instantSearchInstance: this.instantSearchInstance\n      };\n    },\n    watch: {\n      searchClient: function (e) {\n        this.instantSearchInstance.helper.setClient(e).search();\n      },\n      indexName: function (e) {\n        this.instantSearchInstance.helper.setIndex(e).search();\n      },\n      stalledSearchDelay: function (e) {\n        this.instantSearchInstance._stalledSearchDelay = e;\n      },\n      routing: function () {\n        throw new Error(\"routing configuration can not be changed dynamically at this point.\\n\\nPlease open a new issue: https://github.com/algolia/vue-instantsearch/issues/new?template=feature.md\");\n      },\n      searchFunction: function (e) {\n        this.instantSearchInstance._searchFunction = e;\n      },\n      middlewares: {\n        immediate: !0,\n        handler: function (e, t) {\n          var i = this;\n          (t || []).filter(function (t) {\n            return -1 === (e || []).indexOf(t);\n          }).forEach(function (e) {\n            i.instantSearchInstance.unuse(e);\n          }), (e || []).filter(function (e) {\n            return -1 === (t || []).indexOf(e);\n          }).forEach(function (e) {\n            i.instantSearchInstance.use(e);\n          });\n        }\n      }\n    },\n    created: function () {\n      var e = this.instantSearchInstance.client;\n      \"function\" == typeof e.addAlgoliaAgent && (e.addAlgoliaAgent(\"Vue (\" + version + \")\"), e.addAlgoliaAgent(\"Vue InstantSearch (\" + version$1 + \")\"));\n    },\n    mounted: function () {\n      var e = this;\n      this.$nextTick(function () {\n        e.instantSearchInstance.started || e.instantSearchInstance.start();\n      });\n    }\n  }).beforeDestroy = function () {\n    this.instantSearchInstance.started && this.instantSearchInstance.dispose(), this.instantSearchInstance.__initialSearchResults = void 0;\n  }, t), e);\n},\n    oldApiWarning = \"Vue InstantSearch: You used the prop api-key or app-id.\\nThese have been replaced by search-client.\\n\\nSee more info here: https://www.algolia.com/doc/api-reference/widgets/instantsearch/vue/#widget-param-search-client\",\n    InstantSearch = createInstantSearchComponent({\n  name: \"AisInstantSearch\",\n  props: {\n    searchClient: {\n      type: Object,\n      required: !0\n    },\n    insightsClient: {\n      type: Function,\n      default: void 0\n    },\n    indexName: {\n      type: String,\n      required: !0\n    },\n    routing: {\n      default: void 0,\n      validator: function (e) {\n        return !(\"boolean\" == typeof e || !e.router && !e.stateMapping) || (warn(\"The `routing` option expects an object with `router` and/or `stateMapping`.\\n\\nSee https://www.algolia.com/doc/api-reference/widgets/instantsearch/vue/#widget-param-routing\"), !1);\n      }\n    },\n    stalledSearchDelay: {\n      type: Number,\n      default: void 0\n    },\n    searchFunction: {\n      type: Function,\n      default: void 0\n    },\n    initialUiState: {\n      type: Object,\n      default: void 0\n    },\n    apiKey: {\n      type: String,\n      default: void 0,\n      validator: function (e) {\n        return e && warn(oldApiWarning), !1;\n      }\n    },\n    appId: {\n      type: String,\n      default: void 0,\n      validator: function (e) {\n        return e && warn(oldApiWarning), !1;\n      }\n    },\n    middlewares: {\n      type: Array,\n      default: null\n    }\n  },\n  data: function () {\n    return {\n      instantSearchInstance: instantsearch({\n        searchClient: this.searchClient,\n        insightsClient: this.insightsClient,\n        indexName: this.indexName,\n        routing: this.routing,\n        stalledSearchDelay: this.stalledSearchDelay,\n        searchFunction: this.searchFunction,\n        initialUiState: this.initialUiState\n      })\n    };\n  },\n  render: renderCompat(function (e) {\n    var t;\n    return e(\"div\", {\n      class: (t = {}, t[this.suit()] = !0, t[this.suit(\"\", \"ssr\")] = !1, t)\n    }, getDefaultSlot(this));\n  })\n}),\n    InstantSearchSsr = createInstantSearchComponent({\n  name: \"AisInstantSearchSsr\",\n  inject: {\n    $_ais_ssrInstantSearchInstance: {\n      default: function () {\n        throw new Error(\"`createServerRootMixin` is required when using SSR.\");\n      }\n    }\n  },\n  data: function () {\n    return {\n      instantSearchInstance: this.$_ais_ssrInstantSearchInstance\n    };\n  },\n  render: renderCompat(function (e) {\n    var t;\n    return e(\"div\", {\n      class: (t = {}, t[this.suit()] = !0, t[this.suit(\"\", \"ssr\")] = !0, t)\n    }, getDefaultSlot(this));\n  })\n}),\n    InfiniteHits = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: e.suit()\n    }, [e.showPrevious ? e._t(\"loadPrevious\", [i(\"button\", {\n      class: [e.suit(\"loadPrevious\"), e.state.isFirstPage && e.suit(\"loadPrevious\", \"disabled\")],\n      attrs: {\n        disabled: e.state.isFirstPage\n      },\n      on: {\n        click: function (t) {\n          return e.refinePrevious();\n        }\n      }\n    }, [e._v(\"Show previous results\")])], {\n      refinePrevious: e.refinePrevious,\n      page: e.state.results.page,\n      isFirstPage: e.state.isFirstPage\n    }) : e._e(), e._v(\" \"), e._t(\"default\", [i(\"ol\", {\n      class: e.suit(\"list\")\n    }, e._l(e.items, function (t, n) {\n      return i(\"li\", {\n        key: t.objectID,\n        class: e.suit(\"item\")\n      }, [e._t(\"item\", [e._v(\"objectID: \" + e._s(t.objectID) + \", index: \" + e._s(n))], {\n        item: t,\n        index: n,\n        insights: e.state.insights\n      })], 2);\n    }), 0), e._v(\" \"), e._t(\"loadMore\", [i(\"button\", {\n      class: [e.suit(\"loadMore\"), e.state.isLastPage && e.suit(\"loadMore\", \"disabled\")],\n      attrs: {\n        disabled: e.state.isLastPage\n      },\n      on: {\n        click: function (t) {\n          return e.refineNext();\n        }\n      }\n    }, [e._v(\"Show more results\")])], {\n      refineNext: e.refineNext,\n      refine: e.refineNext,\n      page: e.state.results.page,\n      isLastPage: e.state.isLastPage\n    })], {\n      items: e.items,\n      results: e.state.results,\n      isLastPage: e.state.isLastPage,\n      refinePrevious: e.refinePrevious,\n      refineNext: e.refineNext,\n      refine: e.refineNext,\n      insights: e.state.insights,\n      sendEvent: e.state.sendEvent\n    })], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisInfiniteHits\",\n  mixins: [createWidgetMixin({\n    connector: connectors.connectInfiniteHitsWithInsights\n  }), createSuitMixin({\n    name: \"InfiniteHits\"\n  })],\n  props: {\n    showPrevious: {\n      type: Boolean,\n      default: !1\n    },\n    escapeHTML: {\n      type: Boolean,\n      default: !0\n    },\n    transformItems: {\n      type: Function,\n      default: void 0\n    },\n    cache: {\n      type: Object,\n      default: void 0\n    }\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        showPrevious: this.showPrevious,\n        escapeHTML: this.escapeHTML,\n        transformItems: this.transformItems,\n        cache: this.cache\n      };\n    },\n    items: function () {\n      return this.state.hits;\n    }\n  },\n  methods: {\n    refinePrevious: function () {\n      this.state.showPrevious();\n    },\n    refineNext: function () {\n      this.state.showMore();\n    }\n  }\n},\n    Menu = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: [e.suit(), !e.state.canRefine && e.suit(\"\", \"noRefinement\")]\n    }, [e._t(\"default\", [i(\"ul\", {\n      class: e.suit(\"list\")\n    }, e._l(e.state.items, function (t) {\n      return i(\"li\", {\n        key: t.value,\n        class: [e.suit(\"item\"), t.isRefined && e.suit(\"item\", \"selected\")]\n      }, [i(\"a\", {\n        class: e.suit(\"link\"),\n        attrs: {\n          href: e.state.createURL(t.value)\n        },\n        on: {\n          click: function (i) {\n            return i.preventDefault(), e.state.refine(t.value);\n          }\n        }\n      }, [i(\"span\", {\n        class: e.suit(\"label\")\n      }, [e._v(e._s(t.label))]), e._v(\" \"), i(\"span\", {\n        class: e.suit(\"count\")\n      }, [e._v(e._s(t.count))])])]);\n    }), 0), e._v(\" \"), e.showShowMoreButton ? i(\"button\", {\n      class: [e.suit(\"showMore\"), !e.state.canToggleShowMore && e.suit(\"showMore\", \"disabled\")],\n      attrs: {\n        disabled: !e.state.canToggleShowMore\n      },\n      on: {\n        click: function (t) {\n          return t.preventDefault(), e.state.toggleShowMore();\n        }\n      }\n    }, [e._t(\"showMoreLabel\", [e._v(e._s(e.state.isShowingMore ? \"Show less\" : \"Show more\"))], {\n      isShowingMore: e.state.isShowingMore\n    })], 2) : e._e()], {\n      items: e.state.items,\n      canRefine: e.state.canRefine,\n      canToggleShowMore: e.state.canToggleShowMore,\n      isShowingMore: e.state.isShowingMore,\n      refine: e.state.refine,\n      createURL: e.state.createURL,\n      toggleShowMore: e.state.toggleShowMore,\n      sendEvent: e.state.sendEvent\n    })], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisMenu\",\n  mixins: [createSuitMixin({\n    name: \"Menu\"\n  }), createWidgetMixin({\n    connector: connectors.connectMenu\n  }), createPanelConsumerMixin({\n    mapStateToCanRefine: function (e) {\n      return Boolean(e.canRefine);\n    }\n  })],\n  props: {\n    attribute: {\n      type: String,\n      required: !0\n    },\n    limit: {\n      type: Number,\n      default: void 0\n    },\n    showMoreLimit: {\n      type: Number,\n      default: void 0\n    },\n    showMore: {\n      type: Boolean,\n      default: !1\n    },\n    sortBy: {\n      type: [Array, Function],\n      default: void 0\n    },\n    transformItems: {\n      type: Function,\n      default: void 0\n    }\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        attribute: this.attribute,\n        limit: this.limit,\n        showMore: this.showMore,\n        showMoreLimit: this.showMoreLimit,\n        sortBy: this.sortBy,\n        transformItems: this.transformItems\n      };\n    },\n    showShowMoreButton: function () {\n      return this.state.canRefine && this.showMore;\n    }\n  }\n},\n    MenuSelect = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: [e.suit(), !e.state.canRefine && e.suit(\"\", \"noRefinement\")]\n    }, [e._t(\"default\", [i(\"select\", {\n      class: e.suit(\"select\"),\n      on: {\n        change: function (t) {\n          return e.refine(t.currentTarget.value);\n        }\n      }\n    }, [i(\"option\", {\n      class: e.suit(\"option\"),\n      attrs: {\n        value: \"\"\n      }\n    }, [e._t(\"defaultOption\", [e._v(\"See all\")])], 2), e._v(\" \"), e._l(e.state.items, function (t) {\n      return i(\"option\", {\n        key: t.value,\n        class: e.suit(\"option\"),\n        domProps: {\n          value: t.value,\n          selected: t.isRefined\n        }\n      }, [e._t(\"item\", [e._v(e._s(t.label) + \" (\" + e._s(t.count) + \")\")], {\n        item: t\n      })], 2);\n    })], 2)], {\n      items: e.state.items,\n      canRefine: e.state.canRefine,\n      refine: e.refine,\n      createURL: e.state.createURL,\n      sendEvent: e.state.sendEvent\n    })], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisMenuSelect\",\n  mixins: [createSuitMixin({\n    name: \"MenuSelect\"\n  }), createWidgetMixin({\n    connector: connectors.connectMenu\n  }), createPanelConsumerMixin({\n    mapStateToCanRefine: function (e) {\n      return Boolean(e.canRefine);\n    }\n  })],\n  props: {\n    attribute: {\n      type: String,\n      required: !0\n    },\n    limit: {\n      type: Number,\n      default: 10\n    },\n    sortBy: {\n      type: [Array, Function],\n      default: void 0\n    },\n    transformItems: {\n      type: Function,\n      default: function (e) {\n        return e;\n      }\n    }\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        attribute: this.attribute,\n        limit: this.limit,\n        sortBy: this.sortBy,\n        transformItems: this.transformItems\n      };\n    }\n  },\n  methods: {\n    refine: function (e) {\n      this.state.refine(e);\n    }\n  }\n},\n    NumericMenu = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: [e.suit(), !e.canRefine && e.suit(\"\", \"noRefinement\")]\n    }, [e._t(\"default\", [i(\"ul\", {\n      class: [e.suit(\"list\")]\n    }, e._l(e.state.items, function (t) {\n      return i(\"li\", {\n        key: t.label,\n        class: [e.suit(\"item\"), t.isRefined && e.suit(\"item\", \"selected\")]\n      }, [i(\"label\", {\n        class: e.suit(\"label\")\n      }, [i(\"input\", {\n        class: e.suit(\"radio\"),\n        attrs: {\n          type: \"radio\",\n          name: e.attribute\n        },\n        domProps: {\n          value: t.value,\n          checked: t.isRefined\n        },\n        on: {\n          change: function (t) {\n            return e.state.refine(t.target.value);\n          }\n        }\n      }), e._v(\" \"), i(\"span\", {\n        class: e.suit(\"labelText\")\n      }, [e._v(e._s(t.label))])])]);\n    }), 0)], {\n      items: e.state.items,\n      canRefine: e.canRefine,\n      refine: e.state.refine,\n      createURL: e.state.createURL,\n      sendEvent: e.state.sendEvent\n    })], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisNumericMenu\",\n  mixins: [createWidgetMixin({\n    connector: connectors.connectNumericMenu\n  }), createSuitMixin({\n    name: \"NumericMenu\"\n  }), createPanelConsumerMixin({\n    mapStateToCanRefine: function (e) {\n      return !1 === e.hasNoResults;\n    }\n  })],\n  props: {\n    attribute: {\n      type: String,\n      required: !0\n    },\n    items: {\n      type: Array,\n      required: !0\n    },\n    transformItems: {\n      type: Function,\n      default: void 0\n    }\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        attribute: this.attribute,\n        transformItems: this.transformItems,\n        items: this.items\n      };\n    },\n    canRefine: function () {\n      return !this.state.hasNoResults;\n    }\n  }\n},\n    Pagination = {\n  render: function () {\n    var e,\n        t,\n        i,\n        n,\n        s = this,\n        a = s.$createElement,\n        r = s._self._c || a;\n    return s.state ? r(\"div\", {\n      class: s.suit()\n    }, [s._t(\"default\", [r(\"ul\", {\n      class: s.suit(\"list\")\n    }, [s.showFirst ? r(\"li\", {\n      class: (e = {}, e[s.suit(\"item\")] = !0, e[s.suit(\"item\", \"firstPage\")] = !0, e[s.suit(\"item\", \"disabled\")] = s.state.isFirstPage, e)\n    }, [s._t(\"first\", [s.state.isFirstPage ? [r(\"span\", {\n      class: s.suit(\"link\"),\n      attrs: {\n        \"aria-label\": \"First\"\n      }\n    }, [s._v(\"‹‹\")])] : [r(\"a\", {\n      class: s.suit(\"link\"),\n      attrs: {\n        \"aria-label\": \"First\",\n        href: s.state.createURL(0)\n      },\n      on: {\n        click: function (e) {\n          return e.preventDefault(), s.refine(0);\n        }\n      }\n    }, [s._v(\"‹‹\")])]], {\n      createURL: function () {\n        return s.state.createURL(0);\n      },\n      isFirstPage: s.state.isFirstPage,\n      refine: function () {\n        return s.refine(0);\n      }\n    })], 2) : s._e(), s._v(\" \"), s.showPrevious ? r(\"li\", {\n      class: (t = {}, t[s.suit(\"item\")] = !0, t[s.suit(\"item\", \"previousPage\")] = !0, t[s.suit(\"item\", \"disabled\")] = s.state.isFirstPage, t)\n    }, [s._t(\"previous\", [s.state.isFirstPage ? [r(\"span\", {\n      class: s.suit(\"link\"),\n      attrs: {\n        \"aria-label\": \"Previous\"\n      }\n    }, [s._v(\"‹\")])] : [r(\"a\", {\n      class: s.suit(\"link\"),\n      attrs: {\n        \"aria-label\": \"Previous\",\n        href: s.state.createURL(s.state.currentRefinement - 1)\n      },\n      on: {\n        click: function (e) {\n          return e.preventDefault(), s.refine(s.state.currentRefinement - 1);\n        }\n      }\n    }, [s._v(\"‹\")])]], {\n      createURL: function () {\n        return s.state.createURL(s.state.currentRefinement - 1);\n      },\n      isFirstPage: s.state.isFirstPage,\n      refine: function () {\n        return s.refine(s.state.currentRefinement - 1);\n      }\n    })], 2) : s._e(), s._v(\" \"), s._l(s.state.pages, function (e) {\n      var t;\n      return r(\"li\", {\n        key: e,\n        class: (t = {}, t[s.suit(\"item\")] = !0, t[s.suit(\"item\", \"selected\")] = s.state.currentRefinement === e, t)\n      }, [s._t(\"item\", [r(\"a\", {\n        class: s.suit(\"link\"),\n        attrs: {\n          href: s.state.createURL(e)\n        },\n        on: {\n          click: function (t) {\n            return t.preventDefault(), s.refine(e);\n          }\n        }\n      }, [s._v(s._s(e + 1))])], {\n        page: e,\n        createURL: function () {\n          return s.state.createURL(e);\n        },\n        isFirstPage: s.state.isFirstPage,\n        isLastPage: s.state.isLastPage,\n        refine: function () {\n          return s.refine(e);\n        }\n      })], 2);\n    }), s._v(\" \"), s.showNext ? r(\"li\", {\n      class: (i = {}, i[s.suit(\"item\")] = !0, i[s.suit(\"item\", \"nextPage\")] = !0, i[s.suit(\"item\", \"disabled\")] = s.state.isLastPage, i)\n    }, [s._t(\"next\", [s.state.isLastPage ? [r(\"span\", {\n      class: s.suit(\"link\"),\n      attrs: {\n        \"aria-label\": \"Next\"\n      }\n    }, [s._v(\"›\")])] : [r(\"a\", {\n      class: s.suit(\"link\"),\n      attrs: {\n        \"aria-label\": \"Next\",\n        href: s.state.createURL(s.state.currentRefinement + 1)\n      },\n      on: {\n        click: function (e) {\n          return e.preventDefault(), s.refine(s.state.currentRefinement + 1);\n        }\n      }\n    }, [s._v(\"›\")])]], {\n      createURL: function () {\n        return s.state.createURL(s.state.currentRefinement + 1);\n      },\n      isLastPage: s.state.isLastPage,\n      refine: function () {\n        return s.refine(s.state.currentRefinement + 1);\n      }\n    })], 2) : s._e(), s._v(\" \"), s.showLast ? r(\"li\", {\n      class: (n = {}, n[s.suit(\"item\")] = !0, n[s.suit(\"item\", \"lastPage\")] = !0, n[s.suit(\"item\", \"disabled\")] = s.state.isLastPage, n)\n    }, [s._t(\"last\", [s.state.isLastPage ? [r(\"span\", {\n      class: s.suit(\"link\"),\n      attrs: {\n        \"aria-label\": \"Last\"\n      }\n    }, [s._v(\"››\")])] : [r(\"a\", {\n      class: s.suit(\"link\"),\n      attrs: {\n        \"aria-label\": \"Last\",\n        href: s.state.createURL(s.state.nbPages - 1)\n      },\n      on: {\n        click: function (e) {\n          return e.preventDefault(), s.refine(s.state.nbPages - 1);\n        }\n      }\n    }, [s._v(\"››\")])]], {\n      createURL: function () {\n        return s.state.createURL(s.state.nbPages - 1);\n      },\n      isLastPage: s.state.isLastPage,\n      refine: function () {\n        return s.refine(s.state.nbPages - 1);\n      }\n    })], 2) : s._e()], 2)], {\n      refine: s.refine,\n      createURL: s.state.createURL,\n      currentRefinement: s.state.currentRefinement,\n      nbHits: s.state.nbHits,\n      nbPages: s.state.nbPages,\n      pages: s.state.pages,\n      isFirstPage: s.state.isFirstPage,\n      isLastPage: s.state.isLastPage\n    })], 2) : s._e();\n  },\n  staticRenderFns: [],\n  name: \"AisPagination\",\n  mixins: [createSuitMixin({\n    name: \"Pagination\"\n  }), createWidgetMixin({\n    connector: connectors.connectPagination\n  }), createPanelConsumerMixin({\n    mapStateToCanRefine: function (e) {\n      return e.nbPages > 1;\n    }\n  })],\n  props: {\n    padding: {\n      type: Number,\n      default: void 0,\n      validator: function (e) {\n        return e > 0;\n      }\n    },\n    totalPages: {\n      type: Number,\n      default: void 0,\n      validator: function (e) {\n        return e > 0;\n      }\n    },\n    showFirst: {\n      type: Boolean,\n      default: !0\n    },\n    showLast: {\n      type: Boolean,\n      default: !0\n    },\n    showNext: {\n      type: Boolean,\n      default: !0\n    },\n    showPrevious: {\n      type: Boolean,\n      default: !0\n    }\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        padding: this.padding,\n        totalPages: this.totalPages\n      };\n    }\n  },\n  emits: [\"page-change\"],\n  methods: {\n    refine: function (e) {\n      var t = Math.min(Math.max(e, 0), this.state.nbPages - 1);\n      this.state.refine(t), this.$emit(\"page-change\", t);\n    }\n  }\n},\n    Panel = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return i(\"div\", {\n      class: [e.suit(), !e.canRefine && e.suit(\"\", \"noRefinement\")]\n    }, [e.getSlot(\"header\") ? i(\"div\", {\n      class: e.suit(\"header\")\n    }, [e._t(\"header\", null, {\n      hasRefinements: e.canRefine\n    })], 2) : e._e(), e._v(\" \"), i(\"div\", {\n      class: e.suit(\"body\")\n    }, [e._t(\"default\", null, {\n      hasRefinements: e.canRefine\n    })], 2), e._v(\" \"), e.getSlot(\"footer\") ? i(\"div\", {\n      class: e.suit(\"footer\")\n    }, [e._t(\"footer\", null, {\n      hasRefinements: e.canRefine\n    })], 2) : e._e()]);\n  },\n  staticRenderFns: [],\n  name: \"AisPanel\",\n  mixins: [createSuitMixin({\n    name: \"Panel\"\n  }), createPanelProviderMixin()],\n  methods: {\n    getSlot: function (e) {\n      return this.$slots[e] || this.$scopedSlots[e];\n    }\n  }\n},\n    PoweredBy = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return i(\"div\", {\n      class: e.suit()\n    }, [i(\"a\", {\n      class: e.suit(\"link\"),\n      attrs: {\n        href: e.algoliaUrl,\n        target: \"_blank\",\n        rel: \"noopener\",\n        \"aria-label\": \"search by Algolia\"\n      }\n    }, [i(\"svg\", {\n      class: [e.suit(\"logo\"), e.suit(\"\", e.theme)],\n      staticStyle: {\n        height: \"1.2em\",\n        width: \"auto\"\n      },\n      attrs: {\n        viewBox: \"0 0 168 24\"\n      }\n    }, [i(\"path\", {\n      attrs: {\n        fill: \"dark\" === e.theme ? \"#FFF\" : \"#5D6494\",\n        d: \"M6.97 6.68V8.3a4.47 4.47 0 0 0-2.42-.67 2.2 2.2 0 0 0-1.38.4c-.34.26-.5.6-.5 1.02 0 .43.16.77.49 1.03.33.25.83.53 1.51.83a7.04 7.04 0 0 1 1.9 1.08c.34.24.58.54.73.89.15.34.23.74.23 1.18 0 .95-.33 1.7-1 2.24a4 4 0 0 1-2.6.81 5.71 5.71 0 0 1-2.94-.68v-1.71c.84.63 1.81.94 2.92.94.58 0 1.05-.14 1.39-.4.34-.28.5-.65.5-1.13 0-.29-.1-.55-.3-.8a2.2 2.2 0 0 0-.65-.53 23.03 23.03 0 0 0-1.64-.78 13.67 13.67 0 0 1-1.11-.64c-.12-.1-.28-.22-.46-.4a1.72 1.72 0 0 1-.39-.5 4.46 4.46 0 0 1-.22-.6c-.07-.23-.1-.48-.1-.75 0-.91.33-1.63 1-2.17a4 4 0 0 1 2.57-.8c.97 0 1.8.18 2.47.52zm7.47 5.7v-.3a2.26 2.26 0 0 0-.5-1.44c-.3-.35-.74-.53-1.32-.53-.53 0-.99.2-1.37.58-.38.39-.62.95-.72 1.68h3.91zm1 2.79v1.4c-.6.34-1.38.51-2.36.51a4.02 4.02 0 0 1-3-1.13 4.04 4.04 0 0 1-1.11-2.97c0-1.3.34-2.32 1.02-3.06a3.38 3.38 0 0 1 2.6-1.1c1.03 0 1.85.32 2.46.96.6.64.9 1.57.9 2.78 0 .33-.03.68-.09 1.04h-5.31c.1.7.4 1.24.89 1.61.49.38 1.1.56 1.85.56.86 0 1.58-.2 2.15-.6zm6.61-1.78h-1.21c-.6 0-1.05.12-1.35.36-.3.23-.46.53-.46.89 0 .37.12.66.36.88.23.2.57.32 1.02.32.5 0 .9-.15 1.2-.43.3-.28.44-.65.44-1.1v-.92zm-4.07-2.55V9.33a4.96 4.96 0 0 1 2.5-.55c2.1 0 3.17 1.03 3.17 3.08V17H22.1v-.96c-.42.68-1.15 1.02-2.19 1.02-.76 0-1.38-.22-1.84-.66-.46-.44-.7-1-.7-1.68 0-.78.3-1.38.88-1.81.59-.43 1.4-.65 2.46-.65h1.34v-.46c0-.55-.13-.97-.4-1.25-.26-.29-.7-.43-1.32-.43-.86 0-1.65.24-2.35.72zm9.34-1.93v1.42c.39-1 1.1-1.5 2.12-1.5.15 0 .31.02.5.05v1.53c-.23-.1-.48-.14-.76-.14-.54 0-.99.24-1.34.71a2.8 2.8 0 0 0-.52 1.71V17h-1.57V8.91h1.57zm5 4.09a3 3 0 0 0 .76 2.01c.47.53 1.14.8 2 .8.64 0 1.24-.18 1.8-.53v1.4c-.53.32-1.2.48-2 .48a3.98 3.98 0 0 1-4.17-4.18c0-1.16.38-2.15 1.14-2.98a4 4 0 0 1 3.1-1.23c.7 0 1.34.15 1.92.44v1.44a3.24 3.24 0 0 0-1.77-.5A2.65 2.65 0 0 0 32.33 13zm7.92-7.28v4.58c.46-1 1.3-1.5 2.5-1.5.8 0 1.42.24 1.9.73.48.5.72 1.17.72 2.05V17H43.8v-5.1c0-.56-.14-.99-.43-1.29-.28-.3-.65-.45-1.1-.45-.54 0-1 .2-1.42.6-.4.4-.61 1.02-.61 1.85V17h-1.56V5.72h1.56zM55.2 15.74c.6 0 1.1-.25 1.5-.76.4-.5.6-1.16.6-1.95 0-.92-.2-1.62-.6-2.12-.4-.5-.92-.74-1.55-.74-.56 0-1.05.22-1.5.67-.44.45-.66 1.13-.66 2.06 0 .96.22 1.67.64 2.14.43.47.95.7 1.57.7zM53 5.72v4.42a2.74 2.74 0 0 1 2.43-1.34c1.03 0 1.86.38 2.51 1.15.65.76.97 1.78.97 3.05 0 1.13-.3 2.1-.92 2.9-.62.81-1.47 1.21-2.54 1.21s-1.9-.45-2.46-1.34V17h-1.58V5.72H53zm9.9 11.1l-3.22-7.9h1.74l1 2.62 1.26 3.42c.1-.32.48-1.46 1.15-3.42l.91-2.63h1.66l-2.92 7.87c-.78 2.07-1.96 3.1-3.56 3.1-.28 0-.53-.02-.73-.07v-1.34c.17.04.35.06.54.06 1.03 0 1.76-.57 2.17-1.7z\"\n      }\n    }), e._v(\" \"), i(\"path\", {\n      attrs: {\n        fill: \"#5468FF\",\n        d: \"M78.99.94h16.6a2.97 2.97 0 0 1 2.96 2.96v16.6a2.97 2.97 0 0 1-2.97 2.96h-16.6a2.97 2.97 0 0 1-2.96-2.96V3.9A2.96 2.96 0 0 1 79 .94\"\n      }\n    }), e._v(\" \"), i(\"path\", {\n      attrs: {\n        fill: \"#FFF\",\n        d: \"M89.63 5.97v-.78a.98.98 0 0 0-.98-.97h-2.28a.98.98 0 0 0-.97.97V6c0 .09.08.15.17.13a7.13 7.13 0 0 1 3.9-.02c.08.02.16-.04.16-.13m-6.25 1L83 6.6a.98.98 0 0 0-1.38 0l-.46.46a.97.97 0 0 0 0 1.38l.38.39c.06.06.15.04.2-.02a7.49 7.49 0 0 1 1.63-1.62c.07-.04.08-.14.02-.2m4.16 2.45v3.34c0 .1.1.17.2.12l2.97-1.54c.06-.03.08-.12.05-.18a3.7 3.7 0 0 0-3.08-1.87c-.07 0-.14.06-.14.13m0 8.05a4.49 4.49 0 1 1 0-8.98 4.49 4.49 0 0 1 0 8.98m0-10.85a6.37 6.37 0 1 0 0 12.74 6.37 6.37 0 0 0 0-12.74\"\n      }\n    }), e._v(\" \"), i(\"path\", {\n      attrs: {\n        fill: \"dark\" === e.theme ? \"#FFF\" : \"#5468FF\",\n        d: \"M120.92 18.8c-4.38.02-4.38-3.54-4.38-4.1V1.36l2.67-.42v13.25c0 .32 0 2.36 1.71 2.37v2.24zm-10.84-2.18c.82 0 1.43-.04 1.85-.12v-2.72a5.48 5.48 0 0 0-1.57-.2c-.3 0-.6.02-.9.07-.3.04-.57.12-.81.24-.24.11-.44.28-.58.49a.93.93 0 0 0-.22.65c0 .63.22 1 .61 1.23.4.24.94.36 1.62.36zm-.23-9.7c.88 0 1.62.11 2.23.33.6.22 1.09.53 1.44.92.36.4.61.92.76 1.48.16.56.23 1.17.23 1.85v6.87c-.4.1-1.03.2-1.86.32-.84.12-1.78.18-2.82.18-.69 0-1.32-.07-1.9-.2a4 4 0 0 1-1.46-.63c-.4-.3-.72-.67-.96-1.13a4.3 4.3 0 0 1-.34-1.8c0-.66.13-1.08.39-1.53.26-.45.6-.82 1.04-1.1.45-.3.95-.5 1.54-.62a8.8 8.8 0 0 1 3.79.05v-.44c0-.3-.04-.6-.11-.87a1.78 1.78 0 0 0-1.1-1.22c-.31-.12-.7-.2-1.15-.2a9.75 9.75 0 0 0-2.95.46l-.33-2.19c.34-.12.84-.23 1.48-.35.65-.12 1.34-.18 2.08-.18zm52.84 9.63c.82 0 1.43-.05 1.85-.13V13.7a5.42 5.42 0 0 0-1.57-.2c-.3 0-.6.02-.9.07-.3.04-.57.12-.81.24-.24.12-.44.28-.58.5a.93.93 0 0 0-.22.65c0 .63.22.99.61 1.23.4.24.94.36 1.62.36zm-.23-9.7c.88 0 1.63.11 2.23.33.6.22 1.1.53 1.45.92.35.39.6.92.76 1.48.15.56.23 1.18.23 1.85v6.88c-.41.08-1.03.19-1.87.31-.83.12-1.77.18-2.81.18-.7 0-1.33-.06-1.9-.2a4 4 0 0 1-1.47-.63c-.4-.3-.72-.67-.95-1.13a4.3 4.3 0 0 1-.34-1.8c0-.66.13-1.08.38-1.53.26-.45.61-.82 1.05-1.1.44-.3.95-.5 1.53-.62a8.8 8.8 0 0 1 3.8.05v-.43c0-.31-.04-.6-.12-.88-.07-.28-.2-.52-.38-.73a1.78 1.78 0 0 0-.73-.5c-.3-.1-.68-.2-1.14-.2a9.85 9.85 0 0 0-2.95.47l-.32-2.19a11.63 11.63 0 0 1 3.55-.53zm-8.03-1.27a1.62 1.62 0 0 0 0-3.24 1.62 1.62 0 1 0 0 3.24zm1.35 13.22h-2.7V7.27l2.7-.42V18.8zm-4.72 0c-4.38.02-4.38-3.54-4.38-4.1l-.01-13.34 2.67-.42v13.25c0 .32 0 2.36 1.72 2.37v2.24zm-8.7-5.9a4.7 4.7 0 0 0-.74-2.79 2.4 2.4 0 0 0-2.07-1 2.4 2.4 0 0 0-2.06 1 4.7 4.7 0 0 0-.74 2.8c0 1.16.25 1.94.74 2.62a2.4 2.4 0 0 0 2.07 1.02c.88 0 1.57-.34 2.07-1.02.49-.68.73-1.46.73-2.63zm2.74 0a6.46 6.46 0 0 1-1.52 4.23c-.49.53-1.07.94-1.76 1.22-.68.29-1.73.45-2.26.45-.53 0-1.58-.15-2.25-.45a5.1 5.1 0 0 1-2.88-3.13 7.3 7.3 0 0 1-.01-4.84 5.13 5.13 0 0 1 2.9-3.1 5.67 5.67 0 0 1 2.22-.42c.81 0 1.56.14 2.24.42.69.29 1.28.69 1.75 1.22.49.52.87 1.15 1.14 1.89a7 7 0 0 1 .43 2.5zm-20.14 0c0 1.11.25 2.36.74 2.88.5.52 1.13.78 1.91.78a4.07 4.07 0 0 0 2.12-.6V9.33c-.19-.04-.99-.2-1.76-.23a2.67 2.67 0 0 0-2.23 1 4.73 4.73 0 0 0-.78 2.8zm7.44 5.27c0 1.82-.46 3.16-1.4 4-.94.85-2.37 1.27-4.3 1.27-.7 0-2.17-.13-3.34-.4l.43-2.11c.98.2 2.27.26 2.95.26 1.08 0 1.84-.22 2.3-.66.46-.43.68-1.08.68-1.94v-.44a5.2 5.2 0 0 1-2.54.6 5.6 5.6 0 0 1-2.01-.36 4.2 4.2 0 0 1-2.58-2.71 9.88 9.88 0 0 1 .02-5.35 4.92 4.92 0 0 1 2.93-2.96 6.6 6.6 0 0 1 2.43-.46 19.64 19.64 0 0 1 4.43.66v10.6z\"\n      }\n    })])])]);\n  },\n  staticRenderFns: [],\n  name: \"AisPoweredBy\",\n  mixins: [createSuitMixin({\n    name: \"PoweredBy\"\n  })],\n  props: {\n    theme: {\n      default: \"light\",\n      validator: function (e) {\n        return -1 !== [\"light\", \"dark\"].indexOf(e);\n      }\n    }\n  },\n  computed: {\n    algoliaUrl: function () {\n      return \"https://www.algolia.com/?utm_source=vue-instantsearch&utm_medium=website&utm_content=\" + (location ? location.hostname : \"\") + \"&utm_campaign=poweredby\";\n    }\n  }\n},\n    QueryRuleContext = {\n  name: \"AisQueryRuleContext\",\n  mixins: [createSuitMixin({\n    name: \"QueryRuleContext\"\n  }), createWidgetMixin({\n    connector: connectors.connectQueryRules\n  })],\n  props: {\n    trackedFilters: {\n      type: Object,\n      required: !0\n    },\n    transformRuleContexts: {\n      type: Function,\n      required: !1,\n      default: void 0\n    }\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        trackedFilters: this.trackedFilters,\n        transformRuleContexts: this.transformRuleContexts\n      };\n    }\n  },\n  render: function () {\n    return null;\n  }\n},\n    QueryRuleCustomData = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: e.suit()\n    }, [e._t(\"default\", e._l(e.state.items, function (t, n) {\n      return i(\"div\", {\n        key: n\n      }, [e._t(\"item\", [i(\"pre\", [e._v(e._s(t))])], {\n        item: t\n      })], 2);\n    }), {\n      items: e.state.items\n    })], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisQueryRuleCustomData\",\n  mixins: [createSuitMixin({\n    name: \"QueryRuleCustomData\"\n  }), createWidgetMixin({\n    connector: connectors.connectQueryRules\n  })],\n  props: {\n    transformItems: {\n      type: Function,\n      required: !1,\n      default: void 0\n    }\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        transformItems: this.transformItems\n      };\n    }\n  }\n},\n    mapStateToCanRefine$1 = function (e) {\n  return e && Boolean(e.range) && e.range.min !== e.range.max;\n},\n    RangeInput = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: [e.suit(), !e.canRefine && e.suit(\"\", \"noRefinement\")]\n    }, [e._t(\"default\", [i(\"form\", {\n      class: e.suit(\"form\"),\n      on: {\n        submit: function (t) {\n          t.preventDefault(), e.refine({\n            min: e.pick(e.minInput, e.values.min),\n            max: e.pick(e.maxInput, e.values.max)\n          });\n        }\n      }\n    }, [i(\"label\", {\n      class: e.suit(\"label\")\n    }, [e._t(\"minLabel\"), e._v(\" \"), i(\"input\", {\n      class: [e.suit(\"input\"), e.suit(\"input\", \"min\")],\n      attrs: {\n        type: \"number\",\n        step: e.step,\n        min: e.state.range.min,\n        max: e.state.range.max,\n        placeholder: e.state.range.min\n      },\n      domProps: {\n        value: e.values.min\n      },\n      on: {\n        change: function (t) {\n          e.minInput = t.currentTarget.value;\n        }\n      }\n    })], 2), e._v(\" \"), i(\"span\", {\n      class: e.suit(\"separator\")\n    }, [e._t(\"separator\", [e._v(\"to\")])], 2), e._v(\" \"), i(\"label\", {\n      class: e.suit(\"label\")\n    }, [e._t(\"maxLabel\"), e._v(\" \"), i(\"input\", {\n      class: [e.suit(\"input\"), e.suit(\"input\", \"max\")],\n      attrs: {\n        type: \"number\",\n        step: e.step,\n        min: e.state.range.min,\n        max: e.state.range.max,\n        placeholder: e.state.range.max\n      },\n      domProps: {\n        value: e.values.max\n      },\n      on: {\n        change: function (t) {\n          e.maxInput = t.currentTarget.value;\n        }\n      }\n    })], 2), e._v(\" \"), i(\"button\", {\n      class: e.suit(\"submit\"),\n      attrs: {\n        type: \"submit\"\n      }\n    }, [e._t(\"submitLabel\", [e._v(\"Go\")])], 2)])], {\n      currentRefinement: e.values,\n      refine: e.refine,\n      canRefine: e.canRefine,\n      range: e.state.range,\n      sendEvent: e.state.sendEvent\n    })], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisRangeInput\",\n  mixins: [createSuitMixin({\n    name: \"RangeInput\"\n  }), createWidgetMixin({\n    connector: connectors.connectRange\n  }), createPanelConsumerMixin({\n    mapStateToCanRefine: mapStateToCanRefine$1\n  })],\n  props: {\n    attribute: {\n      type: String,\n      required: !0\n    },\n    min: {\n      type: Number,\n      required: !1,\n      default: void 0\n    },\n    max: {\n      type: Number,\n      required: !1,\n      default: void 0\n    },\n    precision: {\n      type: Number,\n      required: !1,\n      default: 0\n    }\n  },\n  data: function () {\n    return {\n      minInput: void 0,\n      maxInput: void 0\n    };\n  },\n  updated: function () {\n    this.minInput = void 0, this.maxInput = void 0;\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        attribute: this.attribute,\n        min: this.min,\n        max: this.max,\n        precision: this.precision\n      };\n    },\n    canRefine: function () {\n      return mapStateToCanRefine$1(this.state);\n    },\n    step: function () {\n      return 1 / Math.pow(10, this.precision);\n    },\n    values: function () {\n      var e = this.state.start,\n          t = e[0],\n          i = e[1],\n          n = this.state.range,\n          s = n.min,\n          a = n.max;\n      return {\n        min: t !== -1 / 0 && t !== s ? t : void 0,\n        max: i !== 1 / 0 && i !== a ? i : void 0\n      };\n    }\n  },\n  methods: {\n    pick: function (e, t) {\n      return null != e ? e : t;\n    },\n    refine: function (e) {\n      var t = e.min,\n          i = e.max;\n      this.state.refine([t, i]);\n    }\n  }\n},\n    RatingMenu = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: e.suit()\n    }, [e._t(\"default\", [i(\"svg\", {\n      staticStyle: {\n        display: \"none\"\n      },\n      attrs: {\n        xmlns: \"http://www.w3.org/2000/svg\"\n      }\n    }, [i(\"symbol\", {\n      attrs: {\n        id: \"ais-RatingMenu-starSymbol\",\n        viewBox: \"0 0 24 24\"\n      }\n    }, [i(\"path\", {\n      attrs: {\n        d: \"M12 .288l2.833 8.718h9.167l-7.417 5.389 2.833 8.718-7.416-5.388-7.417 5.388 2.833-8.718-7.416-5.389h9.167z\"\n      }\n    })]), e._v(\" \"), i(\"symbol\", {\n      attrs: {\n        id: \"ais-RatingMenu-starEmptySymbol\",\n        viewBox: \"0 0 24 24\"\n      }\n    }, [i(\"path\", {\n      attrs: {\n        d: \"M12 6.76l1.379 4.246h4.465l-3.612 2.625 1.379 4.246-3.611-2.625-3.612 2.625 1.379-4.246-3.612-2.625h4.465l1.38-4.246zm0-6.472l-2.833 8.718h-9.167l7.416 5.389-2.833 8.718 7.417-5.388 7.416 5.388-2.833-8.718 7.417-5.389h-9.167l-2.833-8.718z\"\n      }\n    })])]), e._v(\" \"), i(\"ul\", {\n      class: e.suit(\"list\")\n    }, e._l(e.state.items, function (t, n) {\n      return i(\"li\", {\n        key: n,\n        class: [e.suit(\"item\"), t.isRefined && e.suit(\"item\", \"selected\")]\n      }, [i(\"a\", {\n        class: e.suit(\"link\"),\n        attrs: {\n          href: e.state.createURL(t.value),\n          \"aria-label\": t.value + \" & Up\"\n        },\n        on: {\n          click: function (i) {\n            return i.preventDefault(), e.state.refine(t.value);\n          }\n        }\n      }, [e._l(t.stars, function (t, n) {\n        return [t ? i(\"svg\", {\n          key: n + \"-full\",\n          class: [e.suit(\"starIcon\"), e.suit(\"starIcon--full\")],\n          attrs: {\n            \"aria-hidden\": \"true\",\n            width: \"24\",\n            height: \"24\"\n          }\n        }, [i(\"use\", {\n          attrs: {\n            \"xlink:href\": \"#ais-RatingMenu-starSymbol\"\n          }\n        })]) : i(\"svg\", {\n          key: n + \"-empty\",\n          class: [e.suit(\"starIcon\"), e.suit(\"starIcon--empty\")],\n          attrs: {\n            \"aria-hidden\": \"true\",\n            width: \"24\",\n            height: \"24\"\n          }\n        }, [i(\"use\", {\n          attrs: {\n            \"xlink:href\": \"#ais-RatingMenu-starEmptySymbol\"\n          }\n        })])];\n      }), e._v(\" \"), i(\"span\", {\n        class: e.suit(\"label\"),\n        attrs: {\n          \"aria-hidden\": \"true\"\n        }\n      }, [e._t(\"andUp\", [e._v(\"& Up\")])], 2), e._v(\" \"), i(\"span\", {\n        class: e.suit(\"count\")\n      }, [e._v(e._s(t.count))])], 2)]);\n    }), 0)], {\n      items: e.state.items,\n      refine: e.state.refine,\n      createURL: e.state.createURL,\n      sendEvent: e.state.sendEvent\n    })], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisRatingMenu\",\n  mixins: [createSuitMixin({\n    name: \"RatingMenu\"\n  }), createWidgetMixin({\n    connector: connectors.connectRatingMenu\n  }), createPanelConsumerMixin({\n    mapStateToCanRefine: function (e) {\n      return !1 === e.hasNoResults;\n    }\n  })],\n  props: {\n    attribute: {\n      type: String,\n      required: !0\n    },\n    max: {\n      type: Number,\n      default: void 0\n    }\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        attribute: this.attribute,\n        max: this.max\n      };\n    }\n  }\n},\n    SearchInput = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return i(\"form\", {\n      class: e.suit(\"form\"),\n      attrs: {\n        action: \"\",\n        role: \"search\",\n        novalidate: \"\"\n      },\n      on: {\n        submit: function (t) {\n          return t.preventDefault(), e.onFormSubmit(t);\n        },\n        reset: function (t) {\n          return t.preventDefault(), e.onFormReset(t);\n        }\n      }\n    }, [i(\"input\", {\n      ref: \"input\",\n      class: e.suit(\"input\"),\n      attrs: {\n        type: \"search\",\n        autocorrect: \"off\",\n        autocapitalize: \"off\",\n        autocomplete: \"off\",\n        spellcheck: \"false\",\n        required: \"\",\n        maxlength: \"512\",\n        \"aria-label\": \"Search\",\n        placeholder: e.placeholder,\n        autofocus: e.autofocus\n      },\n      domProps: {\n        value: e.value || e.modelValue\n      },\n      on: {\n        focus: function (t) {\n          return e.$emit(\"focus\", t);\n        },\n        blur: function (t) {\n          return e.$emit(\"blur\", t);\n        },\n        input: function (t) {\n          e.$emit(\"input\", t.target.value), e.$emit(\"update:modelValue\", t.target.value);\n        }\n      }\n    }), e._v(\" \"), i(\"button\", {\n      class: e.suit(\"submit\"),\n      attrs: {\n        type: \"submit\",\n        title: e.submitTitle,\n        hidden: e.showLoadingIndicator && e.shouldShowLoadingIndicator\n      }\n    }, [e._t(\"submit-icon\", [i(\"svg\", {\n      class: e.suit(\"submitIcon\"),\n      attrs: {\n        role: \"img\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        width: \"10\",\n        height: \"10\",\n        viewBox: \"0 0 40 40\"\n      }\n    }, [i(\"path\", {\n      attrs: {\n        d: \"M26.804 29.01c-2.832 2.34-6.465 3.746-10.426 3.746C7.333 32.756 0 25.424 0 16.378 0 7.333 7.333 0 16.378 0c9.046 0 16.378 7.333 16.378 16.378 0 3.96-1.406 7.594-3.746 10.426l10.534 10.534c.607.607.61 1.59-.004 2.202-.61.61-1.597.61-2.202.004L26.804 29.01zm-10.426.627c7.323 0 13.26-5.936 13.26-13.26 0-7.32-5.937-13.257-13.26-13.257C9.056 3.12 3.12 9.056 3.12 16.378c0 7.323 5.936 13.26 13.258 13.26z\",\n        fillRule: \"evenodd\"\n      }\n    })])])], 2), e._v(\" \"), i(\"button\", {\n      class: e.suit(\"reset\"),\n      attrs: {\n        type: \"reset\",\n        title: e.resetTitle,\n        hidden: !e.value && !e.modelValue || e.showLoadingIndicator && e.shouldShowLoadingIndicator\n      }\n    }, [e._t(\"reset-icon\", [i(\"svg\", {\n      class: e.suit(\"resetIcon\"),\n      attrs: {\n        role: \"img\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        width: \"1em\",\n        height: \"1em\",\n        viewBox: \"0 0 20 20\"\n      }\n    }, [i(\"path\", {\n      attrs: {\n        d: \"M8.114 10L.944 2.83 0 1.885 1.886 0l.943.943L10 8.113l7.17-7.17.944-.943L20 1.886l-.943.943-7.17 7.17 7.17 7.17.943.944L18.114 20l-.943-.943-7.17-7.17-7.17 7.17-.944.943L0 18.114l.943-.943L8.113 10z\",\n        fillRule: \"evenodd\"\n      }\n    })])])], 2), e._v(\" \"), e.showLoadingIndicator ? i(\"span\", {\n      class: e.suit(\"loadingIndicator\"),\n      attrs: {\n        hidden: !e.shouldShowLoadingIndicator\n      }\n    }, [e._t(\"loading-indicator\", [i(\"svg\", {\n      class: e.suit(\"loadingIcon\"),\n      attrs: {\n        role: \"img\",\n        \"aria-label\": \"Results are loading\",\n        width: \"16\",\n        height: \"16\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        stroke: \"#444\",\n        viewBox: \"0 0 38 38\"\n      }\n    }, [i(\"g\", {\n      attrs: {\n        fill: \"none\",\n        \"fill-rule\": \"evenodd\"\n      }\n    }, [i(\"g\", {\n      attrs: {\n        transform: \"translate(1 1)\",\n        \"stroke-width\": \"2\"\n      }\n    }, [i(\"circle\", {\n      attrs: {\n        \"stroke-opacity\": \".5\",\n        cx: \"18\",\n        cy: \"18\",\n        r: \"18\"\n      }\n    }), e._v(\" \"), i(\"path\", {\n      attrs: {\n        d: \"M36 18c0-9.94-8.06-18-18-18\"\n      }\n    }, [i(\"animateTransform\", {\n      attrs: {\n        attributeName: \"transform\",\n        type: \"rotate\",\n        from: \"0 18 18\",\n        to: \"360 18 18\",\n        dur: \"1s\",\n        repeatCount: \"indefinite\"\n      }\n    })], 1)])])])])], 2) : e._e()]);\n  },\n  staticRenderFns: [],\n  name: \"SearchInput\",\n  mixins: [createSuitMixin({\n    name: \"SearchBox\"\n  })],\n  props: {\n    placeholder: {\n      type: String,\n      default: \"Search here…\"\n    },\n    autofocus: {\n      type: Boolean,\n      default: !1\n    },\n    showLoadingIndicator: {\n      type: Boolean,\n      default: !1\n    },\n    shouldShowLoadingIndicator: {\n      type: Boolean,\n      default: !1\n    },\n    submitTitle: {\n      type: String,\n      default: \"Search\"\n    },\n    resetTitle: {\n      type: String,\n      default: \"Clear\"\n    },\n    value: {\n      type: String,\n      required: !1,\n      default: void 0\n    },\n    modelValue: {\n      type: String,\n      required: !1,\n      default: void 0\n    }\n  },\n  emits: [\"input\", \"update:modelValue\", \"blur\", \"focus\", \"reset\"],\n  data: function () {\n    return {\n      query: \"\"\n    };\n  },\n  methods: {\n    onFormSubmit: function () {\n      this.$refs.input.blur();\n    },\n    onFormReset: function () {\n      this.$emit(\"input\", \"\"), this.$emit(\"update:modelValue\", \"\"), this.$emit(\"reset\");\n    }\n  }\n},\n    noop = function () {},\n    RefinementList = {\n  render: function () {\n    var e,\n        t = this,\n        i = t.$createElement,\n        n = t._self._c || i;\n    return t.state ? n(\"div\", {\n      class: [t.suit(), !t.state.canRefine && t.suit(\"\", \"noRefinement\")]\n    }, [t._t(\"default\", [t.searchable ? n(\"div\", {\n      class: t.suit(\"searchBox\")\n    }, [n(\"search-input\", {\n      attrs: {\n        placeholder: t.searchablePlaceholder,\n        \"class-names\": t.classNames\n      },\n      model: {\n        value: t.searchForFacetValues,\n        callback: function (e) {\n          t.searchForFacetValues = e;\n        },\n        expression: \"searchForFacetValues\"\n      }\n    })], 1) : t._e(), t._v(\" \"), t.state.isFromSearch && 0 === t.items.length ? t._t(\"noResults\", [n(\"div\", {\n      class: t.suit(\"noResults\")\n    }, [t._v(\"No results.\")])], {\n      query: t.searchForFacetValues\n    }) : t._e(), t._v(\" \"), n(\"ul\", {\n      class: t.suit(\"list\")\n    }, t._l(t.items, function (e) {\n      return n(\"li\", {\n        key: e.value,\n        class: [t.suit(\"item\"), e.isRefined && t.suit(\"item\", \"selected\")]\n      }, [t._t(\"item\", [n(\"label\", {\n        class: t.suit(\"label\")\n      }, [n(\"input\", {\n        class: t.suit(\"checkbox\"),\n        attrs: {\n          type: \"checkbox\"\n        },\n        domProps: {\n          value: e.value,\n          checked: e.isRefined\n        },\n        on: {\n          change: function (i) {\n            return t.refine(e.value);\n          }\n        }\n      }), t._v(\" \"), t.searchable ? n(\"span\", {\n        class: t.suit(\"labelText\")\n      }, [n(\"ais-highlight\", {\n        attrs: {\n          attribute: \"item\",\n          hit: e\n        }\n      })], 1) : n(\"span\", {\n        class: t.suit(\"labelText\")\n      }, [t._v(t._s(e.label))]), t._v(\" \"), n(\"span\", {\n        class: t.suit(\"count\")\n      }, [t._v(t._s(e.count))])])], {\n        item: e,\n        refine: t.refine,\n        createURL: t.state.createURL\n      })], 2);\n    }), 0), t._v(\" \"), t.showMore ? n(\"button\", {\n      class: [t.suit(\"showMore\"), (e = {}, e[t.suit(\"showMore\", \"disabled\")] = !t.state.canToggleShowMore, e)],\n      attrs: {\n        disabled: !t.state.canToggleShowMore\n      },\n      on: {\n        click: t.toggleShowMore\n      }\n    }, [t._t(\"showMoreLabel\", [t._v(\"Show \" + t._s(t.state.isShowingMore ? \"less\" : \"more\"))], {\n      isShowingMore: t.state.isShowingMore\n    })], 2) : t._e()], {\n      items: t.items,\n      refine: t.refine,\n      searchForItems: t.state.searchForItems,\n      searchForItemsQuery: t.searchForFacetValuesQuery,\n      toggleShowMore: t.toggleShowMore,\n      canToggleShowMore: t.state.canToggleShowMore,\n      isShowingMore: t.state.isShowingMore,\n      createURL: t.state.createURL,\n      isFromSearch: t.state.isFromSearch,\n      canRefine: t.state.canRefine,\n      sendEvent: t.state.sendEvent\n    })], 2) : t._e();\n  },\n  staticRenderFns: [],\n  name: \"AisRefinementList\",\n  components: {\n    SearchInput: SearchInput,\n    AisHighlight: AisHighlight\n  },\n  mixins: [createSuitMixin({\n    name: \"RefinementList\"\n  }), createWidgetMixin({\n    connector: connectors.connectRefinementList\n  }), createPanelConsumerMixin({\n    mapStateToCanRefine: function (e) {\n      return Boolean(e.canRefine);\n    }\n  })],\n  props: {\n    attribute: {\n      type: String,\n      required: !0\n    },\n    searchable: {\n      type: Boolean,\n      default: void 0\n    },\n    searchablePlaceholder: {\n      type: String,\n      required: !1,\n      default: \"Search here…\"\n    },\n    operator: {\n      default: \"or\",\n      validator: function (e) {\n        return \"and\" === e || \"or\" === e;\n      },\n      required: !1\n    },\n    limit: {\n      type: Number,\n      required: !1,\n      default: void 0\n    },\n    showMoreLimit: {\n      type: Number,\n      required: !1,\n      default: void 0\n    },\n    showMore: {\n      type: Boolean,\n      required: !1,\n      default: !1\n    },\n    sortBy: {\n      type: [Array, Function],\n      required: !1,\n      default: void 0\n    },\n    transformItems: {\n      type: Function,\n      required: !1,\n      default: void 0\n    }\n  },\n  data: function () {\n    return {\n      searchForFacetValuesQuery: \"\"\n    };\n  },\n  computed: {\n    searchForFacetValues: {\n      get: function () {\n        return this.searchForFacetValuesQuery;\n      },\n      set: function (e) {\n        this.state.searchForItems(e), this.searchForFacetValuesQuery = e;\n      }\n    },\n    toggleShowMore: function () {\n      return this.state.toggleShowMore || noop;\n    },\n    items: function () {\n      return this.state.items.map(function (e) {\n        return Object.assign({}, e, {\n          _highlightResult: {\n            item: {\n              value: e.highlighted\n            }\n          }\n        });\n      });\n    },\n    widgetParams: function () {\n      return {\n        attribute: this.attribute,\n        operator: this.operator,\n        limit: this.limit,\n        showMore: this.showMore,\n        showMoreLimit: this.showMoreLimit,\n        sortBy: this.sortBy,\n        escapeFacetValues: !0,\n        transformItems: this.transformItems\n      };\n    }\n  },\n  methods: {\n    refine: function (e) {\n      this.state.refine(e), this.searchForFacetValuesQuery = \"\";\n    }\n  }\n},\n    connectStateResults = function (e, t) {\n  return void 0 === t && (t = function () {}), function (i) {\n    return void 0 === i && (i = {}), {\n      init: function (t) {\n        var n = t.instantSearchInstance;\n        e({\n          state: void 0,\n          results: void 0,\n          instantSearchInstance: n,\n          widgetParams: i\n        }, !0);\n      },\n      render: function (t) {\n        var n = t.results,\n            s = t.instantSearchInstance,\n            a = t.state,\n            r = _objectSpread({}, n),\n            o = _objectSpread({}, a);\n\n        e({\n          results: r,\n          state: o,\n          instantSearchInstance: s,\n          widgetParams: i\n        }, !1);\n      },\n      dispose: function () {\n        t();\n      }\n    };\n  };\n},\n    StateResults = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state && e.state.state && e.state.results ? i(\"div\", {\n      class: e.suit()\n    }, [e._t(\"default\", [i(\"p\", [e._v(\" Use this component to have a different layout based on a certain state. \")]), e._v(\" \"), i(\"p\", [e._v(\" Fill in the slot, and get access to the following things: \")]), e._v(\" \"), i(\"pre\", [e._v(\"results: \" + e._s(Object.keys(e.state.results)))]), e._v(\" \"), i(\"pre\", [e._v(\"state: \" + e._s(Object.keys(e.state.state)))])], null, e.stateResults)], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisStateResults\",\n  mixins: [createWidgetMixin({\n    connector: connectStateResults\n  }), createSuitMixin({\n    name: \"StateResults\"\n  })],\n  computed: {\n    stateResults: function () {\n      var e = this.state,\n          t = e.state,\n          i = e.results;\n      return _objectSpread({}, i, {\n        results: i,\n        state: t\n      });\n    }\n  }\n},\n    SearchBox = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: e.suit()\n    }, [e._t(\"default\", [i(\"search-input\", {\n      attrs: {\n        placeholder: e.placeholder,\n        autofocus: e.autofocus,\n        \"show-loading-indicator\": e.showLoadingIndicator,\n        \"should-show-loading-indicator\": e.state.isSearchStalled,\n        \"submit-title\": e.submitTitle,\n        \"reset-title\": e.resetTitle,\n        \"class-names\": e.classNames\n      },\n      on: {\n        focus: function (t) {\n          return e.$emit(\"focus\", t);\n        },\n        blur: function (t) {\n          return e.$emit(\"blur\", t);\n        },\n        reset: function (t) {\n          return e.$emit(\"reset\");\n        }\n      },\n      scopedSlots: e._u([e.isVue3 ? {\n        key: \"loading-indicator\",\n        fn: function (t) {\n          return [e._t(\"loading-indicator\")];\n        }\n      } : null, e.isVue3 ? {\n        key: \"submit-icon\",\n        fn: function (t) {\n          return [e._t(\"submit-icon\")];\n        }\n      } : null, e.isVue3 ? {\n        key: \"reset-icon\",\n        fn: function (t) {\n          return [e._t(\"reset-icon\")];\n        }\n      } : null], !0),\n      model: {\n        value: e.currentRefinement,\n        callback: function (t) {\n          e.currentRefinement = t;\n        },\n        expression: \"currentRefinement\"\n      }\n    }, [e._v(\" \"), e.isVue2 ? e._t(\"loading-indicator\", null, {\n      slot: \"loading-indicator\"\n    }) : e._e(), e._v(\" \"), e._v(\" \"), e.isVue2 ? e._t(\"submit-icon\", null, {\n      slot: \"submit-icon\"\n    }) : e._e(), e._v(\" \"), e._v(\" \"), e.isVue2 ? e._t(\"reset-icon\", null, {\n      slot: \"reset-icon\"\n    }) : e._e()], 2)], {\n      currentRefinement: e.currentRefinement,\n      isSearchStalled: e.state.isSearchStalled,\n      refine: e.state.refine\n    })], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisSearchBox\",\n  mixins: [createWidgetMixin({\n    connector: connectors.connectSearchBox\n  }), createSuitMixin({\n    name: \"SearchBox\"\n  })],\n  components: {\n    SearchInput: SearchInput\n  },\n  props: {\n    placeholder: {\n      type: String,\n      default: \"Search here…\"\n    },\n    autofocus: {\n      type: Boolean,\n      default: !1\n    },\n    showLoadingIndicator: {\n      type: Boolean,\n      default: !1\n    },\n    submitTitle: {\n      type: String,\n      default: \"Search\"\n    },\n    resetTitle: {\n      type: String,\n      default: \"Clear\"\n    },\n    value: {\n      type: String,\n      default: void 0\n    },\n    modelValue: {\n      type: String,\n      default: void 0\n    }\n  },\n  data: function () {\n    return {\n      localValue: \"\",\n      isVue2: isVue2,\n      isVue3: isVue3\n    };\n  },\n  computed: {\n    isControlled: function () {\n      return void 0 !== this.value || void 0 !== this.modelValue;\n    },\n    model: function () {\n      return this.value || this.modelValue;\n    },\n    currentRefinement: {\n      get: function () {\n        return this.isControlled && this.model !== this.localValue && (this.localValue = this.model, this.$emit(\"input\", this.model), this.$emit(\"update:modelValue\", this.model), this.state.refine(this.model)), this.model || this.state.query || \"\";\n      },\n      set: function (e) {\n        this.localValue = e, this.state.refine(e), this.isControlled && (this.$emit(\"input\", e), this.$emit(\"update:modelValue\", e));\n      }\n    }\n  }\n},\n    Snippet = {\n  render: function () {\n    var e = this.$createElement;\n    return (this._self._c || e)(\"ais-highlighter\", {\n      attrs: {\n        hit: this.hit,\n        attribute: this.attribute,\n        \"highlighted-tag-name\": this.highlightedTagName,\n        suit: this.suit,\n        \"highlight-property\": \"_snippetResult\",\n        \"pre-tag\": \"<mark>\",\n        \"post-tag\": \"</mark>\"\n      }\n    });\n  },\n  staticRenderFns: [],\n  name: \"AisSnippet\",\n  mixins: [createSuitMixin({\n    name: \"Snippet\"\n  })],\n  components: {\n    AisHighlighter: AisHighlighter\n  },\n  props: {\n    hit: {\n      type: Object,\n      required: !0\n    },\n    attribute: {\n      type: String,\n      required: !0\n    },\n    highlightedTagName: {\n      type: String,\n      default: \"mark\"\n    }\n  }\n},\n    SortBy = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: e.suit()\n    }, [e._t(\"default\", [i(\"select\", {\n      class: e.suit(\"select\"),\n      on: {\n        change: function (t) {\n          return e.state.refine(t.currentTarget.value);\n        }\n      }\n    }, e._l(e.state.options, function (t) {\n      return i(\"option\", {\n        key: t.value,\n        class: e.suit(\"option\"),\n        domProps: {\n          value: t.value,\n          selected: t.value === e.state.currentRefinement\n        }\n      }, [e._v(e._s(t.label))]);\n    }), 0)], {\n      items: e.state.options,\n      hasNoResults: e.state.hasNoResults,\n      refine: e.state.refine,\n      currentRefinement: e.state.currentRefinement\n    })], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisSortBy\",\n  mixins: [createSuitMixin({\n    name: \"SortBy\"\n  }), createWidgetMixin({\n    connector: connectors.connectSortBy\n  }), createPanelConsumerMixin({\n    mapStateToCanRefine: function (e) {\n      return !1 === e.hasNoResults;\n    }\n  })],\n  props: {\n    items: {\n      type: Array,\n      required: !0\n    },\n    transformItems: {\n      type: Function,\n      default: void 0\n    }\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        items: this.items,\n        transformItems: this.transformItems\n      };\n    }\n  }\n},\n    Stats = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: e.suit()\n    }, [e._t(\"default\", [i(\"span\", {\n      class: e.suit(\"text\")\n    }, [e.state.areHitsSorted ? [e._v(e._s(e.state.nbSortedHits.toLocaleString()) + \" relevant results sorted out of \" + e._s(e.state.nbHits.toLocaleString()))] : [e._v(e._s(e.state.nbHits.toLocaleString()) + \" results\")], e._v(\" found in \" + e._s(e.state.processingTimeMS.toLocaleString()) + \"ms\")], 2)], {\n      results: e.state.instantSearchInstance.helper.lastResults\n    }, e.state)], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisStats\",\n  mixins: [createWidgetMixin({\n    connector: connectors.connectStats\n  }), createSuitMixin({\n    name: \"Stats\"\n  })],\n  computed: {\n    widgetParams: function () {\n      return {};\n    }\n  }\n},\n    mapStateToCanRefine$2 = function (e) {\n  return Boolean(e.value && e.value.count);\n},\n    ToggleRefinement = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: [e.suit(), !e.canRefine && e.suit(\"\", \"noRefinement\")]\n    }, [e._t(\"default\", [i(\"label\", {\n      class: e.suit(\"label\")\n    }, [i(\"input\", {\n      class: e.suit(\"checkbox\"),\n      attrs: {\n        type: \"checkbox\",\n        name: e.state.value.name\n      },\n      domProps: {\n        value: e.on,\n        checked: e.state.value.isRefined\n      },\n      on: {\n        change: function (t) {\n          return e.state.refine(e.state.value);\n        }\n      }\n    }), e._v(\" \"), i(\"span\", {\n      class: e.suit(\"labelText\")\n    }, [e._v(e._s(e.label))]), e._v(\" \"), null !== e.state.value.count ? i(\"span\", {\n      class: e.suit(\"count\")\n    }, [e._v(e._s(e.state.value.count.toLocaleString()))]) : e._e()])], {\n      value: e.state.value,\n      canRefine: e.canRefine,\n      refine: e.state.refine,\n      createURL: e.state.createURL,\n      sendEvent: e.state.sendEvent\n    })], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisToggleRefinement\",\n  mixins: [createSuitMixin({\n    name: \"ToggleRefinement\"\n  }), createWidgetMixin({\n    connector: connectors.connectToggleRefinement\n  }), createPanelConsumerMixin({\n    mapStateToCanRefine: mapStateToCanRefine$2\n  })],\n  props: {\n    attribute: {\n      type: String,\n      required: !0\n    },\n    label: {\n      type: String,\n      required: !0\n    },\n    on: {\n      type: [String, Number, Boolean, Array],\n      required: !1,\n      default: !0\n    },\n    off: {\n      type: [String, Number, Boolean, Array],\n      required: !1,\n      default: void 0\n    }\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        attribute: this.attribute,\n        label: this.label,\n        on: this.on,\n        off: this.off\n      };\n    },\n    canRefine: function () {\n      return mapStateToCanRefine$2(this.state);\n    }\n  }\n},\n    VoiceSearch = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state ? i(\"div\", {\n      class: e.suit()\n    }, [e._t(\"default\", [i(\"button\", {\n      class: e.suit(\"button\"),\n      attrs: {\n        type: \"button\",\n        title: e.state.isBrowserSupported ? e.buttonTitle : e.disabledButtonTitle,\n        disabled: !e.state.isBrowserSupported\n      },\n      on: {\n        click: e.handleClick\n      }\n    }, [e._t(\"buttonText\", [e.errorNotAllowed ? i(\"svg\", e._b({}, \"svg\", e.buttonSvgAttrs, !1), [i(\"line\", {\n      attrs: {\n        x1: \"1\",\n        y1: \"1\",\n        x2: \"23\",\n        y2: \"23\"\n      }\n    }), e._v(\" \"), i(\"path\", {\n      attrs: {\n        d: \"M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6\"\n      }\n    }), e._v(\" \"), i(\"path\", {\n      attrs: {\n        d: \"M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23\"\n      }\n    }), e._v(\" \"), i(\"line\", {\n      attrs: {\n        x1: \"12\",\n        y1: \"19\",\n        x2: \"12\",\n        y2: \"23\"\n      }\n    }), e._v(\" \"), i(\"line\", {\n      attrs: {\n        x1: \"8\",\n        y1: \"23\",\n        x2: \"16\",\n        y2: \"23\"\n      }\n    })]) : i(\"svg\", e._b({}, \"svg\", e.buttonSvgAttrs, !1), [i(\"path\", {\n      attrs: {\n        d: \"M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z\",\n        fill: e.state.isListening ? \"currentColor\" : \"none\"\n      }\n    }), e._v(\" \"), i(\"path\", {\n      attrs: {\n        d: \"M19 10v2a7 7 0 0 1-14 0v-2\"\n      }\n    }), e._v(\" \"), i(\"line\", {\n      attrs: {\n        x1: \"12\",\n        y1: \"19\",\n        x2: \"12\",\n        y2: \"23\"\n      }\n    }), e._v(\" \"), i(\"line\", {\n      attrs: {\n        x1: \"8\",\n        y1: \"23\",\n        x2: \"16\",\n        y2: \"23\"\n      }\n    })])], null, e.innerSlotProps)], 2), e._v(\" \"), i(\"div\", {\n      class: e.suit(\"status\")\n    }, [e._t(\"status\", [i(\"p\", [e._v(e._s(e.state.voiceListeningState.transcript))])], null, e.innerSlotProps)], 2)], null, e.rootSlotProps)], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisVoiceSearch\",\n  mixins: [createWidgetMixin({\n    connector: connectors.connectVoiceSearch\n  }), createSuitMixin({\n    name: \"VoiceSearch\"\n  })],\n  props: {\n    searchAsYouSpeak: {\n      type: Boolean,\n      required: !1,\n      default: void 0\n    },\n    buttonTitle: {\n      type: String,\n      required: !1,\n      default: \"Search by voice\"\n    },\n    disabledButtonTitle: {\n      type: String,\n      required: !1,\n      default: \"Search by voice (not supported on this browser)\"\n    }\n  },\n  data: function () {\n    return {\n      buttonSvgAttrs: {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        width: \"16\",\n        height: \"16\",\n        viewBox: \"0 0 24 24\",\n        fill: \"none\",\n        stroke: \"currentColor\",\n        strokeWidth: \"2\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\"\n      }\n    };\n  },\n  computed: {\n    widgetParams: function () {\n      return {\n        searchAsYouSpeak: this.searchAsYouSpeak\n      };\n    },\n    errorNotAllowed: function () {\n      return \"error\" === this.state.voiceListeningState.status && \"not-allowed\" === this.state.voiceListeningState.errorCode;\n    },\n    rootSlotProps: function () {\n      return {\n        isBrowserSupported: this.state.isBrowserSupported,\n        isListening: this.state.isListening,\n        toggleListening: this.state.toggleListening,\n        voiceListeningState: this.state.voiceListeningState\n      };\n    },\n    innerSlotProps: function () {\n      return {\n        status: this.state.voiceListeningState.status,\n        errorCode: this.state.voiceListeningState.errorCode,\n        isListening: this.state.isListening,\n        transcript: this.state.voiceListeningState.transcript,\n        isSpeechFinal: this.state.voiceListeningState.isSpeechFinal,\n        isBrowserSupported: this.state.isBrowserSupported\n      };\n    }\n  },\n  methods: {\n    handleClick: function (e) {\n      e.currentTarget.blur(), this.state.toggleListening();\n    }\n  }\n},\n    RelevantSort = {\n  render: function () {\n    var e = this,\n        t = e.$createElement,\n        i = e._self._c || t;\n    return e.state && e.state.isVirtualReplica ? i(\"div\", {\n      class: e.suit()\n    }, [e._t(\"default\", [i(\"div\", {\n      class: e.suit(\"text\")\n    }, [e._t(\"text\", null, {\n      isRelevantSorted: e.state.isRelevantSorted\n    })], 2), e._v(\" \"), i(\"button\", {\n      class: e.suit(\"button\"),\n      attrs: {\n        type: \"button\"\n      },\n      on: {\n        click: function (t) {\n          return e.refine();\n        }\n      }\n    }, [e._t(\"button\", [e._v(e._s(e.state.isRelevantSorted ? \"See all results\" : \"See relevant results\"))], {\n      isRelevantSorted: e.state.isRelevantSorted\n    })], 2)], {\n      isRelevantSorted: e.state.isRelevantSorted,\n      refine: e.state.refine\n    })], 2) : e._e();\n  },\n  staticRenderFns: [],\n  name: \"AisRelevantSort\",\n  mixins: [createSuitMixin({\n    name: \"RelevantSort\"\n  }), createWidgetMixin({\n    connector: connectors.connectRelevantSort\n  })],\n  methods: {\n    refine: function () {\n      this.state.isRelevantSorted ? this.state.refine(0) : this.state.refine(void 0);\n    }\n  }\n};\n\nfunction getWidgetAttribute(e) {\n  var t,\n      i = e.componentOptions && e.componentOptions.propsData;\n\n  if (i) {\n    if (i.attribute) return i.attribute;\n    if (Array.isArray(i.attributes)) return i.attributes[0];\n  }\n\n  if (t = e.componentOptions && e.componentOptions.children ? e.componentOptions.children : e.children, Array.isArray(t)) return t.reduce(function (e, t) {\n    return e || getWidgetAttribute(t);\n  }, void 0);\n}\n\nvar DynamicWidgets = {\n  name: \"AisExperimentalDynamicWidgets\",\n  mixins: [createWidgetMixin({\n    connector: connectors.connectDynamicWidgets\n  }), createSuitMixin({\n    name: \"DynamicWidgets\"\n  })],\n  props: {\n    transformItems: {\n      type: Function,\n      default: void 0\n    }\n  },\n  render: renderCompat(function (e) {\n    var t = this,\n        i = new Map();\n\n    if ((getDefaultSlot(this) || []).forEach(function (n) {\n      var s = getWidgetAttribute(n);\n      s && i.set(s, e(\"div\", {\n        key: s,\n        class: [t.suit(\"widget\")]\n      }, [n]));\n    }), !this.state) {\n      var n = [];\n      return i.forEach(function (e) {\n        return n.push(e);\n      }), e(\"div\", _objectSpread({\n        class: [this.suit()]\n      }, {\n        attrs: {\n          hidden: !0\n        }\n      }), n);\n    }\n\n    return e(\"div\", {\n      class: [this.suit()]\n    }, this.state.attributesToRender.map(function (e) {\n      return i.get(e);\n    }));\n  }),\n  computed: {\n    widgetParams: function () {\n      return {\n        transformItems: this.transformItems,\n        widgets: []\n      };\n    }\n  }\n},\n    widgets = Object.freeze({\n  __proto__: null,\n  AisAutocomplete: Autocomplete,\n  AisBreadcrumb: Breadcrumb,\n  AisClearRefinements: ClearRefinements,\n  AisConfigure: Configure,\n  AisExperimentalConfigureRelatedItems: ConfigureRelatedItems,\n  AisCurrentRefinements: CurrentRefinements,\n  AisHierarchicalMenu: HierarchicalMenu,\n  AisHighlight: AisHighlight,\n  AisHits: Hits,\n  AisHitsPerPage: HitsPerPage,\n  AisIndex: Index,\n  AisInstantSearch: InstantSearch,\n  AisInstantSearchSsr: InstantSearchSsr,\n  AisInfiniteHits: InfiniteHits,\n  AisMenu: Menu,\n  AisMenuSelect: MenuSelect,\n  AisNumericMenu: NumericMenu,\n  AisPagination: Pagination,\n  AisPanel: Panel,\n  AisPoweredBy: PoweredBy,\n  AisQueryRuleContext: QueryRuleContext,\n  AisQueryRuleCustomData: QueryRuleCustomData,\n  AisRangeInput: RangeInput,\n  AisRatingMenu: RatingMenu,\n  AisRefinementList: RefinementList,\n  AisStateResults: StateResults,\n  AisSearchBox: SearchBox,\n  AisSnippet: Snippet,\n  AisSortBy: SortBy,\n  AisStats: Stats,\n  AisToggleRefinement: ToggleRefinement,\n  AisVoiceSearch: VoiceSearch,\n  AisRelevantSort: RelevantSort,\n  AisDynamicWidgets: DynamicWidgets\n}),\n    plugin = {\n  install: function (e) {\n    Object.keys(widgets).forEach(function (t) {\n      e.component(widgets[t].name, widgets[t]);\n    });\n  }\n},\n    SearchResults = algoliaHelper.SearchResults,\n    SearchParameters = algoliaHelper.SearchParameters;\n\nfunction walkIndex(e, t) {\n  return t(e), e.getWidgets().forEach(function (e) {\n    \"ais.index\" === e.$$type && (t(e), walkIndex(e, t));\n  });\n}\n\nfunction searchOnlyWithDerivedHelpers(e) {\n  return new Promise(function (t, i) {\n    e.searchOnlyWithDerivedHelpers(), e.derivedHelpers[0].on(\"result\", function () {\n      t();\n    }), e.derivedHelpers.forEach(function (e) {\n      return e.on(\"error\", function (e) {\n        i(e);\n      });\n    });\n  });\n}\n\nfunction defaultCloneComponent(e, t) {\n  void 0 === t && (t = {});\n  var i = t.mixins;\n  void 0 === i && (i = []);\n  var n,\n      s = {\n    serverPrefetch: void 0,\n    fetch: void 0,\n    _base: void 0,\n    name: \"ais-ssr-root-component\"\n  };\n  return s.router = e.$router, s.store = e.$store, (n = new (e.$vnode ? e.$vnode.componentOptions.Ctor.extend(s) : Vue2.component(Object.assign({}, e.$options, s)))({\n    propsData: e.$options.propsData,\n    mixins: [].concat(i)\n  })).$slots = e.$slots, n.$root = e.$root, n.$options.serverPrefetch = [], n;\n}\n\nfunction augmentInstantSearch(e, t, i, n) {\n  var s,\n      a = algoliaHelper(t, i),\n      r = instantsearch(e);\n  return r.findResultsState = function (e) {\n    var t,\n        i,\n        o = e.component,\n        u = e.renderToString;\n    if (!u) throw new Error(\"findResultsState requires `renderToString: (component) => Promise<string>` in the first argument.\");\n    return Promise.resolve().then(function () {\n      t = n(o, {\n        mixins: [{\n          created: function () {\n            i = this, this.instantsearch.helper = a, this.instantsearch.mainHelper = a, this.instantsearch.mainIndex.init({\n              instantSearchInstance: this.instantsearch,\n              parent: null,\n              uiState: this.instantsearch._initialUiState\n            });\n          }\n        }]\n      });\n    }).then(function () {\n      return u(t);\n    }).then(function () {\n      return searchOnlyWithDerivedHelpers(a);\n    }).then(function () {\n      var e = {};\n      return walkIndex(i.instantsearch.mainIndex, function (t) {\n        e[t.getIndexId()] = t.getResults();\n      }), r.hydrate(e), s = Object.keys(e).map(function (t) {\n        var i = e[t],\n            n = i._state,\n            s = i._rawResults;\n        return [t, {\n          _state: Object.keys(n).reduce(function (e, t) {\n            return e[t] = n[t], e;\n          }, {}),\n          _rawResults: s\n        }];\n      }).reduce(function (e, t) {\n        var i = t[0],\n            n = t[1];\n        return e[i] = n, e;\n      }, {\n        __identifier: \"stringified\"\n      }), r.getState();\n    });\n  }, r.getState = function () {\n    if (!s) throw new Error(\"You need to wait for findResultsState to finish\");\n    return s;\n  }, r.__forceRender = function (e, t) {\n    var i = t.getHelper(),\n        n = r.__initialSearchResults[t.getIndexId()];\n\n    if (n) {\n      var s = n._state;\n      i.state = s, e.render({\n        helper: i,\n        results: n,\n        scopedResults: t.getScopedResults().map(function (e) {\n          return Object.assign(e, {\n            results: r.__initialSearchResults[e.indexId]\n          });\n        }),\n        parent: t,\n        state: s,\n        templatesConfig: {},\n        createURL: t.createURL,\n        instantSearchInstance: r,\n        searchMetadata: {\n          isSearchStalled: !1\n        }\n      });\n    }\n  }, r.hydrate = function (e) {\n    if (e) {\n      var t = \"stringified\" === e.__identifier ? Object.keys(e).reduce(function (t, i) {\n        return \"__identifier\" === i ? t : (t[i] = new SearchResults(new SearchParameters(e[i]._state), e[i]._rawResults), t);\n      }, {}) : e;\n      r.__initialSearchResults = t, r.helper = a, r.mainHelper = a, r.mainIndex.init({\n        instantSearchInstance: r,\n        parent: null,\n        uiState: r._initialUiState\n      });\n    } else warn(\"The result of `findResultsState()` needs to be passed to `hydrate()`.\");\n  }, r;\n}\n\nfunction createServerRootMixin(e) {\n  void 0 === e && (e = {});\n  var t = e.searchClient,\n      i = e.indexName,\n      n = e.$cloneComponent;\n  if (void 0 === n && (n = defaultCloneComponent), !t || !i) throw new Error(\"createServerRootMixin requires `searchClient` and `indexName` in the first argument\");\n  var s = augmentInstantSearch(e, t, i, n);\n  return {\n    provide: function () {\n      return {\n        $_ais_ssrInstantSearchInstance: this.instantsearch\n      };\n    },\n    data: function () {\n      return {\n        instantsearch: s\n      };\n    }\n  };\n}\n\nexports.AisAutocomplete = Autocomplete, exports.AisBreadcrumb = Breadcrumb, exports.AisClearRefinements = ClearRefinements, exports.AisConfigure = Configure, exports.AisCurrentRefinements = CurrentRefinements, exports.AisDynamicWidgets = DynamicWidgets, exports.AisExperimentalConfigureRelatedItems = ConfigureRelatedItems, exports.AisHierarchicalMenu = HierarchicalMenu, exports.AisHighlight = AisHighlight, exports.AisHits = Hits, exports.AisHitsPerPage = HitsPerPage, exports.AisIndex = Index, exports.AisInfiniteHits = InfiniteHits, exports.AisInstantSearch = InstantSearch, exports.AisInstantSearchSsr = InstantSearchSsr, exports.AisMenu = Menu, exports.AisMenuSelect = MenuSelect, exports.AisNumericMenu = NumericMenu, exports.AisPagination = Pagination, exports.AisPanel = Panel, exports.AisPoweredBy = PoweredBy, exports.AisQueryRuleContext = QueryRuleContext, exports.AisQueryRuleCustomData = QueryRuleCustomData, exports.AisRangeInput = RangeInput, exports.AisRatingMenu = RatingMenu, exports.AisRefinementList = RefinementList, exports.AisRelevantSort = RelevantSort, exports.AisSearchBox = SearchBox, exports.AisSnippet = Snippet, exports.AisSortBy = SortBy, exports.AisStateResults = StateResults, exports.AisStats = Stats, exports.AisToggleRefinement = ToggleRefinement, exports.AisVoiceSearch = VoiceSearch, exports.createServerRootMixin = createServerRootMixin, exports.createSuitMixin = createSuitMixin, exports.createWidgetMixin = createWidgetMixin, exports.default = plugin;\n\n/***/ }),\n\n/***/ 417:\n/***/ (function(module, exports) {\n\n// Exports\nmodule.exports = {\n\n};\n\n\n/***/ }),\n\n/***/ 428:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_InstantSearch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(470);\n/* harmony import */ var _lib_version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(384);\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(486);\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(487);\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(488);\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(489);\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(490);\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(492);\n/* harmony import */ var _lib_infiniteHitsCache__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(491);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(286);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(385);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_10__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _types__WEBPACK_IMPORTED_MODULE_10__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n\n\n\n\n\n/**\n * InstantSearch is the main component of InstantSearch.js. This object\n * manages the widget and lets you add new ones.\n *\n * Two parameters are required to get you started with InstantSearch.js:\n *  - `indexName`: the main index that you will use for your new search UI\n *  - `searchClient`: the search client to plug to InstantSearch.js\n *\n * The [search client provided by Algolia](algolia.com/doc/api-client/getting-started/what-is-the-api-client/javascript/)\n * needs an `appId` and an `apiKey`. Those parameters can be found in your\n * [Algolia dashboard](https://www.algolia.com/api-keys).\n *\n * If you want to get up and running quickly with InstantSearch.js, have a\n * look at the [getting started](https://www.algolia.com/doc/guides/building-search-ui/getting-started/js/).\n */\n\nvar instantsearch = function instantsearch(options) {\n  return new _lib_InstantSearch__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"](options);\n};\n\ninstantsearch.version = _lib_version__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"];\ninstantsearch.createInfiniteHitsSessionStorageCache = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_9__[/* deprecate */ \"a\"])(_lib_infiniteHitsCache__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"a\"], \"import { createInfiniteHitsSessionStorageCache } from 'instantsearch.js/es/helpers'\");\ninstantsearch.highlight = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_9__[/* deprecate */ \"a\"])(_helpers__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"], \"import { highlight } from 'instantsearch.js/es/helpers'\");\ninstantsearch.reverseHighlight = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_9__[/* deprecate */ \"a\"])(_helpers__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"], \"import { reverseHighlight } from 'instantsearch.js/es/helpers'\");\ninstantsearch.snippet = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_9__[/* deprecate */ \"a\"])(_helpers__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"], \"import { snippet } from 'instantsearch.js/es/helpers'\");\ninstantsearch.reverseSnippet = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_9__[/* deprecate */ \"a\"])(_helpers__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"], \"import { reverseSnippet } from 'instantsearch.js/es/helpers'\");\ninstantsearch.insights = _helpers__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"];\ninstantsearch.getInsightsAnonymousUserToken = _helpers__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"];\nObject.defineProperty(instantsearch, 'widgets', {\n  get: function get() {\n    throw new ReferenceError(\"\\\"instantsearch.widgets\\\" are not available from the ES build.\\n\\nTo import the widgets:\\n\\nimport { searchBox } from 'instantsearch.js/es/widgets'\");\n  }\n});\nObject.defineProperty(instantsearch, 'connectors', {\n  get: function get() {\n    throw new ReferenceError(\"\\\"instantsearch.connectors\\\" are not available from the ES build.\\n\\nTo import the connectors:\\n\\nimport { connectSearchBox } from 'instantsearch.js/es/connectors'\");\n  }\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (instantsearch);\n\n\n/***/ }),\n\n/***/ 429:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_cache_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_InfiniteHitsBlogs_vue_vue_type_style_index_0_id_4309958b_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(400);\n/* harmony import */ var _node_modules_cache_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_InfiniteHitsBlogs_vue_vue_type_style_index_0_id_4309958b_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_cache_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_InfiniteHitsBlogs_vue_vue_type_style_index_0_id_4309958b_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_cache_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_InfiniteHitsBlogs_vue_vue_type_style_index_0_id_4309958b_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_cache_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_InfiniteHitsBlogs_vue_vue_type_style_index_0_id_4309958b_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n\n\n/***/ }),\n\n/***/ 470:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXTERNAL MODULE: external \"algoliasearch-helper\"\nvar external_algoliasearch_helper_ = __webpack_require__(195);\nvar external_algoliasearch_helper_default = /*#__PURE__*/__webpack_require__.n(external_algoliasearch_helper_);\n\n// EXTERNAL MODULE: external \"events\"\nvar external_events_ = __webpack_require__(237);\nvar external_events_default = /*#__PURE__*/__webpack_require__.n(external_events_);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/widgets/index/index.js\nvar index = __webpack_require__(383);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/version.js\nvar version = __webpack_require__(384);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/helpers/highlight.js\nvar helpers_highlight = __webpack_require__(486);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/helpers/reverseHighlight.js\nvar helpers_reverseHighlight = __webpack_require__(487);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/helpers/snippet.js\nvar helpers_snippet = __webpack_require__(488);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/helpers/reverseSnippet.js\nvar helpers_reverseSnippet = __webpack_require__(489);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/helpers/insights.js\nvar helpers_insights = __webpack_require__(490);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/createHelpers.js\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\nfunction hoganHelpers(_ref) {\n  var numberLocale = _ref.numberLocale;\n  return {\n    formatNumber: function formatNumber(value, render) {\n      return Number(render(value)).toLocaleString(numberLocale);\n    },\n    highlight: function highlight(options, render) {\n      try {\n        var highlightOptions = JSON.parse(options);\n        return render(Object(helpers_highlight[\"a\" /* default */])(_objectSpread(_objectSpread({}, highlightOptions), {}, {\n          hit: this\n        })));\n      } catch (error) {\n        throw new Error(\"\\nThe highlight helper expects a JSON object of the format:\\n{ \\\"attribute\\\": \\\"name\\\", \\\"highlightedTagName\\\": \\\"mark\\\" }\");\n      }\n    },\n    reverseHighlight: function reverseHighlight(options, render) {\n      try {\n        var reverseHighlightOptions = JSON.parse(options);\n        return render(Object(helpers_reverseHighlight[\"a\" /* default */])(_objectSpread(_objectSpread({}, reverseHighlightOptions), {}, {\n          hit: this\n        })));\n      } catch (error) {\n        throw new Error(\"\\n  The reverseHighlight helper expects a JSON object of the format:\\n  { \\\"attribute\\\": \\\"name\\\", \\\"highlightedTagName\\\": \\\"mark\\\" }\");\n      }\n    },\n    snippet: function snippet(options, render) {\n      try {\n        var snippetOptions = JSON.parse(options);\n        return render(Object(helpers_snippet[\"a\" /* default */])(_objectSpread(_objectSpread({}, snippetOptions), {}, {\n          hit: this\n        })));\n      } catch (error) {\n        throw new Error(\"\\nThe snippet helper expects a JSON object of the format:\\n{ \\\"attribute\\\": \\\"name\\\", \\\"highlightedTagName\\\": \\\"mark\\\" }\");\n      }\n    },\n    reverseSnippet: function reverseSnippet(options, render) {\n      try {\n        var reverseSnippetOptions = JSON.parse(options);\n        return render(Object(helpers_reverseSnippet[\"a\" /* default */])(_objectSpread(_objectSpread({}, reverseSnippetOptions), {}, {\n          hit: this\n        })));\n      } catch (error) {\n        throw new Error(\"\\n  The reverseSnippet helper expects a JSON object of the format:\\n  { \\\"attribute\\\": \\\"name\\\", \\\"highlightedTagName\\\": \\\"mark\\\" }\");\n      }\n    },\n    insights: function insights(options, render) {\n      try {\n        var _JSON$parse = JSON.parse(options),\n            method = _JSON$parse.method,\n            payload = _JSON$parse.payload;\n\n        return render(Object(helpers_insights[\"a\" /* default */])(method, _objectSpread({\n          objectIDs: [this.objectID]\n        }, payload)));\n      } catch (error) {\n        throw new Error(\"\\nThe insights helper expects a JSON object of the format:\\n{ \\\"method\\\": \\\"method-name\\\", \\\"payload\\\": { \\\"eventName\\\": \\\"name of the event\\\" } }\");\n      }\n    }\n  };\n}\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/documentation.js\nvar documentation = __webpack_require__(309);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/defer.js\nvar defer = __webpack_require__(378);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/noop.js\nvar noop = __webpack_require__(310);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/stateMappings/simple.js\nfunction simple_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction simple_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      simple_ownKeys(Object(source), true).forEach(function (key) {\n        simple_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      simple_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction simple_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction getIndexStateWithoutConfigure(uiState) {\n  var configure = uiState.configure,\n      trackedUiState = _objectWithoutProperties(uiState, [\"configure\"]);\n\n  return trackedUiState;\n} // technically a URL could contain any key, since users provide it,\n// which is why the input to this function is UiState, not something\n// which excludes \"configure\" as this function does.\n\n\nfunction simpleStateMapping() {\n  return {\n    stateToRoute: function stateToRoute(uiState) {\n      return Object.keys(uiState).reduce(function (state, indexId) {\n        return simple_objectSpread(simple_objectSpread({}, state), {}, simple_defineProperty({}, indexId, getIndexStateWithoutConfigure(uiState[indexId])));\n      }, {});\n    },\n    routeToState: function routeToState() {\n      var routeState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return Object.keys(routeState).reduce(function (state, indexId) {\n        return simple_objectSpread(simple_objectSpread({}, state), {}, simple_defineProperty({}, indexId, getIndexStateWithoutConfigure(routeState[indexId])));\n      }, {});\n    }\n  };\n}\n// EXTERNAL MODULE: external \"qs\"\nvar external_qs_ = __webpack_require__(238);\nvar external_qs_default = /*#__PURE__*/__webpack_require__.n(external_qs_);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/safelyRunOnBrowser.js\nvar safelyRunOnBrowser = __webpack_require__(373);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/routers/history.js\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction history_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\n\n\nvar setWindowTitle = function setWindowTitle(title) {\n  if (title) {\n    // This function is only executed on browsers so we can disable this check.\n    // eslint-disable-next-line no-restricted-globals\n    window.document.title = title;\n  }\n};\n\nvar history_BrowserHistory = /*#__PURE__*/function () {\n  /**\n   * Initializes a new storage provider that syncs the search state to the URL\n   * using web APIs (`window.location.pushState` and `onpopstate` event).\n   */\n  function BrowserHistory(_ref) {\n    var _this = this;\n\n    var windowTitle = _ref.windowTitle,\n        _ref$writeDelay = _ref.writeDelay,\n        writeDelay = _ref$writeDelay === void 0 ? 400 : _ref$writeDelay,\n        createURL = _ref.createURL,\n        parseURL = _ref.parseURL,\n        getLocation = _ref.getLocation;\n\n    _classCallCheck(this, BrowserHistory);\n\n    history_defineProperty(this, \"windowTitle\", void 0);\n\n    history_defineProperty(this, \"writeDelay\", void 0);\n\n    history_defineProperty(this, \"_createURL\", void 0);\n\n    history_defineProperty(this, \"parseURL\", void 0);\n\n    history_defineProperty(this, \"getLocation\", void 0);\n\n    history_defineProperty(this, \"writeTimer\", void 0);\n\n    history_defineProperty(this, \"shouldPushState\", true);\n\n    this.windowTitle = windowTitle;\n    this.writeTimer = undefined;\n    this.writeDelay = writeDelay;\n    this._createURL = createURL;\n    this.parseURL = parseURL;\n    this.getLocation = getLocation;\n    Object(safelyRunOnBrowser[\"a\" /* safelyRunOnBrowser */])(function () {\n      var title = _this.windowTitle && _this.windowTitle(_this.read());\n\n      setWindowTitle(title);\n    });\n  }\n  /**\n   * Reads the URL and returns a syncable UI search state.\n   */\n\n\n  _createClass(BrowserHistory, [{\n    key: \"read\",\n    value: function read() {\n      return this.parseURL({\n        qsModule: external_qs_default.a,\n        location: this.getLocation()\n      });\n    }\n    /**\n     * Pushes a search state into the URL.\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(routeState) {\n      var _this2 = this;\n\n      Object(safelyRunOnBrowser[\"a\" /* safelyRunOnBrowser */])(function (_ref2) {\n        var window = _ref2.window;\n\n        var url = _this2.createURL(routeState);\n\n        var title = _this2.windowTitle && _this2.windowTitle(routeState);\n\n        if (_this2.writeTimer) {\n          clearTimeout(_this2.writeTimer);\n        }\n\n        _this2.writeTimer = setTimeout(function () {\n          setWindowTitle(title);\n\n          if (_this2.shouldPushState) {\n            window.history.pushState(routeState, title || '', url);\n          }\n\n          _this2.shouldPushState = true;\n          _this2.writeTimer = undefined;\n        }, _this2.writeDelay);\n      });\n    }\n    /**\n     * Sets a callback on the `onpopstate` event of the history API of the current page.\n     * It enables the URL sync to keep track of the changes.\n     */\n\n  }, {\n    key: \"onUpdate\",\n    value: function onUpdate(callback) {\n      var _this3 = this;\n\n      this._onPopState = function (event) {\n        if (_this3.writeTimer) {\n          clearTimeout(_this3.writeTimer);\n          _this3.writeTimer = undefined;\n        }\n\n        _this3.shouldPushState = false;\n        var routeState = event.state; // At initial load, the state is read from the URL without update.\n        // Therefore the state object is not available.\n        // In this case, we fallback and read the URL.\n\n        if (!routeState) {\n          callback(_this3.read());\n        } else {\n          callback(routeState);\n        }\n      };\n\n      Object(safelyRunOnBrowser[\"a\" /* safelyRunOnBrowser */])(function (_ref3) {\n        var window = _ref3.window;\n        window.addEventListener('popstate', _this3._onPopState);\n      });\n    }\n    /**\n     * Creates a complete URL from a given syncable UI state.\n     *\n     * It always generates the full URL, not a relative one.\n     * This allows to handle cases like using a <base href>.\n     * See: https://github.com/algolia/instantsearch.js/issues/790\n     */\n\n  }, {\n    key: \"createURL\",\n    value: function createURL(routeState) {\n      return this._createURL({\n        qsModule: external_qs_default.a,\n        routeState: routeState,\n        location: this.getLocation()\n      });\n    }\n    /**\n     * Removes the event listener and cleans up the URL.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _this4 = this;\n\n      Object(safelyRunOnBrowser[\"a\" /* safelyRunOnBrowser */])(function (_ref4) {\n        var window = _ref4.window;\n\n        if (_this4._onPopState) {\n          window.removeEventListener('popstate', _this4._onPopState);\n        }\n      });\n\n      if (this.writeTimer) {\n        clearTimeout(this.writeTimer);\n      }\n\n      this.write({});\n    }\n  }]);\n\n  return BrowserHistory;\n}();\n\nfunction historyRouter() {\n  var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref5$createURL = _ref5.createURL,\n      createURL = _ref5$createURL === void 0 ? function (_ref6) {\n    var qsModule = _ref6.qsModule,\n        routeState = _ref6.routeState,\n        location = _ref6.location;\n    var protocol = location.protocol,\n        hostname = location.hostname,\n        _location$port = location.port,\n        port = _location$port === void 0 ? '' : _location$port,\n        pathname = location.pathname,\n        hash = location.hash;\n    var queryString = qsModule.stringify(routeState);\n    var portWithPrefix = port === '' ? '' : \":\".concat(port); // IE <= 11 has no proper `location.origin` so we cannot rely on it.\n    // IE <= 11 has no proper `location.origin` so we cannot rely on it.\n\n    if (!queryString) {\n      return \"\".concat(protocol, \"//\").concat(hostname).concat(portWithPrefix).concat(pathname).concat(hash);\n    }\n\n    return \"\".concat(protocol, \"//\").concat(hostname).concat(portWithPrefix).concat(pathname, \"?\").concat(queryString).concat(hash);\n  } : _ref5$createURL,\n      _ref5$parseURL = _ref5.parseURL,\n      parseURL = _ref5$parseURL === void 0 ? function (_ref7) {\n    var qsModule = _ref7.qsModule,\n        location = _ref7.location; // `qs` by default converts arrays with more than 20 items to an object.\n    // We want to avoid this because the data structure manipulated can therefore vary.\n    // Setting the limit to `100` seems a good number because the engine's default is 100\n    // (it can go up to 1000 but it is very unlikely to select more than 100 items in the UI).\n    //\n    // Using an `arrayLimit` of `n` allows `n + 1` items.\n    //\n    // See:\n    //   - https://github.com/ljharb/qs#parsing-arrays\n    //   - https://www.algolia.com/doc/api-reference/api-parameters/maxValuesPerFacet/\n\n    return qsModule.parse(location.search.slice(1), {\n      arrayLimit: 99\n    });\n  } : _ref5$parseURL,\n      _ref5$writeDelay = _ref5.writeDelay,\n      writeDelay = _ref5$writeDelay === void 0 ? 400 : _ref5$writeDelay,\n      windowTitle = _ref5.windowTitle,\n      _ref5$getLocation = _ref5.getLocation,\n      getLocation = _ref5$getLocation === void 0 ? function () {\n    return Object(safelyRunOnBrowser[\"a\" /* safelyRunOnBrowser */])(function (_ref8) {\n      var window = _ref8.window;\n      return window.location;\n    }, {\n      fallback: function fallback() {\n        throw new Error('You need to provide `getLocation` to the `history` router in environments where `window` does not exist.');\n      }\n    });\n  } : _ref5$getLocation;\n\n  return new history_BrowserHistory({\n    createURL: createURL,\n    parseURL: parseURL,\n    writeDelay: writeDelay,\n    windowTitle: windowTitle,\n    getLocation: getLocation\n  });\n}\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/isEqual.js\nvar isEqual = __webpack_require__(367);\n\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/middlewares/createRouterMiddleware.js\nfunction createRouterMiddleware_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction createRouterMiddleware_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      createRouterMiddleware_ownKeys(Object(source), true).forEach(function (key) {\n        createRouterMiddleware_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      createRouterMiddleware_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction createRouterMiddleware_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\n\n\nvar createRouterMiddleware_createRouterMiddleware = function createRouterMiddleware() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _props$router = props.router,\n      router = _props$router === void 0 ? historyRouter() : _props$router,\n      _props$stateMapping = props.stateMapping,\n      stateMapping = _props$stateMapping === void 0 ? simpleStateMapping() : _props$stateMapping;\n  return function (_ref) {\n    var instantSearchInstance = _ref.instantSearchInstance;\n\n    function topLevelCreateURL(nextState) {\n      var uiState = Object.keys(nextState).reduce(function (acc, indexId) {\n        return createRouterMiddleware_objectSpread(createRouterMiddleware_objectSpread({}, acc), {}, createRouterMiddleware_defineProperty({}, indexId, nextState[indexId]));\n      }, instantSearchInstance.mainIndex.getWidgetUiState({}));\n      var route = stateMapping.stateToRoute(uiState);\n      return router.createURL(route);\n    } // casting to UiState here to keep createURL unaware of custom UiState\n    // (as long as it's an object, it's ok)\n\n\n    instantSearchInstance._createURL = topLevelCreateURL;\n    var lastRouteState = undefined;\n    var initialUiState = instantSearchInstance._initialUiState;\n    return {\n      onStateChange: function onStateChange(_ref2) {\n        var uiState = _ref2.uiState;\n        var routeState = stateMapping.stateToRoute(uiState);\n\n        if (lastRouteState === undefined || !Object(isEqual[\"a\" /* default */])(lastRouteState, routeState)) {\n          router.write(routeState);\n          lastRouteState = routeState;\n        }\n      },\n      subscribe: function subscribe() {\n        instantSearchInstance._initialUiState = createRouterMiddleware_objectSpread(createRouterMiddleware_objectSpread({}, initialUiState), stateMapping.routeToState(router.read()));\n        router.onUpdate(function (route) {\n          instantSearchInstance.setUiState(stateMapping.routeToState(route));\n        });\n      },\n      unsubscribe: function unsubscribe() {\n        router.dispose();\n      }\n    };\n  };\n};\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/middlewares/createMetadataMiddleware.js\n\n\nfunction extractPayload(widgets, instantSearchInstance, payload) {\n  var parent = instantSearchInstance.mainIndex;\n  var initOptions = {\n    instantSearchInstance: instantSearchInstance,\n    parent: parent,\n    scopedResults: [],\n    state: parent.getHelper().state,\n    helper: parent.getHelper(),\n    createURL: parent.createURL,\n    uiState: instantSearchInstance._initialUiState,\n    renderState: instantSearchInstance.renderState,\n    templatesConfig: instantSearchInstance.templatesConfig,\n    searchMetadata: {\n      isSearchStalled: instantSearchInstance._isSearchStalled\n    }\n  };\n  widgets.forEach(function (widget) {\n    var widgetParams = {};\n\n    if (widget.getWidgetRenderState) {\n      var renderState = widget.getWidgetRenderState(initOptions);\n\n      if (renderState && renderState.widgetParams) {\n        // casting, as we just earlier checked widgetParams exists, and thus an object\n        widgetParams = renderState.widgetParams;\n      }\n    } // since we destructure in all widgets, the parameters with defaults are set to \"undefined\"\n\n\n    var params = Object.keys(widgetParams).filter(function (key) {\n      return widgetParams[key] !== undefined;\n    });\n    payload.widgets.push({\n      type: widget.$$type,\n      widgetType: widget.$$widgetType,\n      params: params\n    });\n\n    if (widget.$$type === 'ais.index') {\n      extractPayload(widget.getWidgets(), instantSearchInstance, payload);\n    }\n  });\n}\n\nfunction isMetadataEnabled() {\n  return Object(safelyRunOnBrowser[\"a\" /* safelyRunOnBrowser */])(function (_ref) {\n    var window = _ref.window;\n    return window.navigator.userAgent.indexOf('Algolia Crawler') > -1;\n  }, {\n    fallback: function fallback() {\n      return false;\n    }\n  });\n}\n/**\n * Exposes the metadata of mounted widgets in a custom\n * `<meta name=\"instantsearch:widgets\" />` tag. The metadata per widget is:\n * - applied parameters\n * - widget name\n * - connector name\n */\n\nfunction createMetadataMiddleware() {\n  return function (_ref2) {\n    var instantSearchInstance = _ref2.instantSearchInstance;\n    var payload = {\n      widgets: []\n    };\n    var payloadContainer = document.createElement('meta');\n    var refNode = document.querySelector('head');\n    payloadContainer.name = 'instantsearch:widgets';\n    return {\n      onStateChange: function onStateChange() {},\n      subscribe: function subscribe() {\n        // using setTimeout here to delay extraction until widgets have been added in a tick (e.g. Vue)\n        setTimeout(function () {\n          var client = instantSearchInstance.client;\n          payload.ua = client.transporter && client.transporter.userAgent ? client.transporter.userAgent.value : client._ua;\n          extractPayload(instantSearchInstance.mainIndex.getWidgets(), instantSearchInstance, payload);\n          payloadContainer.content = JSON.stringify(payload);\n          refNode.appendChild(payloadContainer);\n        }, 0);\n      },\n      unsubscribe: function unsubscribe() {\n        payloadContainer.remove();\n      }\n    };\n  };\n}\n// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/InstantSearch.js\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction InstantSearch_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction InstantSearch_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      InstantSearch_ownKeys(Object(source), true).forEach(function (key) {\n        InstantSearch_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      InstantSearch_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction InstantSearch_classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction InstantSearch_defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction InstantSearch_createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) InstantSearch_defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) InstantSearch_defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction InstantSearch_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n\n\n\n\n\n\n\n\nvar withUsage = Object(documentation[\"b\" /* createDocumentationMessageGenerator */])({\n  name: 'instantsearch'\n});\n\nfunction defaultCreateURL() {\n  return '#';\n}\n/**\n * Global options for an InstantSearch instance.\n */\n\n/**\n * The actual implementation of the InstantSearch. This is\n * created using the `instantsearch` factory function.\n * It emits the 'render' event every time a search is done\n */\n\n\nvar InstantSearch_InstantSearch = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(InstantSearch, _EventEmitter);\n\n  var _super = _createSuper(InstantSearch);\n\n  function InstantSearch(options) {\n    var _this;\n\n    InstantSearch_classCallCheck(this, InstantSearch);\n\n    _this = _super.call(this);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"client\", void 0);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"indexName\", void 0);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"insightsClient\", void 0);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"onStateChange\", null);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"helper\", void 0);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"mainHelper\", void 0);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"mainIndex\", void 0);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"started\", void 0);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"templatesConfig\", void 0);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"renderState\", {});\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"_stalledSearchDelay\", void 0);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"_searchStalledTimer\", void 0);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"_isSearchStalled\", void 0);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"_initialUiState\", void 0);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"_createURL\", void 0);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"_searchFunction\", void 0);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"_mainHelperSearch\", void 0);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"middleware\", []);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"sendEventToInsights\", void 0);\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"scheduleSearch\", Object(defer[\"a\" /* default */])(function () {\n      if (_this.started) {\n        _this.mainHelper.search();\n      }\n    }));\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"scheduleRender\", Object(defer[\"a\" /* default */])(function () {\n      if (!_this.mainHelper.hasPendingRequests()) {\n        clearTimeout(_this._searchStalledTimer);\n        _this._searchStalledTimer = null;\n        _this._isSearchStalled = false;\n      }\n\n      _this.mainIndex.render({\n        instantSearchInstance: _assertThisInitialized(_this)\n      });\n\n      _this.emit('render');\n    }));\n\n    InstantSearch_defineProperty(_assertThisInitialized(_this), \"onInternalStateChange\", Object(defer[\"a\" /* default */])(function () {\n      var nextUiState = _this.mainIndex.getWidgetUiState({});\n\n      _this.middleware.forEach(function (_ref) {\n        var instance = _ref.instance;\n        instance.onStateChange({\n          uiState: nextUiState\n        });\n      });\n    }));\n\n    var _options$indexName = options.indexName,\n        indexName = _options$indexName === void 0 ? null : _options$indexName,\n        numberLocale = options.numberLocale,\n        _options$initialUiSta = options.initialUiState,\n        initialUiState = _options$initialUiSta === void 0 ? {} : _options$initialUiSta,\n        _options$routing = options.routing,\n        routing = _options$routing === void 0 ? null : _options$routing,\n        searchFunction = options.searchFunction,\n        _options$stalledSearc = options.stalledSearchDelay,\n        stalledSearchDelay = _options$stalledSearc === void 0 ? 200 : _options$stalledSearc,\n        _options$searchClient = options.searchClient,\n        searchClient = _options$searchClient === void 0 ? null : _options$searchClient,\n        _options$insightsClie = options.insightsClient,\n        insightsClient = _options$insightsClie === void 0 ? null : _options$insightsClie,\n        _options$onStateChang = options.onStateChange,\n        onStateChange = _options$onStateChang === void 0 ? null : _options$onStateChang;\n\n    if (indexName === null) {\n      throw new Error(withUsage('The `indexName` option is required.'));\n    }\n\n    if (searchClient === null) {\n      throw new Error(withUsage('The `searchClient` option is required.'));\n    }\n\n    if (typeof searchClient.search !== 'function') {\n      throw new Error(\"The `searchClient` must implement a `search` method.\\n\\nSee: https://www.algolia.com/doc/guides/building-search-ui/going-further/backend-search/in-depth/backend-instantsearch/js/\");\n    }\n\n    if (typeof searchClient.addAlgoliaAgent === 'function') {\n      searchClient.addAlgoliaAgent(\"instantsearch.js (\".concat(version[\"a\" /* default */], \")\"));\n    }\n\n     false ? undefined : void 0;\n\n    if (insightsClient && typeof insightsClient !== 'function') {\n      throw new Error(withUsage('The `insightsClient` option should be a function.'));\n    }\n\n     false ? undefined : void 0;\n    _this.client = searchClient;\n    _this.insightsClient = insightsClient;\n    _this.indexName = indexName;\n    _this.helper = null;\n    _this.mainHelper = null;\n    _this.mainIndex = Object(index[\"default\"])({\n      indexName: indexName\n    });\n    _this.onStateChange = onStateChange;\n    _this.started = false;\n    _this.templatesConfig = {\n      helpers: hoganHelpers({\n        numberLocale: numberLocale\n      }),\n      compileOptions: {}\n    };\n    _this._stalledSearchDelay = stalledSearchDelay;\n    _this._searchStalledTimer = null;\n    _this._isSearchStalled = false;\n    _this._createURL = defaultCreateURL;\n    _this._initialUiState = initialUiState;\n\n    if (searchFunction) {\n      _this._searchFunction = searchFunction;\n    }\n\n    _this.sendEventToInsights = noop[\"a\" /* default */];\n\n    if (routing) {\n      var routerOptions = typeof routing === 'boolean' ? undefined : routing;\n\n      _this.use(createRouterMiddleware_createRouterMiddleware(routerOptions));\n    }\n\n    if (isMetadataEnabled()) {\n      _this.use(createMetadataMiddleware());\n    }\n\n    return _this;\n  }\n  /**\n   * Hooks a middleware into the InstantSearch lifecycle.\n   */\n\n\n  InstantSearch_createClass(InstantSearch, [{\n    key: \"use\",\n    value: function use() {\n      var _this2 = this;\n\n      for (var _len = arguments.length, middleware = new Array(_len), _key = 0; _key < _len; _key++) {\n        middleware[_key] = arguments[_key];\n      }\n\n      var newMiddlewareList = middleware.map(function (fn) {\n        var newMiddleware = InstantSearch_objectSpread({\n          subscribe: noop[\"a\" /* default */],\n          unsubscribe: noop[\"a\" /* default */],\n          onStateChange: noop[\"a\" /* default */]\n        }, fn({\n          instantSearchInstance: _this2\n        }));\n\n        _this2.middleware.push({\n          creator: fn,\n          instance: newMiddleware\n        });\n\n        return newMiddleware;\n      }); // If the instance has already started, we directly subscribe the\n      // middleware so they're notified of changes.\n\n      if (this.started) {\n        newMiddlewareList.forEach(function (m) {\n          m.subscribe();\n        });\n      }\n\n      return this;\n    }\n    /**\n     * Removes a middleware from the InstantSearch lifecycle.\n     */\n\n  }, {\n    key: \"unuse\",\n    value: function unuse() {\n      for (var _len2 = arguments.length, middlewareToUnuse = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        middlewareToUnuse[_key2] = arguments[_key2];\n      }\n\n      this.middleware.filter(function (m) {\n        return middlewareToUnuse.includes(m.creator);\n      }).forEach(function (m) {\n        return m.instance.unsubscribe();\n      });\n      this.middleware = this.middleware.filter(function (m) {\n        return !middlewareToUnuse.includes(m.creator);\n      });\n      return this;\n    } // @major we shipped with EXPERIMENTAL_use, but have changed that to just `use` now\n\n  }, {\n    key: \"EXPERIMENTAL_use\",\n    value: function EXPERIMENTAL_use() {\n       false ? undefined : void 0;\n      return this.use.apply(this, arguments);\n    }\n    /**\n     * Adds a widget to the search instance.\n     * A widget can be added either before or after InstantSearch has started.\n     * @param widget The widget to add to InstantSearch.\n     *\n     * @deprecated This method will still be supported in 4.x releases, but not further. It is replaced by `addWidgets([widget])`.\n     */\n\n  }, {\n    key: \"addWidget\",\n    value: function addWidget(widget) {\n       false ? undefined : void 0;\n      return this.addWidgets([widget]);\n    }\n    /**\n     * Adds multiple widgets to the search instance.\n     * Widgets can be added either before or after InstantSearch has started.\n     * @param widgets The array of widgets to add to InstantSearch.\n     */\n\n  }, {\n    key: \"addWidgets\",\n    value: function addWidgets(widgets) {\n      if (!Array.isArray(widgets)) {\n        throw new Error(withUsage('The `addWidgets` method expects an array of widgets. Please use `addWidget`.'));\n      }\n\n      if (widgets.some(function (widget) {\n        return typeof widget.init !== 'function' && typeof widget.render !== 'function';\n      })) {\n        throw new Error(withUsage('The widget definition expects a `render` and/or an `init` method.'));\n      }\n\n      this.mainIndex.addWidgets(widgets);\n      return this;\n    }\n    /**\n     * Removes a widget from the search instance.\n     * @deprecated This method will still be supported in 4.x releases, but not further. It is replaced by `removeWidgets([widget])`\n     * @param widget The widget instance to remove from InstantSearch.\n     *\n     * The widget must implement a `dispose()` method to clear its state.\n     */\n\n  }, {\n    key: \"removeWidget\",\n    value: function removeWidget(widget) {\n       false ? undefined : void 0;\n      return this.removeWidgets([widget]);\n    }\n    /**\n     * Removes multiple widgets from the search instance.\n     * @param widgets Array of widgets instances to remove from InstantSearch.\n     *\n     * The widgets must implement a `dispose()` method to clear their states.\n     */\n\n  }, {\n    key: \"removeWidgets\",\n    value: function removeWidgets(widgets) {\n      if (!Array.isArray(widgets)) {\n        throw new Error(withUsage('The `removeWidgets` method expects an array of widgets. Please use `removeWidget`.'));\n      }\n\n      if (widgets.some(function (widget) {\n        return typeof widget.dispose !== 'function';\n      })) {\n        throw new Error(withUsage('The widget definition expects a `dispose` method.'));\n      }\n\n      this.mainIndex.removeWidgets(widgets);\n      return this;\n    }\n    /**\n     * Ends the initialization of InstantSearch.js and triggers the\n     * first search. This method should be called after all widgets have been added\n     * to the instance of InstantSearch.js. InstantSearch.js also supports adding and removing\n     * widgets after the start as an **EXPERIMENTAL** feature.\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this3 = this;\n\n      if (this.started) {\n        throw new Error(withUsage('The `start` method has already been called once.'));\n      } // This Helper is used for the queries, we don't care about its state. The\n      // states are managed at the `index` level. We use this Helper to create\n      // DerivedHelper scoped into the `index` widgets.\n      // In Vue InstantSearch' hydrate, a main helper gets set before start, so\n      // we need to respect this helper as a way to keep all listeners correct.\n\n\n      var mainHelper = this.mainHelper || external_algoliasearch_helper_default()(this.client, this.indexName);\n\n      mainHelper.search = function () {\n        // This solution allows us to keep the exact same API for the users but\n        // under the hood, we have a different implementation. It should be\n        // completely transparent for the rest of the codebase. Only this module\n        // is impacted.\n        return mainHelper.searchOnlyWithDerivedHelpers();\n      };\n\n      if (this._searchFunction) {\n        // this client isn't used to actually search, but required for the helper\n        // to not throw errors\n        var fakeClient = {\n          search: function search() {\n            return new Promise(noop[\"a\" /* default */]);\n          }\n        };\n        this._mainHelperSearch = mainHelper.search.bind(mainHelper);\n\n        mainHelper.search = function () {\n          var mainIndexHelper = _this3.mainIndex.getHelper();\n\n          var searchFunctionHelper = external_algoliasearch_helper_default()(fakeClient, mainIndexHelper.state.index, mainIndexHelper.state);\n          searchFunctionHelper.once('search', function (_ref2) {\n            var state = _ref2.state;\n            mainIndexHelper.overrideStateWithoutTriggeringChangeEvent(state);\n\n            _this3._mainHelperSearch();\n          }); // Forward state changes from `searchFunctionHelper` to `mainIndexHelper`\n\n          searchFunctionHelper.on('change', function (_ref3) {\n            var state = _ref3.state;\n            mainIndexHelper.setState(state);\n          });\n\n          _this3._searchFunction(searchFunctionHelper);\n\n          return mainHelper;\n        };\n      } // Only the \"main\" Helper emits the `error` event vs the one for `search`\n      // and `results` that are also emitted on the derived one.\n\n\n      mainHelper.on('error', function (_ref4) {\n        var error = _ref4.error;\n\n        _this3.emit('error', {\n          error: error\n        });\n      });\n      this.mainHelper = mainHelper;\n      this.middleware.forEach(function (_ref5) {\n        var instance = _ref5.instance;\n        instance.subscribe();\n      });\n      this.mainIndex.init({\n        instantSearchInstance: this,\n        parent: null,\n        uiState: this._initialUiState\n      });\n      this.scheduleSearch(); // Keep the previous reference for legacy purpose, some pattern use\n      // the direct Helper access `search.helper` (e.g multi-index).\n\n      this.helper = this.mainIndex.getHelper(); // track we started the search if we add more widgets,\n      // to init them directly after add\n\n      this.started = true;\n    }\n    /**\n     * Removes all widgets without triggering a search afterwards. This is an **EXPERIMENTAL** feature,\n     * if you find an issue with it, please\n     * [open an issue](https://github.com/algolia/instantsearch.js/issues/new?title=Problem%20with%20dispose).\n     * @return {undefined} This method does not return anything\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.scheduleSearch.cancel();\n      this.scheduleRender.cancel();\n      clearTimeout(this._searchStalledTimer);\n      this.removeWidgets(this.mainIndex.getWidgets());\n      this.mainIndex.dispose(); // You can not start an instance two times, therefore a disposed instance\n      // needs to set started as false otherwise this can not be restarted at a\n      // later point.\n\n      this.started = false; // The helper needs to be reset to perform the next search from a fresh state.\n      // If not reset, it would use the state stored before calling `dispose()`.\n\n      this.removeAllListeners();\n      this.mainHelper.removeAllListeners();\n      this.mainHelper = null;\n      this.helper = null;\n      this.middleware.forEach(function (_ref6) {\n        var instance = _ref6.instance;\n        instance.unsubscribe();\n      });\n    }\n  }, {\n    key: \"scheduleStalledRender\",\n    value: function scheduleStalledRender() {\n      var _this4 = this;\n\n      if (!this._searchStalledTimer) {\n        this._searchStalledTimer = setTimeout(function () {\n          _this4._isSearchStalled = true;\n\n          _this4.scheduleRender();\n        }, this._stalledSearchDelay);\n      }\n    }\n  }, {\n    key: \"setUiState\",\n    value: function setUiState(uiState) {\n      if (!this.mainHelper) {\n        throw new Error(withUsage('The `start` method needs to be called before `setUiState`.'));\n      } // We refresh the index UI state to update the local UI state that the\n      // main index passes to the function form of `setUiState`.\n\n\n      this.mainIndex.refreshUiState();\n      var nextUiState = typeof uiState === 'function' ? uiState(this.mainIndex.getWidgetUiState({})) : uiState;\n\n      var setIndexHelperState = function setIndexHelperState(indexWidget) {\n        var nextIndexUiState = nextUiState[indexWidget.getIndexId()] || {};\n\n        if (false) {}\n\n        indexWidget.getHelper().setState(indexWidget.getWidgetSearchParameters(indexWidget.getHelper().state, {\n          uiState: nextIndexUiState\n        }));\n        indexWidget.getWidgets().filter(index[\"isIndexWidget\"]).forEach(setIndexHelperState);\n      };\n\n      setIndexHelperState(this.mainIndex);\n      this.scheduleSearch();\n      this.onInternalStateChange();\n    }\n  }, {\n    key: \"getUiState\",\n    value: function getUiState() {\n      if (this.started) {\n        // We refresh the index UI state to make sure changes from `refine` are taken in account\n        this.mainIndex.refreshUiState();\n      }\n\n      return this.mainIndex.getWidgetUiState({});\n    }\n  }, {\n    key: \"createURL\",\n    value: function createURL() {\n      var nextState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this.started) {\n        throw new Error(withUsage('The `start` method needs to be called before `createURL`.'));\n      }\n\n      return this._createURL(nextState);\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      if (!this.mainHelper) {\n        throw new Error(withUsage('The `start` method needs to be called before `refresh`.'));\n      }\n\n      this.mainHelper.clearCache().search();\n    }\n  }]);\n\n  return InstantSearch;\n}(external_events_default.a);\n\n/* harmony default export */ var lib_InstantSearch = __webpack_exports__[\"a\"] = (InstantSearch_InstantSearch);\n\n/***/ }),\n\n/***/ 472:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/blogs/InfiniteHitsBlogs.vue?vue&type=template&id=4309958b&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.state)?_c('ol',[_vm._l((_vm.state.hits),function(hit){return _vm._ssrNode(\"<li data-v-4309958b>\",\"</li>\",[_c('nuxt-link',{attrs:{\"to\":(\"/blog/\" + (hit.referencia))}},[_vm._t(\"item\",null,{\"item\":hit})],2)],1)}),_vm._ssrNode(\" \"),_c('li',{directives:[{name:\"observe-visibility\",rawName:\"v-observe-visibility\",value:(_vm.visibilityChanged),expression:\"visibilityChanged\"}],staticClass:\"sentinel\"},[])],2):_vm._e()}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./components/blogs/InfiniteHitsBlogs.vue?vue&type=template&id=4309958b&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/vue-instantsearch/vue2/cjs/index.js\nvar cjs = __webpack_require__(412);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/connectors/infinite-hits/connectInfiniteHits.js\nvar connectInfiniteHits = __webpack_require__(318);\n\n// EXTERNAL MODULE: external \"vue-observe-visibility\"\nvar external_vue_observe_visibility_ = __webpack_require__(204);\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--2-0!./node_modules/babel-loader/lib??ref--2-1!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/blogs/InfiniteHitsBlogs.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n/* harmony default export */ var InfiniteHitsBlogsvue_type_script_lang_js_ = ({\n  mixins: [Object(cjs[\"createWidgetMixin\"])({\n    connector: connectInfiniteHits[\"a\" /* default */]\n  })],\n  directives: {\n    ObserveVisibility: external_vue_observe_visibility_[\"ObserveVisibility\"]\n  },\n  methods: {\n    visibilityChanged(isVisible) {\n      if (isVisible && !this.state.isLastPage) {\n        this.state.showMore();\n      }\n    }\n\n  }\n});\n// CONCATENATED MODULE: ./components/blogs/InfiniteHitsBlogs.vue?vue&type=script&lang=js&\n /* harmony default export */ var blogs_InfiniteHitsBlogsvue_type_script_lang_js_ = (InfiniteHitsBlogsvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(7);\n\n// CONCATENATED MODULE: ./components/blogs/InfiniteHitsBlogs.vue\n\n\n\nfunction injectStyles (context) {\n  \n  var style0 = __webpack_require__(429)\nif (style0.__inject__) style0.__inject__(context)\n\n}\n\n/* normalize component */\n\nvar component = Object(componentNormalizer[\"a\" /* default */])(\n  blogs_InfiniteHitsBlogsvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  injectStyles,\n  \"4309958b\",\n  \"e29ad1fe\"\n  \n)\n\n/* harmony default export */ var InfiniteHitsBlogs = __webpack_exports__[\"default\"] = (component.exports);\n\n/***/ }),\n\n/***/ 473:\n/***/ (function(module, exports) {\n\n// Exports\nmodule.exports = {\n\n};\n\n\n/***/ }),\n\n/***/ 474:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_cache_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_buscador_infinito_blogs_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(417);\n/* harmony import */ var _node_modules_cache_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_buscador_infinito_blogs_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_cache_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_buscador_infinito_blogs_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_cache_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_buscador_infinito_blogs_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_cache_loader_dist_cjs_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_buscador_infinito_blogs_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n\n\n/***/ }),\n\n/***/ 481:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/blogs/buscador-infinito-blogs.vue?vue&type=template&id=61ffdd44&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_vm._ssrNode(\"<div class=\\\"container\\\">\",\"</div>\",[_c('ais-instant-search',{attrs:{\"search-client\":_vm.searchClient,\"index-name\":_vm.indexName}},[_c('div',{staticClass:\"search-panel\"},[_c('div',{staticClass:\"search-panel__results\"},[_c('ais-search-box',{staticClass:\"searchbox\",attrs:{\"placeholder\":\"Busque los blogs\"}}),_vm._v(\" \"),_c('app-infinite-hits-blogs',{scopedSlots:_vm._u([{key:\"item\",fn:function(ref){\nvar item = ref.item;\nreturn [_c('h1',[_c('ais-highlight',{attrs:{\"hit\":item,\"attribute\":\"titulo\"}})],1)]}}])})],1)])])],1)])}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./components/blogs/buscador-infinito-blogs.vue?vue&type=template&id=61ffdd44&\n\n// EXTERNAL MODULE: ./node_modules/vue-instantsearch/vue2/cjs/index.js\nvar cjs = __webpack_require__(412);\n\n// EXTERNAL MODULE: external \"algoliasearch/lite\"\nvar lite_ = __webpack_require__(248);\nvar lite_default = /*#__PURE__*/__webpack_require__.n(lite_);\n\n// EXTERNAL MODULE: ./node_modules/instantsearch.css/themes/algolia-min.css\nvar algolia_min = __webpack_require__(473);\n\n// EXTERNAL MODULE: ./components/blogs/InfiniteHitsBlogs.vue + 4 modules\nvar InfiniteHitsBlogs = __webpack_require__(472);\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--2-0!./node_modules/babel-loader/lib??ref--2-1!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/blogs/buscador-infinito-blogs.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n/* harmony default export */ var buscador_infinito_blogsvue_type_script_lang_js_ = ({\n  components: {\n    'app-infinite-hits-blogs': InfiniteHitsBlogs[\"default\"],\n    'ais-instant-search': cjs[\"AisInstantSearch\"],\n    'ais-search-box': cjs[\"AisSearchBox\"],\n    'ais-highlight': cjs[\"AisHighlight\"]\n  },\n\n  data() {\n    return {\n      searchClient: lite_default()('RNRNTDZS3N', 'af4d4e9d36a7ceb75e258007c3ceccf2'),\n      indexName:  true ? 'blogs_prod' : undefined\n    };\n  },\n\n  created() {}\n\n});\n// CONCATENATED MODULE: ./components/blogs/buscador-infinito-blogs.vue?vue&type=script&lang=js&\n /* harmony default export */ var blogs_buscador_infinito_blogsvue_type_script_lang_js_ = (buscador_infinito_blogsvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(7);\n\n// CONCATENATED MODULE: ./components/blogs/buscador-infinito-blogs.vue\n\n\n\nfunction injectStyles (context) {\n  \n  var style0 = __webpack_require__(474)\nif (style0.__inject__) style0.__inject__(context)\n\n}\n\n/* normalize component */\n\nvar component = Object(componentNormalizer[\"a\" /* default */])(\n  blogs_buscador_infinito_blogsvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  injectStyles,\n  null,\n  \"51392cea\"\n  \n)\n\n/* harmony default export */ var buscador_infinito_blogs = __webpack_exports__[\"default\"] = (component.exports);\n\n/***/ }),\n\n/***/ 486:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return highlight; });\n/* harmony import */ var _lib_suit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(287);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(374);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(264);\n\n\nvar suit = Object(_lib_suit__WEBPACK_IMPORTED_MODULE_0__[/* component */ \"a\"])('Highlight');\nfunction highlight(_ref) {\n  var attribute = _ref.attribute,\n      _ref$highlightedTagNa = _ref.highlightedTagName,\n      highlightedTagName = _ref$highlightedTagNa === void 0 ? 'mark' : _ref$highlightedTagNa,\n      hit = _ref.hit,\n      _ref$cssClasses = _ref.cssClasses,\n      cssClasses = _ref$cssClasses === void 0 ? {} : _ref$cssClasses;\n\n  var _ref2 = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(hit._highlightResult, attribute) || {},\n      _ref2$value = _ref2.value,\n      attributeValue = _ref2$value === void 0 ? '' : _ref2$value; // cx is not used, since it would be bundled as a dependency for Vue & Angular\n\n\n  var className = suit({\n    descendantName: 'highlighted'\n  }) + (cssClasses.highlighted ? \" \".concat(cssClasses.highlighted) : '');\n  return attributeValue.replace(new RegExp(_lib_utils__WEBPACK_IMPORTED_MODULE_2__[/* TAG_REPLACEMENT */ \"b\"].highlightPreTag, 'g'), \"<\".concat(highlightedTagName, \" class=\\\"\").concat(className, \"\\\">\")).replace(new RegExp(_lib_utils__WEBPACK_IMPORTED_MODULE_2__[/* TAG_REPLACEMENT */ \"b\"].highlightPostTag, 'g'), \"</\".concat(highlightedTagName, \">\"));\n}\n\n/***/ }),\n\n/***/ 487:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return reverseHighlight; });\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(374);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(379);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(381);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(380);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(264);\n/* harmony import */ var _lib_suit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(287);\n\n\nvar suit = Object(_lib_suit__WEBPACK_IMPORTED_MODULE_5__[/* component */ \"a\"])('ReverseHighlight');\nfunction reverseHighlight(_ref) {\n  var attribute = _ref.attribute,\n      _ref$highlightedTagNa = _ref.highlightedTagName,\n      highlightedTagName = _ref$highlightedTagNa === void 0 ? 'mark' : _ref$highlightedTagNa,\n      hit = _ref.hit,\n      _ref$cssClasses = _ref.cssClasses,\n      cssClasses = _ref$cssClasses === void 0 ? {} : _ref$cssClasses;\n\n  var _ref2 = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(hit._highlightResult, attribute) || {},\n      _ref2$value = _ref2.value,\n      attributeValue = _ref2$value === void 0 ? '' : _ref2$value; // cx is not used, since it would be bundled as a dependency for Vue & Angular\n\n\n  var className = suit({\n    descendantName: 'highlighted'\n  }) + (cssClasses.highlighted ? \" \".concat(cssClasses.highlighted) : '');\n  var reverseHighlightedValue = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(Object(_lib_utils__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(Object(_lib_utils__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(attributeValue)));\n  return reverseHighlightedValue.replace(new RegExp(_lib_utils__WEBPACK_IMPORTED_MODULE_4__[/* TAG_REPLACEMENT */ \"b\"].highlightPreTag, 'g'), \"<\".concat(highlightedTagName, \" class=\\\"\").concat(className, \"\\\">\")).replace(new RegExp(_lib_utils__WEBPACK_IMPORTED_MODULE_4__[/* TAG_REPLACEMENT */ \"b\"].highlightPostTag, 'g'), \"</\".concat(highlightedTagName, \">\"));\n}\n\n/***/ }),\n\n/***/ 488:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return snippet; });\n/* harmony import */ var _lib_suit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(287);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(374);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(264);\n\n\nvar suit = Object(_lib_suit__WEBPACK_IMPORTED_MODULE_0__[/* component */ \"a\"])('Snippet');\nfunction snippet(_ref) {\n  var attribute = _ref.attribute,\n      _ref$highlightedTagNa = _ref.highlightedTagName,\n      highlightedTagName = _ref$highlightedTagNa === void 0 ? 'mark' : _ref$highlightedTagNa,\n      hit = _ref.hit,\n      _ref$cssClasses = _ref.cssClasses,\n      cssClasses = _ref$cssClasses === void 0 ? {} : _ref$cssClasses;\n\n  var _ref2 = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(hit._snippetResult, attribute) || {},\n      _ref2$value = _ref2.value,\n      attributeValue = _ref2$value === void 0 ? '' : _ref2$value; // cx is not used, since it would be bundled as a dependency for Vue & Angular\n\n\n  var className = suit({\n    descendantName: 'highlighted'\n  }) + (cssClasses.highlighted ? \" \".concat(cssClasses.highlighted) : '');\n  return attributeValue.replace(new RegExp(_lib_utils__WEBPACK_IMPORTED_MODULE_2__[/* TAG_REPLACEMENT */ \"b\"].highlightPreTag, 'g'), \"<\".concat(highlightedTagName, \" class=\\\"\").concat(className, \"\\\">\")).replace(new RegExp(_lib_utils__WEBPACK_IMPORTED_MODULE_2__[/* TAG_REPLACEMENT */ \"b\"].highlightPostTag, 'g'), \"</\".concat(highlightedTagName, \">\"));\n}\n\n/***/ }),\n\n/***/ 489:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return reverseSnippet; });\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(374);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(379);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(381);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(380);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(264);\n/* harmony import */ var _lib_suit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(287);\n\n\nvar suit = Object(_lib_suit__WEBPACK_IMPORTED_MODULE_5__[/* component */ \"a\"])('ReverseSnippet');\nfunction reverseSnippet(_ref) {\n  var attribute = _ref.attribute,\n      _ref$highlightedTagNa = _ref.highlightedTagName,\n      highlightedTagName = _ref$highlightedTagNa === void 0 ? 'mark' : _ref$highlightedTagNa,\n      hit = _ref.hit,\n      _ref$cssClasses = _ref.cssClasses,\n      cssClasses = _ref$cssClasses === void 0 ? {} : _ref$cssClasses;\n\n  var _ref2 = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(hit._snippetResult, attribute) || {},\n      _ref2$value = _ref2.value,\n      attributeValue = _ref2$value === void 0 ? '' : _ref2$value; // cx is not used, since it would be bundled as a dependency for Vue & Angular\n\n\n  var className = suit({\n    descendantName: 'highlighted'\n  }) + (cssClasses.highlighted ? \" \".concat(cssClasses.highlighted) : '');\n  var reverseHighlightedValue = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(Object(_lib_utils__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(Object(_lib_utils__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(attributeValue)));\n  return reverseHighlightedValue.replace(new RegExp(_lib_utils__WEBPACK_IMPORTED_MODULE_4__[/* TAG_REPLACEMENT */ \"b\"].highlightPreTag, 'g'), \"<\".concat(highlightedTagName, \" class=\\\"\").concat(className, \"\\\">\")).replace(new RegExp(_lib_utils__WEBPACK_IMPORTED_MODULE_4__[/* TAG_REPLACEMENT */ \"b\"].highlightPostTag, 'g'), \"</\".concat(highlightedTagName, \">\"));\n}\n\n/***/ }),\n\n/***/ 490:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export readDataAttributes */\n/* unused harmony export hasDataAttributes */\n/* unused harmony export writeDataAttributes */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return insights; });\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(285);\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n\nfunction readDataAttributes(domElement) {\n  var method = domElement.getAttribute('data-insights-method');\n  var serializedPayload = domElement.getAttribute('data-insights-payload');\n\n  if (typeof serializedPayload !== 'string') {\n    throw new Error('The insights helper expects `data-insights-payload` to be a base64-encoded JSON string.');\n  }\n\n  try {\n    var payload = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_0__[/* deserializePayload */ \"a\"])(serializedPayload);\n    return {\n      method: method,\n      payload: payload\n    };\n  } catch (error) {\n    throw new Error('The insights helper was unable to parse `data-insights-payload`.');\n  }\n}\nfunction hasDataAttributes(domElement) {\n  return domElement.hasAttribute('data-insights-method');\n}\nfunction writeDataAttributes(_ref) {\n  var method = _ref.method,\n      payload = _ref.payload;\n\n  if (_typeof(payload) !== 'object') {\n    throw new Error(\"The insights helper expects the payload to be an object.\");\n  }\n\n  var serializedPayload;\n\n  try {\n    serializedPayload = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_0__[/* serializePayload */ \"b\"])(payload);\n  } catch (error) {\n    throw new Error(\"Could not JSON serialize the payload object.\");\n  }\n\n  return \"data-insights-method=\\\"\".concat(method, \"\\\" data-insights-payload=\\\"\").concat(serializedPayload, \"\\\"\");\n}\n/**\n * @deprecated This function will be still supported in 4.x releases, but not further. It is replaced by the `insights` middleware. For more information, visit https://www.algolia.com/doc/guides/getting-insights-and-analytics/search-analytics/click-through-and-conversions/how-to/send-click-and-conversion-events-with-instantsearch/js/\n */\n\nfunction insights(method, payload) {\n   false ? undefined : void 0;\n  return writeDataAttributes({\n    method: method,\n    payload: payload\n  });\n}\n\n/***/ }),\n\n/***/ 491:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return createInfiniteHitsSessionStorageCache; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(373);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(367);\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\n\n\nfunction getStateWithoutPage(state) {\n  var _ref = state || {},\n      page = _ref.page,\n      rest = _objectWithoutProperties(_ref, [\"page\"]);\n\n  return rest;\n}\n\nvar KEY = 'ais.infiniteHits';\nfunction createInfiniteHitsSessionStorageCache() {\n  return {\n    read: function read(_ref2) {\n      var state = _ref2.state;\n      var sessionStorage = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* safelyRunOnBrowser */ \"a\"])(function (_ref3) {\n        var window = _ref3.window;\n        return window.sessionStorage;\n      });\n\n      if (!sessionStorage) {\n        return null;\n      }\n\n      try {\n        var cache = JSON.parse( // @ts-expect-error JSON.parse() requires a string, but it actually accepts null, too.\n        sessionStorage.getItem(KEY));\n        return cache && Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(cache.state, getStateWithoutPage(state)) ? cache.hits : null;\n      } catch (error) {\n        if (error instanceof SyntaxError) {\n          try {\n            sessionStorage.removeItem(KEY);\n          } catch (err) {// do nothing\n          }\n        }\n\n        return null;\n      }\n    },\n    write: function write(_ref4) {\n      var state = _ref4.state,\n          hits = _ref4.hits;\n      var sessionStorage = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* safelyRunOnBrowser */ \"a\"])(function (_ref5) {\n        var window = _ref5.window;\n        return window.sessionStorage;\n      });\n\n      if (!sessionStorage) {\n        return;\n      }\n\n      try {\n        sessionStorage.setItem(KEY, JSON.stringify({\n          state: getStateWithoutPage(state),\n          hits: hits\n        }));\n      } catch (error) {// do nothing\n      }\n    }\n  };\n}\n\n/***/ }),\n\n/***/ 492:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export ANONYMOUS_TOKEN_COOKIE_KEY */\n/* unused harmony export getInsightsAnonymousUserTokenInternal */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return getInsightsAnonymousUserToken; });\n\nvar ANONYMOUS_TOKEN_COOKIE_KEY = '_ALGOLIA';\n\nfunction getCookie(name) {\n  var prefix = \"\".concat(name, \"=\");\n  var cookies = document.cookie.split(';');\n\n  for (var i = 0; i < cookies.length; i++) {\n    var cookie = cookies[i];\n\n    while (cookie.charAt(0) === ' ') {\n      cookie = cookie.substring(1);\n    }\n\n    if (cookie.indexOf(prefix) === 0) {\n      return cookie.substring(prefix.length, cookie.length);\n    }\n  }\n\n  return undefined;\n}\n\nfunction getInsightsAnonymousUserTokenInternal() {\n  return getCookie(ANONYMOUS_TOKEN_COOKIE_KEY);\n}\n/**\n * @deprecated This function will be still supported in 4.x releases, but not further. It is replaced by the `insights` middleware. For more information, visit https://www.algolia.com/doc/guides/getting-insights-and-analytics/search-analytics/click-through-and-conversions/how-to/send-click-and-conversion-events-with-instantsearch/js/\n */\n\nfunction getInsightsAnonymousUserToken() {\n   false ? undefined : void 0;\n  return getInsightsAnonymousUserTokenInternal();\n}\n\n/***/ })\n\n};;"],"mappings":"AAAA;AAkLA;AAsNA;AAgBA;AA8jBA;AAAA;AAuRA;AAwTA;AAwMA;AAAA;AA63BA;AAkOA;AAAA;AAAA;AAAA;AAmRA;AAi1BA;AA6NA;AA6WA;AAqoBA;AA0QA;AA4TA;AAouBA;AA8jCA;AAiEA;AA2KA;AAAA;AAAA;AAksBA;AAkyBA;AA8UA;AA4zCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAm/BA;AAAA;AAmCA;AAAA;AAAA;AA+2EA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAsHA;AAAA;AAUA;AAAA;AAUA;AAAA;AAUA;AAAA;AAaA;AAAA;","sourceRoot":""}